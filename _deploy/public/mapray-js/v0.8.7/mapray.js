(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
typeof define === 'function' && define.amd ? define(factory) :
(global = global || self, global.mapray = factory());
}(this, (function () { 'use strict';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var check = function (it) {
  return it && it.Math == Math && it;
}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


var global_1 = // eslint-disable-next-line no-undef
check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func
Function('return this')();

var fails = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

var descriptors = !fails(function () {
  return Object.defineProperty({}, 1, {
    get: function () {
      return 7;
    }
  })[1] != 7;
});

var isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var document$1 = global_1.document; // typeof document.createElement is 'object' in old IE

var EXISTS = isObject(document$1) && isObject(document$1.createElement);

var documentCreateElement = function (it) {
  return EXISTS ? document$1.createElement(it) : {};
};

var ie8DomDefine = !descriptors && !fails(function () {
  return Object.defineProperty(documentCreateElement('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

var anObject = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  }

  return it;
};

// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string

var toPrimitive = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty

var f = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (ie8DomDefine) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};
var objectDefineProperty = {
  f: f
};

var createPropertyDescriptor = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var createNonEnumerableProperty = descriptors ? function (object, key, value) {
  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty = {}.hasOwnProperty;

var has = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var setGlobal = function (key, value) {
  try {
    createNonEnumerableProperty(global_1, key, value);
  } catch (error) {
    global_1[key] = value;
  }

  return value;
};

var SHARED = '__core-js_shared__';
var store = global_1[SHARED] || setGlobal(SHARED, {});
var sharedStore = store;

var functionToString = Function.toString; // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper

if (typeof sharedStore.inspectSource != 'function') {
  sharedStore.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

var inspectSource = sharedStore.inspectSource;

var WeakMap = global_1.WeakMap;
var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

var isPure = false;

var shared = createCommonjsModule(function (module) {
  (module.exports = function (key, value) {
    return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.6.4',
    mode:  'global',
    copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
  });
});

var id = 0;
var postfix = Math.random();

var uid = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

var keys = shared('keys');

var sharedKey = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

var hiddenKeys = {};

var WeakMap$1 = global_1.WeakMap;
var set, get, has$1;

var enforce = function (it) {
  return has$1(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;

    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    }

    return state;
  };
};

if (nativeWeakMap) {
  var store$1 = new WeakMap$1();
  var wmget = store$1.get;
  var wmhas = store$1.has;
  var wmset = store$1.set;

  set = function (it, metadata) {
    wmset.call(store$1, it, metadata);
    return metadata;
  };

  get = function (it) {
    return wmget.call(store$1, it) || {};
  };

  has$1 = function (it) {
    return wmhas.call(store$1, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;

  set = function (it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };

  get = function (it) {
    return has(it, STATE) ? it[STATE] : {};
  };

  has$1 = function (it) {
    return has(it, STATE);
  };
}

var internalState = {
  set: set,
  get: get,
  has: has$1,
  enforce: enforce,
  getterFor: getterFor
};

var redefine = createCommonjsModule(function (module) {
  var getInternalState = internalState.get;
  var enforceInternalState = internalState.enforce;
  var TEMPLATE = String(String).split('String');
  (module.exports = function (O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;

    if (typeof value == 'function') {
      if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
      enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }

    if (O === global_1) {
      if (simple) O[key] = value;else setGlobal(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }

    if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, 'toString', function toString() {
    return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
  });
});

var DatePrototype = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var nativeDateToString = DatePrototype[TO_STRING];
var getTime = DatePrototype.getTime; // `Date.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-date.prototype.tostring

if (new Date(NaN) + '' != INVALID_DATE) {
  redefine(DatePrototype, TO_STRING, function toString() {
    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
  });
}

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
  1: 2
}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

var f$1 = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;
var objectPropertyIsEnumerable = {
  f: f$1
};

var toString = {}.toString;

var classofRaw = function (it) {
  return toString.call(it).slice(8, -1);
};

var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

var indexedObject = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

var toIndexedObject = function (it) {
  return indexedObject(requireObjectCoercible(it));
};

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

var f$2 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (ie8DomDefine) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) {
    /* empty */
  }
  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
};
var objectGetOwnPropertyDescriptor = {
  f: f$2
};

var path = global_1;

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

var getBuiltIn = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
};

var ceil = Math.ceil;
var floor = Math.floor; // `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger

var toInteger = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

var min = Math.min; // `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength

var toLength = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min; // Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

var toAbsoluteIndex = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
};

var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};

var indexOf = arrayIncludes.indexOf;

var objectKeysInternal = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key); // Don't enum bug & hidden keys


  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }

  return result;
};

// IE8- don't enum bug keys
var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames

var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return objectKeysInternal(O, hiddenKeys$1);
};

var objectGetOwnPropertyNames = {
  f: f$3
};

var f$4 = Object.getOwnPropertySymbols;
var objectGetOwnPropertySymbols = {
  f: f$4
};

var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = objectGetOwnPropertyNames.f(anObject(it));
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

var copyConstructorProperties = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = objectDefineProperty.f;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
var isForced_1 = isForced;

var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/

var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;

  if (GLOBAL) {
    target = global_1;
  } else if (STATIC) {
    target = global_1[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global_1[TARGET] || {}).prototype;
  }

  if (target) for (key in source) {
    sourceProperty = source[key];

    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor$1(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];

    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    } // add a flag to not completely full polyfills


    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    } // extend global


    redefine(target, key, sourceProperty, options);
  }
};

var log = Math.log;
var LN2 = Math.LN2; // `Math.log2` method
// https://tc39.github.io/ecma262/#sec-math.log2

_export({
  target: 'Math',
  stat: true
}, {
  log2: function log2(x) {
    return log(x) / LN2;
  }
});

var defineProperty = objectDefineProperty.f;
var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name

if (descriptors && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/**
 * @summary ã¢ãã¡ã¼ã·ã§ã³å±éã®ã¨ã©ã¼
 *
 * @memberof mapray.animation
 * @extends Error
 *
 * @see {@link mapray.animation.Binder}
 */
var AnimationError =
/*#__PURE__*/
function (_Error) {
  _inherits(AnimationError, _Error);

  /**
   * @param {string} message  ã¨ã©ã¼ã®èª¬æ
   */
  function AnimationError(message) {
    var _this;

    _classCallCheck(this, AnimationError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimationError).call(this, message));
    _this.name = "mapray.animation.AnimationError";
    return _this;
  }

  return AnimationError;
}(_wrapNativeSuper(Error));

var aPossiblePrototype = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  }

  return it;
};

// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */

var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;

  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {
    /* empty */
  }

  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
    return O;
  };
}() : undefined);

var inheritIfRequired = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if ( // it can work only with native `setPrototypeOf`
  objectSetPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
  typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) objectSetPrototypeOf($this, NewTargetPrototype);
  return $this;
};

// https://tc39.github.io/ecma262/#sec-object.keys

var objectKeys = Object.keys || function keys(O) {
  return objectKeysInternal(O, enumBugKeys);
};

// https://tc39.github.io/ecma262/#sec-object.defineproperties

var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;

  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);

  return O;
};

var html = getBuiltIn('document', 'documentElement');

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () {
  /* empty */
};

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
}; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak

  return temp;
}; // Create object with fake `null` prototype: use iframe Object with cleared prototype


var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
}; // Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug


var activeXDocument;

var NullProtoObject = function () {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) {
    /* ignore */
  }

  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;

  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];

  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true; // `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create

var objectCreate = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = NullProtoObject();

  return Properties === undefined ? result : objectDefineProperties(result, Properties);
};

// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

var createMethod$1 = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod$1(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod$1(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod$1(3)
};

var getOwnPropertyNames = objectGetOwnPropertyNames.f;
var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var defineProperty$1 = objectDefineProperty.f;
var trim = stringTrim.trim;
var NUMBER = 'Number';
var NativeNumber = global_1[NUMBER];
var NumberPrototype = NativeNumber.prototype; // Opera ~12 has broken Object#toString

var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER; // `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber

var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;

  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal of /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal of /^0o[0-7]+$/i

        default:
          return +it;
      }

      digits = it.slice(2);
      length = digits.length;

      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
}; // `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor


if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper // check on 1..constructor(foo) case
    && (BROKEN_CLASSOF ? fails(function () {
      NumberPrototype.valueOf.call(dummy);
    }) : classofRaw(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };

  for (var keys$1 = descriptors ? getOwnPropertyNames(NativeNumber) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES2015 (in case, if modules with ES2015 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys$1.length > j; j++) {
    if (has(NativeNumber, key = keys$1[j]) && !has(NumberWrapper, key)) {
      defineProperty$1(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
    }
  }

  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global_1, NUMBER, NumberWrapper);
}

/**
 * @summary ã¢ãã¡ã¼ã·ã§ã³æå»
 *
 * @classdesc
 * <p>ã¢ãã¡ã¼ã·ã§ã³ã®æå»ãè¡¨ç¾ããã¯ã©ã¹ã§ããã</p>
 * <p>ãã®ã¯ã©ã¹ã®ã¤ã³ã¹ã¿ã³ã¹ã¯ã¤ãã¥ã¼ã¿ãã«ã§ããã</p>
 *
 * @memberof mapray.animation
 * @hideconstructor
 */
var Time =
/*#__PURE__*/
function () {
  /**
   * éå¬éã®æ§ç¯å­
   *
   * @param {number} ntime  æ°å¤æå»
   */
  function Time(ntime) {
    _classCallCheck(this, Time);

    this._ntime = ntime;
  }
  /**
   * @summary è¡¨ç¾å¯è½ãªæåã®æå»
   *
   * @type {mapray.animation.Time}
   * @readonly
   */


  _createClass(Time, [{
    key: "toNumber",

    /**
     * @summary æå»ãæ°å¤ã«å¤æ
     *
     * @desc
     * <p>this ã®æå»ã«å¯¾å¿ããæ°å¤ãåå¾ããã</p>
     *
     * @return {number}  æå»ã«å¯¾å¿ããæ°å¤
     */
    value: function toNumber() {
      return this._ntime;
    }
    /** @summary æå»ã®æ¯è¼ (==)
     *
     * @desc
     * <p>this ã®æå»ã¨ rhs ã®æå»ãåãã¨ã true, ããä»¥å¤ã®ã¨ã false ãè¿ãã</p>
     *
     * @param {mapray.animation.Time} rhs  æå»
     *
     * @return {boolean}  æ¯è¼çµæ
     */

  }, {
    key: "equals",
    value: function equals(rhs) {
      return this._ntime == rhs._ntime;
    }
    /** @summary æå»ã®æ¯è¼ (<)
     *
     * @desc
     * <p>this ã®æå»ã rhs ã®æå»ããåã®ã¨ã true, ããä»¥å¤ã®ã¨ã false ãè¿ãã</p>
     *
     * @param {mapray.animation.Time} rhs  æå»
     *
     * @return {boolean}  æ¯è¼çµæ
     */

  }, {
    key: "lessThan",
    value: function lessThan(rhs) {
      return this._ntime < rhs._ntime;
    }
    /** @summary æå»ã®æ¯è¼ (<=)
     *
     * @desc
     * <p>this ã®æå»ã rhs ã®æå»ããåã¾ãã¯åãã¨ã true, ããä»¥å¤ã®ã¨ã false ãè¿ãã</p>
     *
     * @param {mapray.animation.Time} rhs  æå»
     *
     * @return {boolean}  æ¯è¼çµæ
     */

  }, {
    key: "lessEqual",
    value: function lessEqual(rhs) {
      return this._ntime <= rhs._ntime;
    }
  }], [{
    key: "fromNumber",

    /**
     * @summary æ°å¤ãæå»ã«å¤æ
     *
     * @desc
     * <p>æå»ã«å¯¾å¿ããæ°å¤ãã Time ã¤ã³ã¹ã¿ã³ã¹ãçæããã</p>
     * <p>æ¡ä»¶: Time.MIN_NTIME <= ntime <= Time.MAX_NTIME</p>
     *
     * @param {number} ntime  æå»ã«å¯¾å¿ããæ°å¤
     *
     * @return {mapray.animation.Time}  Time ã¤ã³ã¹ã¿ã³ã¹
     */
    value: function fromNumber(ntime) {
      return new Time(ntime);
    }
  }, {
    key: "MIN_TIME",
    get: function get() {
      return TIME_MIN_TIME;
    }
    /**
     * @summary è¡¨ç¾å¯è½ãªæå¾ã®æå»
     *
     * @type {mapray.animation.Time}
     * @readonly
     */

  }, {
    key: "MAX_TIME",
    get: function get() {
      return TIME_MAX_TIME;
    }
    /**
     * @summary æå»ã«å¯¾å¿ããæ°å¤ã®æå°å¤
     *
     * @type {number}
     * @readonly
     */

  }, {
    key: "MIN_NTIME",
    get: function get() {
      return TIME_MIN_NTIME;
    }
    /**
     * @summary æå»ã«å¯¾å¿ããæ°å¤ã®æå¤§å¤
     *
     * @type {number}
     * @readonly
     */

  }, {
    key: "MAX_NTIME",
    get: function get() {
      return TIME_MAX_NTIME;
    }
  }]);

  return Time;
}();

var TIME_MIN_NTIME = -Number.MAX_VALUE;
var TIME_MAX_NTIME = +Number.MAX_VALUE;
var TIME_MIN_TIME = Time.fromNumber(TIME_MIN_NTIME);
var TIME_MAX_TIME = Time.fromNumber(TIME_MAX_NTIME);

/**
 * @summary ã¢ãã¡ã¼ã·ã§ã³æå»ã®åºé
 *
 * @classdesc
 * <p>ã¢ãã¡ã¼ã·ã§ã³æå»ã®åºéãè¡¨ç¾ããã¯ã©ã¹ã§ããã</p>
 * <p>ãã®ã¯ã©ã¹ã®ã¤ã³ã¹ã¿ã³ã¹ã¯ã¤ãã¥ã¼ã¿ãã«ã§ããã</p>
 *
 * @memberof mapray.animation
 */

var Interval =
/*#__PURE__*/
function () {
  /**
   * @desc
   * <p>ä¸é lower ã¨ä¸é upper ã®æå»åºéãçæããã</p>
   * <p>ç«¯ç¹ã§ãã lower ã¨ upper ãåºéã«å«ã¾ãããã©ããã¯ l_open ã¨ u_open ã«ããæå®ããã</p>
   *
   * <pre>
   *  interval       | l_open  u_open
   * ----------------+----------------
   *  [lower, upper] | false   false
   *  [lower, upper) | false   true
   *  (lower, upper] | true    false
   *  (lower, upper) | true    true
   * </pre>
   *
   * @param {mapray.animation.Time} lower  åºéã®ä¸éæå»
   * @param {mapray.animation.Time} upper  åºéã®ä¸éæå»
   * @param {boolean}      [l_open=false]  lower ãåºéã«ãå«ã¾ããã¨ã false, å«ã¾ããªãã¨ã true
   * @param {boolean}      [u_open=false]  upper ãåºéã«ãå«ã¾ããã¨ã false, å«ã¾ããªãã¨ã true
   */
  function Interval(lower, upper, l_open, u_open) {
    _classCallCheck(this, Interval);

    this._lower = lower;
    this._upper = upper;
    this._l_open = l_open === undefined ? false : l_open;
    this._u_open = u_open === undefined ? false : u_open;
  }
  /**
   * @summary å¨æå»åºé
   *
   * @type {mapray.animation.Interval}
   * @readonly
   */


  _createClass(Interval, [{
    key: "isEmpty",

    /**
     * @summary ç©ºæå»åºéãï¼
     *
     * @desc
     * <p>this ãç©ºã®æå»åºéãã©ãããè¿ãã</p>
     * <p>ç©ºæå»åºéã®å ´åãåºéåã« 1 ã¤ãæå»ãå­å¨ããªãã</p>
     *
     * @return {boolean}  ç©ºæå»åºéã®ã¨ã true, ããä»¥å¤ã®ã¨ã false
     */
    value: function isEmpty() {
      var lower = this._lower;
      var upper = this._upper;
      return upper.lessThan(lower) || upper.equals(lower) && (this._l_open || this._u_open);
    }
    /**
     * @summary åä¸æå»åºéãï¼
     *
     * @desc
     * <p>this ãåä¸æå»ã®æå»åºéãã©ãããè¿ãã</p>
     * <p>åä¸æå»åºéã®å ´åãåºéåã«ãã  1 ã¤ã®æå»ãå­å¨ããã</p>
     * <p>åä¸æå»åºéã§ãããªã lower == upper ã§ãããéã¯å¿ãããæãç«ããªãã</p>
     *
     * @return {boolean}  åä¸æå»åºéã®ã¨ã true, ããä»¥å¤ã®ã¨ã false
     */

  }, {
    key: "isSingle",
    value: function isSingle() {
      return this._lower.equals(this._upper) && !(this._l_open || this._u_open);
    }
    /**
     * @summary éå¸¸æå»åºéãï¼
     *
     * @desc
     * <p>this ãéå¸¸ã®æå»åºéãã©ãããè¿ãã</p>
     * <p>éå¸¸æå»åºéã®å ´åãåºéåã«ç¡éåã®æå»ãå­å¨ããã</p>
     * <p>éå¸¸æå»åºéã§ãããªã lower < upper ã§ãããéãæãç«ã¤ã</p>
     *
     * @return {boolean}  éå¸¸æå»åºéã®ã¨ã true, ããä»¥å¤ã®ã¨ã false
     */

  }, {
    key: "isProper",
    value: function isProper() {
      return this._lower.lessThan(this._upper);
    }
    /**
     * @summary åè¡ãã¦ãããï¼
     *
     * @desc
     * <p>this ã®ãã¹ã¦ã®æå»ã rhs ã®ãã¹ã¦ã®æå»ããåè¡ãã¦ããã¨ãã« true, ããä»¥å¤ã®ã¨ãã¯ false ãè¿ãã</p>
     * <p>this ã¾ãã¯ rhs ã®ã©ã¡ãããã¾ãã¯ä¸¡æ¹ãç©ºæå»åºéã®ã¨ãã¯ true ãè¿ãã</p>
     *
     * @param {mapray.animation.Interval} rhs  æå»åºé
     *
     * @return {boolean}  this ã rhs ã«åè¡ãã¦ããã¨ã true, ããä»¥å¤ã®ã¨ã false
     */

  }, {
    key: "precedes",
    value: function precedes(rhs) {
      if (this.isEmpty() || rhs.isEmpty()) {
        // this ã¾ãã¯ rhs ã®ã©ã¡ãããã¾ãã¯ä¸¡æ¹ãç©ºæå»åºéã®ã¨ãã®ä»æ§
        return true;
      } else {
        var ut1 = this._upper;
        var uo1 = this._u_open;
        var lt2 = rhs._lower;
        var lo2 = rhs._l_open;
        return ut1.lessThan(lt2) || ut1.equals(lt2) && (uo1 || lo2);
      }
    }
    /**
     * @summary åå«ãã¦ãããï¼
     *
     * @desc
     * <p>rhs ã®ãã¹ã¦ã®æå»ã this ã«å«ã¾ããã¨ã true, ããä»¥å¤ã®ã¨ãã¯ false ãè¿ãã</p>
     * <p>rhs ãç©ºæå»åºéã®ã¨ãã¯ true ãè¿ãã</p>
     * <p>ããã¯ rhs â this ã¨ç­ä¾¡ã§ããã</p>
     *
     * @param {mapray.animation.Interval} rhs  æå»åºé
     *
     * @return {boolean}  this ã rhs ãåå«ãã¦ããã¨ã true, ããä»¥å¤ã®ã¨ã false
     */

  }, {
    key: "includes",
    value: function includes(rhs) {
      if (rhs.isEmpty()) {
        // rhs ãç©ºæå»åºéã®ã¨ãã®ä»æ§
        return true;
      } else {
        var lt1 = this._lower;
        var lt2 = rhs._lower;
        var lo1 = this._l_open;
        var lo2 = rhs._l_open;
        var inc_l = lt1.lessThan(lt2) || lt1.equals(lt2) && (!lo1 || lo2);
        var ut1 = this._upper;
        var ut2 = rhs._upper;
        var uo1 = this._u_open;
        var uo2 = rhs._u_open;
        var inc_u = ut2.lessThan(ut1) || ut2.equals(ut1) && (uo2 || !uo1);
        return inc_l && inc_u;
      }
    }
    /**
     * @summary æå»ãåå«ãã¦ãããï¼
     *
     * @desc
     * <p>rhs ã®æå»ã this ã«å«ã¾ããã¨ã true, ããä»¥å¤ã®ã¨ãã¯ false ãè¿ãã</p>
     * <p>ãã®ã¡ã½ããã¯ this.includes( new Interval( rhs, rhs ) ) ã¨åç­ã§ããã</p>
     *
     * @param {mapray.animation.Time} rhs  æå»
     *
     * @return {boolean}  this ã rhs ãåå«ãã¦ããã¨ã true, ããä»¥å¤ã®ã¨ã false
     */

  }, {
    key: "includesTime",
    value: function includesTime(rhs) {
      var lower = this._lower;
      var inc_l = lower.lessThan(rhs) || lower.equals(rhs) && !this._l_open;
      var upper = this._upper;
      var inc_u = rhs.lessThan(upper) || rhs.equals(upper) && !this._u_open;
      return inc_l && inc_u;
    }
    /**
     * @summary å±éæå»åºéã¯å­å¨ãããï¼
     *
     * @desc
     * <p>!this.getIntersection( rhs ).isEmpty() ã¨åãã§ããã</p>
     *
     * @param {mapray.animation.Interval} rhs  æå»åºé
     *
     * @return {boolean}  å±éæå»åºé
     *
     * @see {@link mapray.animation.Interval#getIntersection}
     */

  }, {
    key: "hasIntersection",
    value: function hasIntersection(rhs) {
      // todo: ãªãã¸ã§ã¯ããçæããªãããã«æé©å
      return !this.getIntersection(rhs).isEmpty();
    }
    /**
     * @summary åè¡æå»åºéãåå¾
     *
     * @desc
     * <p>this ã®ãã¹ã¦ã®æå»ã«å¯¾ãã¦ãåã®æå»ã¨ãªããã¹ã¦ã®æå»ãå«ãåè¡æå»åºéãè¿ãã</p>
     * <p>this ãç©ºæå»åºéã®ã¨ãã¯å¨æå»åºéãè¿ããthis
     *    ã«è¡¨ç¾å¯è½ãªæåã®æå»ãå«ã¾ããã¨ãã¯ç©ºæå»åºéãè¿ãã</p>
     * <p>this.getPrecedings().precedes( this ) ã¯å¸¸ã« true ãè¿ãã</p>
     *
     * @return {mapray.animation.Interval}  åè¡æå»åºé
     */

  }, {
    key: "getPrecedings",
    value: function getPrecedings() {
      if (this.isEmpty()) {
        // ç©ºæå»åºéã®ã¨ãã¯å¨æå»åºéãè¿ãä»æ§
        return INTERVAL_UNIVERSAL;
      } else {
        return new Interval(Time.MIN_TIME, this._lower, false, !this._l_open);
      }
    }
    /**
     * @summary å¾ç¶æå»åºéãåå¾
     *
     * @desc
     * <p>this ã®ãã¹ã¦ã®æå»ã«å¯¾ãã¦ãå¾ã®æå»ã¨ãªããã¹ã¦ã®æå»ãå«ãå¾ç¶æå»åºéãè¿ãã</p>
     * <p>this ãç©ºæå»åºéã®ã¨ãã¯å¨æå»åºéãè¿ããthis
     *    ã«è¡¨ç¾å¯è½ãªæå¾ã®æå»ãå«ã¾ããã¨ãã¯ç©ºæå»åºéãè¿ãã</p>
     * <p>this.precedes( this.getFollowings() ) ã¯å¸¸ã« true ãè¿ãã</p>
     *
     * @return {mapray.animation.Interval}  å¾ç¶æå»åºé
     */

  }, {
    key: "getFollowings",
    value: function getFollowings() {
      if (this.isEmpty()) {
        // ç©ºæå»åºéã®ã¨ãã¯å¨æå»åºéãè¿ãä»æ§
        return INTERVAL_UNIVERSAL;
      } else {
        return new Interval(this._upper, Time.MAX_TIME, !this._u_open, false);
      }
    }
    /**
     * @summary å±éæå»åºéãåå¾
     *
     * @desc
     * <p>this ã¨ rhs ã®å±éæå»åºé (this â© rhs) ãè¿ãã</p>
     * <p>this ã¨ rhs ã«å±éã®æå»ãå­å¨ããªããã°ç©ºæå»åºéãè¿ãã</p>
     *
     * @param {mapray.animation.Interval} rhs  æå»åºé
     *
     * @return {mapray.animation.Interval}  å±éæå»åºé
     *
     * @see {@link mapray.animation.Interval#hasIntersection}
     */

  }, {
    key: "getIntersection",
    value: function getIntersection(rhs) {
      // B = Lb â© Ub ã¨ããã¨ã
      // A â© B = A â© Lb â© Ub
      // A â© Lb
      var cross = this._getIntersectionByLower(rhs._lower, rhs._l_open); // (A â© Lb) â© Ub


      return cross._getIntersectionByUpper(rhs._upper, rhs._u_open);
    }
    /**
     * @summary åä½µæå»åºéãåå¾
     *
     * @desc
     * <p>this ã¨ rhs ãåä½µããæå»éå (this âª rhs) ãæå»åºéã®éåã¨ãã¦è¿ãã</p>
     * <p>0 ãã 2 åã®æå»åºéãå«ãéåãè¿ããéåã®è¦ç´ ã«ç©ºæå»åºéã¯å«ã¾ããªãã</p>
     * <p>2 è¦ç´ ã®éå v ãè¿ãããã¨ããv[0] ã¨ v[1] ã®éã«æå»ãå­å¨ããããã«
     *    v[0].precedes( v[1] ) ã¯ true ã¨ãªãã</p>
     *
     * @param {mapray.animation.Interval} rhs  æå»åºé
     *
     * @return {mapray.animation.Interval[]}  åä½µæå»åºé
     */

  }, {
    key: "getUnion",
    value: function getUnion(rhs) {
      if (this.isEmpty()) {
        return rhs.isEmpty() ? [] : [rhs];
      } else if (rhs.isEmpty()) {
        // Assert: !this.isEmpty() && rhs.isEmpty()
        return [this];
      } // Assert: !this.isEmpty() && !rhs.isEmpty()


      var lt1 = this._lower;
      var ut1 = this._upper;
      var lo1 = this._l_open;
      var uo1 = this._u_open;
      var lt2 = rhs._lower;
      var ut2 = rhs._upper;
      var lo2 = rhs._l_open;
      var uo2 = rhs._u_open;

      if (ut1.lessThan(lt2) || ut1.equals(lt2) && uo1 && lo2) {
        // Assert: this ã¨ rhs ã¯é¢ãã¦ããããã¤ this ãåè¡
        return [this, rhs];
      } else if (ut2.lessThan(lt1) || lt1.equals(ut2) && lo1 && uo2) {
        // Assert: this ã¨ rhs ã¯é¢ãã¦ããããã¤ rhs ãåè¡
        return [rhs, this];
      } // Assert: this ã¨ rhs ã¯äº¤å·®ã¾ãã¯é£æ¥ãã¦ãã (åä¸ã®æå»åºéã«åä½µã§ãã)


      var _ref = lt1.lessThan(lt2) || lt1.equals(lt2) && lo2 ? [lt1, lo1] : [lt2, lo2],
          _ref2 = _slicedToArray(_ref, 2),
          lower = _ref2[0],
          l_open = _ref2[1];

      var _ref3 = ut2.lessThan(ut1) || ut2.equals(ut1) && uo2 ? [ut1, uo1] : [ut2, uo2],
          _ref4 = _slicedToArray(_ref3, 2),
          upper = _ref4[0],
          u_open = _ref4[1];

      return [new Interval(lower, upper, l_open, u_open)];
    }
    /**
     * @summary æå»åºéã®å·®ãåå¾
     *
     * @desc
     * <p>this ãã rhs ãå·®ãå¼ããæå»éå (this - rhs) ãæå»åºéã®éåã¨ãã¦è¿ãã</p>
     * <p>0 ãã 2 åã®æå»åºéãå«ãéåãè¿ããéåã®è¦ç´ ã«ç©ºæå»åºéã¯å«ã¾ããªãã</p>
     * <p>2 è¦ç´ ã®éå v ãè¿ãããã¨ããv[0] ã¨ v[1] ã®éã«æå»ãå­å¨ããããã«
     *    v[0].precedes( v[1] ) ã¯ true ã¨ãªãã</p>
     *
     * @param {mapray.animation.Interval} rhs  æå»åºé
     *
     * @return {mapray.animation.Interval[]}  æå»åºéã®å·®
     */

  }, {
    key: "getDifference",
    value: function getDifference(rhs) {
      // B = Lb â© Ub ã¨ããã¨ã
      // A - B = A â© ~B
      //       = (A â© ~Lb) âª (A â© ~Ub)
      // A â© ~Lb
      var i1 = this._getIntersectionByUpper(rhs._lower, !rhs._l_open); // A â© ~Ub


      var i2 = this._getIntersectionByLower(rhs._upper, !rhs._u_open); // (A â© ~Lb) âª (A â© ~Ub)


      return i1.getUnion(i2);
    }
    /**
     * @summary è£æå»åºéãåå¾
     *
     * @desc
     * <p>å¨æå»åºé ãã this ãå·®ãå¼ããæå»éåãæå»åºéã®éåã¨ãã¦è¿ãã</p>
     * <p>0 ãã 2 åã®æå»åºéãå«ãéåãè¿ããéåã®è¦ç´ ã«ç©ºæå»åºéã¯å«ã¾ããªãã</p>
     * <p>2 è¦ç´ ã®éå v ãè¿ãããã¨ããv[0] ã¨ v[1] ã®éã«æå»ãå­å¨ããããã«
     *    v[0].precedes( v[1] ) ã¯ true ã¨ãªãã</p>
     *
     * @return {mapray.animation.Interval[]}  è£æå»åºé
     */

  }, {
    key: "getComplement",
    value: function getComplement() {
      return INTERVAL_UNIVERSAL.getDifference(this);
    }
    /**
     * @summary ä¸éæå»åºéã¨ã®å±éæå»åºéãåå¾
     *
     * @desc
     * <p>this â© Lower(bound, open) â Interval<p>
     *
     * @param {mapray.animation.Time} bound
     * @param {boolean}               open
     *
     * @return {mapray.animation.Interval}  å±éæå»åºé
     *
     * @private
     */

  }, {
    key: "_getIntersectionByLower",
    value: function _getIntersectionByLower(bound, open) {
      if (bound.lessThan(this._lower) || bound.equals(this._lower) && this._l_open) {
        return this;
      } else {
        return new Interval(bound, this._upper, open, this._u_open);
      }
    }
    /**
     * @summary ä¸éæå»åºéã¨ã®å±éæå»åºéãåå¾
     *
     * @desc
     * <p>this â© Upper(bound, open) â Interval<p>
     *
     * @param {mapray.animation.Time} bound
     * @param {boolean}               open
     *
     * @return {mapray.animation.Interval}  å±éæå»åºé
     *
     * @private
     */

  }, {
    key: "_getIntersectionByUpper",
    value: function _getIntersectionByUpper(bound, open) {
      if (this._upper.lessThan(bound) || this._upper.equals(bound) && this._u_open) {
        return this;
      } else {
        return new Interval(this._lower, bound, this._l_open, open);
      }
    }
  }, {
    key: "lower",

    /**
     * @summary ä¸éæå»
     *
     * @type {mapray.animation.Time}
     * @readonly
     */
    get: function get() {
      return this._lower;
    }
    /**
     * @summary ä¸éæå»
     *
     * @type {mapray.animation.Time}
     * @readonly
     */

  }, {
    key: "upper",
    get: function get() {
      return this._upper;
    }
    /**
     * @summary ä¸éæå»ã¯é¤å¤ããããï¼
     *
     * @type {boolean}
     * @readonly
     */

  }, {
    key: "l_open",
    get: function get() {
      return this._l_open;
    }
    /**
     * @summary ä¸éæå»ã¯é¤å¤ããããï¼
     *
     * @type {boolean}
     * @readonly
     */

  }, {
    key: "u_open",
    get: function get() {
      return this._u_open;
    }
  }], [{
    key: "UNIVERSAL",
    get: function get() {
      return INTERVAL_UNIVERSAL;
    }
  }]);

  return Interval;
}();

var INTERVAL_UNIVERSAL = new Interval(Time.MIN_TIME, Time.MAX_TIME);

var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});

var useSymbolAsUid = nativeSymbol // eslint-disable-next-line no-undef
&& !Symbol.sham // eslint-disable-next-line no-undef
&& typeof Symbol.iterator == 'symbol';

// https://tc39.github.io/ecma262/#sec-isarray

var isArray = Array.isArray || function isArray(arg) {
  return classofRaw(arg) == 'Array';
};

// https://tc39.github.io/ecma262/#sec-toobject

var toObject = function (argument) {
  return Object(requireObjectCoercible(argument));
};

var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;
var toString$1 = {}.toString;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
}; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


var f$5 = function getOwnPropertyNames(it) {
  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
};

var objectGetOwnPropertyNamesExternal = {
  f: f$5
};

var WellKnownSymbolsStore = shared('wks');
var Symbol$1 = global_1.Symbol;
var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

var wellKnownSymbol = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  }

  return WellKnownSymbolsStore[name];
};

var f$6 = wellKnownSymbol;
var wellKnownSymbolWrapped = {
  f: f$6
};

var defineProperty$2 = objectDefineProperty.f;

var defineWellKnownSymbol = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty$2(Symbol, NAME, {
    value: wellKnownSymbolWrapped.f(NAME)
  });
};

var defineProperty$3 = objectDefineProperty.f;
var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var setToStringTag = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty$3(it, TO_STRING_TAG, {
      configurable: true,
      value: TAG
    });
  }
};

var aFunction$1 = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  }

  return it;
};

var functionBindContext = function (fn, that, length) {
  aFunction$1(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 0:
      return function () {
        return fn.call(that);
      };

    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

var SPECIES = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate

var arraySpeciesCreate = function (originalArray, length) {
  var C;

  if (isArray(originalArray)) {
    C = originalArray.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

var push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation

var createMethod$2 = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = indexedObject(O);
    var boundFunction = functionBindContext(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;

    for (; length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);

      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
            case 3:
              return true;
            // some

            case 5:
              return value;
            // find

            case 6:
              return index;
            // findIndex

            case 2:
              push.call(target, value);
            // filter
          } else if (IS_EVERY) return false; // every
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$2(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod$2(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod$2(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod$2(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod$2(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod$2(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$2(6)
};

var $forEach = arrayIteration.forEach;
var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE$1 = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = internalState.set;
var getInternalState = internalState.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE$1];
var $Symbol = global_1.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var nativeDefineProperty$1 = objectDefineProperty.f;
var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore$1 = shared('wks');
var QObject = global_1.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDescriptor = descriptors && fails(function () {
  return objectCreate(nativeDefineProperty$1({}, 'a', {
    get: function () {
      return nativeDefineProperty$1(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty$1(O, P, Attributes);

  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty$1;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!descriptors) symbol.description = description;
  return symbol;
};

var isSymbol = useSymbolAsUid ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);

  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = objectCreate(Attributes, {
        enumerable: createPropertyDescriptor(0, false)
      });
    }

    return setSymbolDescriptor(O, key, Attributes);
  }

  return nativeDefineProperty$1(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable$1.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);

  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }

  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
}; // `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor


if (!nativeSymbol) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);

    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };

    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
      configurable: true,
      set: setter
    });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
    return getInternalState(this).tag;
  });
  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });
  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
  objectDefineProperty.f = $defineProperty;
  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

  wellKnownSymbolWrapped.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (descriptors) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });

    {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, {
        unsafe: true
      });
    }
  }
}

_export({
  global: true,
  wrap: true,
  forced: !nativeSymbol,
  sham: !nativeSymbol
}, {
  Symbol: $Symbol
});
$forEach(objectKeys(WellKnownSymbolsStore$1), function (name) {
  defineWellKnownSymbol(name);
});
_export({
  target: SYMBOL,
  stat: true,
  forced: !nativeSymbol
}, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () {
    USE_SETTER = true;
  },
  useSimple: function () {
    USE_SETTER = false;
  }
});
_export({
  target: 'Object',
  stat: true,
  forced: !nativeSymbol,
  sham: !descriptors
}, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});
_export({
  target: 'Object',
  stat: true,
  forced: !nativeSymbol
}, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443

_export({
  target: 'Object',
  stat: true,
  forced: fails(function () {
    objectGetOwnPropertySymbols.f(1);
  })
}, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return objectGetOwnPropertySymbols.f(toObject(it));
  }
}); // `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify

if ($stringify) {
  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
    var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}

    return $stringify([symbol]) != '[null]' // WebKit converts symbol values to JSON as null
    || $stringify({
      a: symbol
    }) != '{}' // V8 throws on boxed symbols
    || $stringify(Object(symbol)) != '{}';
  });
  _export({
    target: 'JSON',
    stat: true,
    forced: FORCED_JSON_STRINGIFY
  }, {
    // eslint-disable-next-line no-unused-vars
    stringify: function stringify(it, replacer, space) {
      var args = [it];
      var index = 1;
      var $replacer;

      while (arguments.length > index) args.push(arguments[index++]);

      $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

      if (!isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return $stringify.apply(null, args);
    }
  });
} // `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive


if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
} // `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag


setToStringTag($Symbol, SYMBOL);
hiddenKeys[HIDDEN] = true;

var defineProperty$4 = objectDefineProperty.f;
var NativeSymbol = global_1.Symbol;

if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) || // Safari 12 bug
NativeSymbol().description !== undefined)) {
  var EmptyStringDescriptionStore = {}; // wrap Symbol constructor for correct work with undefined description

  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper ? new NativeSymbol(description) // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
    : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };

  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;
  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty$4(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });
  _export({
    global: true,
    forced: true
  }, {
    Symbol: SymbolWrapper
  });
}

// https://tc39.github.io/ecma262/#sec-symbol.iterator

defineWellKnownSymbol('iterator');

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype; // Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

if (ArrayPrototype[UNSCOPABLES] == undefined) {
  objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: objectCreate(null)
  });
} // add a key to Array.prototype[@@unscopables]


var addToUnscopables = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

var defineProperty$5 = Object.defineProperty;
var cache = {};

var thrower = function (it) {
  throw it;
};

var arrayMethodUsesToLength = function (METHOD_NAME, options) {
  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
  if (!options) options = {};
  var method = [][METHOD_NAME];
  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
  var argument0 = has(options, 0) ? options[0] : thrower;
  var argument1 = has(options, 1) ? options[1] : undefined;
  return cache[METHOD_NAME] = !!method && !fails(function () {
    if (ACCESSORS && !descriptors) return true;
    var O = {
      length: -1
    };
    if (ACCESSORS) defineProperty$5(O, 1, {
      enumerable: true,
      get: thrower
    });else O[1] = 1;
    method.call(O, argument0, argument1);
  });
};

var $includes = arrayIncludes.includes;
var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', {
  ACCESSORS: true,
  1: 0
}); // `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes

_export({
  target: 'Array',
  proto: true,
  forced: !USES_TO_LENGTH
}, {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables('includes');

var iterators = {};

var correctPrototypeGetter = !fails(function () {
  function F() {
    /* empty */
  }

  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

var IE_PROTO$1 = sharedKey('IE_PROTO');
var ObjectPrototype$1 = Object.prototype; // `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof

var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectPrototype$1 : null;
};

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () {
  return this;
}; // `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object


var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

if ( !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

var iteratorsCore = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;

var returnThis$1 = function () {
  return this;
};

var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
    next: createPropertyDescriptor(1, next)
  });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
  iterators[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$1 = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis$2 = function () {
  return this;
};

var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS:
        return function keys() {
          return new IteratorConstructor(this, KIND);
        };

      case VALUES:
        return function values() {
          return new IteratorConstructor(this, KIND);
        };

      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }

    return function () {
      return new IteratorConstructor(this);
    };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY; // fix native

  if (anyNativeIterator) {
    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));

    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
      if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
        if (objectSetPrototypeOf) {
          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
        } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);
        }
      } // Set @@toStringTag to native iterators


      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;

    defaultIterator = function values() {
      return nativeIterator.call(this);
    };
  } // define iterator


  if ( IterablePrototype[ITERATOR$1] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
  }

  iterators[NAME] = defaultIterator; // export additional methods

  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else _export({
      target: NAME,
      proto: true,
      forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME
    }, methods);
  }

  return methods;
};

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState$1 = internalState.set;
var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator

var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState$1(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated),
    // target
    index: 0,
    // next index
    kind: kind // kind

  }); // `%ArrayIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState$1(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;

  if (!target || index >= target.length) {
    state.target = undefined;
    return {
      value: undefined,
      done: true
    };
  }

  if (kind == 'keys') return {
    value: index,
    done: false
  };
  if (kind == 'values') return {
    value: target[index],
    done: false
  };
  return {
    value: [index, target[index]],
    done: false
  };
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject

iterators.Arguments = iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
var test = {};
test[TO_STRING_TAG$1] = 'z';
var toStringTagSupport = String(test) === '[object z]';

var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag'); // ES3 wrong here

var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) {
    /* empty */
  }
}; // getting tag from ES6+ `Object.prototype.toString`


var classof = toStringTagSupport ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

// https://tc39.github.io/ecma262/#sec-object.prototype.tostring


var objectToString = toStringTagSupport ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};

// https://tc39.github.io/ecma262/#sec-object.prototype.tostring

if (!toStringTagSupport) {
  redefine(Object.prototype, 'toString', objectToString, {
    unsafe: true
  });
}

var MATCH = wellKnownSymbol('match'); // `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp

var isRegexp = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
};

var notARegexp = function (it) {
  if (isRegexp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  }

  return it;
};

var MATCH$1 = wellKnownSymbol('match');

var correctIsRegexpLogic = function (METHOD_NAME) {
  var regexp = /./;

  try {
    '/./'[METHOD_NAME](regexp);
  } catch (e) {
    try {
      regexp[MATCH$1] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (f) {
      /* empty */
    }
  }

  return false;
};

// https://tc39.github.io/ecma262/#sec-string.prototype.includes


_export({
  target: 'String',
  proto: true,
  forced: !correctIsRegexpLogic('includes')
}, {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});

var createMethod$3 = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$3(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$3(true)
};

var charAt = stringMultibyte.charAt;
var STRING_ITERATOR = 'String Iterator';
var setInternalState$2 = internalState.set;
var getInternalState$2 = internalState.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator

defineIterator(String, 'String', function (iterated) {
  setInternalState$2(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  }); // `%StringIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState$2(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return {
    value: undefined,
    done: true
  };
  point = charAt(string, index);
  state.index += point.length;
  return {
    value: point,
    done: false
  };
});

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

var ITERATOR$2 = wellKnownSymbol('iterator');
var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
var ArrayValues = es_array_iterator.values;

for (var COLLECTION_NAME in domIterables) {
  var Collection = global_1[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;

  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR$2] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR$2, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR$2] = ArrayValues;
    }

    if (!CollectionPrototype[TO_STRING_TAG$3]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);
    }

    if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
      }
    }
  }
}

// è¾æ¸ã¯äºåæ¢ç´¢æ¨ã«ããå®ç¾ãã¦ãã
// äºåæ¢ç´¢æ¨ã®æ¿å¥ã»åé¤æä½ã¯2è²æ¨ã§å®è£ãã¦ãã
// 2è²æ¨ã®ã¢ã«ã´ãªãºã ã¯è¿ä»£ç§å­¦ç¤¾ã®ãã¢ã«ã´ãªãºã ã¤ã³ãã­ãã¯ã·ã§ã³ç¬¬3çã(ä»¥é IA3) ãåèã«ãã

/**
 * @summary 2è²æ¨ã®çªåµ (T.nil)
 *
 * @desc
 * <p>æ ¹ã®è¦ªãèã®å­ãã¾ãã¯ç©ºè¾æ¸ã® root ãè¡¨ç¾ããã</p>
 *
 * @see IA3/13.1 2è²æ¨ã®æ§è³ª
 *
 * @private
 */
var T_nil;
/**
 * @summary é åºããè¾æ¸
 *
 * @classdesc
 * <p>ã­ã¼ã®å¤ã«ããé åºä»ããããè¾æ¸ã§ããã</p>
 * <p>ç­ä¾¡ (equivalent) ã­ã¼ãæã¤è¤æ°ã®ã¢ã¤ãã ã¯å­å¨ã§ããªãã</p>
 * <p>this ã¯ã­ã¼ã¨å¤ã®åç§ãä¿æãã¦ãããä¿æãã¦ããã­ã¼ã®ã¤ã³ã¹ã¿ã³ã¹ãå¤æ´ããã¨åä½ã¯ä¿è¨¼ãããªãã</p>
 *
 * @memberof mapray
 * @private
 */

var OrderedMap =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.OrderedMap.Compare} compare  ã­ã¼æ¯è¼é¢æ°
   */
  function OrderedMap(compare) {
    _classCallCheck(this, OrderedMap);

    this._compare = compare;
    this._root = T_nil;
    this._size = 0;
  }
  /**
   * @summary è¦ç´ æ°
   *
   * @type {number}
   * @readonly
   */


  _createClass(OrderedMap, [{
    key: "clone",

    /**
     * @summary ã¤ã³ã¹ã¿ã³ã¹ãè¤è£½
     *
     * @desc
     * <p>ã­ã¼æ¯è¼é¢æ°ãã­ã¼ãå¤ã¯ã·ã£ã­ã¼ã³ãã¼ãããã<p>
     *
     * <p>è¨ç®é: è¦ç´ æ° n ã«å¯¾ãã¦ O(n)</p>
     *
     * @return {mapray.OrderedMap}  this ã®è¤è£½
     */
    value: function clone() {
      var cloned = new OrderedMap(this._compare);

      if (this._root !== T_nil) {
        cloned._root = this._root._clone(T_nil);
      }

      cloned._size = this._size;
      return cloned;
    }
    /**
     * @summary è¦ç´ ã¯å­å¨ããªããï¼
     *
     * <p>è¨ç®é: è¦ç´ æ° n ã«å¯¾ãã¦ O(1)</p>
     *
     * @return {boolean}  è¦ç´ ãå­å¨ããªãã¨ã true, ããã§ãªãã¨ã false
     */

  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this._root === T_nil;
    }
    /**
     * @summary åé ­è¦ç´ ãæ¤ç´¢
     *
     * @desc
     * <p>é åºãæåã®è¦ç´ ãæ¤ç´¢ããã</p>
     *
     * <p>è¨ç®é: è¦ç´ æ° n ã«å¯¾ãã¦ O(log n)</p>
     *
     * @return {!mapray.OrderedMap.Item}  æ¤ç´¢ãããã¢ã¤ãã  (this ãç©ºãªã null)
     */

  }, {
    key: "findFirst",
    value: function findFirst() {
      if (this._root !== T_nil) {
        return this._root._findMinimum();
      } else {
        return null;
      }
    }
    /**
     * @summary æ«å°¾è¦ç´ ãæ¤ç´¢
     *
     * @desc
     * <p>é åºãæå¾ã®è¦ç´ ãæ¤ç´¢ããã</p>
     *
     * <p>è¨ç®é: è¦ç´ æ° n ã«å¯¾ãã¦ O(log n)</p>
     *
     * @return {!mapray.OrderedMap.Item}  æ¤ç´¢ãããã¢ã¤ãã  (this ãç©ºãªã null)
     */

  }, {
    key: "findLast",
    value: function findLast() {
      if (this._root !== T_nil) {
        return this._root._findMaximum();
      } else {
        return null;
      }
    }
    /**
     * @summary ä¸éè¦ç´ ãæ¤ç´¢
     *
     * @desc
     * <p>bound ã¨åãã¾ãã¯å¾ã«ãªãã­ã¼ãå­å¨ããã°ããã®ä¸­ã§æåã®è¦ç´ ãè¿ãã</p>
     * <p>ãã®ãããªè¦ç´ ãå­å¨ããªãå ´åã¯ null ãè¿ãã</p>
     *
     * <p>è¨ç®é: è¦ç´ æ° n ã«å¯¾ãã¦ O(log n)</p>
     *
     * @param {mapray.OrderedMap.Key} bound  å¢çã­ã¼
     *
     * @return {?mapray.OrderedMap.Item}  æ¤ç´¢ãããè¦ç´ ãå­å¨ããªããã° null
     */

  }, {
    key: "findLower",
    value: function findLower(bound) {
      return this._root._findLowerBound(bound, this._compare);
    }
    /**
     * @summary ä¸éè¦ç´ ãæ¤ç´¢
     *
     * @desc
     * <p>bound ããå¾ã«ãªãã­ã¼ãå­å¨ããã°ããã®ä¸­ã§æåã®è¦ç´ ãè¿ãã</p>
     * <p>ãã®ãããªè¦ç´ ãå­å¨ããªãå ´åã¯ null ãè¿ãã</p>
     *
     * <p>è¨ç®é: è¦ç´ æ° n ã«å¯¾ãã¦ O(log n)</p>
     *
     * @param {mapray.OrderedMap.Key} bound  å¢çã­ã¼
     *
     * @return {?mapray.OrderedMap.Item}  æ¤ç´¢ãããè¦ç´ ãå­å¨ããªããã° null
     */

  }, {
    key: "findUpper",
    value: function findUpper(bound) {
      return this._root._findUpperBound(bound, this._compare);
    }
    /**
     * @summary è¦ç´ ãæ¤ç´¢
     *
     * @desc
     * <p>key ã¨åãã­ã¼ã®è¦ç´ ãå­å¨ããã°è¿ãã</p>
     * <p>ãã®ãããªè¦ç´ ãå­å¨ããªãå ´åã¯ null ãè¿ãã</p>
     *
     * <p>è¨ç®é: è¦ç´ æ° n ã«å¯¾ãã¦ O(log n)</p>
     *
     * @param {mapray.OrderedMap.Key} key  ã­ã¼
     *
     * @return {?mapray.OrderedMap.Item}  æ¤ç´¢ãããè¦ç´ ãå­å¨ããªããã° null
     */

  }, {
    key: "findEqual",
    value: function findEqual(key) {
      return this._root._findEqual(key, this._compare);
    }
    /**
     * @summary ãã¹ã¦ã®è¦ç´ ãåé¤
     *
     * @desc
     * <p>è¨ç®é: è¦ç´ æ° n ã«å¯¾ãã¦ O(1)</p>
     */

  }, {
    key: "clear",
    value: function clear() {
      this._root = T_nil;
      this._size = 0;
    }
    /**
     * @summary è¦ç´ ãæ¿å¥
     *
     * @desc
     * <p>ã­ã¼ã key ã¨ãã¦ value ãæ¿å¥ãããã®ã¢ã¤ãã ãè¿ãã</p>
     *
     * <p>è¨ç®é: è¦ç´ æ° n ã«å¯¾ãã¦ O(log n)</p>
     *
     * @param {mapray.OrderedMap.Key}   key    ã­ã¼
     * @param {mapray.OrderedMap.Value} value  å¤
     *
     * @return {mapray.OrderedMap.Item}  æ¿å¥ãããè¦ç´ 
     */

  }, {
    key: "insert",
    value: function insert(key, value) {
      // åç§: IA3/13.3 æ¿å¥
      var trail = this._root;
      var parent = T_nil;
      var comp = this._compare;

      while (trail !== T_nil) {
        parent = trail;

        if (comp(key, trail.key)) {
          // å·¦ã¸ä¸ã
          trail = trail._child_L;
        } else if (comp(trail.key, key)) {
          // å³ã¸ä¸ã
          trail = trail._child_R;
        } else {
          // ã­ã¼ãä¸è´ããã¢ã¤ãã ã®å¤ãæ´æ°ãã¦è¿ã
          trail._value = value;
          return trail;
        }
      } // æ°ããã¢ã¤ãã ãè¿½å 


      var item = new Item(parent, key, value);
      item._is_red = true; // é» â èµ¤

      if (parent === T_nil) {
        this._root = item;
      } else if (comp(key, parent.key)) {
        parent._child_L = item;
      } else {
        parent._child_R = item;
      } // è¦ç´ æ°ãå¢å 


      ++this._size; // 2è²æ¨æ¡ä»¶ã®åå¾©

      this._insert_fixup(item);

      return item;
    }
    /**
     * @summary æ¿å¥å¾ã«2è²æ¨æ¡ä»¶ãæºããããã«æ¨ãä¿®æ­£
     *
     * @desc
     * <p>è¨ç®é: è¦ç´ æ° n ã«å¯¾ãã¦ææª O(log n)</p>
     *
     * @param {mapray.OrderedMap.Item} item  æ¿å¥ãããã¢ã¤ãã 
     *
     * @see IA3/13.3 æ¿å¥
     *
     * @private
     */

  }, {
    key: "_insert_fixup",
    value: function _insert_fixup(item) {
      var trail = item;

      while (trail._parent._is_red
      /* èµ¤ */
      ) {
        // ããã§ã¯ãå¸¸ã«ä¸å¤å¼ a, b, c ãæºãã
        if (trail._parent === trail._parent._parent._child_L) {
          // trail ã®è¦ªãç¥ç¶ã®å·¦å´
          var uncle = trail._parent._parent._child_R;

          if (uncle._is_red
          /* èµ¤ */
          ) {
              // å ´å 1
              trail._parent._is_red = false; // é»

              uncle._is_red = false; // é»

              trail._parent._parent._is_red = true; // èµ¤

              trail = trail._parent._parent;
            } else {
            if (trail === trail._parent._child_R) {
              // å ´å 2
              trail = trail._parent;

              this._rotate_L(trail);
            } // å ´å 2,3


            trail._parent._is_red = false; // é»

            trail._parent._parent._is_red = true; // èµ¤

            this._rotate_R(trail._parent._parent);
          }
        } else {
          // trail ã®è¦ªãç¥ç¶ã®å³å´
          var _uncle = trail._parent._parent._child_L;

          if (_uncle._is_red
          /* èµ¤ */
          ) {
              // å ´å 1
              trail._parent._is_red = false; // é»

              _uncle._is_red = false; // é»

              trail._parent._parent._is_red = true; // èµ¤

              trail = trail._parent._parent;
            } else {
            if (trail === trail._parent._child_L) {
              // å ´å 2
              trail = trail._parent;

              this._rotate_R(trail);
            } // å ´å 2,3


            trail._parent._is_red = false; // é»

            trail._parent._parent._is_red = true; // èµ¤

            this._rotate_L(trail._parent._parent);
          }
        }
      }

      this._root._is_red = false; // é»
      // ããã§2è²æ¨æ¡ä»¶ãå®å¨ã«æºãã
    }
    /**
     * @summary è¦ç´ ãåé¤
     *
     * @desc
     * <p>last ãçç¥ããã¨ãã¯ first ãåé¤ãã¦ãfirst ã®å¾ç¶ãè¿ãããã®ã¨ã first ã« null
     *    ãæå®ãããã¨ã¯ã§ããªãã</p>
     *
     * <p>last ãæå®ããã¨ãã¯ first ãã last ã®åã¾ã§ã®è¦ç´ ãåé¤ãã¦ last ãè¿ããlast ã¯
     *    first ã¨åããå¾ã®è¦ç´ ã§ãªããã°ãªããªãã</p>
     *
     * <p>null ã¯ this ã®æ«å°¾è¦ç´ ã®æ¬¡ã®è¦ç´ ãè¡¨ãã</p>
     *
     * <p>è¨ç®é: 1 è¦ç´ ã®åé¤ã®å ´åãè¦ç´ æ° n ã«å¯¾ãã¦ O(log n)</p>
     *
     * todo: è¤æ°è¦ç´ ã®åé¤ã®è¨ç®éãåæ
     *
     * @param {?mapray.OrderedMap.Item} first   åé¤ããåé ­ã®è¦ç´ 
     * @param {?mapray.OrderedMap.Item} [last]  åé¤ããæå¾ã®è¦ç´ ã®æ¬¡
     *
     * @return {?mapray.OrderedMap.Item}  åé¤ãããè¦ç´ ã®æ¬¡ã®è¦ç´ 
     *
     * @private
     */

  }, {
    key: "remove",
    value: function remove(first, last) {
      if (last === undefined) {
        return this._remove(first);
      } else {
        for (var item = first; item != last;) {
          item = this._remove(item);
        }

        return last;
      }
    }
    /**
     * @summary ã¢ã¤ãã ãåé¤
     *
     * @desc
     * <p>è¨ç®é: å¨ä½ããªã¼ã®ã¢ã¤ãã æ° n ã«å¯¾ãã¦ææª O(log n)</p>
     *
     * @param {mapray.OrderedMap.Item} item  åé¤å¯¾è±¡
     *
     * @return {?mapray.OrderedMap.Item}  item ã®å¾ç¶ãå­å¨ããªããã° null
     *
     * @see IA3/13.4 åé¤
     *
     * @private
     */

  }, {
    key: "_remove",
    value: function _remove(item) {
      // item ã®å¾ç¶ (ç¡ããã° null)
      var succ = item.findSuccessor();
      var orgY_is_red;
      var x_item;

      if (item._child_L === T_nil) {
        // (a) å·¦å´ãªã
        orgY_is_red = item._is_red;
        x_item = item._child_R;

        this._replace(item._child_R, item);
      } else if (item._child_R === T_nil) {
        // (b) å³å´ãªã (å·¦å´ãã)
        orgY_is_red = item._is_red;
        x_item = item._child_L;

        this._replace(item._child_L, item);
      } else {
        // å·¦å³ãã
        orgY_is_red = succ._is_red;
        x_item = succ._child_R;

        if (succ._parent === item) {
          // (c) item ã®å¾ç¶ã item ã®å³ã®å­
          // x_item ã T_nil ã§ãã£ã¦ãè¦ªãè¨­å®
          x_item._parent = succ;
        } else {
          // (d) item ã®å¾ç¶ã item ã®å³ã®å­ã®å·¦å´
          this._replace(succ._child_R, succ);

          succ._child_R = item._child_R;
          succ._child_R._parent = succ;
        } // (c), (d)


        this._replace(succ, item);

        succ._child_L = item._child_L;
        succ._child_L._parent = succ;
        succ._is_red = item._is_red;
      } // è¦ç´ æ°ãæ¸å°


      --this._size;

      if (!orgY_is_red
      /* é» */
      ) {
          // 2è²æ¨æ¡ä»¶ã®åå¾©
          this._remove_fixup(x_item);
        }

      return succ;
    }
    /**
     * @summary åé¤å¾ã«2è²æ¨æ¡ä»¶ãæºããããã«æ¨ãä¿®æ­£
     *
     * @param {mapray.OrderedMap.Item} x_item
     *
     * @see IA3/13.4 åé¤
     *
     * @private
     */

  }, {
    key: "_remove_fixup",
    value: function _remove_fixup(x_item) {
      var trail = x_item;

      while (trail !== this._root && !trail._is_red
      /* é» */
      ) {
        if (trail === trail._parent._child_L) {
          // trail ã¯è¦ªã®å·¦å´
          var sibling = trail._parent._child_R;

          if (sibling._is_red
          /* èµ¤ */
          ) {
              // å ´å 1
              sibling._is_red = false; // é»

              trail._parent._is_red = true; // èµ¤

              this._rotate_L(trail._parent);

              sibling = trail._parent._child_R;
            }

          if (!sibling._child_L._is_red
          /* é» */
          && !sibling._child_R._is_red
          /* é» */
          ) {
              // å ´å 2
              sibling._is_red = true; // èµ¤

              trail = trail._parent;
            } else {
            if (!sibling._child_R._is_red
            /* é» */
            ) {
                // å ´å 3
                sibling._child_L._is_red = false; // é»

                sibling._is_red = true; // èµ¤

                this._rotate_R(sibling);

                sibling = trail._parent._child_R;
              } // å ´å 3,4


            sibling._is_red = trail._parent._is_red;
            trail._parent._is_red = false; // é»

            sibling._child_R._is_red = false; // é»

            this._rotate_L(trail._parent);

            trail = this._root;
          }
        } else {
          // trail ã¯è¦ªã®å³å´
          var _sibling = trail._parent._child_L;

          if (_sibling._is_red
          /* èµ¤ */
          ) {
              // å ´å 1
              _sibling._is_red = false; // é»

              trail._parent._is_red = true; // èµ¤

              this._rotate_R(trail._parent);

              _sibling = trail._parent._child_L;
            }

          if (!_sibling._child_R._is_red
          /* é» */
          && !_sibling._child_L._is_red
          /* é» */
          ) {
              // å ´å 2
              _sibling._is_red = true; // èµ¤

              trail = trail._parent;
            } else {
            if (!_sibling._child_L._is_red
            /* é» */
            ) {
                // å ´å 3
                _sibling._child_R._is_red = false; // é»

                _sibling._is_red = true; // èµ¤

                this._rotate_L(_sibling);

                _sibling = trail._parent._child_L;
              } // å ´å 3,4


            _sibling._is_red = trail._parent._is_red;
            trail._parent._is_red = false; // é»

            _sibling._child_L._is_red = false; // é»

            this._rotate_R(trail._parent);

            trail = this._root;
          }
        }
      }

      trail._is_red = false; // é»
    }
    /**
     * @summary ã¢ã¤ãã ã®ç½®ãæã
     *
     * @desc
     * <p>dst ã®å ´æã src ã¢ã¤ãã ã§ç½®ãæãããsrc ã T_nil ã®ã¨ãã¯ dst ã®å ´æã¯èã«ãªãã</p>
     * <p>dst ã®è¦ªã®å·¦ã¾ãã¯å³ã®å­ä¾ (ã¾ãã¯ this._root) ã¨ src._parent ã¯å¤æ´ãããããdst
     *    èªèº«ã®åå®¹ã¯å¤æ´ãããªãã</p>
     *
     * @param {mapray.OrderedMap.Item} src
     * @param {mapray.OrderedMap.Item} dst
     *
     * @private
     */

  }, {
    key: "_replace",
    value: function _replace(src, dst) {
      var dp = dst._parent;

      if (dp !== T_nil) {
        if (dp._child_L === dst) {
          // dst ã¯ dp ã®å·¦å´
          dp._child_L = src;
        } else {
          // dst ã¯ dp ã®å³å´
          dp._child_R = src;
        }
      } else {
        // dst ã¯æä¸ä½
        this._root = src;
      } // src ã®è¦ªãå¤æ´


      src._parent = dp;
    }
    /**
     * @summary ã¢ã¤ãã ãå·¦åè»¢
     *
     * è¨ç®é: O(1)
     *
     * @see IA3/13.2 åè»¢
     *
     * @param {mapray.OrderedMap.Item} pivot  åè»¢ä¸­å¿ã®ã¢ã¤ãã 
     *
     * @private
     */

  }, {
    key: "_rotate_L",
    value: function _rotate_L(pivot) {
      // next ã¯åè»¢å¾ã« pivot ã®ä½ç½®ã«ãªã
      var next = pivot._child_R; // pivot ã®å³å´ã next ã®å·¦å´ã«è¨­å®

      pivot._child_R = next._child_L;

      if (next._child_L !== T_nil) {
        next._child_L._parent = pivot;
      } // next ã®è¦ªã pivot ã®åã®è¦ªã«è¨­å®


      next._parent = pivot._parent;

      if (pivot._parent === T_nil) {
        this._root = next;
      } else if (pivot === pivot._parent._child_L) {
        pivot._parent._child_L = next;
      } else {
        pivot._parent._child_R = next;
      } // next ã®å·¦å´ã pivot ã«è¨­å®


      next._child_L = pivot;
      pivot._parent = next;
    }
    /**
     * @summary ã¢ã¤ãã ãå³åè»¢
     *
     * è¨ç®é: O(1)
     *
     * @see IA3/13.2 åè»¢
     *
     * @param {mapray.OrderedMap.Item} pivot  åè»¢ä¸­å¿ã®ã¢ã¤ãã 
     *
     * @private
     */

  }, {
    key: "_rotate_R",
    value: function _rotate_R(pivot) {
      // next ã¯åè»¢å¾ã« pivot ã®ä½ç½®ã«ãªã
      var next = pivot._child_L; // pivot ã®å·¦å´ã next ã®å³å´ã«è¨­å®

      pivot._child_L = next._child_R;

      if (next._child_R !== T_nil) {
        next._child_R._parent = pivot;
      } // next ã®è¦ªã pivot ã®åã®è¦ªã«è¨­å®


      next._parent = pivot._parent;

      if (pivot._parent === T_nil) {
        this._root = next;
      } else if (pivot === pivot._parent._child_R) {
        pivot._parent._child_R = next;
      } else {
        pivot._parent._child_L = next;
      } // next ã®å³å´ã pivot ã«è¨­å®


      next._child_R = pivot;
      pivot._parent = next;
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    }
  }]);

  return OrderedMap;
}();
/**
 * @summary OrderedMap ã®ã¢ã¤ãã 
 *
 * @classdesc
 * <p>ãã¹ã¦ã® this._child_L ã®ã¢ã¤ãã  L ã«å¯¾ãã¦ Compare( L._key, this._key ) ãæãç«ã¤ã</p>
 * <p>ãã¹ã¦ã® this._child_R ã®ã¢ã¤ãã  R ã«å¯¾ãã¦ Compare( this._key, R._key ) ãæãç«ã¤ã</p>
 *
 * @memberof mapray.OrderedMap
 * @private
 */


var Item =
/*#__PURE__*/
function () {
  /**
   * @desc
   * <p>è²ã¯é»ã«è¨­å®ãããã</p>
   *
   * @param {mapray.OrderedMap.Item}  parent  è¦ªã¢ã¤ãã 
   * @param {mapray.OrderedMap.Key}   key     ã¢ã¤ãã ã®ã­ã¼
   * @param {mapray.OrderedMap.Value} value   ã¢ã¤ãã ã®å¤
   */
  function Item(parent, key, value) {
    _classCallCheck(this, Item);

    this._parent = parent;
    this._child_L = T_nil; // å·¦å´ããªã¼

    this._child_R = T_nil; // å³å´ããªã¼

    this._is_red = false; // è²: é»=false, èµ¤=true

    this._key = key;
    this._value = value;
  }
  /**
   * @summary ã­ã¼
   *
   * @type {mapray.OrderedMap.Key}
   * @readonly
   */


  _createClass(Item, [{
    key: "_clone",

    /**
     * @summary ã¤ã³ã¹ã¿ã³ã¹ãè¤è£½
     *
     * @desc
     * <p>ã­ã¼ãå¤ã¯ã·ã£ã­ã¼ã³ãã¼ãããã<p>
     *
     * @param {mapray.OrderedMap.Item} parant  è¦ªã¢ã¤ãã  (this ãæ ¹ã®ã¨ãã¯ T_nil)
     *
     * @return {mapray.OrderedMap.Item}  this ã®è¤è£½
     *
     * @private
     */
    value: function _clone(parent) {
      // å­å­«ã¨è²ä»¥å¤ãè¤è£½
      var cloned = new Item(parent, this._key, this._value); // å·¦å´å­å­«ãè¤è£½

      if (this._child_L !== T_nil) {
        cloned._child_L = this._child_L._clone(cloned);
      } // å³å´å­å­«ãè¤è£½


      if (this._child_R !== T_nil) {
        cloned._child_R = this._child_R._clone(cloned);
      } // è²ãè¤è£½


      cloned._is_red = this._is_red;
      return cloned;
    }
    /**
     * @summary åé ­ã¢ã¤ãã ã®æ¤ç´¢
     *
     * @desc
     * <p>this ããªã¼ã®ä¸­ã§æãåã®é åºã®ã¢ã¤ãã ãæ¤ç´¢ããã</p>
     *
     * <p>è¨ç®é: this ããªã¼ã®ã¢ã¤ãã æ° n ã«å¯¾ãã¦ O(log n)</p>
     *
     * @return {mapray.OrderedMap.Item}  æ¤ç´¢ãããã¢ã¤ãã 
     *
     * @private
     */

  }, {
    key: "_findMinimum",
    value: function _findMinimum() {
      var item = this; // è¿½è·¡ãã¤ã³ã¿

      while (item._child_L !== T_nil) {
        item = item._child_L;
      }

      return item;
    }
    /**
     * @summary å¾å°¾ã¢ã¤ãã ã®æ¤ç´¢
     *
     * @desc
     * <p>this ããªã¼ã®ä¸­ã§æãå¾ã®é åºã®ã¢ã¤ãã ãæ¤ç´¢ããã</p>
     *
     * <p>è¨ç®é: this ããªã¼ã®ã¢ã¤ãã æ° n ã«å¯¾ãã¦ O(log n)</p>
     *
     * @return {mapray.OrderedMap.Item}  æ¤ç´¢ãããã¢ã¤ãã 
     *
     * @private
     */

  }, {
    key: "_findMaximum",
    value: function _findMaximum() {
      var item = this; // è¿½è·¡ãã¤ã³ã¿

      while (item._child_R !== T_nil) {
        item = item._child_R;
      }

      return item;
    }
    /**
     * @summary åã®ã¢ã¤ãã ã®æ¤ç´¢
     *
     * @desc
     * <p>root ããªã¼ãã this ã®åã®é åºã®ã¢ã¤ãã ãæ¤ç´¢ãããthis ãåé ­ãªã null ãè¿ãã</p>
     *
     * <p>è¨ç®é: è¾æ¸ã®è¦ç´ æ° n ã«å¯¾ãã¦ææª O(log n)</p>
     * <p>todo: å¹³åè¨ç®éãåæãã</p>
     *
     * @return {?mapray.OrderedMap.Item}  æ¤ç´¢ãããã¢ã¤ãã ãå­å¨ããªããã° null
     */

  }, {
    key: "findPredecessor",
    value: function findPredecessor() {
      // å·¦å´å­å­«ãããã°ãå·¦å´å­å­«ã®å¾å°¾
      if (this._child_L !== T_nil) {
        return this._child_L._findMaximum();
      } // å·¦å´å­å­«ãããªããã°ãthis ãå³å´å­å­«ã¨ãã¦æã¤æãè¿ãç¥å
      // ããããªããã° this ã¯å¨ä½ããªã¼ã®åé ­ãªã®ã§æ¤ç´¢å¤±æ


      var item = this;
      var parent = item._parent;

      while (parent !== T_nil && item === parent._child_L) {
        item = parent;
        parent = item._parent;
      }

      return parent !== T_nil ? parent : null;
    }
    /**
     * @summary æ¬¡ã®ã¢ã¤ãã ã®æ¤ç´¢
     *
     * @desc
     * <p>root ããªã¼ãã this ã®æ¬¡ã®é åºã®ã¢ã¤ãã ãæ¤ç´¢ãããthis ãå¾å°¾ãªã null ãè¿ãã</p>
     *
     * <p>è¨ç®é: è¾æ¸ã®è¦ç´ æ° n ã«å¯¾ãã¦ææª O(log n)</p>
     * <p>todo: å¹³åè¨ç®éãåæãã</p>
     *
     * @return {?mapray.OrderedMap.Item}  æ¤ç´¢ãããã¢ã¤ãã ãå­å¨ããªããã° null
     */

  }, {
    key: "findSuccessor",
    value: function findSuccessor() {
      // å³å´å­å­«ãããã°ãå³å´å­å­«ã®åé ­
      if (this._child_R !== T_nil) {
        return this._child_R._findMinimum();
      } // å³å´å­å­«ãããªããã°ãthis ãå·¦å´å­å­«ã¨ãã¦æã¤æãè¿ãç¥å
      // ããããªããã° this ã¯å¨ä½ããªã¼ã®å¾å°¾ãªã®ã§æ¤ç´¢å¤±æ


      var item = this;
      var parent = item._parent;

      while (parent !== T_nil && item === parent._child_R) {
        item = parent;
        parent = item._parent;
      }

      return parent !== T_nil ? parent : null;
    }
    /**
     * @summary ä¸éã¢ã¤ãã ãæ¤ç´¢
     *
     * @desc
     * <p>this ããªã¼ã®ä¸­ã§ !comp(item.key, bkey) ã¨ãªãæåã®ã¢ã¤ãã ãæ¤ç´¢ããã</p>
     * <p>ã¤ã¾ã bkey ã¨åãã¾ãã¯å¾ã«ãªãã­ã¼ã this ããªã¼ã«å­å¨ããã°ããã®ä¸­ã§æåã®ã¢ã¤ãã ãè¿ãã</p>
     * <p>ãã®ãããªã¢ã¤ãã ãå­å¨ããªãå ´åã¯ null ãè¿ãã</p>
     * <p>this ã T_nil ã®å ´åã¯ null ãè¿ãã</p>
     *
     * <p>è¨ç®é: this ããªã¼ã®ã¢ã¤ãã æ° n ã«å¯¾ãã¦ææª O(log n)</p>
     *
     * @param {mapray.OrderedMap.Key}     bkey  å¢çã­ã¼
     * @param {mapray.OrderedMap.Compare} comp  ã­ã¼æ¯è¼é¢æ°
     *
     * @return {?mapray.OrderedMap.Item}  æ¤ç´¢ãããã¢ã¤ãã ãå­å¨ããªããã° null
     *
     * @private
     */

  }, {
    key: "_findLowerBound",
    value: function _findLowerBound(bkey, comp) {
      var item = this;

      while (item !== T_nil) {
        if (comp(bkey, item._key)) {
          // bkey < item.key
          if (item._child_L !== T_nil) {
            var found = item._child_L._findLowerBound(bkey, comp);

            if (found !== null) return found;
          }

          return item;
        } else if (comp(item._key, bkey)) {
          // bkey > item.key
          item = item._child_R;
        } else {
          // bkey == item.key (ç­ä¾¡)
          return item;
        }
      }

      return null;
    }
    /**
     * @summary ä¸éã¢ã¤ãã ãæ¤ç´¢
     *
     * @desc
     * <p>this ããªã¼ã®ä¸­ã§ comp(bkey, item.key) ã¨ãªãæåã®ã¢ã¤ãã ãæ¤ç´¢ããã</p>
     * <p>ã¤ã¾ã bkey ããå¾ã«ãªãã­ã¼ã this ããªã¼ã«å­å¨ããã°ããã®ä¸­ã§æåã®ã¢ã¤ãã ãè¿ãã</p>
     * <p>ãã®ãããªã¢ã¤ãã ãå­å¨ããªãå ´åã¯ null ãè¿ãã</p>
     * <p>this ã T_nil ã®å ´åã¯ null ãè¿ãã</p>
     *
     * <p>è¨ç®é: this ããªã¼ã®ã¢ã¤ãã æ° n ã«å¯¾ãã¦ææª O(log n)</p>
     *
     * @param {mapray.OrderedMap.Key}     bkey  å¢çã­ã¼
     * @param {mapray.OrderedMap.Compare} comp  ã­ã¼æ¯è¼é¢æ°
     *
     * @return {?mapray.OrderedMap.Item}  æ¤ç´¢ãããã¢ã¤ãã ãå­å¨ããªããã° null
     *
     * @private
     */

  }, {
    key: "_findUpperBound",
    value: function _findUpperBound(bkey, comp) {
      var item = this;

      while (item !== T_nil) {
        if (comp(bkey, item._key)) {
          // bkey < item.key
          if (item._child_L !== T_nil) {
            var found = item._child_L._findUpperBound(bkey, comp);

            if (found !== null) return found;
          }

          return item;
        } else {
          // bkey >= item.key
          item = item._child_R;
        }
      }

      return null;
    }
    /**
     * @summary ç­ä¾¡ã­ã¼ã®ã¢ã¤ãã ãæ¤ç´¢
     *
     * @desc
     * <p>this ããªã¼ã®ä¸­ã§ !comp(key, item.key) ãã¤ !comp(item.key, key) ã¨ãªãã¢ã¤ãã ãæ¤ç´¢ããã</p>
     * <p>ãã®ãããªã¢ã¤ãã ãå­å¨ããªãå ´åã¯ null ãè¿ãã</p>
     * <p>this == T_nil ã®å ´åã¯ null ãè¿ãã</p>
     *
     * <p>è¨ç®é: this ããªã¼ã®ã¢ã¤ãã æ° n ã«å¯¾ãã¦ææª O(log n)</p>
     *
     * @param {mapray.OrderedMap.Key}     key   ã­ã¼
     * @param {mapray.OrderedMap.Compare} comp  ã­ã¼æ¯è¼é¢æ°
     *
     * @return {?mapray.OrderedMap.Item}  æ¤ç´¢ãããã¢ã¤ãã ãå­å¨ããªããã° null
     *
     * @private
     */

  }, {
    key: "_findEqual",
    value: function _findEqual(key, comp) {
      var item = this;

      while (item !== T_nil) {
        if (comp(key, item._key)) {
          // key < item.key
          item = item._child_L;
        } else if (comp(item._key, key)) {
          // bkey > item.key
          item = item._child_R;
        } else {
          // bkey == item.key (ç­ä¾¡)
          return item;
        }
      }

      return null;
    }
    /**
     * @summary ä¸éã¢ã¤ãã ãæ¤ç´¢ (æ¤è¨ä¸­)
     *
     * @desc
     * <p>root ããªã¼ã®ä¸­ã§ !comp(item.key, bkey) ã¨ãªãæåã®ã¢ã¤ãã ãæ¤ç´¢ããã</p>
     * <p>ã¤ã¾ã bkey ã¨åãã¾ãã¯å¾ã«ãªãã­ã¼ã root ããªã¼ã«å­å¨ããã°ããã®ä¸­ã§æåã®ã¢ã¤ãã ãè¿ãã</p>
     * <p>ãã®ãããªã¢ã¤ãã ãå­å¨ããªãå ´åã¯ null ãè¿ãã</p>
     *
     * <p>è¨ç®é: root ããªã¼ã®ã¢ã¤ãã æ° n ã«å¯¾ãã¦ææª O(log^2 n)</p>
     *
     * @param {mapray.OrderedMap.Key}     bkey  å¢çã­ã¼
     * @param {mapray.OrderedMap.Compare} comp  ã­ã¼æ¯è¼é¢æ°
     *
     * @return {?mapray.OrderedMap.Item}  æ¤ç´¢ãããã¢ã¤ãã ãå­å¨ããªããã° null
     *
     * @private
     */

  }, {
    key: "_findLowerBoundR",
    value: function _findLowerBoundR(bkey, comp) {
      var item = this;

      if (item._parent !== T_nil) {
        // item == root
        return item._findLowerBound(bkey, comp);
      }

      var imin = item._findMinimum();

      var imax = item._findMaximum();

      do {
        if (!comp(bkey, imin._key) && !comp(imax._key, bkey)) {
          // imin <= bkey <= imax ãªã®ã§
          // item._findLowerBound() ã§å¿ãè¦ã¤ãã
          break;
        }

        if (item._parent._child_L === item) {
          // item ã¯ parent ã®å·¦å´ãªã®ã§ãç»ãã¨ imax ã®ã¿ãå¤å
          imax = item._findMaximum();
        } else {
          // item ã¯ parent ã®å³å´ãªã®ã§ãç»ãã¨ imin ã®ã¿ãå¤å
          imin = item._findMinimum();
        } // item ã¯ç»ã


        item = item._parent;
      } while (item._parent !== T_nil); // item == root


      return item._findLowerBound(bkey, comp);
    }
  }, {
    key: "key",
    get: function get() {
      return this._key;
    }
    /**
     * @summary å¤
     *
     * @type {mapray.OrderedMap.Value}
     * @readonly
     */

  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
  }]);

  return Item;
}(); // çªåµãçæ


T_nil = new Item();

/**
 * @summary ã¢ãã¡ã¼ã·ã§ã³é¢æ°å¤ã®ä¸å¤æ§æå ±
 *
 * @classdesc
 * <p>Curve ã®ãµãã¯ã©ã¹ã®å®è£èããã¢ãã¡ã¼ã·ã§ã³é¢æ°å¤ãä¸å®ã¨ãªãæå»åºéãè¡¨æããããã«å©ç¨ããã¯ã©ã¹ã§ããã</p>
 *
 * @see {@link mapray.animation.Curve#getInvariance}
 *
 * @memberof mapray.animation
 */

var Invariance =
/*#__PURE__*/
function () {
  function Invariance() {
    _classCallCheck(this, Invariance);

    this._imap = createEmptyMap();
  }
  /**
   * @summary è¤è£½ãåå¾
   *
   * @desc
   * <p>this ã¨åãåå®¹ã®ã¤ã³ã¹ã¿ã³ã¹ãçæããã</p>
   *
   * <p>è¨ç®é: æå»åºéæ° n ã«å¯¾ãã¦ O(n)</p>
   *
   * @return {mapray.animation.Invariance}  this ã®è¤è£½
   */


  _createClass(Invariance, [{
    key: "clone",
    value: function clone() {
      var cloned = new Invariance(); // Time ã¨ Interval ã¯ã¤ãã¥ã¼ã¿ãã«ãªã®ã§ã·ã£ã­ã¼ã³ãã¼ã§åå

      cloned._imap = this._imap.clone();
      return cloned;
    }
    /**
     * @summary åä¸å¤ã®æå»åºéãä¸æ¸ã
     *
     * @desc
     * <p>this ãæã£ã¦ãããã¹ã¦ã®åä¸å¤æå»åºéã« interval ã®æå»åºéé¨åãä¸æ¸ãããã</p>
     *
     * <p>ã¤ã¡ã¼ã¸çã«ã¯ interval é¨åã«æ¯åæ°ããè²ãéã­ã¦ãããæçµçã«ã§ããåè²ã®åºéãåä¸å¤ã®æå»åºéã¨è¦ãªãã</p>
     *
     * @param {mapray.animation.Interval} interval  åä¸å¤ãæã¤æå»åºé
     *
     * @return {mapray.animation.Invariance}  this
     */

  }, {
    key: "write",
    value: function write(interval) {
      // todo: è¨ç®éãåæ (remove() ã«ä¾å­)
      this.remove(interval);

      this._insert(interval);

      return this;
    }
    /**
     * @summary æå»åºéã®æ¶å»
     *
     * @desc
     * <p>this ãæã£ã¦ãããã¹ã¦ã®åä¸å¤æå»åºéãã interval ã®æå»åºéé¨åãæ¶å»ããã</p>
     *
     * <p>ã¤ã¡ã¼ã¸çã«ã¯ {@link mapray.animation.Invariance#write write()} ã§éã­ãè²ã®
     *    interval é¨åãéæã«ããã</p>
     *
     * @param {mapray.animation.Interval} interval  æå»åºé
     *
     * @return {mapray.animation.Invariance}  this
     */

  }, {
    key: "remove",
    value: function remove(interval) {
      // todo: è¨ç®éãåæ (OrderMap#remove() ã«ä¾å­)
      if (interval.isEmpty()) {
        // ç©ºæå»åºéã®æ¶å»ã¯å¤åãªã
        return this;
      } // interval.lower ååºéã«ååãããæåã®è¦ç´  (ç¡ããã° null)


      var fit = interval.l_open ? this._imap.findUpper(interval.lower) : this._imap.findLower(interval.lower); // fit ã«åè¡ããè¦ç´  (ç¡ããã° null)

      var pfit = fit !== null ? fit.findPredecessor() : this._imap.findLast();

      this._chopItem(pfit, interval);

      if (fit !== null && interval.includes(fit.value)) {
        // fit ã¯ interval ã«ååãããæåã®è¦ç´ 
        // interval ã®å¾ç¶ã§æåã®è¦ç´  (ç¡ããã° null)
        var it2 = interval.u_open ? this._imap.findLower(interval.upper) : this._imap.findUpper(interval.upper); // it2 ã®åè¡ (é null)

        var it1 = it2 !== null ? it2.findPredecessor() : this._imap.findLast(); // fit ã®å¾ç¶ã§ interval ã«ååãããªãæåã®è¦ç´  (ç¡ããã° null)

        var lit = interval.includes(it1.value) ? it2 : it1; // interval ã«ååãããè¦ç´ ããã¹ã¦åé¤

        this._imap.remove(fit, lit); // lit ã¯ interval ã¨äº¤å·®ãã¦ããå¯è½æ§ããã


        this._chopItem(lit, interval);
      } else {
        // interval ã¯ã©ã®æå»åºéãååããªã
        // fit ã¯ interval ã¨äº¤å·®ãã¦ããå¯è½æ§ããã
        this._chopItem(fit, interval);
      }

      return this;
    }
    /**
     * @summary é¸æç¯å²ã«çµã£ãä¸å¤æ§æå ±ãåå¾
     *
     * @desc
     * <p>interval ã§æå®ããé¸æç¯å²ã¨äº¤å·®ããä¸å®å¤æå»åºéãé¸æãã¦ãæ°ããä¸å¤æ§æå ±ã®ã¤ã³ã¹ã¿ã³ã¹ãè¿ãã</p>
     *
     * @param {mapray.animation.Interval} narrow  é¸æç¯å²
     *
     * @return {mapray.animation.Invariance}  ç¯å²ãç­ããä¸å¤æ§æå ±
     */

  }, {
    key: "getNarrowed",
    value: function getNarrowed(narrow) {
      var invr = new Invariance();

      if (narrow.isEmpty()) {
        // äº¤å·®ããªãã®ã§ç©ºãè¿ã
        return invr;
      } // narrow ã¨äº¤å·®ããç¯å²ãæ±ºå®


      var lo1 = this._imap.findUpper(narrow.lower);

      var lo0 = lo1 !== null ? lo1.findPredecessor() : this._imap.findLast();
      var lower = lo0 !== null && lo0.value.hasIntersection(narrow) ? lo0 : lo1;
      var upper = narrow.u_open ? this._imap.findLower(narrow.upper) : this._imap.findUpper(narrow.upper); // invr ã¸ [lower, upper) ãè¿½å 

      for (var it = lower; it !== upper; it = it.findSuccessor()) {
        invr._imap.insert(it.key, it.value);
      }

      return invr;
    }
    /**
     * @summary è¤æ°ã® Invariance ãçµ±å
     *
     * @desc
     * <p>invariances ã®ãã¹ã¦ã®åä¸å¤æå»åºéã®å±éåºéãæã£ã Invariance ã¤ã³ã¹ã¿ã³ã¹ãçæããã</p>
     *
     * @param {mapray.animation.Invariance[]} invariances  çµ±ååã®ãªã¹ã
     *
     * @return {mapray.animation.Invariance}  çµ±åçµæ
     */

  }, {
    key: "_$getArray",

    /**
     * @summary æå»åºéã®éåãåå¾
     *
     * @desc
     * <p>Proper ã®æå»åºéãæå»é ã§æ ¼ç´ãããéåãè¿ãã</p>
     *
     * @return {mapray.animation.Interval[]}  æå»åºéã®éå
     *
     * @package
     */
    value: function _$getArray() {
      var array = [];

      for (var it = this._imap.findFirst(); it !== null; it = it.findSuccessor()) {
        array.push(it.value);
      }

      return array;
    }
    /**
     * @summary ä¸å¤æ§æå ±ãä¿®æ­£
     *
     * @desc
     * <p>Curve#getInvariance() ã§å¾ãä¸é¨ã®ä¸å¤æ§æå ± subinvr ãåã« this ãæ´æ°ããã</p>
     * <p>æ´æ°å¾ã® this ã¯ Curve ã¤ã³ã¹ã¿ã³ã¹å¨ä½ã®ä¸å¤æ§æå ±ã¨ä¸è´ãããã¨ãæå¾ãããã</p>
     *
     * @param {mapray.animation.Invariance} subinvr  æ´æ°é¨å
     *
     * @package
     */

  }, {
    key: "_$modify",
    value: function _$modify(subinvr) {
      // subinvr ã®æåã¨æå¾
      var ita = subinvr._imap.findFirst();

      if (ita === null) {
        // subinvr ã¯ç©ºãªã®ã§å¤åãªã
        return;
      }

      var itb = subinvr._imap.findLast(); // subinvr ã®å¨ç¯å²ãããã¬ã


      var ai = ita.value;
      var bi = itb.value;
      this.remove(new Interval(ai.lower, bi.upper, ai.l_open, bi.u_open)); // subinvr ã®ãã¹ã¦ã®æå»åºéãæ¿å¥
      // è¨ç®é: this ã®è¦ç´ æ° n, subinvr ã®è¦ç´ æ° m ã«å¯¾ãã¦ O(m log n)

      for (var it = ita; it !== null; it = it.findSuccessor()) {
        this._insert(it.value);
      }
    }
    /**
     * @summary æå»åºéãæ´åã«ããæ¡å¼µ
     *
     * @desc
     * <p>interval ã®ç«¯ã this ã®ããåºéåã«ãªããªããåã¾ãã¯æ¬¡ã®åºéã®å¢çã¾ã§æ¡å¤§ããã</p>
     *
     * <p>äºåæ¡ä»¶: !interval.isEmpty()</p>
     *
     * @param {mapray.animation.Interval} interval  æ¡å¤§å¯¾è±¡ã®æå»åºé
     *
     * @return {mapray.animation.Interval}  æ¡å¤§ãããæå»åºé
     *
     * @package
     */

  }, {
    key: "_$expandIntervalByAlignment",
    value: function _$expandIntervalByAlignment(interval) {
      var map = this._imap; // å·¦å´

      var lower; // Interval

      {
        var it1 = map.findLower(interval.lower);

        if (it1 !== null && it1.value.lower.equals(interval.lower) && (interval.l_open || !it1.value.l_open)) {
          // intervalã®ä¸éæå» ã¨ it1 ã®ä¸éæå»ãä¸è´ãã
          // interval ã®å·¦ç«¯æå»ã it1 åºéã«å«ã¾ãã
          lower = interval;
        } else {
          var it0 = it1 !== null ? it1.findPredecessor() : map.findLast();

          if (it0 !== null) {
            if (it0.value.hasIntersection(interval)) {
              // interval ã®å·¦ç«¯ã¨ it0 ãäº¤å·®ãã
              lower = interval;
            } else {
              // interval ã®å·¦ç«¯ã¨ it0 ãäº¤å·®ããªã
              lower = it0.value.getFollowings();
            }
          } else {
            // interval ã®å·¦ç«¯ã¨äº¤å·®ããåºéã¯ãªãããã®å·¦å´ã«ãåºéããªã
            lower = Interval.UNIVERSAL;
          }
        }
      } // å³å´

      var upper; // Interval

      {
        var _it = map.findLower(interval.upper);

        if (_it !== null && interval.upper.equals(_it.value.lower) && (!interval.u_open || !_it.value.l_open)) {
          // interval ä¸éæå»ã¨ it1 ã®ä¸éæå»ãä¸è´ãã
          // interval ã®å³ç«¯æå»ã it1 åºéã«å«ã¾ãã
          upper = interval;
        } else {
          var _it2 = _it !== null ? _it.findPredecessor() : map.findLast();

          if (_it2 !== null && _it2.value.hasIntersection(interval) && (interval.upper.lessThan(_it2.value.upper) || interval.upper.equals(_it2.value.upper) && (interval.u_open || !_it2.value.u_open))) {
            // interval ã®å³ç«¯ã¨ it0 ãäº¤å·®ãã
            upper = interval;
          } else {
            // interval ã®å³ç«¯ã¨ it0 ãäº¤å·®ããªã
            upper = _it !== null ? _it.value.getPrecedings() : Interval.UNIVERSAL;
          }
        }
      }
      return new Interval(lower.lower, upper.upper, lower.l_open, upper.u_open);
    }
    /**
     * @summary item ãã interval é¨åãåãåã
     *
     * @desc
     * <p>item ã®æå»åºéãã interval é¨åãæ¶å»ããã</p>
     * <p>ãã ã item ã null ã®ã¨ãã¯ä½ãããªãã</p>
     * <p>æå¾ã« item ã¯ç¡å¹ã«ãªãã</p>
     *
     * @param {?mapray.OrderedMap.Item}   item
     * @param {mapray.animation.Interval} interval
     *
     * @private
     */

  }, {
    key: "_chopItem",
    value: function _chopItem(item, interval) {
      if (item === null) {
        // ä½ãããªã
        return;
      }

      var diffs = item.value.getDifference(interval); // åã£ãæå»åºéãå¥ãæ¿ã

      this._imap.remove(item);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = diffs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var di = _step.value;

          if (di.isProper()) {
            this._imap.insert(di.lower, di);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * @summary æå»åºéãæ¿å¥
     *
     * @desc
     * <p>æ¡ä»¶: this._imap ã« interval ã¨äº¤å·®ããåºéãå­å¨ããªã</p>
     *
     * <p>è¨ç®é: æå»åºéæ° n ã«å¯¾ãã¦ææª O(log n)</p>
     *
     * @param {mapray.animation.Interval} interval  æå»åºé
     *
     * @private
     */

  }, {
    key: "_insert",
    value: function _insert(interval) {
      if (!interval.isProper()) {
        // Empty ã¨ Single ã®æå»åºéã¯ä¿æããªã
        return;
      }

      this._imap.insert(interval.lower, interval);
    }
    /**
     * @summary Invariance ãçµ±å
     *
     * è¨ç®é:
     *   this ã®æå»åºéæ° k
     *   source ã®æå»åºéæ° n
     *   this ã®åæå»åºéç¯å²åã® source ã®æå»åºéæ° mã(å¹³åå¤)
     *   merged_imap ã®æå»åºéæ° p
     *
     * findSuccessor() ã O(1) ã¨èããã¨ã
     *   O(k * (m * log p + log n))
     *
     * @param {mapray.animation.Invariance} source
     *
     * @private
     */

  }, {
    key: "_merge_from_invariance",
    value: function _merge_from_invariance(source) {
      var merged_imap = createEmptyMap();

      for (var target = this._imap.findFirst(); target !== null; target = target.findSuccessor()) {
        mergeIntervalInvariance(target.value, source, merged_imap);
      }

      this._imap = merged_imap;
    }
  }], [{
    key: "merge",
    value: function merge(invariances) {
      var result = new Invariance();
      result.write(Interval.UNIVERSAL);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = invariances[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var source = _step2.value;

          result._merge_from_invariance(source);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return result;
    }
  }]);

  return Invariance;
}();
/**
 * @summary _merge_from_invariance() ã®ä¸é¨
 *
 * è¨ç®é:
 *   source ã®æå»åºéæ° n
 *   tgtIv ç¯å²åã® source æå»åºéæ° m
 *   merged_imap ã®æå»åºéæ° p
 *
 * findSuccessor() ã O(1) ã¨èããã¨ã
 *   O(m * log p + log n)
 *   
 * @param {mapray.animation.Interval}    tgtIv  æå»åºé
 * @param {mapray.animation.Invariance} source
 * @param {mapray.OrderedMap}      merged_imap
 *
 * @private
 */


function mergeIntervalInvariance(tgtIv, source, merged_imap) {
  var src_imap = source._imap; // tgtIv ã®ç¯å²ã® source åã®æå»åºéãæ±ºå®
  // è¨ç®é: source ã®æå»åºéæ° n ã«å¯¾ãã¦ O(log n)

  var lower = src_imap.findLower(tgtIv.lower);
  var fit = lower !== null ? lower.findPredecessor() : null;

  if (fit === null) {
    fit = src_imap.findFirst();
  }

  var lit = src_imap.findUpper(tgtIv.upper); // fit ãã lit ã¾ã§ã®æå»åºéã¨ tgtIv ã¨ã®äº¤å·®ã merged_imap ã¸è¿½å 
  // è¨ç®é: merged_imap ã®æå»åºéæ° p, tgtIv ç¯å²åã® source æå»åºéæ° m
  // ã«å¯¾ãã¦ææª O(m * log n * log p)

  for (var it = fit; it !== lit; it = it.findSuccessor()) {
    var srcIv = it.value;
    var cross = tgtIv.getIntersection(srcIv);

    if (cross.isProper()) {
      merged_imap.insert(cross.lower, cross);
    }
  }
}
/** 
 * @summary ç©ºã®æå»åºéããããçæ
 *
 * @desc
 * Proper æå»åºéãäº¤å·®ãããæå»é ã«ä¸¦ãã§ãã
 * ãã®æ¡ä»¶ã§ã¯æå»åºéã®ä¸éæå»ãã­ã¼ã¨ãã¦æ´åã§ãã
 *
 * @return {mapray.OrderedMap}
 *
 * @private
 */


function createEmptyMap() {
  return new OrderedMap(function (a, b) {
    return a.lessThan(b);
  });
}

var freezing = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});

var internalMetadata = createCommonjsModule(function (module) {
  var defineProperty = objectDefineProperty.f;
  var METADATA = uid('meta');
  var id = 0;

  var isExtensible = Object.isExtensible || function () {
    return true;
  };

  var setMetadata = function (it) {
    defineProperty(it, METADATA, {
      value: {
        objectID: 'O' + ++id,
        // object ID
        weakData: {} // weak collections IDs

      }
    });
  };

  var fastKey = function (it, create) {
    // return a primitive with prefix
    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

    if (!has(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F'; // not necessary to add metadata

      if (!create) return 'E'; // add missing metadata

      setMetadata(it); // return object ID
    }

    return it[METADATA].objectID;
  };

  var getWeakData = function (it, create) {
    if (!has(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true; // not necessary to add metadata

      if (!create) return false; // add missing metadata

      setMetadata(it); // return the store of weak collections IDs
    }

    return it[METADATA].weakData;
  }; // add metadata on freeze-family methods calling


  var onFreeze = function (it) {
    if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
    return it;
  };

  var meta = module.exports = {
    REQUIRED: false,
    fastKey: fastKey,
    getWeakData: getWeakData,
    onFreeze: onFreeze
  };
  hiddenKeys[METADATA] = true;
});
var internalMetadata_1 = internalMetadata.REQUIRED;
var internalMetadata_2 = internalMetadata.fastKey;
var internalMetadata_3 = internalMetadata.getWeakData;
var internalMetadata_4 = internalMetadata.onFreeze;

var ITERATOR$3 = wellKnownSymbol('iterator');
var ArrayPrototype$1 = Array.prototype; // check on default Array iterator

var isArrayIteratorMethod = function (it) {
  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$3] === it);
};

var ITERATOR$4 = wellKnownSymbol('iterator');

var getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$4] || it['@@iterator'] || iterators[classof(it)];
};

var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};

var iterate_1 = createCommonjsModule(function (module) {
  var Result = function (stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
    var boundFunction = functionBindContext(fn, that, AS_ENTRIES ? 2 : 1);
    var iterator, iterFn, index, length, result, next, step;

    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators

      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = toLength(iterable.length); length > index; index++) {
          result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
          if (result && result instanceof Result) return result;
        }

        return new Result(false);
      }

      iterator = iterFn.call(iterable);
    }

    next = iterator.next;

    while (!(step = next.call(iterator)).done) {
      result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
      if (typeof result == 'object' && result && result instanceof Result) return result;
    }

    return new Result(false);
  };

  iterate.stop = function (result) {
    return new Result(true, result);
  };
});

var anInstance = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  }

  return it;
};

var ITERATOR$5 = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return {
        done: !!called++
      };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };

  iteratorWithReturn[ITERATOR$5] = function () {
    return this;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {
  /* empty */
}

var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;

  try {
    var object = {};

    object[ITERATOR$5] = function () {
      return {
        next: function () {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };

    exec(object);
  } catch (error) {
    /* empty */
  }

  return ITERATION_SUPPORT;
};

var collection = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
      nativeMethod.call(this, value === 0 ? 0 : value);
      return this;
    } : KEY == 'delete' ? function (key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'get' ? function get(key) {
      return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'has' ? function has(key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : function set(key, value) {
      nativeMethod.call(this, key === 0 ? 0 : key, value);
      return this;
    });
  }; // eslint-disable-next-line max-len


  if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    internalMetadata.REQUIRED = true;
  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new

    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
      new NativeConstructor(iterable);
    }); // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;

      while (index--) $instance[ADDER](index, index);

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  _export({
    global: true,
    forced: Constructor != NativeConstructor
  }, exported);
  setToStringTag(Constructor, CONSTRUCTOR_NAME);
  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};

var redefineAll = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);

  return target;
};

var SPECIES$1 = wellKnownSymbol('species');

var setSpecies = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = objectDefineProperty.f;

  if (descriptors && Constructor && !Constructor[SPECIES$1]) {
    defineProperty(Constructor, SPECIES$1, {
      configurable: true,
      get: function () {
        return this;
      }
    });
  }
};

var defineProperty$6 = objectDefineProperty.f;
var fastKey = internalMetadata.fastKey;
var setInternalState$3 = internalState.set;
var internalStateGetterFor = internalState.getterFor;
var collectionStrong = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState$3(that, {
        type: CONSTRUCTOR_NAME,
        index: objectCreate(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!descriptors) that.size = 0;
      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
    });
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index; // change existing entry

      if (entry) {
        entry.value = value; // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (descriptors) state.size++;else that.size++; // add to index

        if (index !== 'F') state.index[index] = entry;
      }

      return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that); // fast case

      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index]; // frozen object case

      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;

        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }

        state.first = state.last = undefined;
        if (descriptors) state.size = 0;else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (descriptors) state.size--;else that.size--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        var state = getInternalState(this);
        var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this); // revert to the last existing entry

          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });
    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (descriptors) defineProperty$6(C.prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME); // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11

    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState$3(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last; // revert to the last existing entry

      while (entry && entry.removed) entry = entry.previous; // get next entry


      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      } // return step by kind


      if (kind == 'keys') return {
        value: entry.key,
        done: false
      };
      if (kind == 'values') return {
        value: entry.value,
        done: false
      };
      return {
        value: [entry.key, entry.value],
        done: false
      };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(CONSTRUCTOR_NAME);
  }
};

// https://tc39.github.io/ecma262/#sec-map-objects


var es_map = collection('Map', function (init) {
  return function Map() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong);

/**
 * @summary ã¢ãã¡ã¼ã·ã§ã³å¤ã®å
 *
 * @classdesc
 * <p>ã¢ãã¡ã¼ã·ã§ã³ããå¤ã®åãè¡¨ç¾ããããã®æ½è±¡ã¯ã©ã¹ã§ããã</p>
 * <p>Binder ã¤ã³ã¹ã¿ã³ã¹ã¨çµåãããã©ã¡ã¼ã¿å¤ã®åã¨ãCurve ã¤ã³ã¹ã¿ã³ã¹ãè¿å´ããå¤ã®åãè¡¨ç¾ããã</p>
 *
 * <p>Type ã®å·è±¡ã¯ã©ã¹ã®ã¤ã³ã¹ã¿ã³ã¹ã¯ {@link mapray.animation.Type.register}()
 *    ã«ããç»é²ãã{@link mapray.animation.Type.find}() ã«ããåå¾ãããã¨ãã§ããã</p>
 *
 * <p>ç¹å®ã® Type ã®å·è±¡ã¯ã©ã¹ã®ã¤ã³ã¹ã¿ã³ã¹ã¯ 1 ã¤ããå­å¨ããªãããã®ãã Type ã¤ã³ã¹ã¿ã³ã¹ãè¡¨ãåã®åä¸æ§ã¯
 *    === æ¼ç®å­ã§å¤æ­ãããã¨ãã§ããã</p>
 *
 * @abstract
 * @memberof mapray.animation
 */

var Type =
/*#__PURE__*/
function () {
  /**
   * @param {string} name  åã®ç»é²å
   * @protected
   */
  function Type(name) {
    _classCallCheck(this, Type);

    this._name = name;
  }
  /**
   * @summary åå
   *
   * @type {string}
   * @readonly
   */


  _createClass(Type, [{
    key: "isConvertible",

    /**
     * @summary å¤æå¯è½ãï¼
     *
     * @desc
     * <p>from åã®å¤ã this åã®å¤ã¸ã®å¤æãå¯è½ãã©ãããè¿ãã</p>
     * <p>this ã¨ from ãåä¸ãªããå¿ã true ãè¿ãã</p>
     * <p>ãã®ã¡ã½ããã true ãè¿ããå ´åã¯ convertValue() ã«ãã from åã®å¤ã
     *    this åã®å¤ã«å¤æãããã¨ãå¯è½ã§ããã</p>
     *
     * @param {mapray.animation.Type} from  å¤æåã®å
     *
     * @return {boolean}  å¤æå¯è½ããªã true, ããã§ãªããªã false
     *
     * @see {@link mapray.animation.Type#convertValue}
     *
     * @abstract
     */
    value: function isConvertible(from) {
      this._override_error("isConvertible");
    }
    /**
     * @summary å¤ãå¤æ
     *
     * @desc
     * <p>value ã this åã¸å¤æãããªãã¸ã§ã¯ããè¿ãã</p>
     * <p>å¤æçµæã value ã¨åãå¤ã®å ´åãvalue èªèº«ãè¿ããã¨ãå¯è½ã§ããã</p>
     *
     * <p>äºåæ¡ä»¶1: value ã¯ from åã®ãªãã¸ã§ã¯ãã§ãã<br>
     *    äºåæ¡ä»¶2: this.isConvertible( from ) == true</p>
     *
     * @param {mapray.animation.Type} from  å¤æåã®å
     * @param {object}               value  å¤æåã®å¤ (from å)
     *
     * @return {object}  å¤æãããå¤ (this å)
     *
     * @see {@link mapray.animation.Type#isConvertible}
     *
     * @abstract
     */

  }, {
    key: "convertValue",
    value: function convertValue(from, value) {
      this._override_error("convertValue");
    }
    /**
     * @summary æ¢å®å¤ãåå¾
     *
     * @desc
     * <p>this åã®æ¢å®å¤ãè¿ãã</p>
     *
     * @return {object}  æ¢å®å¤ (this å)
     *
     * @abstract
     */

  }, {
    key: "getDefaultValue",
    value: function getDefaultValue() {
      this._override_error("getDefaultValue");
    }
    /**
     * @summary å¤ã®è¤è£½ãåå¾
     *
     * @desc
     * <p>value ã®æ°ããè¤è£½ãè¿ãã</p>
     * <p>ãã ã value ãã¤ãã¥ã¼ã¿ãã«ã®å ´åãvalue èªèº«ãè¿ããã¨ãå¯è½ã§ããã</p>
     *
     * <p>äºåæ¡ä»¶: value ã¯ this åã®ãªãã¸ã§ã¯ãã§ãã</p>
     *
     * @param {object} value  è¤è£½åã®å¤ (this å)
     *
     * @return {object}  è¤è£½ãããå¤ (this å)
     *
     * @abstract
     */

  }, {
    key: "getCloneValue",
    value: function getCloneValue(value) {
      this._override_error("getCloneValue");
    }
    /**
     * @summary åãç»é²
     *
     * @desc
     * <p>ååã name ã¨ãã¦ type åãç»é²ããã</p>
     * <p>ç»é²ããã type ã¯ name ã«ããæ¤ç´¢ãããã¨ãã§ããã</p>
     *
     * @param {string}                name  åã®åå
     * @param {mapray.animation.Type} type  Type ã¤ã³ã¹ã¿ã³ã¹
     *
     * @return {mapray.animation.Type}  type
     *
     * @throws {@link mapray.animation.Type.AlreadyRegisteredError}  name ããã§ã«ç»é²ããã¦ããã¨ã
     *
     * @see {@link mapray.animation.Type.find}
     */

  }, {
    key: "_override_error",

    /**
     * @summary ã¡ã½ããããªã¼ãã¼ã©ã¤ãããã¦ããªã
     *
     * arguments.callee ã¨ Error#stack ã¯äºææ§ãä½ãã®ã§ãé¢æ°åã®åå¾ã«ä½¿ããªãã£ã
     *
     * @param {string} func_name
     *
     * @private
     */
    value: function _override_error(func_name) {
      throw new Error("Type#" + func_name + "() method has not been overridden in " + this.constructor.name);
    }
  }, {
    key: "name",
    get: function get() {
      return this._name;
    }
  }], [{
    key: "register",
    value: function register(name, type) {
      if (type_register_map.has(name)) {
        // name ã¯ãã§ã«ç»é²æ¸ã¿
        throw new AlreadyRegisteredError("specified name (" + name + ") has already been registered");
      }

      type_register_map.set(name, type);
      return type;
    }
    /**
     * @summary åãæ¤ç´¢
     *
     * @desc
     * <p>ååã name ã¨ãã¦ç»é²ããã Type ã¤ã³ã¹ã¿ã³ã¹ãè¿ãã</p>
     *
     * <p>name ã®åãç»é²ããã¦ããå ´åãname ã«å¯¾ãã¦å¸¸ã«åãã¤ã³ã¹ã¿ã³ã¹ãè¿ãã
     *
     * @param {string} name  åã®åå
     *
     * @return {mapray.animation.Type}
     *
     * @throws {@link mapray.animation.Type.NotRegisteredError}  name ã«å¯¾å¿ããåãç»é²ããã¦ããªãã¨ã
     *
     * @see {@link mapray.animation.Type.register}
     */

  }, {
    key: "find",
    value: function find(name) {
      var type = type_register_map.get(name);

      if (type === undefined) {
        // name ã¯ç»é²ããã¦ããªã
        throw new NotRegisteredError("type with the specified name (" + name + ") is not registered");
      }

      return type;
    }
  }]);

  return Type;
}();
/**
 * @summary åã®å¤éç»é²ã¨ã©ã¼
 *
 * @memberof mapray.animation.Type
 * @extends mapray.animation.AnimationError
 *
 * @see {@link mapray.animation.Type.register}
 */


var AlreadyRegisteredError =
/*#__PURE__*/
function (_AnimationError) {
  _inherits(AlreadyRegisteredError, _AnimationError);

  /**
   * @param {string} message  ã¨ã©ã¼ã®èª¬æ
   */
  function AlreadyRegisteredError(message) {
    var _this;

    _classCallCheck(this, AlreadyRegisteredError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AlreadyRegisteredError).call(this, message));
    _this.name = "mapray.animation.Type.AlreadyRegisteredError";
    return _this;
  }

  return AlreadyRegisteredError;
}(AnimationError);

Type.AlreadyRegisteredError = AlreadyRegisteredError;
/**
 * @summary åã®æªç»é²ã¨ã©ã¼
 *
 * @memberof mapray.animation.Type
 * @extends mapray.animation.AnimationError
 *
 * @see {@link mapray.animation.Type.find}
 */

var NotRegisteredError =
/*#__PURE__*/
function (_AnimationError2) {
  _inherits(NotRegisteredError, _AnimationError2);

  /**
   * @param {string} message  ã¨ã©ã¼ã®èª¬æ
   */
  function NotRegisteredError(message) {
    var _this2;

    _classCallCheck(this, NotRegisteredError);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(NotRegisteredError).call(this, message));
    _this2.name = "mapray.animation.Type.NotRegisteredError";
    return _this2;
  }

  return NotRegisteredError;
}(AnimationError);

Type.NotRegisteredError = NotRegisteredError;
/**
 * @summary åã®ç»é²æå ±
 *
 * @type {Map.<string, mapray.animation.Type>}
 * @readonly
 *
 * @private
 */

var type_register_map = new Map();

var $find = arrayIteration.find;
var FIND = 'find';
var SKIPS_HOLES = true;
var USES_TO_LENGTH$1 = arrayMethodUsesToLength(FIND); // Shouldn't skip holes

if (FIND in []) Array(1)[FIND](function () {
  SKIPS_HOLES = false;
}); // `Array.prototype.find` method
// https://tc39.github.io/ecma262/#sec-array.prototype.find

_export({
  target: 'Array',
  proto: true,
  forced: SKIPS_HOLES || !USES_TO_LENGTH$1
}, {
  find: function find(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables(FIND);

// https://tc39.github.io/ecma262/#sec-set-objects


var es_set = collection('Set', function (init) {
  return function Set() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong);

var arrayBufferNative = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

// https://tc39.github.io/ecma262/#sec-toindex

var toIndex = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};

// IEEE754 conversions based on https://github.com/feross/ieee754
// eslint-disable-next-line no-shadow-restricted-names
var Infinity$1 = 1 / 0;
var abs = Math.abs;
var pow = Math.pow;
var floor$1 = Math.floor;
var log$1 = Math.log;
var LN2$1 = Math.LN2;

var pack = function (number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number); // eslint-disable-next-line no-self-compare

  if (number != number || number === Infinity$1) {
    // eslint-disable-next-line no-self-compare
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor$1(log$1(number) / LN2$1);

    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }

    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }

    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }

    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }

  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);

  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;

  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);

  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;

  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);

  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;

  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);

  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity$1 : Infinity$1;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  }

  return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

var ieee754 = {
  pack: pack,
  unpack: unpack
};

// https://tc39.github.io/ecma262/#sec-array.prototype.fill


var arrayFill = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) O[index++] = value;

  return O;
};

var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var defineProperty$7 = objectDefineProperty.f;
var getInternalState$3 = internalState.get;
var setInternalState$4 = internalState.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE$2 = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global_1[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global_1[DATA_VIEW];
var $DataViewPrototype = $DataView && $DataView[PROTOTYPE$2];
var ObjectPrototype$2 = Object.prototype;
var RangeError$1 = global_1.RangeError;
var packIEEE754 = ieee754.pack;
var unpackIEEE754 = ieee754.unpack;

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key) {
  defineProperty$7(Constructor[PROTOTYPE$2], key, {
    get: function () {
      return getInternalState$3(this)[key];
    }
  });
};

var get$1 = function (view, count, index, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState$3(view);
  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
  var bytes = getInternalState$3(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set$1 = function (view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState$3(view);
  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
  var bytes = getInternalState$3(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);

  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!arrayBufferNative) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState$4(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!descriptors) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState$3(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError$1('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError$1(WRONG_LENGTH);
    setInternalState$4(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });

    if (!descriptors) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (descriptors) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE$2], {
    getInt8: function getInt8(byteOffset) {
      return get$1(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get$1(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset
    /* , littleEndian */
    ) {
      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset
    /* , littleEndian */
    ) {
      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get$1(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set$1(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set$1(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value
    /* , littleEndian */
    ) {
      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value
    /* , littleEndian */
    ) {
      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value
    /* , littleEndian */
    ) {
      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value
    /* , littleEndian */
    ) {
      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value
    /* , littleEndian */
    ) {
      set$1(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value
    /* , littleEndian */
    ) {
      set$1(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new NativeArrayBuffer(); // eslint-disable-line no-new

    new NativeArrayBuffer(1.5); // eslint-disable-line no-new

    new NativeArrayBuffer(NaN); // eslint-disable-line no-new

    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };

    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE$2] = NativeArrayBuffer[PROTOTYPE$2];

    for (var keys$2 = getOwnPropertyNames$1(NativeArrayBuffer), j$1 = 0, key$1; keys$2.length > j$1;) {
      if (!((key$1 = keys$2[j$1++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key$1, NativeArrayBuffer[key$1]);
      }
    }

    ArrayBufferPrototype.constructor = $ArrayBuffer;
  } // WebKit bug - the same parent prototype for typed arrays and data view


  if (objectSetPrototypeOf && objectGetPrototypeOf($DataViewPrototype) !== ObjectPrototype$2) {
    objectSetPrototypeOf($DataViewPrototype, ObjectPrototype$2);
  } // iOS Safari 7.x bug


  var testView = new $DataView(new $ArrayBuffer(2));
  var nativeSetInt8 = $DataViewPrototype.setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, {
    unsafe: true
  });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
var arrayBuffer = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};

var SPECIES$2 = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor

var speciesConstructor = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES$2]) == undefined ? defaultConstructor : aFunction$1(S);
};

var ArrayBuffer$1 = arrayBuffer.ArrayBuffer;
var DataView$1 = arrayBuffer.DataView;
var nativeArrayBufferSlice = ArrayBuffer$1.prototype.slice;
var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer$1(2).slice(1, undefined).byteLength;
}); // `ArrayBuffer.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice

_export({
  target: 'ArrayBuffer',
  proto: true,
  unsafe: true,
  forced: INCORRECT_SLICE
}, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }

    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer$1))(toLength(fin - first));
    var viewSource = new DataView$1(this);
    var viewTarget = new DataView$1(result);
    var index = 0;

    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    }

    return result;
  }
});

var defineProperty$8 = objectDefineProperty.f;
var Int8Array$1 = global_1.Int8Array;
var Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;
var Uint8ClampedArray = global_1.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array$1 && objectGetPrototypeOf(Int8Array$1);
var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype$3 = Object.prototype;
var isPrototypeOf = ObjectPrototype$3.isPrototypeOf;
var TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG'); // Fixing native typed arrays in Opera Presto crashes the browser, see #595

var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferNative && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME$1;
var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var isView = function isView(it) {
  var klass = classof(it);
  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (objectSetPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME$1)) {
    var TypedArrayConstructor = global_1[ARRAY];

    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  }

  throw TypeError('Target is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced) {
  if (!descriptors) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global_1[ARRAY];

    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }

  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!descriptors) return;

  if (objectSetPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global_1[ARRAY];

      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }

    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array$1[KEY] || property);
      } catch (error) {
        /* empty */
      }
    } else return;
  }

  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global_1[ARRAY];

    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME$1 in TypedArrayConstructorsList) {
  if (!global_1[NAME$1]) NATIVE_ARRAY_BUFFER_VIEWS = false;
} // WebKit bug - typed arrays constructors prototype is Object.prototype


if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };

  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME$1 in TypedArrayConstructorsList) {
    if (global_1[NAME$1]) objectSetPrototypeOf(global_1[NAME$1], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$3) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME$1 in TypedArrayConstructorsList) {
    if (global_1[NAME$1]) objectSetPrototypeOf(global_1[NAME$1].prototype, TypedArrayPrototype);
  }
} // WebKit bug - one more object in Uint8ClampedArray prototype chain


if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (descriptors && !has(TypedArrayPrototype, TO_STRING_TAG$4)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty$8(TypedArrayPrototype, TO_STRING_TAG$4, {
    get: function () {
      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
    }
  });

  for (NAME$1 in TypedArrayConstructorsList) if (global_1[NAME$1]) {
    createNonEnumerableProperty(global_1[NAME$1], TYPED_ARRAY_TAG, NAME$1);
  }
}

var arrayBufferViewCore = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};

/* eslint-disable no-new */

var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var ArrayBuffer$2 = global_1.ArrayBuffer;
var Int8Array$2 = global_1.Int8Array;
var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails(function () {
  Int8Array$2(1);
}) || !fails(function () {
  new Int8Array$2(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array$2();
  new Int8Array$2(null);
  new Int8Array$2(1.5);
  new Int8Array$2(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array$2(new ArrayBuffer$2(2), 1, undefined).length !== 1;
});

var toPositiveInteger = function (it) {
  var result = toInteger(it);
  if (result < 0) throw RangeError("The argument can't be less than 0");
  return result;
};

var toOffset = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};

var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;

var typedArrayFrom = function from(source
/* , mapfn, thisArg */
) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;

  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    O = [];

    while (!(step = next.call(iterator)).done) {
      O.push(step.value);
    }
  }

  if (mapping && argumentsLength > 2) {
    mapfn = functionBindContext(mapfn, arguments[2], 2);
  }

  length = toLength(O.length);
  result = new (aTypedArrayConstructor$1(this))(length);

  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }

  return result;
};

var typedArrayConstructor = createCommonjsModule(function (module) {

  var getOwnPropertyNames = objectGetOwnPropertyNames.f;
  var forEach = arrayIteration.forEach;
  var getInternalState = internalState.get;
  var setInternalState = internalState.set;
  var nativeDefineProperty = objectDefineProperty.f;
  var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var round = Math.round;
  var RangeError = global_1.RangeError;
  var ArrayBuffer = arrayBuffer.ArrayBuffer;
  var DataView = arrayBuffer.DataView;
  var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
  var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
  var TypedArray = arrayBufferViewCore.TypedArray;
  var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
  var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
  var isTypedArray = arrayBufferViewCore.isTypedArray;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var WRONG_LENGTH = 'Wrong length';

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = new (aTypedArrayConstructor(C))(length);

    while (length > index) result[index] = list[index++];

    return result;
  };

  var addGetter = function (it, key) {
    nativeDefineProperty(it, key, {
      get: function () {
        return getInternalState(this)[key];
      }
    });
  };

  var isArrayBuffer = function (it) {
    var klass;
    return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
  };

  var isTypedArrayIndex = function (target, key) {
    return isTypedArray(target) && typeof key != 'symbol' && key in target && String(+key) == String(key);
  };

  var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
    return isTypedArrayIndex(target, key = toPrimitive(key, true)) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
  };

  var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
    if (isTypedArrayIndex(target, key = toPrimitive(key, true)) && isObject(descriptor) && has(descriptor, 'value') && !has(descriptor, 'get') && !has(descriptor, 'set') // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable && (!has(descriptor, 'writable') || descriptor.writable) && (!has(descriptor, 'enumerable') || descriptor.enumerable)) {
      target[key] = descriptor.value;
      return target;
    }

    return nativeDefineProperty(target, key, descriptor);
  };

  if (descriptors) {
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
      objectDefineProperty.f = wrappedDefineProperty;
      addGetter(TypedArrayPrototype, 'buffer');
      addGetter(TypedArrayPrototype, 'byteOffset');
      addGetter(TypedArrayPrototype, 'byteLength');
      addGetter(TypedArrayPrototype, 'length');
    }

    _export({
      target: 'Object',
      stat: true,
      forced: !NATIVE_ARRAY_BUFFER_VIEWS
    }, {
      getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
      defineProperty: wrappedDefineProperty
    });

    module.exports = function (TYPE, wrapper, CLAMPED) {
      var BYTES = TYPE.match(/\d+$/)[0] / 8;
      var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
      var GETTER = 'get' + TYPE;
      var SETTER = 'set' + TYPE;
      var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
      var TypedArrayConstructor = NativeTypedArrayConstructor;
      var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
      var exported = {};

      var getter = function (that, index) {
        var data = getInternalState(that);
        return data.view[GETTER](index * BYTES + data.byteOffset, true);
      };

      var setter = function (that, index, value) {
        var data = getInternalState(that);
        if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
        data.view[SETTER](index * BYTES + data.byteOffset, value, true);
      };

      var addElement = function (that, index) {
        nativeDefineProperty(that, index, {
          get: function () {
            return getter(this, index);
          },
          set: function (value) {
            return setter(this, index, value);
          },
          enumerable: true
        });
      };

      if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
          anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
          var index = 0;
          var byteOffset = 0;
          var buffer, byteLength, length;

          if (!isObject(data)) {
            length = toIndex(data);
            byteLength = length * BYTES;
            buffer = new ArrayBuffer(byteLength);
          } else if (isArrayBuffer(data)) {
            buffer = data;
            byteOffset = toOffset(offset, BYTES);
            var $len = data.byteLength;

            if ($length === undefined) {
              if ($len % BYTES) throw RangeError(WRONG_LENGTH);
              byteLength = $len - byteOffset;
              if (byteLength < 0) throw RangeError(WRONG_LENGTH);
            } else {
              byteLength = toLength($length) * BYTES;
              if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
            }

            length = byteLength / BYTES;
          } else if (isTypedArray(data)) {
            return fromList(TypedArrayConstructor, data);
          } else {
            return typedArrayFrom.call(TypedArrayConstructor, data);
          }

          setInternalState(that, {
            buffer: buffer,
            byteOffset: byteOffset,
            byteLength: byteLength,
            length: length,
            view: new DataView(buffer)
          });

          while (index < length) addElement(that, index++);
        });
        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
        TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
      } else if (typedArrayConstructorsRequireWrappers) {
        TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
          anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
          return inheritIfRequired(function () {
            if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
            if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
            if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
            return typedArrayFrom.call(TypedArrayConstructor, data);
          }(), dummy, TypedArrayConstructor);
        });
        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
        forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
          if (!(key in TypedArrayConstructor)) {
            createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
          }
        });
        TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
      }

      if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
      }

      if (TYPED_ARRAY_TAG) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
      }

      exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
      _export({
        global: true,
        forced: TypedArrayConstructor != NativeTypedArrayConstructor,
        sham: !NATIVE_ARRAY_BUFFER_VIEWS
      }, exported);

      if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
        createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
      }

      if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
      }

      setSpecies(CONSTRUCTOR_NAME);
    };
  } else module.exports = function () {
    /* empty */
  };
});

// https://tc39.github.io/ecma262/#sec-typedarray-objects

typedArrayConstructor('Float32', function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// https://tc39.github.io/ecma262/#sec-typedarray-objects

typedArrayConstructor('Float64', function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

var min$2 = Math.min; // `Array.prototype.copyWithin` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin

var arrayCopyWithin = [].copyWithin || function copyWithin(target
/* = 0 */
, start
/* = 0, end = @length */
) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min$2((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin

exportTypedArrayMethod$1('copyWithin', function copyWithin(target, start
/* , end */
) {
  return arrayCopyWithin.call(aTypedArray$1(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});

var $every = arrayIteration.every;
var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.every` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every

exportTypedArrayMethod$2('every', function every(callbackfn
/* , thisArg */
) {
  return $every(aTypedArray$2(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

var aTypedArray$3 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$3 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars

exportTypedArrayMethod$3('fill', function fill(value
/* , start, end */
) {
  return arrayFill.apply(aTypedArray$3(this), arguments);
});

var $filter = arrayIteration.filter;
var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod$4 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter

exportTypedArrayMethod$4('filter', function filter(callbackfn
/* , thisArg */
) {
  var list = $filter(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor$2(C))(length);

  while (length > index) result[index] = list[index++];

  return result;
});

var $find$1 = arrayIteration.find;
var aTypedArray$5 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$5 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.find` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find

exportTypedArrayMethod$5('find', function find(predicate
/* , thisArg */
) {
  return $find$1(aTypedArray$5(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

var $findIndex = arrayIteration.findIndex;
var aTypedArray$6 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex

exportTypedArrayMethod$6('findIndex', function findIndex(predicate
/* , thisArg */
) {
  return $findIndex(aTypedArray$6(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

var $forEach$1 = arrayIteration.forEach;
var aTypedArray$7 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$7 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach

exportTypedArrayMethod$7('forEach', function forEach(callbackfn
/* , thisArg */
) {
  $forEach$1(aTypedArray$7(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

var $includes$1 = arrayIncludes.includes;
var aTypedArray$8 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$8 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes

exportTypedArrayMethod$8('includes', function includes(searchElement
/* , fromIndex */
) {
  return $includes$1(aTypedArray$8(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

var $indexOf = arrayIncludes.indexOf;
var aTypedArray$9 = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof

exportTypedArrayMethod$9('indexOf', function indexOf(searchElement
/* , fromIndex */
) {
  return $indexOf(aTypedArray$9(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

var ITERATOR$6 = wellKnownSymbol('iterator');
var Uint8Array$1 = global_1.Uint8Array;
var arrayValues = es_array_iterator.values;
var arrayKeys = es_array_iterator.keys;
var arrayEntries = es_array_iterator.entries;
var aTypedArray$a = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$a = arrayBufferViewCore.exportTypedArrayMethod;
var nativeTypedArrayIterator = Uint8Array$1 && Uint8Array$1.prototype[ITERATOR$6];
var CORRECT_ITER_NAME = !!nativeTypedArrayIterator && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray$a(this));
}; // `%TypedArray%.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries


exportTypedArrayMethod$a('entries', function entries() {
  return arrayEntries.call(aTypedArray$a(this));
}); // `%TypedArray%.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys

exportTypedArrayMethod$a('keys', function keys() {
  return arrayKeys.call(aTypedArray$a(this));
}); // `%TypedArray%.prototype.values` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values

exportTypedArrayMethod$a('values', typedArrayValues, !CORRECT_ITER_NAME); // `%TypedArray%.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator

exportTypedArrayMethod$a(ITERATOR$6, typedArrayValues, !CORRECT_ITER_NAME);

var aTypedArray$b = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$b = arrayBufferViewCore.exportTypedArrayMethod;
var $join = [].join; // `%TypedArray%.prototype.join` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars

exportTypedArrayMethod$b('join', function join(separator) {
  return $join.apply(aTypedArray$b(this), arguments);
});

var arrayMethodIsStrict = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () {
      throw 1;
    }, 1);
  });
};

var min$3 = Math.min;
var nativeLastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf'); // For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method

var USES_TO_LENGTH$2 = arrayMethodUsesToLength('indexOf', {
  ACCESSORS: true,
  1: 0
});
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH$2; // `Array.prototype.lastIndexOf` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof

var arrayLastIndexOf = FORCED ? function lastIndexOf(searchElement
/* , fromIndex = @[*-1] */
) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min$3(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;

  for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;

  return -1;
} : nativeLastIndexOf;

var aTypedArray$c = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$c = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars

exportTypedArrayMethod$c('lastIndexOf', function lastIndexOf(searchElement
/* , fromIndex */
) {
  return arrayLastIndexOf.apply(aTypedArray$c(this), arguments);
});

var $map = arrayIteration.map;
var aTypedArray$d = arrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor$3 = arrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod$d = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.map` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map

exportTypedArrayMethod$d('map', function map(mapfn
/* , thisArg */
) {
  return $map(aTypedArray$d(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (aTypedArrayConstructor$3(speciesConstructor(O, O.constructor)))(length);
  });
});

var createMethod$4 = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction$1(callbackfn);
    var O = toObject(that);
    var self = indexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }

      index += i;

      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }

    for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }

    return memo;
  };
};

var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod$4(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod$4(true)
};

var $reduce = arrayReduce.left;
var aTypedArray$e = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$e = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce

exportTypedArrayMethod$e('reduce', function reduce(callbackfn
/* , initialValue */
) {
  return $reduce(aTypedArray$e(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

var $reduceRight = arrayReduce.right;
var aTypedArray$f = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$f = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduceRicht` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright

exportTypedArrayMethod$f('reduceRight', function reduceRight(callbackfn
/* , initialValue */
) {
  return $reduceRight(aTypedArray$f(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

var aTypedArray$g = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$g = arrayBufferViewCore.exportTypedArrayMethod;
var floor$2 = Math.floor; // `%TypedArray%.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse

exportTypedArrayMethod$g('reverse', function reverse() {
  var that = this;
  var length = aTypedArray$g(that).length;
  var middle = floor$2(length / 2);
  var index = 0;
  var value;

  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  }

  return that;
});

var aTypedArray$h = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$h = arrayBufferViewCore.exportTypedArrayMethod;
var FORCED$1 = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).set({});
}); // `%TypedArray%.prototype.set` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set

exportTypedArrayMethod$h('set', function set(arrayLike
/* , offset */
) {
  aTypedArray$h(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');

  while (index < len) this[offset + index] = src[index++];
}, FORCED$1);

var aTypedArray$i = arrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor$4 = arrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod$i = arrayBufferViewCore.exportTypedArrayMethod;
var $slice = [].slice;
var FORCED$2 = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).slice();
}); // `%TypedArray%.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice

exportTypedArrayMethod$i('slice', function slice(start, end) {
  var list = $slice.call(aTypedArray$i(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor$4(C))(length);

  while (length > index) result[index] = list[index++];

  return result;
}, FORCED$2);

var $some = arrayIteration.some;
var aTypedArray$j = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$j = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.some` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some

exportTypedArrayMethod$j('some', function some(callbackfn
/* , thisArg */
) {
  return $some(aTypedArray$j(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

var aTypedArray$k = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$k = arrayBufferViewCore.exportTypedArrayMethod;
var $sort = [].sort; // `%TypedArray%.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort

exportTypedArrayMethod$k('sort', function sort(comparefn) {
  return $sort.call(aTypedArray$k(this), comparefn);
});

var aTypedArray$l = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$l = arrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.subarray` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray

exportTypedArrayMethod$l('subarray', function subarray(begin, end) {
  var O = aTypedArray$l(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
});

var Int8Array$3 = global_1.Int8Array;
var aTypedArray$m = arrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod$m = arrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var $slice$1 = [].slice; // iOS Safari 6.x fails here

var TO_LOCALE_STRING_BUG = !!Int8Array$3 && fails(function () {
  $toLocaleString.call(new Int8Array$3(1));
});
var FORCED$3 = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array$3([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array$3.prototype.toLocaleString.call([1, 2]);
}); // `%TypedArray%.prototype.toLocaleString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring

exportTypedArrayMethod$m('toLocaleString', function toLocaleString() {
  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice$1.call(aTypedArray$m(this)) : aTypedArray$m(this), arguments);
}, FORCED$3);

var exportTypedArrayMethod$n = arrayBufferViewCore.exportTypedArrayMethod;
var Uint8Array$2 = global_1.Uint8Array;
var Uint8ArrayPrototype = Uint8Array$2 && Uint8Array$2.prototype || {};
var arrayToString = [].toString;
var arrayJoin = [].join;

if (fails(function () {
  arrayToString.call({});
})) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
}

var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString; // `%TypedArray%.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring

exportTypedArrayMethod$n('toString', arrayToString, IS_NOT_ARRAY_METHOD);

/**
 * @summary æ°å­¦ã¦ã¼ãã£ãªãã£ã¼
 *
 * @classdesc
 * <p>æ°å­¦é¢é£ã®é¢æ°ã¾ãã¯å®æ°ãå®ç¾©ããã¦ã¼ãã£ãªãã£ã¼ã¯ã©ã¹ã§ããã</p>
 * <p>ãã®ã¯ã©ã¹ã¯ static ã¡ã³ãã¼ããæããªãã</p>
 *
 * @hideconstructor
 * @memberof mapray
 * @see mapray.Matrix
 */
var GeoMath =
/*#__PURE__*/
function () {
  function GeoMath() {
    _classCallCheck(this, GeoMath);
  }

  _createClass(GeoMath, null, [{
    key: "createMatrix",

    /**
     * @summary è¡åãªãã¸ã§ã¯ããä½æ
     * @desc
     * <p>mat ãè¤è£½ããããã ã mat ãçç¥ããã¨ãã¯ããã¹ã¦ã®è¦ç´ ã 0 ã®è¡åãçæããã</p>
     *
     * @param  {mapray.Matrix} [mat]  å¥åè¡å
     * @return {mapray.Matrix}        æ°ããè¡å
     */
    value: function createMatrix(mat) {
      return new Float64Array(mat || 16);
    }
    /**
     * @summary è¡å (åç²¾åº¦) ãªãã¸ã§ã¯ããä½æ
     * @param  {mapray.Matrix} [mat]  å¥åè¡å
     * @return {mapray.Matrix}        æ°ããè¡å
     * @package
     */

  }, {
    key: "createMatrixf",
    value: function createMatrixf(mat) {
      return new Float32Array(mat || 16);
    }
    /**
     * @summary 4 æ¬¡ãã¯ãã«ã®çæ
     * @desc
     * <p>vec ãè¤è£½ãã¦ 4 æ¬¡ãã¯ãã«ãçæããããã ã vec ãçç¥ããã¨ãã¯ããã¹ã¦ã®è¦ç´ ã 0 ã®ãã¯ãã«ãçæããã</p>
     * @param  {mapray.Vector4} [vec]  å¥åãã¯ãã«
     * @return {mapray.Vector4}        æ°ãããã¯ãã«
     */

  }, {
    key: "createVector4",
    value: function createVector4(vec) {
      return new Float64Array(vec || 4);
    }
    /**
     * @summary 4 æ¬¡ãã¯ãã« (åç²¾åº¦) ã®çæ
     * @param  {mapray.Vector4} [vec]  å¥åãã¯ãã«
     * @return {mapray.Vector4}        æ°ãããã¯ãã«
     * @package
     */

  }, {
    key: "createVector4f",
    value: function createVector4f(vec) {
      return new Float32Array(vec || 4);
    }
    /**
     * @summary 3 æ¬¡ãã¯ãã«ã®çæ
     * <p>vec ãè¤è£½ãã¦ 3 æ¬¡ãã¯ãã«ãçæããããã ã vec ãçç¥ããã¨ãã¯ããã¹ã¦ã®è¦ç´ ã 0 ã®ãã¯ãã«ãçæããã</p>
     * @param  {mapray.Vector3} [vec]  å¥åãã¯ãã«
     * @return {mapray.Vector3}        æ°ãããã¯ãã«
     */

  }, {
    key: "createVector3",
    value: function createVector3(vec) {
      return new Float64Array(vec || 3);
    }
    /**
     * @summary 3 æ¬¡ãã¯ãã« (åç²¾åº¦) ã®çæ
     * @param  {mapray.Vector3} [vec]  å¥åãã¯ãã«
     * @return {mapray.Vector3}        æ°ãããã¯ãã«
     * @package
     */

  }, {
    key: "createVector3f",
    value: function createVector3f(vec) {
      return new Float32Array(vec || 3);
    }
    /**
     * @summary 2 æ¬¡ãã¯ãã«ã®çæ
     * <p>vec ãè¤è£½ãã¦ 2 æ¬¡ãã¯ãã«ãçæããããã ã vec ãçç¥ããã¨ãã¯ããã¹ã¦ã®è¦ç´ ã 0 ã®ãã¯ãã«ãçæããã</p>
     * @param  {mapray.Vector2} [vec]  å¥åãã¯ãã«
     * @return {mapray.Vector2}        æ°ãããã¯ãã«
     */

  }, {
    key: "createVector2",
    value: function createVector2(vec) {
      return new Float64Array(vec || 2);
    }
    /**
     * @summary 2 æ¬¡ãã¯ãã« (åç²¾åº¦) ã®çæ
     * @param  {mapray.Vector2} [vec]  å¥åãã¯ãã«
     * @return {mapray.Vector2}        æ°ãããã¯ãã«
     * @package
     */

  }, {
    key: "createVector2f",
    value: function createVector2f(vec) {
      return new Float32Array(vec || 2);
    }
    /**
     * @summary è¡åãä»£å¥
     * @desc
     * <p>src ã dst ã«ä»£å¥ããã</p>
     * @param  {mapray.Matrix} src  ä»£å¥å
     * @param  {mapray.Matrix} dst  ä»£å¥å
     * @return {mapray.Matrix}      dst
     */

  }, {
    key: "copyMatrix",
    value: function copyMatrix(src, dst) {
      for (var i = 0; i < 16; ++i) {
        dst[i] = src[i];
      }

      return dst;
    }
    /**
     * @summary 4 æ¬¡ãã¯ãã«ãä»£å¥
     * @desc
     * <p>src ã dst ã«ä»£å¥ããã</p>
     * @param  {mapray.Vector4} src  ä»£å¥å
     * @param  {mapray.Vector4} dst  ä»£å¥å
     * @return {mapray.Vector4}      dst
     */

  }, {
    key: "copyVector4",
    value: function copyVector4(src, dst) {
      for (var i = 0; i < 4; ++i) {
        dst[i] = src[i];
      }

      return dst;
    }
    /**
     * @summary 3 æ¬¡ãã¯ãã«ãä»£å¥
     * @desc
     * <p>src ã dst ã«ä»£å¥ããã</p>
     * @param  {mapray.Vector3} src  ä»£å¥å
     * @param  {mapray.Vector3} dst  ä»£å¥å
     * @return {mapray.Vector3}      dst
     */

  }, {
    key: "copyVector3",
    value: function copyVector3(src, dst) {
      for (var i = 0; i < 3; ++i) {
        dst[i] = src[i];
      }

      return dst;
    }
    /**
     * @summary 2 æ¬¡ãã¯ãã«ãä»£å¥
     * @desc
     * <p>src ã dst ã«ä»£å¥ããã</p>
     * @param  {mapray.Vector2} src  ä»£å¥å
     * @param  {mapray.Vector2} dst  ä»£å¥å
     * @return {mapray.Vector2}      dst
     */

  }, {
    key: "copyVector2",
    value: function copyVector2(src, dst) {
      dst[0] = src[0];
      dst[1] = src[1];
      return dst;
    }
    /**
     * @summary æç­è¡åãè¨­å®
     * @param  {mapray.Matrix} dst  çµæãä»£å¥ããè¡å
     * @return {mapray.Matrix}      dst
     */

  }, {
    key: "setIdentity",
    value: function setIdentity(dst) {
      dst[0] = 1;
      dst[1] = 0;
      dst[2] = 0;
      dst[3] = 0;
      dst[4] = 0;
      dst[5] = 1;
      dst[6] = 0;
      dst[7] = 0;
      dst[8] = 0;
      dst[9] = 0;
      dst[10] = 1;
      dst[11] = 0;
      dst[12] = 0;
      dst[13] = 0;
      dst[14] = 0;
      dst[15] = 1;
      return dst;
    }
    /**
     * @summary 3 æ¬¡ãã¯ãã«ã®åç©ãè¨ç®
     * @param  {mapray.Vector3} a  å·¦ã®ãã¯ãã«
     * @param  {mapray.Vector3} b  å³ã®ãã¯ãã«
     * @return {number}            a ã¨ b ã®åç©
     */

  }, {
    key: "dot3",
    value: function dot3(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    /**
     * @summary 3æ¬¡ãã¯ãã«ã®å¤ç©ãè¨ç®
     * @param  {mapray.Vector3} a    å·¦ã®ãã¯ãã«
     * @param  {mapray.Vector3} b    å³ã®ãã¯ãã«
     * @param  {mapray.Vector3} dst  a ã¨ b ã®å¤ç©ãä»£å¥ãããã¯ãã«
     * @return {mapray.Vector3}      dst
     */

  }, {
    key: "cross3",
    value: function cross3(a, b, dst) {
      var x = a[1] * b[2] - a[2] * b[1];
      var y = a[2] * b[0] - a[0] * b[2];
      var z = a[0] * b[1] - a[1] * b[0];
      dst[0] = x;
      dst[1] = y;
      dst[2] = z;
      return dst;
    }
    /**
     * @summary 3æ¬¡ãã¯ãã«ã®æ­£è¦åãè¨ç®
     * @param  {mapray.Vector3} vec  ãã¯ãã«
     * @param  {mapray.Vector3} dst  æ­£è¦åãããå¤ãä»£å¥ãããã¯ãã«
     * @return {mapray.Vector3}      dst
     */

  }, {
    key: "normalize3",
    value: function normalize3(vec, dst) {
      var x = vec[0];
      var y = vec[1];
      var z = vec[2];
      var ilen = 1 / Math.sqrt(x * x + y * y + z * z); // é·ãã®éæ°

      dst[0] = vec[0] * ilen;
      dst[1] = vec[1] * ilen;
      dst[2] = vec[2] * ilen;
      return dst;
    }
  }, {
    key: "scale3",
    value: function scale3(a, vec, dst) {
      dst[0] = a * vec[0];
      dst[1] = a * vec[1];
      dst[2] = a * vec[2];
      return dst;
    }
    /**
     * @summary è¡åã®ç©ãè¨ç® (ã¢ãã£ã³å¤æ x ã¢ãã£ã³å¤æ)
     * @param  {mapray.Matrix}  a    å·¦ã®è¡å
     * @param  {mapray.Matrix}  b    å³ã®è¡å
     * @param  {mapray.Matrix}  dst  çµæãä»£å¥ããè¡å
     * @return {mapray.Matrix}       dst
     */

  }, {
    key: "mul_AA",
    value: function mul_AA(a, b, dst) {
      var a00 = a[0],
          a01 = a[4],
          a02 = a[8],
          a03 = a[12],
          a10 = a[1],
          a11 = a[5],
          a12 = a[9],
          a13 = a[13],
          a20 = a[2],
          a21 = a[6],
          a22 = a[10],
          a23 = a[14];
      var b00 = b[0],
          b01 = b[4],
          b02 = b[8],
          b03 = b[12],
          b10 = b[1],
          b11 = b[5],
          b12 = b[9],
          b13 = b[13],
          b20 = b[2],
          b21 = b[6],
          b22 = b[10],
          b23 = b[14];
      dst[0] = a00 * b00 + a01 * b10 + a02 * b20;
      dst[1] = a10 * b00 + a11 * b10 + a12 * b20;
      dst[2] = a20 * b00 + a21 * b10 + a22 * b20;
      dst[3] = 0;
      dst[4] = a00 * b01 + a01 * b11 + a02 * b21;
      dst[5] = a10 * b01 + a11 * b11 + a12 * b21;
      dst[6] = a20 * b01 + a21 * b11 + a22 * b21;
      dst[7] = 0;
      dst[8] = a00 * b02 + a01 * b12 + a02 * b22;
      dst[9] = a10 * b02 + a11 * b12 + a12 * b22;
      dst[10] = a20 * b02 + a21 * b12 + a22 * b22;
      dst[11] = 0;
      dst[12] = a00 * b03 + a01 * b13 + a02 * b23 + a03;
      dst[13] = a10 * b03 + a11 * b13 + a12 * b23 + a13;
      dst[14] = a20 * b03 + a21 * b13 + a22 * b23 + a23;
      dst[15] = 1;
      return dst;
    }
    /**
     * @summary è¡åã®ç©ãè¨ç® (ä¸è¬å¤æ x ã¢ãã£ã³å¤æ)
     * @param  {mapray.Matrix}  a    å·¦ã®è¡å
     * @param  {mapray.Matrix}  b    å³ã®è¡å
     * @param  {mapray.Matrix}  dst  çµæãä»£å¥ããè¡å
     * @return {mapray.Matrix}       dst
     */

  }, {
    key: "mul_GA",
    value: function mul_GA(a, b, dst) {
      var a00 = a[0],
          a01 = a[4],
          a02 = a[8],
          a03 = a[12],
          a10 = a[1],
          a11 = a[5],
          a12 = a[9],
          a13 = a[13],
          a20 = a[2],
          a21 = a[6],
          a22 = a[10],
          a23 = a[14],
          a30 = a[3],
          a31 = a[7],
          a32 = a[11],
          a33 = a[15];
      var b00 = b[0],
          b01 = b[4],
          b02 = b[8],
          b03 = b[12],
          b10 = b[1],
          b11 = b[5],
          b12 = b[9],
          b13 = b[13],
          b20 = b[2],
          b21 = b[6],
          b22 = b[10],
          b23 = b[14];
      dst[0] = a00 * b00 + a01 * b10 + a02 * b20;
      dst[1] = a10 * b00 + a11 * b10 + a12 * b20;
      dst[2] = a20 * b00 + a21 * b10 + a22 * b20;
      dst[3] = a30 * b00 + a31 * b10 + a32 * b20;
      dst[4] = a00 * b01 + a01 * b11 + a02 * b21;
      dst[5] = a10 * b01 + a11 * b11 + a12 * b21;
      dst[6] = a20 * b01 + a21 * b11 + a22 * b21;
      dst[7] = a30 * b01 + a31 * b11 + a32 * b21;
      dst[8] = a00 * b02 + a01 * b12 + a02 * b22;
      dst[9] = a10 * b02 + a11 * b12 + a12 * b22;
      dst[10] = a20 * b02 + a21 * b12 + a22 * b22;
      dst[11] = a30 * b02 + a31 * b12 + a32 * b22;
      dst[12] = a00 * b03 + a01 * b13 + a02 * b23 + a03;
      dst[13] = a10 * b03 + a11 * b13 + a12 * b23 + a13;
      dst[14] = a20 * b03 + a21 * b13 + a22 * b23 + a23;
      dst[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33;
      return dst;
    }
    /**
     * @summary è¡åã®ç©ãè¨ç® (æå½±å¤æ x ã¢ãã£ã³å¤æ)
     * @param  {mapray.Matrix}  a    å·¦ã®è¡å
     * @param  {mapray.Matrix}  b    å³ã®è¡å
     * @param  {mapray.Matrix}  dst  çµæãä»£å¥ããè¡å
     * @return {mapray.Matrix}       dst
     */

  }, {
    key: "mul_PzA",
    value: function mul_PzA(a, b, dst) {
      var a00 = a[0],
          a02 = a[8],
          a03 = a[12];
      var a11 = a[5],
          a12 = a[9],
          a13 = a[13];
      var a22 = a[10],
          a23 = a[14];
      var a32 = a[11],
          a33 = a[15];
      var b00 = b[0],
          b01 = b[4],
          b02 = b[8],
          b03 = b[12],
          b10 = b[1],
          b11 = b[5],
          b12 = b[9],
          b13 = b[13],
          b20 = b[2],
          b21 = b[6],
          b22 = b[10],
          b23 = b[14];
      dst[0] = a00 * b00 + a02 * b20;
      dst[1] = a11 * b10 + a12 * b20;
      dst[2] = a22 * b20;
      dst[3] = a32 * b20;
      dst[4] = a00 * b01 + a02 * b21;
      dst[5] = a11 * b11 + a12 * b21;
      dst[6] = a22 * b21;
      dst[7] = a32 * b21;
      dst[8] = a00 * b02 + a02 * b22;
      dst[9] = a11 * b12 + a12 * b22;
      dst[10] = a22 * b22;
      dst[11] = a32 * b22;
      dst[12] = a00 * b03 + a02 * b23 + a03;
      dst[13] = a11 * b13 + a12 * b23 + a13;
      dst[14] = a22 * b23 + a23;
      dst[15] = a32 * b23 + a33;
      return dst;
    }
    /**
     * @summary éè¡åãè¨ç® (ã¢ãã£ã³å¤æ)
     * @param  {mapray.Matrix}  mat  è¡å
     * @param  {mapray.Matrix}  dst  çµæãä»£å¥ããè¡å
     * @return {mapray.Matrix}       dst
     */

  }, {
    key: "inverse_A",
    value: function inverse_A(mat, dst) {
      var a00 = mat[0],
          a01 = mat[4],
          a02 = mat[8],
          a03 = mat[12],
          a10 = mat[1],
          a11 = mat[5],
          a12 = mat[9],
          a13 = mat[13],
          a20 = mat[2],
          a21 = mat[6],
          a22 = mat[10],
          a23 = mat[14]; // cofactors

      var b00 = a11 * a22 - a21 * a12;
      var b01 = a20 * a12 - a10 * a22;
      var b02 = a10 * a21 - a20 * a11;
      var b10 = a21 * a02 - a01 * a22;
      var b11 = a00 * a22 - a20 * a02;
      var b12 = a20 * a01 - a00 * a21;
      var b20 = a01 * a12 - a11 * a02;
      var b21 = a10 * a02 - a00 * a12;
      var b22 = a00 * a11 - a10 * a01;
      var b30 = -(a03 * b00 + a13 * b10 + a23 * b20);
      var b31 = -(a03 * b01 + a13 * b11 + a23 * b21);
      var b32 = -(a03 * b02 + a13 * b12 + a23 * b22); // 1/det(mat)

      var idet = 1 / (a00 * b00 + a01 * b01 + a02 * b02); // matã®ä½å å­è¡å / det(mat)

      dst[0] = b00 * idet;
      dst[1] = b01 * idet;
      dst[2] = b02 * idet;
      dst[3] = 0;
      dst[4] = b10 * idet;
      dst[5] = b11 * idet;
      dst[6] = b12 * idet;
      dst[7] = 0;
      dst[8] = b20 * idet;
      dst[9] = b21 * idet;
      dst[10] = b22 * idet;
      dst[11] = 0;
      dst[12] = b30 * idet;
      dst[13] = b31 * idet;
      dst[14] = b32 * idet;
      dst[15] = 1;
      return dst;
    }
    /**
     * @summary å¹³é¢ãã¯ãã«ãå¤æ (ã¢ãã£ã³å¤æ)
     * @desc
     * <p>mat ã«ã¯å¹³é¢ãã¯ãã«ãå¤æããè¡åãæå®ããã
     * ä½ç½®ãã¯ãã«ãå¤æããè¡åã M ãªããå¹³é¢ãã¯ãã«ãå¤æããè¡åã¯ M<sup>-1</sup> ãæå®ããã</p>
     *
     * <p>dst ã«ã¯ plane * mat ãä»£å¥ãããã</p>
     *
     * @param  mat   {mapray.Matrix}   å¤æè¡å
     * @param  plane {mapray.Vector4}  å¹³é¢ãã¯ãã«
     * @param  dst   {mapray.Vector4}  çµæãä»£å¥ãããã¯ãã«
     * @return       {mapray.Vector4}  dst
     */

  }, {
    key: "transformPlane_A",
    value: function transformPlane_A(mat, plane, dst) {
      var m = mat;
      var x = plane[0];
      var y = plane[1];
      var z = plane[2];
      var w = plane[3];
      dst[0] = x * m[0] + y * m[1] + z * m[2];
      dst[1] = x * m[4] + y * m[5] + z * m[6];
      dst[2] = x * m[8] + y * m[9] + z * m[10];
      dst[3] = x * m[12] + y * m[13] + z * m[14] + w;
      return dst;
    }
    /**
     * @summary åº§æ¨å¤æè¡åãè¨ç® (Inou çé¢åº§æ¨ç³» â å°å¿ç´äº¤åº§æ¨ç³»)
     * @desc
     * <p>åç¹ã position ã®ç´äº¤åº§æ¨ç³» (LOCS) ããå°å¿ç´äº¤åº§æ¨ç³» (GOCS) ã«å¤æããè¡åãè¨ç®ããã</p>
     * <p>position.height + GeoMath.EARTH_RADIUS > 0 ãã¤ position.latitude == 0 ã®ã¨ããLOCS ã® Z è»¸ã¯ä¸æ¹åãY è»¸ã¯åæ¹åãX è»¸ã¯æ±æ¹åã¨ãªãã</p>
     *
     * @param  {object}         position             ä½ç½® (Inou çé¢åº§æ¨ç³»)
     * @param  {number}         position.latitude    ç·¯åº¦ (Degrees)
     * @param  {number}         position.longitude   çµåº¦ (Degrees)
     * @param  {number}         position.height      é«åº¦ (Meters)
     * @param  {mapray.Matrix}  dst                  çµæãä»£å¥ããè¡å
     * @return {mapray.Matrix}                       dst
     *
     * @deprecated {@link mapray.GeoPoint#getMlocsToGocsMatrix} ã®ä½¿ç¨ãæ¨å¥¨
     */

  }, {
    key: "iscs_to_gocs_matrix",
    value: function iscs_to_gocs_matrix(position, dst) {
      var Î» = position.longitude * GeoMath.DEGREE;
      var Ï = position.latitude * GeoMath.DEGREE;
      var sinÎ» = Math.sin(Î»);
      var cosÎ» = Math.cos(Î»);
      var sinÏ = Math.sin(Ï);
      var cosÏ = Math.cos(Ï);
      var r = GeoMath.EARTH_RADIUS + position.height; // âu/âÎ»

      dst[0] = -sinÎ»;
      dst[1] = cosÎ»;
      dst[2] = 0;
      dst[3] = 0; // âu/âÏ

      dst[4] = -cosÎ» * sinÏ;
      dst[5] = -sinÎ» * sinÏ;
      dst[6] = cosÏ;
      dst[7] = 0; // u = {x, y, z} / r

      dst[8] = cosÏ * cosÎ»;
      dst[9] = cosÏ * sinÎ»;
      dst[10] = sinÏ;
      dst[11] = 0; // {x, y, z}

      dst[12] = r * cosÏ * cosÎ»;
      dst[13] = r * cosÏ * sinÎ»;
      dst[14] = r * sinÏ;
      dst[15] = 1;
      return dst;
    }
    /**
     * @summary å°å¿ç´äº¤åº§æ¨ã Inou çé¢åº§æ¨ã«å¤æ
     *
     * @param  {mapray.Vector3} src            å¥å GOCS åº§æ¨ (Meters)
     * @param  {object}         dst            åºå ISCS åº§æ¨
     * @param  {number}         dst.latitude   ç·¯åº¦ (Degrees)
     * @param  {number}         dst.longitude  çµåº¦ (Degrees)
     * @param  {number}         dst.height     é«åº¦ (Meters)
     * @return {object}                        dst
     *
     * @deprecated {@link mapray.GeoPoint#setFromGocs} ã®ä½¿ç¨ãæ¨å¥¨
     */

  }, {
    key: "gocs_to_iscs",
    value: function gocs_to_iscs(src, dst) {
      var x = src[0];
      var y = src[1];
      var z = src[2];
      var x2 = x * x;
      var y2 = y * y;
      var z2 = z * z; // ç·¯åº¦ Ï = ArcTan[z / â(x^2 + y^2)]
      // çµåº¦ Î» = ArcTan[x, y]

      if (x != 0 || y != 0) {
        dst.latitude = Math.atan(z / Math.sqrt(x2 + y2)) / GeoMath.DEGREE;
        dst.longitude = Math.atan2(y, x) / GeoMath.DEGREE;
      } else {
        // x == 0 && y == 0
        if (z > 0) dst.latitude = 90;else if (z < 0) dst.latitude = -90;else dst.latitude = 0;
        dst.longitude = 0;
      } // é«åº¦ h = â(x^2 + y^2 + z^2) - R


      dst.height = Math.sqrt(x2 + y2 + z2) - GeoMath.EARTH_RADIUS;
      return dst;
    }
    /**
     * @summary åº§æ¨å¤æè¡åãè¨ç® (è¦ç¹åº§æ¨ç³» â ã¯ãªããåæ¬¡åº§æ¨ç³»)
     * @param  {number}        left
     * @param  {number}        right
     * @param  {number}        bottom
     * @param  {number}        top
     * @param  {number}        nearVal
     * @param  {number}        farVal
     * @param  {mapray.Matrix} dst     çµæãä»£å¥ããè¡å
     * @return {mapray.Matrix}         dst
     *
     * @see https://www.opengl.org/sdk/docs/man2/xhtml/glFrustum.xml
     */

  }, {
    key: "frustum_matrix",
    value: function frustum_matrix(left, right, bottom, top, nearVal, farVal, dst) {
      dst[0] = 2 * nearVal / (right - left);
      dst[1] = 0;
      dst[2] = 0;
      dst[3] = 0;
      dst[4] = 0;
      dst[5] = 2 * nearVal / (top - bottom);
      dst[6] = 0;
      dst[7] = 0;
      dst[8] = (right + left) / (right - left);
      dst[9] = (top + bottom) / (top - bottom);
      dst[10] = (farVal + nearVal) / (nearVal - farVal);
      dst[11] = -1;
      dst[12] = 0;
      dst[13] = 0;
      dst[14] = 2 * farVal * nearVal / (nearVal - farVal);
      dst[15] = 0;
      return dst;
    }
    /**
     * @summary åº§æ¨å¤æè¡åãè¨ç® (å³æåº§æ¨ç³» â è¦ç¹åº§æ¨ç³»)
     *
     * @param  {mapray.Vector3}  eye     è¦ç¹ã®ä½ç½®
     * @param  {mapray.Vector3}  center  æ³¨è¦ç¹ã®ä½ç½®
     * @param  {mapray.Vector3}  up      ä¸æ¹åãã¯ãã«
     * @param  {mapray.Matrix}   dst     çµæãä»£å¥ããè¡å
     * @return {mapray.Matrix}           dst
     */

  }, {
    key: "lookat_matrix",
    value: function lookat_matrix(eye, center, up, dst) {
      var xaxis = GeoMath._xaxis;
      var yaxis = GeoMath._yaxis;
      var zaxis = GeoMath._zaxis;
      zaxis[0] = eye[0] - center[0];
      zaxis[1] = eye[1] - center[1];
      zaxis[2] = eye[2] - center[2];
      GeoMath.normalize3(zaxis, zaxis);
      GeoMath.cross3(up, zaxis, xaxis);
      GeoMath.normalize3(xaxis, xaxis);
      GeoMath.cross3(zaxis, xaxis, yaxis); // åä½ãã¯ãã«ã«ãªã£ã¦ãã

      dst[0] = xaxis[0];
      dst[1] = xaxis[1];
      dst[2] = xaxis[2];
      dst[3] = 0;
      dst[4] = yaxis[0];
      dst[5] = yaxis[1];
      dst[6] = yaxis[2];
      dst[7] = 0;
      dst[8] = zaxis[0];
      dst[9] = zaxis[1];
      dst[10] = zaxis[2];
      dst[11] = 0;
      dst[12] = eye[0];
      dst[13] = eye[1];
      dst[14] = eye[2];
      dst[15] = 1;
      return dst;
    }
    /**
     * @summary ä»»æè»¸åãã®åè»¢è¡å
     * @desc
     * <p>axis ã Z è»¸æ¹åã¨ããã¨ãX è»¸ãã Y è»¸ã®æ¹åã« angle åº¦åè»¢ãããå¤æè¡åãè¿ãã</p>
     * @param  {mapray.Vector3} axis   åè»¢è»¸ (åä½ãã¯ãã«)
     * @param  {number}         angle  åè»¢è§ (Degrees)
     * @param  {mapray.Matrix}  dst    çµæãä»£å¥ããè¡å
     * @return {mapray.Matrix}         dst
     */

  }, {
    key: "rotation_matrix",
    value: function rotation_matrix(axis, angle, dst) {
      var Î¸ = angle * GeoMath.DEGREE;
      var sinÎ¸ = Math.sin(Î¸);
      var cosÎ¸ = Math.cos(Î¸);
      var ax = axis[0];
      var ay = axis[1];
      var az = axis[2];
      dst[0] = ax * ax * (1 - cosÎ¸) + cosÎ¸;
      dst[1] = ax * ay * (1 - cosÎ¸) + az * sinÎ¸;
      dst[2] = ax * az * (1 - cosÎ¸) - ay * sinÎ¸;
      dst[3] = 0;
      dst[4] = ax * ay * (1 - cosÎ¸) - az * sinÎ¸;
      dst[5] = ay * ay * (1 - cosÎ¸) + cosÎ¸;
      dst[6] = ay * az * (1 - cosÎ¸) + ax * sinÎ¸;
      dst[7] = 0;
      dst[8] = ax * az * (1 - cosÎ¸) + ay * sinÎ¸;
      dst[9] = ay * az * (1 - cosÎ¸) - ax * sinÎ¸;
      dst[10] = az * az * (1 - cosÎ¸) + cosÎ¸;
      dst[11] = 0;
      dst[12] = 0;
      dst[13] = 0;
      dst[14] = 0;
      dst[15] = 1;
      return dst;
    }
    /**
     * @summary KML äºæã®ã¢ãã«å¤æè¡å
     *
     * @desc
     * <p>å¤æã¯ scale -> roll -> tilt -> heading ã®é ã«è¡ãããã</p>
     *
     * @param  {number}         heading  Z è»¸ãä¸­å¿ã« Y è»¸ãã X è»¸ã®æ¹åã®åè»¢è§ (Degrees)
     * @param  {number}         tilt     X è»¸ãä¸­å¿ã« Z è»¸ãã Y è»¸ã®æ¹åã®åè»¢è§ (Degrees)
     * @param  {number}         roll     Y è»¸ãä¸­å¿ã« X è»¸ãã Z è»¸ã®æ¹åã®åè»¢è§ (Degrees)
     * @param  {mapray.Vector3} scale    ã¹ã±ã¼ã«
     * @param  {mapray.Matrix}  dst      çµæãä»£å¥ããè¡å
     * @return {mapray.Matrix}           dst
     *
     * @package
     * @see https://developers.google.com/kml/documentation/kmlreference#model
     *
     * @deprecated {@link mapray.Orientation#getTransformMatrix} ã®ä½¿ç¨ãæ¨å¥¨
     */

  }, {
    key: "kml_model_matrix",
    value: function kml_model_matrix(heading, tilt, roll, scale, dst) {
      var h = heading * GeoMath.DEGREE;
      var t = tilt * GeoMath.DEGREE;
      var r = roll * GeoMath.DEGREE;
      var sinH = Math.sin(h);
      var cosH = Math.cos(h);
      var sinT = Math.sin(t);
      var cosT = Math.cos(t);
      var sinR = Math.sin(r);
      var cosR = Math.cos(r);
      var sx = scale[0];
      var sy = scale[1];
      var sz = scale[2];
      dst[0] = sx * (sinH * sinR * sinT + cosH * cosR);
      dst[1] = sx * (cosH * sinR * sinT - sinH * cosR);
      dst[2] = sx * sinR * cosT;
      dst[3] = 0;
      dst[4] = sy * sinH * cosT;
      dst[5] = sy * cosH * cosT;
      dst[6] = -sy * sinT;
      dst[7] = 0;
      dst[8] = sz * (sinH * cosR * sinT - cosH * sinR);
      dst[9] = sz * (cosH * cosR * sinT + sinH * sinR);
      dst[10] = sz * cosR * cosT;
      dst[11] = 0;
      dst[12] = 0;
      dst[13] = 0;
      dst[14] = 0;
      dst[15] = 1;
      return dst;
    }
    /**
     * @summary ã°ã¼ãã«ãã³é¢æ°
     * @param  {number}  x   æ°å¤
     * @return {number}      gd( x )
     */

  }, {
    key: "gudermannian",
    value: function gudermannian(x) {
      return 2 * Math.atan(Math.exp(x)) - Math.PI / 2;
    }
    /** 
     * @summary éã°ã¼ãã«ãã³é¢æ°
     * @param  {number}  x   æ°å¤
     * @return {number}      gd<sup>-1</sup>( x )
     */

  }, {
    key: "invGudermannian",
    value: function invGudermannian(x) {
      return Math.log(Math.tan(x / 2 + Math.PI / 4));
    }
    /**
     * @summary å¤ãæå®åºéåã«å¶é
     * @param  {number}  x    å¤
     * @param  {number}  min  æå°å¤
     * @param  {number}  max  æå¤§å¤
     * @return {number}       min <= x <= max ã®ã¨ã x, x < min ã®ã¨ã min, x > max ã®ã¨ã max
     */

  }, {
    key: "clamp",
    value: function clamp(x, min, max) {
      return Math.min(Math.max(x, min), max);
    }
  }]);

  return GeoMath;
}();
/**
 * @summary å°çã®åå¾
 * @desc
 * <p>Inou çé¢åº§æ¨ç³»ã§å®ç¾©ããããå°çã®åå¾ (Meters) ã§ããã</p>
 * @type {number}
 * @constant
 */


GeoMath.EARTH_RADIUS = 6378137;
/**
 * @summary 1åº¦ã«å¯¾å¿ããã©ã¸ã¢ã³ã®æ°å¤
 * @desc
 * <p>ãã®æ°å¤ã¯ Ï / 180 ã§ããã</p>
 * <p>åº¦æ°ã DEGREE ã§æãåãããã¨ã«ãã£ã¦ã©ã¸ã¢ã³ã«å¤æãããã¨ãã§ããã</p>
 * @type {number}
 * @constant
 */

GeoMath.DEGREE = 0.017453292519943295769;
/**
 * @summary log2(Ï)
 * @type {number}
 * @constant
 */

GeoMath.LOG2PI = 1.6514961294723187980;
/**
 * @summary 4è¡4åã®è¡åãè¡¨ç¾
 * @desc
 * <p>ãã®ã¯ã©ã¹ã¯å®å¨ããªãä¾¿å®çãªãã®ã§ãããArray ã TypedArray ç­ã® 16 è¦ç´ ã®éåã«ç½®ãæãããã¨ãã§ããã
 * ãã®éåã®æ°å¤ã®ä¸¦ã³ã¯ååªåã§ããã</p>
 *
 * @class mapray.Matrix
 * @see mapray.GeoMath
 */

/**
 * @summary 2æ¬¡ãã¯ãã«ãè¡¨ç¾
 * @desc
 * <p>ãã®ã¯ã©ã¹ã¯å®å¨ããªãä¾¿å®çãªãã®ã§ãããArray ã TypedArray ç­ã® 2 è¦ç´ ã®éåã«ç½®ãæãããã¨ãã§ããã</p>
 *
 * @class mapray.Vector2
 * @see mapray.GeoMath
 */

/**
 * @summary 3æ¬¡ãã¯ãã«ãè¡¨ç¾
 * @desc
 * <p>ãã®ã¯ã©ã¹ã¯å®å¨ããªãä¾¿å®çãªãã®ã§ãããArray ã TypedArray ç­ã® 3 è¦ç´ ã®éåã«ç½®ãæãããã¨ãã§ããã</p>
 *
 * @class mapray.Vector3
 * @see mapray.GeoMath
 */

/**
 * @summary 4æ¬¡ãã¯ãã«ãè¡¨ç¾
 * @desc
 * <p>ãã®ã¯ã©ã¹ã¯å®å¨ããªãä¾¿å®çãªãã®ã§ãããArray ã TypedArray ç­ã® 4 è¦ç´ ã®éåã«ç½®ãæãããã¨ãã§ããã</p>
 *
 * @class mapray.Vector4
 * @see mapray.GeoMath
 */
// GeoMath ã®åé¨ãã³ãã©ãªå¤æ°ãçæ

{
  GeoMath._xaxis = GeoMath.createVector3();
  GeoMath._yaxis = GeoMath.createVector3();
  GeoMath._zaxis = GeoMath.createVector3();
}
/**
 * @summary çé¢åº§æ¨
 *
 * @classdesc
 * <p>çµåº¦ãç·¯åº¦ãé«åº¦ã«ããä½ç½®ãè¡¨ç¾ããã</p>
 *
 * @memberof mapray
 */

var GeoPoint =
/*#__PURE__*/
function () {
  /**
   * @desc
   * <p>çµåº¦ãç·¯åº¦ãé«åº¦ãä¸ãã¦ã¤ã³ã¹ã¿ã³ã¹ãçæããã</p>
   *
   * @param {number} [longitude=0]  çµåº¦ (Degrees)
   * @param {number} [latitude=0]   ç·¯åº¦ (Degrees)
   * @param {number} [altitude=0]   é«åº¦ (Meters)
   */
  function GeoPoint(longitude, latitude, altitude) {
    _classCallCheck(this, GeoPoint);

    /**
     *  @summary çµåº¦ (Degrees)
     *  @member mapray.GeoPoint#longitude
     *  @type {number}
     */
    this.longitude = longitude !== undefined ? longitude : 0;
    /**
     *  @summary ç·¯åº¦ (Degrees)
     *  @member mapray.GeoPoint#latitude
     *  @type {number}
     */

    this.latitude = latitude !== undefined ? latitude : 0;
    /**
     *  @summary é«åº¦ (Meters)
     *  @member mapray.GeoPoint#altitude
     *  @type {number}
     */

    this.altitude = altitude !== undefined ? altitude : 0;
  }
  /**
   * @summary ã¤ã³ã¹ã¿ã³ã¹ãè¤è£½
   *
   * @desc
   * <p>this ã®è¤è£½ãçæãã¦è¿ãã</p>
   *
   * @return {mapray.GeoPoint}  this ã®è¤è£½
   */


  _createClass(GeoPoint, [{
    key: "clone",
    value: function clone() {
      return new GeoPoint(this.longitude, this.latitude, this.altitude);
    }
    /**
     * @summary ã¤ã³ã¹ã¿ã³ã¹ãä»£å¥
     *
     * @desc
     * <p>src ã this ã«ä»£å¥ããã</p>
     *
     * @param  {mapray.GeoPoint} src  ä»£å¥å
     * @return {mapray.GeoPoint}      this
     */

  }, {
    key: "assign",
    value: function assign(src) {
      this.longitude = src.longitude;
      this.latitude = src.latitude;
      this.altitude = src.altitude;
      return this;
    }
    /**
     * @summary éåããã®è¨­å®
     *
     * @desc
     * <p>longitude, latitude, altitude ã®é åºã§æ ¼ç´ããã¦ããéå position ã«ãããã­ããã£ãè¨­å®ããã</p>
     * <p>position ã®é·ãã¯ 2 ã¾ãã¯ 3 ã§ãé·ãã 2 ãªã altitude ã¯ 0 ã«è¨­å®ãããã</p>
     *
     * @param  {number[]} position  [longitude, latitude, altitude] ã¾ãã¯ [longitude, latitude]
     * @return {mapray.GeoPoint} this
     */

  }, {
    key: "setFromArray",
    value: function setFromArray(position) {
      this.longitude = position[0];
      this.latitude = position[1];
      this.altitude = position.length > 2 ? position[2] : 0;
      return this;
    }
    /**
     * @summary å°å¿ç´äº¤åº§æ¨ããã®è¨­å®
     *
     * @desc
     * <p>å°å¿ç´äº¤åº§æ¨ position ãçé¢åº§æ¨ã«å¤æãã¦ this ã«è¨­å®ããã</p>
     *
     * @param  {mapray.Vector3} position  å¥å GOCS åº§æ¨ (Meters)
     * @return {mapray.GeoPoint}  this
     */

  }, {
    key: "setFromGocs",
    value: function setFromGocs(position) {
      var x = position[0];
      var y = position[1];
      var z = position[2];
      var x2 = x * x;
      var y2 = y * y;
      var z2 = z * z; // ç·¯åº¦ Ï = ArcTan[z / â(x^2 + y^2)]
      // çµåº¦ Î» = ArcTan[x, y]

      if (x != 0 || y != 0) {
        this.latitude = Math.atan(z / Math.sqrt(x2 + y2)) / GeoMath.DEGREE;
        this.longitude = Math.atan2(y, x) / GeoMath.DEGREE;
      } else {
        // x == 0 && y == 0
        if (z > 0) this.latitude = 90;else if (z < 0) this.latitude = -90;else this.latitude = 0;
        this.longitude = 0;
      } // é«åº¦ h = â(x^2 + y^2 + z^2) - R


      this.altitude = Math.sqrt(x2 + y2 + z2) - GeoMath.EARTH_RADIUS;
      return this;
    }
    /**
     * @summary å°å¿ç´äº¤åº§æ¨ã¨ãã¦åå¾
     *
     * @param  {mapray.Vector3} dst  çµæãæ ¼ç´ãããªãã¸ã§ã¯ã
     * @return {mapray.Vector3}      dst
     */

  }, {
    key: "getAsGocs",
    value: function getAsGocs(dst) {
      var Î» = this.longitude * GeoMath.DEGREE;
      var Ï = this.latitude * GeoMath.DEGREE;
      var r = GeoMath.EARTH_RADIUS + this.altitude;
      var cosÏ = Math.cos(Ï);
      dst[0] = r * cosÏ * Math.cos(Î»);
      dst[1] = r * cosÏ * Math.sin(Î»);
      dst[2] = r * Math.sin(Ï);
      return dst;
    }
    /**
     * @summary åº§æ¨å¤æè¡åãè¨ç® (MLOCS â GOCS)
     * @desc
     * <p>åç¹ã this ã® Mapray ã­ã¼ã«ã«ç´äº¤åº§æ¨ç³» (MLOCS) ããå°å¿ç´äº¤åº§æ¨ç³» (GOCS) ã«å¤æããè¡åãè¨ç®ããã</p>
     *
     * @param  {mapray.Matrix} dst  çµæãä»£å¥ããè¡å
     * @return {mapray.Matrix}      dst
     */

  }, {
    key: "getMlocsToGocsMatrix",
    value: function getMlocsToGocsMatrix(dst) {
      var Î» = this.longitude * GeoMath.DEGREE;
      var Ï = this.latitude * GeoMath.DEGREE;
      var sinÎ» = Math.sin(Î»);
      var cosÎ» = Math.cos(Î»);
      var sinÏ = Math.sin(Ï);
      var cosÏ = Math.cos(Ï);
      var r = GeoMath.EARTH_RADIUS + this.altitude; // âu/âÎ»

      dst[0] = -sinÎ»;
      dst[1] = cosÎ»;
      dst[2] = 0;
      dst[3] = 0; // âu/âÏ

      dst[4] = -cosÎ» * sinÏ;
      dst[5] = -sinÎ» * sinÏ;
      dst[6] = cosÏ;
      dst[7] = 0; // u = {x, y, z} / r

      dst[8] = cosÏ * cosÎ»;
      dst[9] = cosÏ * sinÎ»;
      dst[10] = sinÏ;
      dst[11] = 0; // {x, y, z}

      dst[12] = r * cosÏ * cosÎ»;
      dst[13] = r * cosÏ * sinÎ»;
      dst[14] = r * sinÏ;
      dst[15] = 1;
      return dst;
    }
    /**
     * @summary éç´ä¸æ¹åã®ãã¯ãã«ãè¨ç®
     *
     * @param  {mapray.Vector3} dst  çµæãä»£å¥ãããªãã¸ã§ã¯ã
     * @return {mapray.Vector3}      dst
     */

  }, {
    key: "getUpwardVector",
    value: function getUpwardVector(dst) {
      var Î» = this.longitude * GeoMath.DEGREE;
      var Ï = this.latitude * GeoMath.DEGREE;
      var cosÏ = Math.cos(Ï);
      dst[0] = cosÏ * Math.cos(Î»);
      dst[1] = cosÏ * Math.sin(Î»);
      dst[2] = Math.sin(Ï);
      return dst;
    }
    /**
     * @summary å°è¡¨é¢(é«åº¦0)ã§ã®2å°ç¹éã®è·é¢ãç®åº
     * @desc
     * <p> GeoMath.DEGREE ãåå¾ã¨ããççã¨ãã¦è¨ç®ããã</p>
     *
     * @param  {mapray.GeoPoint} to
     * @return {number}   arc è·é¢(m)
     */

  }, {
    key: "getGeographicalDistance",
    value: function getGeographicalDistance(to) {
      var from_vec = this.getAsGocs(GeoMath.createVector3());
      var to_vec = to.getAsGocs(GeoMath.createVector3());
      var cross = GeoMath.cross3(from_vec, to_vec, GeoMath.createVector3());
      return GeoMath.EARTH_RADIUS * Math.atan2(Math.sqrt(cross[0] * cross[0] + cross[1] * cross[1] + cross[2] * cross[2]), GeoMath.dot3(from_vec, to_vec));
    }
    /**
     * @summary çé¢åº§æ¨ãå°å¿ç´äº¤åº§æ¨ã«å¤æ
     *
     * @param  {number[]} points      [lon_0, lat_0, alt_0, ...]
     * @param  {number}   num_points  ç¹ã®æ°
     * @param  {number[]} dst         [x0, y0, z0, ...] (çµæãæ ¼ç´ããéå)
     * @return {number[]} dst
     *
     * @see {@link mapray.GeoPoint.getAsGocs}
     */

  }], [{
    key: "toGocsArray",
    value: function toGocsArray(points, num_points, dst) {
      var degree = GeoMath.DEGREE;
      var radius = GeoMath.EARTH_RADIUS;

      for (var i = 0; i < num_points; ++i) {
        var b = 3 * i;
        var Î» = points[b] * degree;
        var Ï = points[b + 1] * degree;
        var r = radius + points[b + 2];
        var cosÏ = Math.cos(Ï);
        dst[b] = r * cosÏ * Math.cos(Î»);
        dst[b + 1] = r * cosÏ * Math.sin(Î»);
        dst[b + 2] = r * Math.sin(Ï);
      }

      return dst;
    }
  }]);

  return GeoPoint;
}();
/**
 * @summary æ¹åè¡¨ç¾
 *
 * @classdesc
 * <p>heading (æ©é¦æ¹ä½)ãtilt (åå¾ã®å¾ã)ãroll (å·¦å³ã®å¾ã) ã«ããæ¹åãè¡¨ç¾ããã</p>
 *
 * @memberof mapray
 * @see https://developers.google.com/kml/documentation/kmlreference#model
 */


var Orientation =
/*#__PURE__*/
function () {
  /**
   * @desc
   * <p>heading, tilt, roll ã«è§åº¦ãä¸ãã¦ã¤ã³ã¹ã¿ã³ã¹ãçæããã</p>
   *
   * @param {number} [heading=0]  æ©é¦æ¹ä½ (Degrees)
   * @param {number} [tilt=0]     åå¾ã®å¾ã (Degrees)
   * @param {number} [roll=0]     å·¦å³ã®å¾ã (Degrees)
   */
  function Orientation(heading, tilt, roll) {
    _classCallCheck(this, Orientation);

    /**
     *  @summary æ©é¦æ¹ä½ (Degrees)
     *  @member mapray.Orientation#heading
     *  @type {number}
     */
    this.heading = heading !== undefined ? heading : 0;
    /**
     *  @summary åå¾ã®å¾ã (Degrees)
     *  @member mapray.Orientation#tilt
     *  @type {number}
     */

    this.tilt = tilt !== undefined ? tilt : 0;
    /**
     *  @summary å·¦å³ã®å¾ã (Degrees)
     *  @member mapray.Orientation#roll
     *  @type {number}
     */

    this.roll = roll !== undefined ? roll : 0;
  }
  /**
   * @summary ã¤ã³ã¹ã¿ã³ã¹ãè¤è£½
   *
   * @desc
   * <p>this ã®è¤è£½ãçæãã¦è¿ãã</p>
   *
   * @return {mapray.Orientation}  this ã®è¤è£½
   */


  _createClass(Orientation, [{
    key: "clone",
    value: function clone() {
      return new Orientation(this.heading, this.tilt, this.roll);
    }
    /**
     * @summary ã¤ã³ã¹ã¿ã³ã¹ãä»£å¥
     *
     * @desc
     * <p>src ã this ã«ä»£å¥ããã</p>
     *
     * @param  {mapray.Orientation} src  ä»£å¥å
     * @return {mapray.Orientation}      this
     */

  }, {
    key: "assign",
    value: function assign(src) {
      this.heading = src.heading;
      this.tilt = src.tilt;
      this.roll = src.roll;
      return this;
    }
    /**
     * @summary å¤æè¡åãåå¾
     *
     * @desc
     * <p>å¤æã¯ scale -> roll -> tilt -> heading ã®é ã«è¡ãããã</p>
     *
     * @param  {mapray.Vector3} scale  ã¹ã±ã¼ã«
     * @param  {mapray.Matrix}  dst    çµæãä»£å¥ããè¡å
     * @return {mapray.Matrix}  dst
     */

  }, {
    key: "getTransformMatrix",
    value: function getTransformMatrix(scale, dst) {
      var h = this.heading * GeoMath.DEGREE;
      var t = this.tilt * GeoMath.DEGREE;
      var r = this.roll * GeoMath.DEGREE;
      var sinH = Math.sin(h);
      var cosH = Math.cos(h);
      var sinT = Math.sin(t);
      var cosT = Math.cos(t);
      var sinR = Math.sin(r);
      var cosR = Math.cos(r);
      var sx = scale[0];
      var sy = scale[1];
      var sz = scale[2];
      dst[0] = sx * (sinH * sinR * sinT + cosH * cosR);
      dst[1] = sx * (cosH * sinR * sinT - sinH * cosR);
      dst[2] = sx * sinR * cosT;
      dst[3] = 0;
      dst[4] = sy * sinH * cosT;
      dst[5] = sy * cosH * cosT;
      dst[6] = -sy * sinT;
      dst[7] = 0;
      dst[8] = sz * (sinH * cosR * sinT - cosH * sinR);
      dst[9] = sz * (cosH * cosR * sinT + sinH * sinR);
      dst[10] = sz * cosR * cosT;
      dst[11] = 0;
      dst[12] = 0;
      dst[13] = 0;
      dst[14] = 0;
      dst[15] = 1;
      return dst;
    }
  }]);

  return Orientation;
}();

/*
 * è§£èª¬: ãã®ãã¡ã¤ã«ã§ GeoPoint ã¯ã©ã¹ã¨ Orientation ã¯ã©ã¹ãå®ç¾©ãã¦ããçç±
 *
 *   GeoPoint ã¨ Orientation ã®ã¤ã³ã¿ãã§ã¼ã¹ã¯ GeoMath ã«ä¾å­ããªãããGeoMath
 *   ã®ã¤ã³ã¿ãã§ã¼ã¹ã¯ GeoPoint ã Orientation ã«ä¾å­ããå¯è½æ§ãããã
 *
 *   ä¸æ¹ãGeoPoint ã¨ Orientation ã®åé¨å®è£ã§ã¯ä¸é¨ã® GeoMath ã¤ã³ã¿ãã§ã¼ã¹ã
 *   ä½¿ç¨ã§ããã»ããé½åãããã
 *
 *   GeoPoint ã¨ Orientation ãåå¥ã®ãã¡ã¤ã«ã§å®ç¾©ããããããã®å ´åå®è£ã®ããã«
 *   GeoMath ãã¤ã³ãã¼ããããã¨ã«ãªãã
 *
 *   ããããã¨ãGeoMath.js ã« GeoPoint ã Orientation ã (å¾ªç°ä¾å­ã®ãã)
 *   ã¤ã³ãã¼ãã§ããªããªã£ã¦ãã¾ãã
 *
 *   ããã§ GeoMath.js åã§ GeoPoint ã¨ Orientation ãå®ç¾©ãããããã§ GeoPoint
 *   ã¨ Orientation ã®å®è£ã§ GeoMath ãä½¿ç¨ã§ããGeoMath ã®ã¤ã³ã¿ãã§ã¼ã¹ã¨å®è£ã§
 *   GeoPoint ã Orientation ãä½¿ç¨ã§ããã
 *
 *   GeoPoint ã¯ã¾ã GeoMath.js ãã GeoPoint.js ã«ã¨ã¯ã¹ãã¼ãããããã«
 *   GeoPoint.js ãã GeoPoint ãä»ã®ãã¡ã¤ã«ã«ã¨ã¯ã¹ãã¼ãããã
 *   Orientation ãåæ§ã®ãã¨ãè¡ãã
 *
 *   ãã®ããã«ãããã¨ã§ãä»ã®ãã¡ã¤ã«ããã¯å®è£ã®äºæã¯è¦ããªããªãã
 */

/**
 * @summary ççå¤å
 *
 * @classdesc
 * <p>ç»é²å: "boolean"</p>
 * <p>å®è£å: boolean</p>
 * <p>æ¬¡ã®åã¸å¤æå¯è½: {@link mapray.animation.NumberType}</p>
 *
 * @memberof mapray.animation
 * @extends mapray.animation.Type
 * @hideconstructor
 */

var BooleanType =
/*#__PURE__*/
function (_Type) {
  _inherits(BooleanType, _Type);

  /**
   */
  function BooleanType() {
    var _this;

    _classCallCheck(this, BooleanType);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BooleanType).call(this, "boolean"));
    _this._number_type = null;
    _this._convertibles = new Set([_assertThisInitialized(_this)]);
    return _this;
  }
  /**
   * @private
   */


  _createClass(BooleanType, [{
    key: "_postinit",
    value: function _postinit() {
      this._number_type = Type.find("number");

      this._convertibles.add(this._number_type);
    }
    /**
     * @override
     */

  }, {
    key: "isConvertible",
    value: function isConvertible(from) {
      return this._convertibles.has(from);
    }
    /**
     * @override
     */

  }, {
    key: "convertValue",
    value: function convertValue(from, value) {
      if (from === this) {
        // åä¸å
        return value;
      } else {
        // assert: from === this._number_type
        return value >= 0.5;
      }
    }
    /**
     * @override
     */

  }, {
    key: "getDefaultValue",
    value: function getDefaultValue() {
      return false;
    }
    /**
     * @override
     */

  }, {
    key: "getCloneValue",
    value: function getCloneValue(value) {
      return value;
    }
  }]);

  return BooleanType;
}(Type);
/**
 * @summary æ°å¤å
 *
 * @classdesc
 * <p>ç»é²å: "number"</p>
 * <p>å®è£å: number</p>
 * <p>æ¬¡ã®åã¸å¤æå¯è½: {@link mapray.animation.BooleanType}</p>
 *
 * @memberof mapray.animation
 * @extends mapray.animation.Type
 * @hideconstructor
 */


var NumberType =
/*#__PURE__*/
function (_Type2) {
  _inherits(NumberType, _Type2);

  /**
   */
  function NumberType() {
    var _this2;

    _classCallCheck(this, NumberType);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(NumberType).call(this, "number"));
    _this2._boolean_type = null;
    _this2._convertibles = new Set([_assertThisInitialized(_this2)]);
    return _this2;
  }
  /**
   * @private
   */


  _createClass(NumberType, [{
    key: "_postinit",
    value: function _postinit() {
      this._boolean_type = Type.find("boolean");

      this._convertibles.add(this._boolean_type);
    }
    /**
     * @override
     */

  }, {
    key: "isConvertible",
    value: function isConvertible(from) {
      return this._convertibles.has(from);
    }
    /**
     * @override
     */

  }, {
    key: "convertValue",
    value: function convertValue(from, value) {
      if (from === this) {
        // åä¸å
        return value;
      } else {
        // assert: from === this._boolean_type
        return value ? 1 : 0;
      }
    }
    /**
     * @override
     */

  }, {
    key: "getDefaultValue",
    value: function getDefaultValue() {
      return 0;
    }
    /**
     * @override
     */

  }, {
    key: "getCloneValue",
    value: function getCloneValue(value) {
      return value;
    }
  }]);

  return NumberType;
}(Type);
/**
 * @summary æå­åå
 *
 * @classdesc
 * <p>ç»é²å: "string"</p>
 * <p>å®è£å: string</p>
 *
 * @memberof mapray.animation
 * @extends mapray.animation.Type
 * @hideconstructor
 */


var StringType =
/*#__PURE__*/
function (_Type3) {
  _inherits(StringType, _Type3);

  /**
   */
  function StringType() {
    _classCallCheck(this, StringType);

    return _possibleConstructorReturn(this, _getPrototypeOf(StringType).call(this, "string"));
  }
  /**
   * @private
   */


  _createClass(StringType, [{
    key: "_postinit",
    value: function _postinit() {}
    /**
     * @override
     */

  }, {
    key: "isConvertible",
    value: function isConvertible(from) {
      return from === this;
    }
    /**
     * @override
     */

  }, {
    key: "convertValue",
    value: function convertValue(from, value) {
      return value;
    }
    /**
     * @override
     */

  }, {
    key: "getDefaultValue",
    value: function getDefaultValue() {
      return "";
    }
    /**
     * @override
     */

  }, {
    key: "getCloneValue",
    value: function getCloneValue(value) {
      return value;
    }
  }]);

  return StringType;
}(Type);
/**
 * @summary 2 æ¬¡ãã¯ãã«å
 *
 * @classdesc
 * <p>ç»é²å: "vector2"</p>
 * <p>å®è£å: {@link mapray.Vector2}</p>
 *
 * @memberof mapray.animation
 * @extends mapray.animation.Type
 * @hideconstructor
 */


var Vector2Type =
/*#__PURE__*/
function (_Type4) {
  _inherits(Vector2Type, _Type4);

  /**
   */
  function Vector2Type() {
    _classCallCheck(this, Vector2Type);

    return _possibleConstructorReturn(this, _getPrototypeOf(Vector2Type).call(this, "vector2"));
  }
  /**
   * @private
   */


  _createClass(Vector2Type, [{
    key: "_postinit",
    value: function _postinit() {}
    /**
     * @override
     */

  }, {
    key: "isConvertible",
    value: function isConvertible(from) {
      return from === this;
    }
    /**
     * @override
     */

  }, {
    key: "convertValue",
    value: function convertValue(from, value) {
      return value;
    }
    /**
     * @override
     */

  }, {
    key: "getDefaultValue",
    value: function getDefaultValue() {
      return GeoMath.createVector2();
    }
    /**
     * @override
     */

  }, {
    key: "getCloneValue",
    value: function getCloneValue(value) {
      return GeoMath.createVector2(value);
    }
  }]);

  return Vector2Type;
}(Type);
/**
 * @summary 3 æ¬¡ãã¯ãã«å
 *
 * @classdesc
 * <p>ç»é²å: "vector3"</p>
 * <p>å®è£å: {@link mapray.Vector3}</p>
 *
 * @memberof mapray.animation
 * @extends mapray.animation.Type
 * @hideconstructor
 */


var Vector3Type =
/*#__PURE__*/
function (_Type5) {
  _inherits(Vector3Type, _Type5);

  /**
   */
  function Vector3Type() {
    _classCallCheck(this, Vector3Type);

    return _possibleConstructorReturn(this, _getPrototypeOf(Vector3Type).call(this, "vector3"));
  }
  /**
   * @private
   */


  _createClass(Vector3Type, [{
    key: "_postinit",
    value: function _postinit() {}
    /**
     * @override
     */

  }, {
    key: "isConvertible",
    value: function isConvertible(from) {
      return from === this;
    }
    /**
     * @override
     */

  }, {
    key: "convertValue",
    value: function convertValue(from, value) {
      return value;
    }
    /**
     * @override
     */

  }, {
    key: "getDefaultValue",
    value: function getDefaultValue() {
      return GeoMath.createVector3();
    }
    /**
     * @override
     */

  }, {
    key: "getCloneValue",
    value: function getCloneValue(value) {
      return GeoMath.createVector3(value);
    }
  }]);

  return Vector3Type;
}(Type);
/**
 * @summary 4 æ¬¡ãã¯ãã«å
 *
 * @classdesc
 * <p>ç»é²å: "vector4"</p>
 * <p>å®è£å: {@link mapray.Vector4}</p>
 *
 * @memberof mapray.animation
 * @extends mapray.animation.Type
 * @hideconstructor
 */


var Vector4Type =
/*#__PURE__*/
function (_Type6) {
  _inherits(Vector4Type, _Type6);

  /**
   */
  function Vector4Type() {
    _classCallCheck(this, Vector4Type);

    return _possibleConstructorReturn(this, _getPrototypeOf(Vector4Type).call(this, "vector4"));
  }
  /**
   * @private
   */


  _createClass(Vector4Type, [{
    key: "_postinit",
    value: function _postinit() {}
    /**
     * @override
     */

  }, {
    key: "isConvertible",
    value: function isConvertible(from) {
      return from === this;
    }
    /**
     * @override
     */

  }, {
    key: "convertValue",
    value: function convertValue(from, value) {
      return value;
    }
    /**
     * @override
     */

  }, {
    key: "getDefaultValue",
    value: function getDefaultValue() {
      return GeoMath.createVector4();
    }
    /**
     * @override
     */

  }, {
    key: "getCloneValue",
    value: function getCloneValue(value) {
      return GeoMath.createVector4(value);
    }
  }]);

  return Vector4Type;
}(Type);
/**
 * @summary è¡åå
 *
 * @classdesc
 * <p>ç»é²å: "matrix"</p>
 * <p>å®è£å: {@link mapray.Matrix}</p>
 *
 * @memberof mapray.animation
 * @extends mapray.animation.Type
 * @hideconstructor
 */


var MatrixType =
/*#__PURE__*/
function (_Type7) {
  _inherits(MatrixType, _Type7);

  /**
   */
  function MatrixType() {
    _classCallCheck(this, MatrixType);

    return _possibleConstructorReturn(this, _getPrototypeOf(MatrixType).call(this, "matrix"));
  }
  /**
   * @private
   */


  _createClass(MatrixType, [{
    key: "_postinit",
    value: function _postinit() {}
    /**
     * @override
     */

  }, {
    key: "isConvertible",
    value: function isConvertible(from) {
      return from === this;
    }
    /**
     * @override
     */

  }, {
    key: "convertValue",
    value: function convertValue(from, value) {
      return value;
    }
    /**
     * @override
     */

  }, {
    key: "getDefaultValue",
    value: function getDefaultValue() {
      return GeoMath.setIdentity(GeoMath.createMatrix());
    }
    /**
     * @override
     */

  }, {
    key: "getCloneValue",
    value: function getCloneValue(value) {
      return GeoMath.createMatrix(value);
    }
  }]);

  return MatrixType;
}(Type);
/**
 * @summary äºåå®ç¾©åãç»é²
 *
 * @private
 */


function registerPredefinedTypes() {
  var type_classes = [BooleanType, NumberType, StringType, Vector3Type, Vector2Type, Vector4Type, MatrixType];
  var type_instances = []; // åãç»é²

  for (var _i = 0, _type_classes = type_classes; _i < _type_classes.length; _i++) {
    var type_class = _type_classes[_i];
    var type = new type_class();
    Type.register(type.name, type);
    type_instances.push(type);
  } // ç»é²å¾ã®å¦ç


  for (var _i2 = 0, _type_instances = type_instances; _i2 < _type_instances.length; _i2++) {
    var _type = _type_instances[_i2];

    _type._postinit();
  }
}

registerPredefinedTypes();

/**
 * @summary ã¢ãã¡ã¼ã·ã§ã³é¢æ°
 *
 * @classdesc
 * <p>æå®æå»ã®ã¢ãã¡ã¼ã·ã§ã³é¢æ°å¤ãåå¾ããããã®æ½è±¡ã¯ã©ã¹ã§ããã</p>
 *
 * @abstract
 * @memberof mapray.animation
 */
var Curve =
/*#__PURE__*/
function () {
  /**
   * @protected
   */
  function Curve() {
    _classCallCheck(this, Curve);

    this._value_change_listeners = new Set();
  }
  /**
   * @summary åã¯ãµãã¼ãããããï¼
   *
   * @desc
   * <p>type åãã¢ãã¡ã¼ã·ã§ã³é¢æ°ã®è¿å´å¤ã®åã¨ãã¦ä½¿ç¨ã§ãããã©ãããè¿ãã</p>
   * <p>this ã®çå­ä¸­ããã®ã¡ã½ããã® type ã«å¯¾ããçµæã¯ä¸å®ã§ããã</p>
   * <p>ãã®ã¡ã½ããã true ãè¿ããå ´åãgetValue() ã«ãã
   *    ã¢ãã¡ã¼ã·ã§ã³é¢æ°å¤ã type åã§åå¾ãããã¨ãå¯è½ã§ããã</p>
   *
   * @param {mapray.animation.Type} type  ç¢ºèªããå
   *
   * @return {boolean}  type ããµãã¼ããããã¨ã true, ããä»¥å¤ã¯ false
   *
   * @see {@link mapray.animation.Curve#getValue}
   *
   * @abstract
   */


  _createClass(Curve, [{
    key: "isTypeSupported",
    value: function isTypeSupported(type) {
      this._override_error("isTypeSupported");
    }
    /**
     * @summary æå®æå»ã®å¤ãåå¾
     *
     * @desc
     * <p>æå» time ã®ã¢ãã¡ã¼ã·ã§ã³é¢æ°å¤ã type åã¨ãã¦åå¾ããã</p>
     *
     * <p>äºåæ¡ä»¶: this.isTypeSupported( type ) == true</p>
     *
     * @param {mapray.animation.Time} time  æå»ãã©ã¡ã¼ã¿
     * @param {mapray.animation.Type} type  è¿å´å¤ã®å
     *
     * @return {object}  æå» time ã«å¯¾ãã type åã®å¤
     *
     * @see {@link mapray.animation.Curve#isTypeSupported}
     *
     * @abstract
     */

  }, {
    key: "getValue",
    value: function getValue(time, type) {
      this._override_error("getValue");
    }
    /**
     * @summary ä¸å¤æ§æå ±ãåå¾
     *
     * @desc
     * <p>interval ã§æå®ãããç¯å²ã®ä¸å¤æ§æå ±ãè¿ãã</p>
     *
     * <p>ä¸å¤æ§æå ±ã¯ interval ã«ååãããã¾ãã¯äº¤å·®ããæå»åºéãæã£ã¦ããã</p>
     * <p>ä¸é¨ã interval ã¨äº¤å·®ããæå»åºéã¯ã¯ãªããããªãã</p>
     *
     * <p>äºåæ¡ä»¶: interval.isEmpty() == false</p>
     *
     * @param {mapray.animation.Interval} interval  å¯¾è±¡ã¨ããæå»åºé
     *
     * @return {mapray.animation.Invariance}  ä¸å¤æ§æå ±
     *
     * @abstract
     */

  }, {
    key: "getInvariance",
    value: function getInvariance(interval) {
      this._override_error("getInvariance");
    }
    /**
     * @summary é¢æ°å¤ãå¤åãããã¨ãéç¥
     *
     * @desc
     * <p>æå»åºé interval ã®ç¯å²ã®é¢æ°å¤ãå¤åãããã¨ããã¬ã¼ã ã¯ã¼ã¯ã«éç¥ããã</p>
     * <p>ãã®ã¡ã½ããã¯é¢æ°å¤ãå¤åããã¨ãã«ãµãã¯ã©ã¹ã®å®è£èãå¼ã³åºãã</p>
     *
     * @param {mapray.animation.Interval} interval  é¢æ°å¤ãå¤åããæå»åºé
     *
     * @see {@link mapray.animation.Curve#addValueChangeListener}
     * @see {@link mapray.animation.Curve#removeValueChangeListener}
     *
     * @protected
     */

  }, {
    key: "notifyValueChange",
    value: function notifyValueChange(interval) {
      if (interval.isEmpty()) {
        // ç©ºæå»åºéãªã®ã§å®éã«ã¯å¤åãªã
        // ValueChangeListener ã®äºåæ¡ä»¶ãæºãããªã
        return;
      } // é¢æ°å¤å¤åãªã¹ãã¼ã®å¼ã³åºã


      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._value_change_listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var vcl = _step.value;
          vcl(interval);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * @summary é¢æ°å¤å¤åãªã¹ãã¼ã®ç»é²
     *
     * @param {mapray.animation.Curve.ValueChangeListener} vcl  é¢æ°å¤å¤åãªã¹ãã¼
     *
     * @see {@link mapray.animation.Curve#notifyValueChange}
     * @see {@link mapray.animation.Curve#removeValueChangeListener}
     */

  }, {
    key: "addValueChangeListener",
    value: function addValueChangeListener(vcl) {
      this._value_change_listeners.add(vcl);
    }
    /**
     * @summary é¢æ°å¤å¤åãªã¹ãã¼ã®ç»é²è§£é¤
     *
     * @param {mapray.animation.Curve.ValueChangeListener} vcl  é¢æ°å¤å¤åãªã¹ãã¼
     *
     * @see {@link mapray.animation.Curve#notifyValueChange}
     * @see {@link mapray.animation.Curve#addValueChangeListener}
     */

  }, {
    key: "removeValueChangeListener",
    value: function removeValueChangeListener(vcl) {
      this._value_change_listeners["delete"](vcl);
    }
    /**
     * @summary ã¡ã½ããããªã¼ãã¼ã©ã¤ãããã¦ããªã
     *
     * arguments.callee ã¨ Error#stack ã¯äºææ§ãä½ãã®ã§ãé¢æ°åã®åå¾ã«ä½¿ããªãã£ã
     *
     * @param {string} func_name
     *
     * @private
     */

  }, {
    key: "_override_error",
    value: function _override_error(func_name) {
      throw new Error("Curve#" + func_name + "() method has not been overridden in " + this.constructor.name);
    }
  }]);

  return Curve;
}();

var createProperty = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
};

// https://tc39.github.io/ecma262/#sec-array.from


var arrayFrom = function from(arrayLike
/* , mapfn = undefined, thisArg = undefined */
) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2); // if the target is not iterable or it's an array with the default iterator - use a simple case

  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();

    for (; !(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);

    for (; length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }

  result.length = index;
  return result;
};

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
}); // `Array.from` method
// https://tc39.github.io/ecma262/#sec-array.from

_export({
  target: 'Array',
  stat: true,
  forced: INCORRECT_ITERATION
}, {
  from: arrayFrom
});

/**
 * @summary ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿ã®æ´æ°ç®¡ç
 *
 * @classdesc
 * <p>ã¢ãã¡ã¼ã·ã§ã³é¢æ°ã¨çµåãã¦ããã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿ãæ´æ°ããããã®æ©è½ãæä¾ããã</p>
 *
 * @memberof mapray.animation
 */

var Updater =
/*#__PURE__*/
function () {
  /**
   */
  function Updater() {
    _classCallCheck(this, Updater);

    // ååæ´æ°ããæå» (ä¸åº¦ãæ´æ°ãã¦ããªãã¨ãã¯ null)
    this._prev_time = null; // Curve -> Tracked è¾æ¸

    this._track_binders = new Map(); // ãã©ã¡ã¼ã¿ãã¾ã æ´æ°ããã¦ããªããã¾ãã¯ã¢ãã¡ã¼ã·ã§ã³é¢æ°å¤ã¨
    // çç¾ããå¯è½æ§ã®ãã Binder ã¤ã³ã¹ã¿ã³ã¹

    this._dirty_binders = new Set(); // é¢æ°å¤ãå¤åãã Curve ãç®¡ç

    this._vary_curves = new VaryCurves();
  }
  /**
   * @summary ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿ãæ´æ°
   *
   * @desc
   * <p>æå» time ã§ã®ã¢ãã¡ã¼ã·ã§ã³é¢æ°å¤ãã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿ã«è¨­å®ããã</p>
   *
   * @param {mapray.animation.Time} time  æå»
   */


  _createClass(Updater, [{
    key: "update",
    value: function update(time) {
      this._update_dirty_binders(time);

      if (this._prev_time !== null) {
        var vary_curves = this._vary_curves.getVaryCurves(this._prev_time, time);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = vary_curves[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var curve = _step.value;

            var tracked = this._track_binders.get(curve);

            tracked.updateBinders(time);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      this._flush_dirty_binders(); // ååã®æå»ãæ´æ°


      this._prev_time = time;
    }
    /**
     * @summary Binder ã¤ã³ã¹ã¿ã³ã¹ã®ç»é²
     *
     * @desc
     * <p>äºåæ¡ä»¶: binder ã¯ this ã§ç®¡çããã¦ããªã</p>
     *
     * @param {mapray.animation.Binder} binder
     *
     * @package
     */

  }, {
    key: "_$register",
    value: function _$register(binder) {
      // æåã¯ dirty_binders ã«ç»é²
      this._dirty_binders.add(binder);
    }
    /**
     * @summary Binder ã¤ã³ã¹ã¿ã³ã¹ã®æ¹æ¶
     *
     * @desc
     * <p>äºåæ¡ä»¶: binder ã¯ this ã§ç®¡çããã¦ãã</p>
     *
     * @param {mapray.animation.Binder} binder
     *
     * @package
     */

  }, {
    key: "_$unregister",
    value: function _$unregister(binder) {
      if (this._dirty_binders["delete"](binder)) ; else {
        // binder ã¯ track_binders å´ã«å­å¨ãã
        var tracked = this._track_binders.get(binder._$curve);

        tracked.unregister(binder);
      }
    }
    /**
     * @summary _dirty_binders ã®ãã¹ã¦ã®ãã©ã¡ã¼ã¿ãæ´æ°
     *
     * @param {mapray.animation.Time} time
     *
     * @private
     */

  }, {
    key: "_update_dirty_binders",
    value: function _update_dirty_binders(time) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._dirty_binders[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var binder = _step2.value;

          binder._$update(time);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    /**
     * @summary _dirty_binders ãã _track_binders ã¸ Binder ãç§»å
     *
     * @private
     */

  }, {
    key: "_flush_dirty_binders",
    value: function _flush_dirty_binders() {
      for (var _i = 0, _Array$from = Array.from(this._dirty_binders); _i < _Array$from.length; _i++) {
        var binder = _Array$from[_i];

        // dirty_binders ãã binder ãåé¤
        this._dirty_binders["delete"](binder); // track_binders ã¸ binder ãè¿½å 


        var curve = binder._$curve;

        var tracked = this._track_binders.get(curve);

        if (tracked === undefined) {
          // curve ãä½¿ã£ã¦ãã Binder ã¤ã³ã¹ã¿ã³ã¹ãåãã¦ç»é²ããã
          tracked = new Tracked(this, curve, binder);

          this._track_binders.set(curve, tracked);
        } else {
          // 2ã¤ç®ä»¥éã® Binder ã¤ã³ã¹ã¿ã³ã¹
          tracked.register(binder);
        }
      }
    }
  }]);

  return Updater;
}();
/**
 * @summary è¿½è·¡ããããã¤ã³ã
 *
 * @memberof mapray.animation.Updater
 * @private
 */


var Tracked =
/*#__PURE__*/
function () {
  /**
   * @desc
   * <p>updater._track_binders ã«è¿½å ãããã¨ãã«å¼ã³åºãããã</p>
   * <p>updater._vary_curves ãæ´æ°ããã</p>
   *
   * @param {mapray.animation.Updater} updater      this ãç®¡çãã Updater ã¤ã³ã¹ã¿ã³ã¹
   * @param {mapray.animation.Curve}   curve        å¯¾è±¡ã¨ãã Curve ã¤ã³ã¹ã¿ã³ã¹
   * @param {mapray.animation.Binder}  init_binder  æåã® Binder ã¤ã³ã¹ã¿ã³ã¹
   */
  function Tracked(updater, curve, init_binder) {
    var _this = this;

    _classCallCheck(this, Tracked);

    this._updater = updater;
    this._curve = curve; // curve ã¨çµåãã¦ãã Binder ã¤ã³ã¹ã¿ã³ã¹ã®éå

    this._binders = new Set([init_binder]); // curve ã®ç¾å¨ã®ä¸å¤æ§

    this._invariance = curve.getInvariance(Interval.UNIVERSAL); // ã¢ãã¡ã¼ã·ã§ã³é¢æ°å¤ã®å¤æ´ç®¡ç

    this._listener = function (interval) {
      _this._onValueChange(interval);
    };

    curve.addValueChangeListener(this._listener); // vary_curves ã« curve ãè¿½å 

    updater._vary_curves.addCurve(curve, this._invariance);
  }
  /**
   * @summary Curve ãæã¤ Binder ãç»é²
   *
   * @param {mapray.animation.Binder} binder
   */


  _createClass(Tracked, [{
    key: "register",
    value: function register(binder) {
      // Assert: !this._binders.has( binder )
      this._binders.add(binder);
    }
    /**
     * @summary Curve ãæã¤ Binder ãæ¹æ¶
     *
     * @desc
     * <p>this ã updater._track_binders ããåé¤ããããã¨ãããã</p>
     * <p>curve ã updater._vary_curves ããåé¤ããããã¨ãããã</p>
     *
     * @param {mapray.animation.Binder} binder
     */

  }, {
    key: "unregister",
    value: function unregister(binder) {
      // Assert: this._binders.has( binder )
      this._binders["delete"](binder);

      if (this._binders.size > 0) {
        // ã¾ã  this._curve ã¨é¢é£ãã Binder ã¤ã³ã¹ã¿ã³ã¹ã this ã«å­å¨ãã
        return;
      } // this._curve ã¨é¢é£ããå¯ä¸ã® Binder ã¤ã³ã¹ã¿ã³ã¹ã this ããåé¤ããã
      // vary_curves ãã curve ãåé¤


      this._updater._vary_curves.removeCurve(this._curve, this._invariance); // å¤æ´ãè¿½è·¡ããå¿è¦ã¯ãªããªã£ãã®ã§ãªã¹ãã¼ãåé¤


      this._curve.removeValueChangeListener(this._listener); // this ã this._updater ããåé¤


      this._updater._track_binders["delete"](this._curve);
    }
    /**
     * @summary ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿ãæ´æ°
     *
     * @desc
     * <p>æå» time ã§ã®ã¢ãã¡ã¼ã·ã§ã³é¢æ°å¤ãã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿ã«è¨­å®ããã</p>
     *
     * @param {mapray.animation.Time} time  æå»
     */

  }, {
    key: "updateBinders",
    value: function updateBinders(time) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this._binders[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var binder = _step3.value;

          binder._$update(time);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
    /**
     * @summary ã¢ãã¡ã¼ã·ã§ã³éæ°å¤ãå¤æ´ããã
     *
     * @param {mapray.animation.Interval} chg_ival  å¤æ´ãããæå»åºé
     *
     * @private
     */

  }, {
    key: "_onValueChange",
    value: function _onValueChange(chg_ival) {
      // assert: !chg_ival.isEmpty()
      // assert: this._updater._prev_time != null
      if (chg_ival.includesTime(this._updater._prev_time)) {
        // ç¾å¨è¨­å®ããã¦ãããã©ã¡ã¼ã¿å¤ã¨çç¾ãçãã
        // this._binders ã dirty_binders ã«ç§»å
        this._move_to_dirty_binders();
      } else {
        // ä¸å¤æ§æå ±ãé¨åçã«æ´æ°
        var subinvr = this._curve.getInvariance(chg_ival);

        this._updater._vary_curves.modifyCurve(this._curve, chg_ival, subinvr, this._invariance);

        this._invariance._$modify(subinvr);
      }
    }
    /**
     * @summary this ã dirty_binders ã«ç§»å
     *
     * @desc
     * <p>this ã¯ updater._track_binders, updater._vary_curves ããåé¤ãããã</p>
     *
     * @private
     */

  }, {
    key: "_move_to_dirty_binders",
    value: function _move_to_dirty_binders() {
      for (var _i2 = 0, _Array$from2 = Array.from(this._binders); _i2 < _Array$from2.length; _i2++) {
        var binder = _Array$from2[_i2];
        // this ãã binder ãåé¤
        this.unregister(binder); // dirty_binders ã« binder ãè¿½å 

        this._updater._dirty_binders.add(binder);
      }
    }
  }]);

  return Tracked;
}();
/**
 * @summary æå»éã§ã®é¢æ°å¤ãå¤åãã Curve ãå¾ã
 *
 * @memberof mapray.animation.Updater
 * @private
 */


var VaryCurves =
/*#__PURE__*/
function () {
  /**
   */
  function VaryCurves() {
    _classCallCheck(this, VaryCurves);

    // é£ç¶å¤åã®æå»åºé (ãã¹ã¦ Proper)
    // OrderedMap<Time, ContCurves>
    //   å¤ããåé¨ã«å¥ããåé¨ã§åãã¨ãå¤åãã
    //   ä¸éã '[' ã®ã¨ããå·¦ããä¸éã«å¥ããä¸éããå·¦ã¸åºãã¨ãå¤åãã
    //   ä¸éã ']' ã®ã¨ããå³ããä¸éã«å¥ããä¸éããå³ã¸åºãã¨ãå¤åãã
    this._continuous = createTimeMap(); // åçºå¤åã®æå» []
    // OrderedMap<Time, Set<Curve>>
    //   ç¹ãééãç¹ã«å¥ããç¹ããåºãã¨ãå¤åãã

    this._oneshot = createTimeMap(); // åçºå¤åã®æå» [)
    // OrderedMap<Time, Set<Curve>>
    //   ç¹ãééãå·¦ããç¹ã«å¥ããç¹ããå·¦ã¸åºãã¨ãå¤åãã

    this._oneshot_L = createTimeMap(); // åçºå¤åã®æå» (]
    // OrderedMap<Time, Set<Curve>>
    //   ç¹ãééãå³ããç¹ã«å¥ããç¹ããå³ã¸åºãã¨ãå¤åãã

    this._oneshot_R = createTimeMap();
  }
  /**
   * @summary Curve ãè¿½å 
   *
   * @desc
   * <p>ãã¼ã¿ãã¼ã¹ã«ä¸å¤æ§ã invariance ã§ãã curve ãè¿½å ããã</p>
   *
   * <p>äºåæ¡ä»¶: curve ã¯ filter åã«å­å¨ããªã</p>
   *
   * @param {mapray.animation.Curve}        curve     è¿½å ãã Curve ã¤ã³ã¹ã¿ã³ã¹
   * @param {mapray.animation.Invariance} invariance  curve ã®ä¸å¤æ§æå ±
   * @param {mapray.animation.Interval}    [filter]   è¿½å ããæå»åºé (ååã®ä¸å¤æ§æå ±ã§æ´åæ¸ã¿)
   */


  _createClass(VaryCurves, [{
    key: "addCurve",
    value: function addCurve(curve, invariance) {
      var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Interval.UNIVERSAL;

      var invr_ivals = invariance.getNarrowed(filter)._$getArray();

      if (invr_ivals.length == 0) {
        // å¨æå»åºéãå¤å
        this._addToGeneric(curve, filter);
      } else {
        // ä¸å¤åºéãå­å¨ããå ´å
        var lastIndex = invr_ivals.length - 1; // æå

        {
          var invr_ival = invr_ivals[0];
          var vary_ival = filter.getIntersection(invr_ival.getPrecedings());

          if (!vary_ival.isEmpty()) {
            this._addToGeneric(curve, vary_ival);
          } else if (isSameInterval_L(filter, invr_ival) && !this._hasContiguous_L(invr_ival, curve)) {
            // invr_ival ã¨ filter ã®å·¦ãä¸è´ãã¦ãcurve ãæã£ã invr_ival ã®å·¦é£æ¥ãå­å¨ããªã
            if (invr_ival.l_open) {
              this._addToOneshotGroup(curve, invr_ival, "_oneshot_R");
            } else if (!invr_ival.getPrecedings().isEmpty()) {
              this._addToOneshotGroup(curve, invr_ival, "_oneshot_L");
            }
          }
        } // ä¸­é

        for (var i = 0; i < lastIndex; ++i) {
          var lower = invr_ivals[i].getFollowings();
          var upper = invr_ivals[i + 1].getPrecedings();

          var _vary_ival = lower.getIntersection(upper);

          if (_vary_ival.isEmpty()) {
            //  lower ã¨ upper ã«éããªã
            this._addToOneshotGroup(curve, lower, lower.l_open ? "_oneshot_R" : "_oneshot_L");
          } else {
            // lower ã¨ upper ã«éããã
            this._addToGeneric(curve, _vary_ival);
          }
        } // æå¾


        {
          var _invr_ival = invr_ivals[lastIndex];

          var _vary_ival2 = filter.getIntersection(_invr_ival.getFollowings());

          if (!_vary_ival2.isEmpty()) {
            this._addToGeneric(curve, _vary_ival2);
          } else if (isSameInterval_R(filter, _invr_ival) && !this._hasContiguous_R(_invr_ival, curve)) {
            if (_invr_ival.u_open) {
              this._addToOneshotGroup(curve, _invr_ival, "_oneshot_L");
            } else if (!_invr_ival.getFollowings().isEmpty()) {
              this._addToOneshotGroup(curve, _invr_ival, "_oneshot_R");
            }
          }
        }
      }
    }
    /**
     * @summary interval ã®å·¦ã®é£æ¥ããåºéã¯å­å¨ãããï¼
     *
     * @desc
     * <p>continuous ã®ä¸­ã« interval ã®å·¦ã«é£æ¥ããåºéãããããã¤
     *    curve ãæã£ã¦ãããã®ã¯å­å¨ãããã©ãããè¿ãã</p>
     *
     * @param {mapray.animation.Interval} interval (!= Î¦)
     * @param {mapray.animation.Curve}    curve
     *
     * @return {boolean}
     *
     * @private
     */

  }, {
    key: "_hasContiguous_L",
    value: function _hasContiguous_L(interval, curve) {
      var map = this._continuous; // interval ã®å·¦ã®ã¢ã¤ãã 

      var it1 = map.findLower(interval.lower);
      var it0 = it1 !== null ? it1.findPredecessor() : map.findLast();

      if (it0 !== null) {
        var pred = it0.value; // ContCurves

        var pred_ival = pred.interval;

        if (pred_ival.upper.equals(interval.lower) && (interval.l_open && !pred_ival.u_open || !interval.l_open && pred_ival.u_open)) {
          // é£æ¥ãã¦ãã
          if (pred.curves.has(curve)) {
            // é£æ¥ãã¦ curve ãæã£ã¦ãã
            return true;
          }
        }
      }

      return false;
    }
    /**
     * @summary interval ã®å³ã®é£æ¥ããåºéã¯å­å¨ãããï¼
     *
     * @desc
     * <p>continuous ã®ä¸­ã« interval ã®å³ã«é£æ¥ããåºéãããããã¤
     *    curve ãæã£ã¦ãããã®ã¯å­å¨ãããã©ãããè¿ãã</p>
     *
     * @param {mapray.animation.Interval} interval (!= Î¦)
     * @param {mapray.animation.Curve}    curve
     *
     * @return {boolean}
     *
     * @private
     */

  }, {
    key: "_hasContiguous_R",
    value: function _hasContiguous_R(interval, curve) {
      var map = this._continuous; // interval ã®å³ã®ã¢ã¤ãã 

      var it = map.findLower(interval.upper);

      if (it === null) {
        // interval ã®å³ã«åºéãå­å¨ããªã
        return false;
      }

      var succ = it.value; // ContCurves

      var succ_ival = succ.interval;

      if (!succ_ival.lower.equals(interval.upper)) {
        // å¢çãä¸ä¸è´
        return false;
      }

      if (succ_ival.l_open && interval.u_open || !succ_ival.l_open && !interval.u_open) {
        // éè¤ã¾ãã¯é¢ãã¦ãã
        return false;
      }

      return succ.curves.has(curve);
    }
    /**
     * @summary Curve ãåé¤
     *
     * @desc
     * <p>filter ç¯å²ã® curve ãåé¤ãããfilter ã¯æ´åæ¸ã¿ãæ³å®ãã¦ããã®ã§åºéã®åå²ã¯è¡ããªãã</p>
     *
     * <p>äºåæ¡ä»¶: curve ã¯ invariance ã¨çç¾ããªãç¶æã§ this ã«å­å¨ãã</p>
     * <p>äºåæ¡ä»¶: !filter.isEmpty()</p>
     *
     * <p>todo: åé¤å¾ã«é£æ¥åºéãåãéåã«ãªã£ãã¨ãã®çµ±åå¦ç</p>
     *
     * @param {mapray.animation.Curve}        curve     åé¤ãã Curve ã¤ã³ã¹ã¿ã³ã¹
     * @param {mapray.animation.Invariance} invariance  curve ã®ä¸å¤æ§æå ±
     * @param {mapray.animation.Interval}    [filter]   åé¤ããæå»åºé (invariance ã§æ´åæ¸ã¿)
     */

  }, {
    key: "removeCurve",
    value: function removeCurve(curve, invariance) {
      var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Interval.UNIVERSAL;

      var invr_ivals = invariance.getNarrowed(filter)._$getArray();

      if (invr_ivals.length == 0) {
        // filter ã®å¨æå»åºéãå¤å
        this._removeForGeneric(curve, filter);
      } else {
        // ä¸å¤åºéãå­å¨ããå ´å
        var lastIndex = invr_ivals.length - 1; // æå

        {
          var invr_ival = invr_ivals[0];
          var vary_ival = filter.getIntersection(invr_ival.getPrecedings());

          if (!vary_ival.isEmpty()) {
            this._removeForGeneric(curve, vary_ival);
          } else {
            if (isSameInterval_L(filter, invr_ival)) {
              // oneshot_L/R ã®å¯è½æ§ã«å¯¾å¿
              this._removeForOneshotGroup(curve, filter);
            }
          }
        } // ä¸­é

        for (var i = 0; i < lastIndex; ++i) {
          var lower = invr_ivals[i].getFollowings();
          var upper = invr_ivals[i + 1].getPrecedings();

          var _vary_ival3 = lower.getIntersection(upper);

          if (_vary_ival3.isEmpty()) {
            // ai ã¨ bi ã«éããªã
            this._removeForOneshotGroup(curve, lower);
          } else {
            // ai ã¨ bi ã«éããã
            this._removeForGeneric(curve, _vary_ival3);
          }
        } // æå¾


        {
          var _invr_ival2 = invr_ivals[lastIndex];

          var _vary_ival4 = filter.getIntersection(_invr_ival2.getFollowings());

          if (!_vary_ival4.isEmpty()) {
            this._removeForGeneric(curve, _vary_ival4);
          } else {
            if (isSameInterval_R(filter, _invr_ival2)) {
              // oneshot_L/R ã®å¯è½æ§ã«å¯¾å¿
              var _upper = filter.upper;

              this._removeForOneshotGroup(curve, new Interval(_upper, _upper));
            }
          }
        }
      }
    }
    /**
     * @summary Curve ãå¤æ´
     *
     * @param {mapray.animation.Curve}      curve
     * @param {mapray.animation.Interval}   chg_ival  æ´æ°æå»åºé (!= Î¦)
     * @param {mapray.animation.Invariance} sub_invr  æ´æ°é¨åã® Invariance
     * @param {mapray.animation.Invariance} old_invr  ä»¥åã® Invariance
     */

  }, {
    key: "modifyCurve",
    value: function modifyCurve(curve, chg_ival, sub_invr, old_invr) {
      // old_invr ãåºã«ãã¦ chg_ival ãæ´åæ¡å¼µ
      var aligned = old_invr._$expandIntervalByAlignment(chg_ival); // this ã®ãã¼ã¿ãã¼ã¹ãã aligned åºéã® curve ãåé¤


      this.removeCurve(curve, old_invr, aligned); // aligned åºéã§ sub_invr ãè¿½å 

      this.addCurve(curve, sub_invr, aligned);
    }
    /**
     * @summary é¢æ°å¤ãå¤åãã Curve ã¤ã³ã¹ã¿ã³ã¹éåãåå¾
     *
     * @desc
     * <p>æå»ã prev_time ãã time ã«é£ç¶å¤åããã¨ãã«ãé¢æ°å¤ãå¤åããå¯è½æ§ã®ãã
     *    Curve ã¤ã³ã¹ã¿ã³ã¹ãå¾ãããã®åæå¯è½ãªãã¸ã§ã¯ããè¿ãã</p>
     *
     * @param {mapray.animation.Time} prev_time  å§ç¹æå»
     * @param {mapray.animation.Time} time       çµç¹æå»
     *
     * @return {iterable.<mapray.animation.Curve>}
     */

  }, {
    key: "getVaryCurves",
    value: function getVaryCurves(prev_time, time) {
      if (prev_time.lessThan(time)) {
        // é åç
        return this._collectCurves(prev_time, time);
      } else if (time.lessThan(prev_time)) {
        // éåç
        return this._collectCurves(time, prev_time);
      } else {
        // æå»å¤ããã
        return [];
      }
    }
    /**
     * @summary curve ã continuous ã¾ãã¯ oneshot ã¸è¿½å 
     *
     * @desc
     * <p>curve ã continuous ã¾ãã¯ oneshot ã«ç»é²ããã
     *    ãã ã interval.isEmpty() ã®ã¨ãã¯ä½ãããªãã</p>
     *
     * @param {mapray.animation.Curve}       curve  è¿½å ãã Curve ã¤ã³ã¹ã¿ã³ã¹
     * @param {mapray.animation.Interval} interval  å¤åããæå»åºé
     *
     * @private
     */

  }, {
    key: "_addToGeneric",
    value: function _addToGeneric(curve, interval) {
      if (interval.isProper()) {
        this._addToContinuous(curve, interval);
      } else if (interval.isSingle()) {
        this._addToOneshotGroup(curve, interval, "_oneshot");
      }
    }
    /**
     * @summary curve ã oneshot æã¸è¿½å 
     *
     * @param {mapray.animation.Curve}       curve  è¿½å ãã Curve ã¤ã³ã¹ã¿ã³ã¹
     * @param {mapray.animation.Interval} interval  lower ãæå»ã¨ãã¦ä½¿ããã
     * @param {string}                       pname  oneshot æã®ãã­ããã£å
     *
     * @private
     */

  }, {
    key: "_addToOneshotGroup",
    value: function _addToOneshotGroup(curve, interval, pname) {
      var map = this[pname]; // OrderedMap<Time, Set<Curve>>

      var time = interval.lower;
      var item = map.findEqual(time);

      if (item === null) {
        // æ°è¦ã®æå»
        // ç©ºã® Set<Curve> ã¤ã³ã¹ã¿ã³ã¹ãè¿½å 
        item = map.insert(time, new Set());
      }

      item.value.add(curve);
    }
    /**
     * @summary curve ã continuous ã¸è¿½å 
     *
     * @desc
     * <p>äºåæ¡ä»¶: interval.isProper()</p>
     *
     * @param {mapray.animation.Curve}       curve  è¿½å ãã Curve ã¤ã³ã¹ã¿ã³ã¹
     * @param {mapray.animation.Interval} interval  å¤åããæå»åºé
     *
     * @private
     */

  }, {
    key: "_addToContinuous",
    value: function _addToContinuous(curve, interval) {
      // assert: interval.isProper()
      // A ã¯è¿½å ããé£ç¶åºé
      // T ã¯ç»é²æ¸ã¿ã®é£ç¶åºé (A ã¨äº¤å·®ããåºéã®ä¸­ã§ä¸çªå·¦å´ã®åºé)
      // äº¤å·®ã¿ã¤ã
      //
      // (1) ç»é²æ¸ã¿ã®åºéã« A ã¨äº¤å·®ããåºéã¯ãªã
      //     A: ====
      //
      // (2) T ã¯ A ã®å·¦ããé£ã³åºããå³ããã¯é£ã³åºãã¦ããªã
      //     A:  ====
      //     T: ====
      //
      // (3) T ã¯ A ã®å³ããé£ã³åºããå·¦ããã¯é£ã³åºãã¦ããªã
      //     A: ====
      //     T:  ====
      //
      // (4) T ã¯ A ã®å·¦å³ã©ã¡ããããé£ã³åºãã¦ãã
      //     A:  ===
      //     T: =====
      //
      // (5) T ã¯ A ã®å·¦å³ã©ã¡ããããé£ã³åºãã¦ããªã
      //     A: =====
      //     T:  ===
      // è¨å·ã®æå³
      //
      //   $X ã¯ X.getPrecedings()
      //   X$ ã¯ X.getFollowings()
      var A_ival = interval; // A

      var A_curve = curve;

      for (;;) {
        // assert: A != Î¦
        var target = this._removeFirstCrossInContinuous(A_ival);

        if (target !== null) {
          var T_ival = target.cc.interval; // T: A ã¨äº¤å·®ããåºéã§ä¸çªå·¦å´ã®åºé

          var T_curves = target.cc.curves; // T ã® Curve ã¤ã³ã¿ã³ã¹éå

          var A_x_T = target.cross; // Aâ©T

          var $A_x_T = A_ival.getPrecedings().getIntersection(T_ival); // $Aâ©T

          if ($A_x_T.isEmpty()) {
            // äº¤å·®ã¿ã¤ã (3) ã¾ãã¯ (5)
            var A_x_$T = A_ival.getIntersection(T_ival.getPrecedings()); // Aâ©$T

            if (!A_x_$T.isEmpty()) {
              // (d) Aâ©$T != Î¦ ãªããAâ©$T ã¨ãã¦ãA_curve ãæ°è¦ç»é²
              this._addForContinuous(A_x_$T, A_curve);
            }
          } else {
            // äº¤å·®ã¿ã¤ã (2) ã¾ãã¯ (4)
            // (b) $Aâ©T ã¨ãã¦ãT_curves ãæ°è¦ç»é²
            this._addForContinuous($A_x_T, new Set(T_curves));
          }

          var A$_x_T = A_ival.getFollowings().getIntersection(T_ival); // A$â©T

          if (A$_x_T.isEmpty()) {
            // äº¤å·®ã¿ã¤ã (2) ã¾ãã¯ (5)
            // (a) Aâ©T ã¨ãã¦ãT_curves ã« A_curve ãå ããéåãæ°è¦ç»é²
            this._addForContinuous(A_x_T, T_curves.add(A_curve)); // (z) Aâ©T$ != Î¦ ãªããA ã Aâ©T$ ã¨ãã¦åå¦ç


            var A_x_T$ = A_ival.getIntersection(T_ival.getFollowings()); // Aâ©T$

            if (!A_x_T$.isEmpty()) {
              A_ival = A_x_T$;
              continue;
            }
          } else {
            // äº¤å·®ã¿ã¤ã (3) ã¾ãã¯ (4)
            // (c) A$â©T ã¨ãã¦ãT_curves ãæ°è¦ç»é²
            this._addForContinuous(A$_x_T, new Set(T_curves)); // (a) Aâ©T ã¨ãã¦ãT_curves ã« A_curve ãå ããéåãæ°è¦ç»é²


            this._addForContinuous(A_x_T, T_curves.add(A_curve));
          }
        } else {
          // äº¤å·®ã¿ã¤ã (1)
          // A ã¨ãã¦ãA_curve ãæ°è¦ç»é²
          this._addForContinuous(A_ival, A_curve);
        }

        break;
      }
    }
    /**
     * @summary æåã« interval ã¨äº¤å·®ããè¦ç´ ãåé¤
     *
     * @desc
     * <p></p>
     * <p>this._continuous åã®æå»åºéã®ä¸­ãããæåã« interval ã¨äº¤å·®ããè¦ç´ ãåé¤ãããã
     *    ãã®äº¤å·®åºéã¨è¦ç´ ãæã£ã¦ãã ContCurves ã¤ã³ã¹ã¿ã³ã¹ãè¿ãã</p>
     * <p>ãã ããäº¤å·®ããåºéãå­å¨ããªããã° null ãè¿ãã</p>
     *
     * @param {mapray.animation.Interval} interval  æå»åºé
     *
     * @return {!object}  { cc: ContCurves, cross: Interval }
     *
     * @private
     */

  }, {
    key: "_removeFirstCrossInContinuous",
    value: function _removeFirstCrossInContinuous(interval) {
      var map = this._continuous; // ååºéã¯ Proper åæ

      var t1 = map.findUpper(interval.lower);
      var t0 = t1 !== null ? t1.findPredecessor() : map.findLast();

      if (t0 !== null) {
        var cross = interval.getIntersection(t0.value.interval);

        if (!cross.isEmpty()) {
          var cc = t0.value;
          map.remove(t0);
          return {
            cc: cc,
            cross: cross
          };
        }
      }

      if (t1 !== null) {
        var _cross = interval.getIntersection(t1.value.interval);

        if (!_cross.isEmpty()) {
          var _cc = t1.value;
          map.remove(t1);
          return {
            cc: _cc,
            cross: _cross
          };
        }
      } // äº¤å·®ã¯å­å¨ããªã


      return null;
    }
    /**
     * @summary curves ã continuous ã¾ãã¯ oneshot ã¸è¿½å 
     *
     * @desc
     * <p>interval.isSingle() ã®ã¨ãã¯ curves ã this._oneshot ã® Curve éåã«è¿½å ããã</p>
     * <p>interval.isProper() ã®ã¨ãã¯ ContCurves ã¤ã³ã¹ã¿ã³ã¹ãæ°è¦ã« this._continuous ã¸è¿½å ããã</p>
     *
     * <p>äºåæ¡ä»¶: !interval.isEmpty()</p>
     *
     * @param {mapray.animation.Interval} interval  æå»åºéãã¾ãã¯æå» (lower ãæå»ã¨ãã)
     * @param {mapray.animation.Curve|Set}  curves  è¿½å ãã Curve ã¤ã³ã¹ã¿ã³ã¹ãã¾ãã¯ãã®éå
     *
     * @private
     */

  }, {
    key: "_addForContinuous",
    value: function _addForContinuous(interval, curves) {
      var time = interval.lower; // æå»ã¸å¤æ

      if (interval.isSingle()) {
        // oneshot: curves ã Curve éåã¸è¿½å 
        var it = this._oneshot.findEqual(time);

        if (it === null) {
          // æ°è¦ã®æå»
          // ç©ºã® Set<Curve> ã¤ã³ã¹ã¿ã³ã¹ãè¿½å 
          it = this._oneshot.insert(time, new Set());
        }

        var dst_set = it.value;

        if (curves instanceof Set) {
          // è¤æ° Curve
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = curves[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var curve = _step4.value;
              dst_set.add(curve);
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        } else {
          // åä¸ Curve
          dst_set.add(curves);
        }
      } else {
        // continuous: curves ãæ°è¦è¿½å 
        this._continuous.insert(time, new ContCurves(interval, curves));
      }
    }
    /**
     * @summary curve ã continuous ã¾ãã¯ oneshot ããåé¤
     *
     * @desc
     * <p>curve ã continuous ã¾ãã¯ oneshot ããåé¤ããeã
     *    ãã ã interval.isEmpty() ã®ã¨ãã¯ä½ãããªãã</p>
     *
     * @param {mapray.animation.Curve}       curve  åé¤ãã Curve ã¤ã³ã¹ã¿ã³ã¹
     * @param {mapray.animation.Interval} interval  å¤åããæå»åºé
     *
     * @private
     */

  }, {
    key: "_removeForGeneric",
    value: function _removeForGeneric(curve, interval) {
      if (interval.isProper()) {
        this._removeForContinuous(curve, interval);
      } else if (interval.isSingle()) {
        this._removeForOneshotGroup(curve, interval);
      }
    }
    /**
     * @summary curve ã oneshot æããåé¤
     *
     * @desc
     * <p>ãã oneshot æã®æå» interval.lower ã« curve
     *    ãå­å¨ããã°åé¤ããå­å¨ããªããã°ä½ãããªãã</p>
     *
     * @param {mapray.animation.Curve}       curve  åé¤ãã Curve ã¤ã³ã¹ã¿ã³ã¹
     * @param {mapray.animation.Interval} interval  lower ãæå»ã¨ãã¦ä½¿ããã
     *
     * @private
     */

  }, {
    key: "_removeForOneshotGroup",
    value: function _removeForOneshotGroup(curve, interval) {
      var time = interval.lower;

      for (var _i3 = 0, _arr = ["_oneshot", "_oneshot_L", "_oneshot_R"]; _i3 < _arr.length; _i3++) {
        var pname = _arr[_i3];
        var map = this[pname]; // OrderedMap<Time, Set<Curve>>

        var item = map.findEqual(time);

        if (item !== null) {
          var curves = item.value; // curve ãåé¤ããç©ºã«ãªã£ãã curves ãåé¤

          if (curves.has(curve)) {
            curves["delete"](curve);

            if (curves.size == 0) {
              map.remove(item);
            }
          } // curve ã¯è¤æ°ã«æå±ãããã¨ã¯ãªãã®ã§ã1ã¤åé¤ãããçµäº


          break;
        }
      }
    }
    /**
     * @summary curves ã continuous ã¾ãã¯ oneshot ããåé¤
     *
     * @desc
     * <p>interval åºéã«ãã continuous ã¨ oneshot ã® curve ãåé¤ããã</p>
     * <p>äºåæ¡ä»¶: interval.isProper()</p>
     *
     * @param {mapray.animation.Curve}       curve  åé¤ãã Curve ã¤ã³ã¹ã¿ã³ã¹
     * @param {mapray.animation.Interval} interval  æå»åºé
     *
     * @private
     */

  }, {
    key: "_removeForContinuous",
    value: function _removeForContinuous(curve, interval) {
      // this._continuous
      {
        var map = this._continuous; // ååºéã¯ Proper åæ

        var it1 = map.findUpper(interval.lower);
        var it0 = it1 !== null ? it1.findPredecessor() : map.findLast();
        var end = map.findUpper(interval.upper);

        for (var it = it0 || it1; it !== end;) {
          var curves = it.value.curves;
          curves["delete"](curve);
          it = curves.size == 0 ? map.remove(it) : it.findSuccessor();
        }
      } // this._oneshot

      {
        var _map = this._oneshot;

        var _it = _map.findLower(interval.lower);

        var _end = _map.findUpper(interval.upper);

        for (var _it2 = _it; _it2 !== _end;) {
          var _curves = _it2.value;

          _curves["delete"](curve);

          _it2 = _curves.size == 0 ? _map.remove(_it2) : _it2.findSuccessor();
        }
      }
    }
    /**
     * @summary Curve ã¤ã³ã¹ã¿ã³ã¹ãåé
     *
     * @desc
     * äºåæ¡ä»¶: t1.lessThan( t2 )
     *
     * @param {mapray.animation.Time} t1
     * @param {mapray.animation.Time} t2
     *
     * @return {iterable.<mapray.animation.Curve>}
     *
     * @private
     */

  }, {
    key: "_collectCurves",
    value: function _collectCurves(t1, t2) {
      var curves = new Set(); // Set<Curve>

      this._collectContinuousCurves(t1, t2, curves);

      this._collectOneshotCurves(t1, t2, "_oneshot", true, true, curves);

      this._collectOneshotCurves(t1, t2, "_oneshot_L", false, true, curves);

      this._collectOneshotCurves(t1, t2, "_oneshot_R", true, false, curves);

      return curves;
    }
    /**
     * @summary continuous ãã Curve ã¤ã³ã¹ã¿ã³ã¹ãåé
     *
     * @desc
     * äºåæ¡ä»¶: t1.lessThan( t2 )
     *
     * @param {mapray.animation.Time}        t1
     * @param {mapray.animation.Time}        t2
     * @param {Set.<mapray.animation.Curve>} curves
     *
     * @private
     */

  }, {
    key: "_collectContinuousCurves",
    value: function _collectContinuousCurves(t1, t2, curves) {
      // æå»åºé [t1, â) ã¨äº¤å·®ããæåã®æå»åºé
      var it_A = this._continuous.findLower(t1);

      if (it_A !== null) {
        // it_A != null ã§ããæå»åºé Pred ã¨äº¤å·®ãã¦ããå¯è½æ§ããã
        var it_Pred = it_A.findPredecessor();

        if (it_Pred !== null) {
          if (it_Pred.value.interval.includesTime(t1)) {
            // Pred ã¨ [t1, â) ãäº¤å·®ããã®ã§ it_Pred ã«ç½®ãæãã
            it_A = it_Pred;
          }
        }
      } else {
        // it_A == null ã§ããæå»åºé Last ã¨äº¤å·®ãã¦ããå¯è½æ§ããã
        var it_Last = this._continuous.findLast();

        if (it_Last !== null) {
          if (it_Last.value.interval.includesTime(t1)) {
            // Last ã¨ [t1, â) ãäº¤å·®ããã®ã§ it_Last ã«ç½®ãæãã
            it_A = it_Last;
          }
        }
      } // æå»åºé (â, t2] ã¨äº¤å·®ããæå¾ã®æå»åºéã®ç´å¾


      var it_Z = this._continuous.findLower(t2);

      if (it_Z !== null) {
        var Z_ival = it_Z.value.interval;

        if (Z_ival.lower.equals(t2) && !Z_ival.l_open) {
          // it_Z ã®æå°æå»ãã®ãªã®ãª (â, t2] ã«å¥ãã®ã§ it_Z ã®ç´å¾ãé¸ã¶
          it_Z = it_Z.findSuccessor();
        }
      } // assert: it_A != null || it_Z == null
      // Curve ã¤ã³ã¹ã¿ã³ã¹ãåé


      for (var it = it_A; it !== it_Z; it = it.findSuccessor()) {
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = it.value.curves[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var curve = _step5.value;
            curves.add(curve);
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }
    }
    /**
     * @summary oneshot ãã Curve ã¤ã³ã¹ã¿ã³ã¹ãåé
     *
     * @desc
     * äºåæ¡ä»¶: t1.lessThan( t2 )
     *
     * @param {mapray.animation.Time}        t1
     * @param {mapray.animation.Time}        t2
     * @param {string}                       pname
     * @param {boolean}                      closed1
     * @param {boolean}                      closed2
     * @param {Set.<mapray.animation.Curve>} curves
     *
     * @private
     */

  }, {
    key: "_collectOneshotCurves",
    value: function _collectOneshotCurves(t1, t2, pname, closed1, closed2, curves) {
      var map = this[pname]; // OrderedMap<Time, Set<Curve>>
      // æå»åºé [t1, â) ã«å«ã¾ããæåã®æå»

      var it_A = closed1 ? map.findLower(t1) : map.findUpper(t1); // æå»åºé (â, t2] ã«å«ã¾ããæå¾ã®æå»åºéã®ç´å¾

      var it_Z = closed1 ? map.findUpper(t2) : map.findLower(t2); // assert: it_A != null || it_Z == null
      // Curve ã¤ã³ã¹ã¿ã³ã¹ãåé

      for (var it = it_A; it !== it_Z; it = it.findSuccessor()) {
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = it.value[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var curve = _step6.value;
            curves.add(curve);
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      }
    }
  }]);

  return VaryCurves;
}();
/**
 * summary VaryCurves#continuous ã®å¤
 *
 * @memberof mapray.animation.Updater.VaryCurves
 * @private
 */


var ContCurves =
/**
 * @param {mapray.animation.Interval} interval  ç¶ç¶çã«å¤åããæå»åºé
 * @param {mapray.animation.Curve|Set}  curves  åæã® Curve ã¤ã³ã¹ã¿ã³ã¹ãã¾ãã¯ãã®éå
 */
function ContCurves(interval, curves) {
  _classCallCheck(this, ContCurves);

  // assert: interval.isProper()
  this.interval = interval;
  this.curves = new Set(curves instanceof Set ? curves : [curves]);
};
/**
 * @summary Time ãæé ã«é åºä»ããè¾æ¸ãçæ
 *
 * @private
 */


function createTimeMap() {
  return new OrderedMap(function (a, b) {
    return a.lessThan(b);
  });
}
/**
 * @summary a ã¨ b ã®å·¦å´ã¯åããï¼
 *
 * @param {mapray.animation.Interval} a
 * @param {mapray.animation.Interval} b
 *
 * @private
 */


function isSameInterval_L(a, b) {
  return a.lower.equals(b.lower) && (a.l_open && b.l_open || !a.l_open && !b.l_open);
}
/**
 * @summary a ã¨ b ã®å³å´ã¯åããï¼
 *
 * @param {mapray.animation.Interval} a
 * @param {mapray.animation.Interval} b
 *
 * @private
 */


function isSameInterval_R(a, b) {
  return a.upper.equals(b.upper) && (a.u_open && b.u_open || !a.u_open && !b.u_open);
}

/**
 * @summary åä¸ä¸è´ã¨ã©ã¼
 *
 * @memberof mapray.animation
 * @extends mapray.animation.AnimationError
 *
 * @see {@link mapray.animation.Binder}
 */

var TypeMismatchError =
/*#__PURE__*/
function (_AnimationError) {
  _inherits(TypeMismatchError, _AnimationError);

  /**
   * @param {string} message  ã¨ã©ã¼ã®èª¬æ
   */
  function TypeMismatchError(message) {
    var _this;

    _classCallCheck(this, TypeMismatchError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TypeMismatchError).call(this, message));
    _this.name = "mapray.animation.TypeMismatchError";
    return _this;
  }

  return TypeMismatchError;
}(AnimationError);

/**
 * @summary ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿ã®çµå
 *
 * @classdesc
 * <p>ãã©ã¡ã¼ã¿ãCurve ã¤ã³ã¹ã¿ã³ã¹ãUpdater ã¤ã³ã¹ã³ã¿ã³ã¹ãçµåããã</p>
 *
 * @see {@link mapray.animation.Curve}
 * @see {@link mapray.animation.Updater}
 *
 * @memberof mapray.animation
 */

var Binder =
/*#__PURE__*/
function () {
  /**
   * @desc
   * <p>ãã©ã¡ã¼ã¿ã¨ curve ã¨ updater ãçµåããã</p>
   * <p>ãã©ã¡ã¼ã¿å¤ã¯ setter ãéãã¦è¨­å®ãããã</p>
   * <p>setter ã«ã¯ type åã®å¤ãæ¸¡ãããã</p>
   *
   * @param {mapray.animation.Updater}      updater  ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿ã®æ´æ°ç®¡ç
   * @param {mapray.animation.Curve}          curve  ã¢ãã¡ã¼ã·ã§ã³é¢æ°
   * @param {mapray.animation.Type}            type  ãã©ã¡ã¼ã¿å¤ã®å
   * @param {mapray.animation.Binder.Setter} setter  ãã©ã¡ã¼ã¿è¨­å®é¢æ°
   *
   * @throws {@link mapray.animation.TypeMismatchError}  curve ã type åããµãã¼ããã¦ããªãã¨ã
   */
  function Binder(updater, curve, type, setter) {
    _classCallCheck(this, Binder);

    if (!curve.isTypeSupported(type)) {
      throw new TypeMismatchError("type mismatch error");
    }

    this._updater = updater;
    this._curve = curve;
    this._type = type;
    this._setter = setter; // updater ã« this ãç»é²

    updater._$register(this);
  }
  /**
   * @summary ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿ã®æ´æ°ç®¡ç
   *
   * @type {mapray.animation.Updater}
   * @readonly
   */


  _createClass(Binder, [{
    key: "unbind",

    /**
     * @summary çµåãè§£é¤
     */
    value: function unbind() {
      // updater ãã this ãæ¹æ¶
      this._updater._$unregister(this);
    }
    /**
     * @summary ã¢ãã¡ã¼ã·ã§ã³é¢æ°
     *
     * @type {mapray.animation.Curve}
     * @readonly
     *
     * @package
     */

  }, {
    key: "_$update",

    /**
     * @summary ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿ãæ´æ°
     *
     * @desc
     * <p>æå» time ã§ã®ã¢ãã¡ã¼ã·ã§ã³é¢æ°å¤ãã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿ã«è¨­å®ããã</p>
     *
     * @param {mapray.animation.Time} time  æå»
     *
     * @package
     */
    value: function _$update(time) {
      var value = this._curve.getValue(time, this._type);

      var setter = this._setter;
      setter(value);
    }
  }, {
    key: "updater",
    get: function get() {
      return this._updater;
    }
    /**
     * @summary ã¢ãã¡ã¼ã·ã§ã³é¢æ°
     *
     * @type {mapray.animation.Curve}
     * @readonly
     */

  }, {
    key: "curve",
    get: function get() {
      return this._curve;
    }
    /**
     * @summary ãã©ã¡ã¼ã¿å¤ã®å
     *
     * @type {mapray.animation.Type}
     * @readonly
     *
     * @see {@link mapray.animation.Binder.Setter}
     */

  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
    /**
     * @summary ãã©ã¡ã¼ã¿è¨­å®é¢æ°
     *
     * @type {mapray.animation.Binder.Setter}
     * @readonly
     */

  }, {
    key: "setter",
    get: function get() {
      return this._setter;
    }
  }, {
    key: "_$curve",
    get: function get() {
      return this._curve;
    }
  }]);

  return Binder;
}();

var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

var process = global_1.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (engineUserAgent) {
  match = engineUserAgent.match(/Edge\/(\d+)/);

  if (!match || match[1] >= 74) {
    match = engineUserAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

var engineV8Version = version && +version;

var SPECIES$3 = wellKnownSymbol('species');

var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return engineV8Version >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};

    constructor[SPECIES$3] = function () {
      return {
        foo: 1
      };
    };

    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded'; // We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679

var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED$4 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species

_export({
  target: 'Array',
  proto: true,
  forced: FORCED$4
}, {
  concat: function concat(arg) {
    // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;

    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];

      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }

    A.length = n;
    return A;
  }
});

/**
 * @summary ã¢ãã¡ã¼ã·ã§ã³è¨­å®ã®æ¨æºã¤ã³ã¿ãã§ã¼ã¹
 *
 * @classdesc
 * <p>ãªãã¸ã§ã¯ãã®ã¢ãã¡ã¼ã·ã§ã³å¯è½ãã©ã¡ã¼ã¿ã«ã¢ãã¡ã¼ã·ã§ã³ãè¨­å® (ãã¤ã³ã)
 +    ããããã®æ¨æºçãªã¤ã³ã¿ãã§ã¼ã¹ãæä¾ããã<p>
 *
 * <p>å·ä½çã«ã¯åé¨ã§åãã©ã¡ã¼ã¿ã«é©ãã {@link mapray.animation.Binder Binder}
 *    ã¤ã³ã¹ã¿ã³ã¹ã®çæããã¦ã¼ã¶ã¼ãç°¡åã«ã¢ãã¡ã¼ã·ã§ã³ãè¨­å®ã§ããããã«ããã<p>
 *
 * <p>ä¸è¬çã«ãã¢ãã¡ã¼ã·ã§ã³å¯è½ãã©ã¡ã¼ã¿ãæã¤ãªãã¸ã§ã¯ãã® <em>animation</em>
 *    ãã­ããã£ããããã®ã¤ã³ã¿ãã§ã¼ã¹ãå¾ããã¨ãã§ããã<p>
 *
 * <p>æ³¨æ: ã¢ãã¡ã¼ã·ã§ã³ãè¨­å®ãã¦ãããã©ã¡ã¼ã¿ã¯
 *    {@link mapray.animation.Updater Updater} ã®ã¡ã½ãããéãã¦ã®ã¿æ´æ°ãããã¨ãã§ããã
 *    ããä»¥å¤ã®ææ®µã§ãã©ã¡ã¼ã¿ãæ´æ°ããå ´åã¯ãã©ã¡ã¼ã¿å¤ã«çç¾ãçããå¯è½æ§ãããã<p>
 *
 * @see {@link mapray.animation.Binder}
 * @see {@link mapray.animation.Updater}
 *
 * @memberof mapray.animation
 * @abstract
 */
var BindingBlock =
/*#__PURE__*/
function () {
  /**
   * @protected
   */
  function BindingBlock() {
    _classCallCheck(this, BindingBlock);
  }
  /**
   * @summary ã¢ãã¡ã¼ã·ã§ã³å¯è½ãã©ã¡ã¼ã¿ã®æå ±ãåå¾
   *
   * @desc
   * <p>ã¢ãã¡ã¼ã·ã§ã³ã«å¯¾å¿ãããã©ã¡ã¼ã¿ã®æå ±ãéåã¨ãã¦åå¾ããã</p>
   * <p>è¿ãããéåã¯ 0 åã¾ãã¯ããä»¥ä¸ã®è¦ç´ ãå«ã¿ãè¦ç´ éã®ãã©ã¡ã¼ã¿ ID ã¯éè¤ããªãã</p>
   * <p>this ã®çå­æéä¸­ã(é åºä»¥å¤) å¸¸ã«åãåå®¹ãè¿ãã</p>
   *
   * @return {mapray.animation.BindingBlock.Parameter[]}
   *
   * @abstract
   */


  _createClass(BindingBlock, [{
    key: "enumSupportedParameters",
    value: function enumSupportedParameters() {
      this._override_error("enumSupportedParameters");
    }
    /**
     * @summary ãã©ã¡ã¼ã¿ã¯çµåä¸­ãï¼
     *
     * @desc
     * <p>id ãç¤ºããã©ã¡ã¼ã¿ãçµåããã¦ããã¨ã true, çµåããã¦ããªãã¨ã false ãè¿ãã</p>
     * <p>ãã ã id ãç¤ºããã©ã¡ã¼ã¿ãã¢ãã¡ã¼ã·ã§ã³ã«å¯¾å¿ãã¦ããªãã¨ãã¯ false ãè¿ãã</p>
     *
     * @param {string} id  ãã©ã¡ã¼ã¿ ID
     *
     * @return {boolean}
     *
     * @abstract
     */

  }, {
    key: "isBound",
    value: function isBound(id) {
      this._override_error("isBound");
    }
    /**
     * @summary ãã©ã¡ã¼ã¿ã«çµåããã¦ãã Updater ã¤ã³ã¹ã¿ã³ã¹ãåå¾
     *
     * @desc
     * <p>id ãç¤ºããã©ã¡ã¼ã¿ãçµåããã¦ãã Updater ã¤ã³ã¹ã¿ã³ã¹ãè¿ãã</p>
     * <p>ãã ã this.isBound( id ) == false ã®ã¨ãã¯ null ãè¿ãã</p>
     *
     * @param {string} id  ãã©ã¡ã¼ã¿ ID
     *
     * @return {?mapray.animation.Updater}
     *
     * @abstract
     */

  }, {
    key: "getBoundUpdater",
    value: function getBoundUpdater(id) {
      this._override_error("getBoundUpdater");
    }
    /**
     * @summary ãã©ã¡ã¼ã¿ã«çµåããã¦ãã Curve ã¤ã³ã¹ã¿ã³ã¹ãåå¾
     *
     * @desc
     * <p>id ãç¤ºããã©ã¡ã¼ã¿ãçµåããã¦ãã Curve ã¤ã³ã¹ã¿ã³ã¹ãè¿ãã</p>
     * <p>ãã ã this.isBound( id ) == false ã®ã¨ãã¯ null ãè¿ãã</p>
     *
     * @param {string} id  ãã©ã¡ã¼ã¿ ID
     *
     * @return {?mapray.animation.Curve}
     *
     * @abstract
     */

  }, {
    key: "getBoundCurve",
    value: function getBoundCurve(id) {
      this._override_error("getBoundCurve");
    }
    /**
     * @summary ãã©ã¡ã¼ã¿ã«ã¢ãã¡ã¼ã·ã§ã³ãçµå
     *
     * @desc
     * <p>id ãç¤ºããã©ã¡ã¼ã¿ã¨ updater ã¨ curve ãçµã³ã¤ããããã ãããã§ã« id
     *    ãç¤ºããã©ã¡ã¼ã¿ã«çµåãããã°ãåã«ãã®çµåãè§£é¤ãã¦ããè¡ãã</p>
     *
     * <p>ãã©ã¡ã¼ã¿ãçµåããã¦ããéãupdater ã«ãããã®ãã©ã¡ã¼ã¿ãæ´æ°ãããã¨ãã§ããã</p>
     *
     * @param {string}                        id  ãã©ã¡ã¼ã¿ ID
     * @param {mapray.animation.Updater} updater  ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿æ´æ°ç®¡ç
     * @param {mapray.animation.Curve}     curve  ã¢ãã¡ã¼ã·ã§ã³é¢æ°
     *
     * @throws {@link mapray.animation.AnimationError}
     *         id ãç¤ºããã©ã¡ã¼ã¿ã¯ã¢ãã¡ã¼ã·ã§ã³ã«å¯¾å¿ãã¦ããªã
     *
     * @throws {@link mapray.animation.TypeMismatchError}
     *         id ãç¤ºããã©ã¡ã¼ã¿ã®åã¨ curve ã®åã«äºææ§ããªãã¨ã
     *
     * @see {@link mapray.animation.Binder}
     *
     * @abstract
     */

  }, {
    key: "bind",
    value: function bind(id, updater, curve) {
      this._override_error("bind");
    }
    /**
     * @summary ãã©ã¡ã¼ã¿ã®çµåãè§£é¤
     *
     * @desc
     * <p>id ãç¤ºããã©ã¡ã¼ã¿ã®çµåãè§£é¤ããã</p>
     * <p>ãã ã this.isBound( id ) == false ã®ã¨ãã¯ä½ãããªãã</p>
     *
     * @param {string} id  ãã©ã¡ã¼ã¿ ID
     *
     * @abstract
     */

  }, {
    key: "unbind",
    value: function unbind(id) {
      this._override_error("unbind");
    }
    /**
     * @summary ãã¹ã¦ã®ãã©ã¡ã¼ã¿ã®çµåãè§£é¤
     *
     * @desc
     * <p>ç¾å¨çµåããã¦ãããã¹ã¦ã®ãã©ã¡ã¼ã¿ã®çµåãè§£é¤ããã</p>
     *
     * @abstract
     */

  }, {
    key: "unbindAll",
    value: function unbindAll() {
      this._override_error("unbindAll");
    }
    /**
     * @summary ãã¹ã¦ã®ãã©ã¡ã¼ã¿ã®çµåãè§£é¤ (å­å­«å«ã)
     *
     * @desc
     * <p>ç¾å¨çµåããã¦ãããã¹ã¦ã®ãã©ã¡ã¼ã¿ã®çµåãè§£é¤ããã</p>
     * <p>ãããã©ã¡ã¼ã¿ãæã¤ãªãã¸ã§ã¯ãã®å­ãªãã¸ã§ã¯ãã BindingBlock
     *    ã¤ã³ã¿ãã§ã¼ã¹ãæã£ã¦ããã°ãå­å­«ãå«ãã¦çµåãè§£é¤ããã</p>
     *
     * @abstract
     */

  }, {
    key: "unbindAllRecursively",
    value: function unbindAllRecursively() {
      this._override_error("unbindAllRecursively");
    }
    /**
     * @summary ã¡ã½ããããªã¼ãã¼ã©ã¤ãããã¦ããªã
     *
     * arguments.callee ã¨ Error#stack ã¯äºææ§ãä½ãã®ã§ãé¢æ°åã®åå¾ã«ä½¿ããªãã£ã
     *
     * @param {string} func_name
     *
     * @private
     */

  }, {
    key: "_override_error",
    value: function _override_error(func_name) {
      throw new Error("BindingBlock#" + func_name + "() method has not been overridden in " + this.constructor.name);
    }
  }]);

  return BindingBlock;
}();
/**
 * @summary ã¢ãã¡ã¼ã·ã§ã³å¯è½ãã©ã¡ã¼ã¿ã®æå ±
 *
 * @see {@link mapray.animation.BindingBlock#enumSupportedParameters}
 * @memberof mapray.animation.BindingBlock
 */


var Parameter =
/*#__PURE__*/
function () {
  /**
   * @param {string}                     id  ãã©ã¡ã¼ã¿ ID
   * @param {mapray.animation.Type[]} types  ãµãã¼ãããåã®ãªã¹ã
   */
  function Parameter(id, types) {
    _classCallCheck(this, Parameter);

    this._id = id;
    this._types = types.concat(); // è¤è£½
  }
  /**
   * @summary ãã©ã¡ã¼ã¿ ID
   *
   * @type {string}
   *
   * @readonly
   */


  _createClass(Parameter, [{
    key: "id",
    get: function get() {
      return this._id;
    }
    /**
     * @summary ãµãã¼ãããåã®ãªã¹ã
     *
     * @desc
     * <p>ãã©ã¡ã¼ã¿ã«çµåå¯è½ãªã¢ãã¡ã¼ã·ã§ã³é¢æ°ã®åã®éåã§ããã</p>
     * <p>éåã¯ 1 ã¾ãã¯ããä»¥ä¸ã®åãå«ãã</p>
     *
     * @type {mapray.animation.Type[]}
     *
     * @see {@link mapray.animation.Curve#isTypeSupported}
     *
     * @readonly
     */

  }, {
    key: "types",
    get: function get() {
      return this._types;
    }
  }]);

  return Parameter;
}();

BindingBlock.Parameter = Parameter;

/**
 * @summary ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿è¨­å®ã®ãã«ãã¼ã¯ã©ã¹
 *
 * @memberof mapray.animation
 * @extends mapray.animation.BindingBlock
 */

var EasyBindingBlock =
/*#__PURE__*/
function (_BindingBlock) {
  _inherits(EasyBindingBlock, _BindingBlock);

  /**
   */
  function EasyBindingBlock() {
    var _this;

    _classCallCheck(this, EasyBindingBlock);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EasyBindingBlock).call(this)); // ã¢ãã¡ã¼ã·ã§ã³å¯è½ãªãã©ã¡ã¼ã¿

    _this._entries = new Map(); // Map<id, Entry>
    // çµåä¸­ã®ãã©ã¡ã¼ã¿

    _this._bounds = new Map(); // Map<id, Binder>
    // ãã¹ã¦ã®å­å­«ã®çµåãè§£é¤ããããã®é¢æ°ã®ãªã¹ã

    _this._descendant_unbinders = []; // DescendantUnbinder[]
    // ä¸å¤æ¡ä»¶: this._bounds.has( id ) â this._entries.has( id )
    //           this._bounds.has( id ) â (this._bounds.get( id ) !== undefined) â this.isBound()

    return _this;
  }
  /**
   * @summary ã¢ãã¡ã¼ã·ã§ã³å¯è½ãã©ã¡ã¼ã¿ãè¿½å 
   *
   * @desc
   * <p>è­å¥å­ã id ã¨ãã¦ã¢ãã¡ã¼ã·ã§ã³å¯è½ãªãã©ã¡ã¼ã¿ãç»é²ããã</p>
   *
   * <p>types ã«ã¯ãã®ãã©ã¡ã¼ã¿ã«çµåå¯è½ãªã¢ãã¡ã¼ã·ã§ã³é¢æ°ã® 1 ã¤ã¾ãã¯ããä»¥ä¸ã®åãéåã§ä¸ããã</p>
   *
   * <p>types ã« 2 ã¤ä»¥ä¸ã®åãå­å¨ããã¨ãã¯ type_solver ã«åãæ±ºå®ããé¢æ°ãæå®ããªããã°ãªããªãã
   *    1 ã¤ããåãå­å¨ããªãã¨ã type_solver ã¯ç¡è¦ãããã®ã§ null ãä¸ãã¦ãããã</p>
   *
   * <p>setter ã¯å®éã®ãã©ã¡ã¼ã¿ã«å¤ãè¨­å®ããé¢æ°ã§ããã</p>
   *
   * <p>id ã«å¯¾å¿ãããã©ã¡ã¼ã¿ããã§ã«çµåããã¦ããå ´åã¯ãã®çµåãè§£é¤ãããã</p>
   *
   * @param {string}                             id  ãã©ã¡ã¼ã¿ ID
   * @param {mapray.animation.Type[]}         types  ãµãã¼ãããåã®ãªã¹ã
   * @param {?mapray.animation.EasyBindingBlock.TypeSolver} type_solver  åæ±ºå®é¢æ°
   * @param {mapray.animation.Binder.Setter} setter  ãã©ã¡ã¼ã¿è¨­å®é¢æ°
   *
   * @see {@link mapray.animation.BindingBlock.Parameter}
   */


  _createClass(EasyBindingBlock, [{
    key: "addEntry",
    value: function addEntry(id, types, type_solver, setter) {
      // ä¸æ¸ãã§è¿½å 
      this._entries.set(id, new Entry(types, type_solver, setter)); // ãã§ã«çµåããã¦ããå ´åã¯è§£é¤ãã


      var binder = this._bounds.get(id);

      if (binder !== undefined) {
        binder.unbind();

        this._bounds["delete"](id);
      }
    }
    /**
     * @summary å­å­«ã®çµåãè§£é¤ããããã®é¢æ°ãè¿½å 
     *
     * @param {mapray.animation.EasyBindingBlock.DescendantUnbinder} unbinder  å­å­«ã®çµåãè§£é¤ããããã®é¢æ°
     *
     * @see {@link mapray.animation.BindingBlock#unbindAllRecursively}
     */

  }, {
    key: "addDescendantUnbinder",
    value: function addDescendantUnbinder(unbinder) {
      this._descendant_unbinders.push(unbinder);
    }
    /**
     * @override
     */

  }, {
    key: "enumSupportedParameters",
    value: function enumSupportedParameters() {
      var parameters = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              id = _step$value[0],
              enrty = _step$value[1];

          parameters.push(new BindingBlock.Parameter(id, enrty.types));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return parameters;
    }
    /**
     * @override
     */

  }, {
    key: "isBound",
    value: function isBound(id) {
      // ä¸å¤æ¡ä»¶ã«ãã !this._entries.has( id ) â !this._bounds.has( id ) ã
      // æãç«ã¤ã®ã§ãid ãã¢ãã¡ã¼ã·ã§ã³ã«å¯¾å¿ãã¦ããªãã¨ãã¯ä»æ§éã false ãè¿ã
      return this._bounds.has(id);
    }
    /**
     * @override
     */

  }, {
    key: "getBoundUpdater",
    value: function getBoundUpdater(id) {
      var binder = this._bounds.get(id);

      return binder !== undefined ? binder.updater : null;
    }
    /**
     * @override
     */

  }, {
    key: "getBoundCurve",
    value: function getBoundCurve(id) {
      var binder = this._bounds.get(id);

      return binder !== undefined ? binder.curve : null;
    }
    /**
     * @override
     */

  }, {
    key: "bind",
    value: function bind(id, updater, curve) {
      var entry = this._entries.get(id);

      if (entry === undefined) {
        // id ã®ãã©ã¡ã¼ã¿ã¯ã¢ãã¡ã¼ã·ã§ã³ã«éå¯¾å¿
        throw new AnimationError("unsupported parameter");
      } // ãã§ã«çµåããã¦ããå ´åã¯åã«è§£é¤


      this.unbind(id); // åãæ±ºå®

      var types = entry.types;
      var type = types.length == 1 ? types[0] : entry.type_solver(curve);

      if (type == null || !curve.isTypeSupported(type)) {
        // curve ã¯ id ã®ãã©ã¡ã¼ã¿ãè¦æ±ããåã«å¯¾å¿ã§ããªã
        throw new TypeMismatchError("type mismatch error");
      } // ãã©ã¡ã¼ã¿ãçµå


      this._bounds.set(id, new Binder(updater, curve, type, entry.setter)); // assert: this.isBound( id )
      // assert: this.getBoundUpdater( id ) === updater
      // assert: this.getBoundCurve( id ) === curve

    }
    /**
     * @override
     */

  }, {
    key: "unbind",
    value: function unbind(id) {
      var binder = this._bounds.get(id);

      if (binder !== undefined) {
        binder.unbind();

        this._bounds["delete"](id);
      } // assert: !this.isBound( id )

    }
    /**
     * @override
     */

  }, {
    key: "unbindAll",
    value: function unbindAll() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._bounds[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = _slicedToArray(_step2.value, 2),

          /*id*/
          binder = _step2$value[1];

          binder.unbind();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this._bounds.clear(); // assert: ä»»æã® id ã«å¯¾ãã¦ !this.isBound( id )

    }
    /**
     * @override
     */

  }, {
    key: "unbindAllRecursively",
    value: function unbindAllRecursively() {
      // å­å­«
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this._descendant_unbinders[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var unbinder = _step3.value;
          unbinder();
        } // èªèº«

      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.unbindAll();
    }
  }]);

  return EasyBindingBlock;
}(BindingBlock);
/**
 * @summary ãã©ã¡ã¼ã¿æå ±
 *
 * @memberof mapray.animation.EasyBindingBlock
 * @private
 */


var Entry =
/**
 * @param {mapray.animation.Type[]}         types  ãµãã¼ãããåã®ãªã¹ã
 * @param {?mapray.animation.EasyBindingBlock.TypeSolver} type_solver  åæ±ºå®é¢æ°
 * @param {mapray.animation.Binder.Setter} setter  ãã©ã¡ã¼ã¿è¨­å®é¢æ°
 */
function Entry(types, type_solver, setter) {
  _classCallCheck(this, Entry);

  if (types.length < 1 || types.length >= 2 && !type_solver) {
    // åã¯ 1 ã¤ä»¥ä¸ã§ã2 ã¤ä»¥ä¸ã®ã¨ãã¯ TypeSolver ãå¿è¦
    // ããã¯äºåæ¡ä»¶ã§ããããæ°ä»ãç¨ã«æãã
    throw new AnimationError("bad parameter entry");
  }

  this.types = types.concat(); // è¤è£½

  this.type_solver = type_solver;
  this.setter = setter;
};

/**
 * @summary å®æ°é¢æ°
 *
 * @classdesc
 * <p>ãã¹ã¦ã®æå»ã§åãå¤ãè¿ãä»»æåã®é¢æ°ã§ããã</p>
 * <p>é¢æ°å¤ã®åã¯æ§ç¯å­ã®ãã©ã¡ã¼ã¿ã«ããæå®ããã</p>
 *
 * @memberof mapray.animation
 * @extends mapray.animation.Curve
 */

var ConstantCurve =
/*#__PURE__*/
function (_Curve) {
  _inherits(ConstantCurve, _Curve);

  /**
   * @desc
   * <p>type åã® value ãå®æ°å¤ã¨ããå®æ°é¢æ°ãçæããã</p>
   * <p>type ã¯ä»»æã®åãæå®ãããã¨ãã§ããã</p>
   * <p>value ãçç¥ããã¨ãã¯ type åã®æ¢å®å¤ãè¿ãå®æ°é¢æ°ã¨ãªãã</p>
   *
   * @param {mapray.animation.Type} type    é¢æ°å¤ã®å
   * @param {object}               [value]  åæå®æ°å¤ (type å)
   */
  function ConstantCurve(type, value) {
    var _this;

    _classCallCheck(this, ConstantCurve);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConstantCurve).call(this));
    _this._constant_type = type;
    _this._constant_value = type.getDefaultValue(); // åæå¤ãæå®ããã¦ããã¨ãã¯è¨­å®

    if (value !== undefined) {
      _this.setConstantValue(value);
    }

    return _this;
  }
  /**
   * @summary å®æ°å¤ãè¨­å®
   *
   * @param {object} value  å®æ°å¤ (é¢æ°å¤ã®å)
   */


  _createClass(ConstantCurve, [{
    key: "setConstantValue",
    value: function setConstantValue(value) {
      if (value == this._constant_value) {
        // åãå¤ã§å¤åãªã
        // == æ¼ç®å­ã§æ¯è¼ã§ããªãåã¯å¸¸ã«éãå¤ã¨å¤æ­ããããã¨ããã
        return;
      } // å®æ°å¤ãå¤æ´


      this._constant_value = this._constant_type.getCloneValue(value); // å¨æå»ã®å¤ãå¤å

      this.notifyValueChange(Interval.UNIVERSAL);
    }
    /**
     * @override
     */

  }, {
    key: "isTypeSupported",
    value: function isTypeSupported(type) {
      var from_type = this._constant_type;
      return type.isConvertible(from_type);
    }
    /**
     * @override
     */

  }, {
    key: "getValue",
    value: function getValue(time, type) {
      var from_type = this._constant_type;
      var from_value = from_type.getCloneValue(this._constant_value);
      return type.convertValue(from_type, from_value);
    }
    /**
     * @override
     */

  }, {
    key: "getInvariance",
    value: function getInvariance(interval) {
      // å¨æéã§ä¸å®
      // (UNIVERSAL ã¨éç©ºåºéã¯å¿ãäº¤å·®ããã®ã§ interval ã®åç§ã¯ä¸è¦)
      var invariance = new Invariance();
      return invariance.write(Interval.UNIVERSAL);
    }
  }]);

  return ConstantCurve;
}(Curve);

/**
 * @summary ã¢ãã¡ã¼ã·ã§ã³å®è£èç¨ã®ã¦ã¼ãã£ãªãã£
 *
 * @hideconstructor
 * @memberof mapray.animation
 *
 * @private
 */

var AnimUtil =
/*#__PURE__*/
function () {
  function AnimUtil() {
    _classCallCheck(this, AnimUtil);
  }

  _createClass(AnimUtil, null, [{
    key: "getDimension",

    /**
     * @summary type ã®æ¬¡åãåå¾
     *
     * @desc
     * <p>type ã number ã®ã¨ã 1, vector2, vector3, vector4
     *    ã®ã¨ãã¯ãã¯ãã«ã®æ¬¡æ°ãè¿ããããä»¥å¤ã®åã®ã¨ãã¯ 0 ãè¿ãã<p>
     *
     * @param {mapray.animation.Type} type
     *
     * @return {number}  type ã®æ¬¡åãtype ãéå¯¾å¿ã®ã¨ãã¯ 0
     */
    value: function getDimension(type) {
      if (Type.find("number") === type) {
        // ã¹ã«ã©ã¼ã¯ 1
        return 1;
      } else if (Type.find("vector2") === type) {
        return 2;
      } else if (Type.find("vector3") === type) {
        return 3;
      } else if (Type.find("vector4") === type) {
        return 4;
      } else {
        // éå¯¾å¿ã®å
        return 0;
      }
    }
    /**
     * @summary ã­ã¼ãã¬ã¼ã ã®ã¤ã³ããã¯ã¹ãæ¤ç´¢
     *
     * @desc
     * <p>key_times ã® [lower, upper) ã®ç¯å²ã« time ããå¾ã®æå»ãå­å¨ããã°ããã®ä¸­ã§æå°ã®ã¤ã³ããã¯ã¹ãè¿ãã
     *    ãã®ãããªæå»ãå­å¨ããªããã° upper ãè¿ãã</p>
     *
     * <p>è¿ãããå¤ã i, key_times ã k ã¨ããã¨ time ã®ä½ç½®ã¯æ¬¡ã®ããã«è§£éã§ããã</p>
     * <pre>
     *   i == lower ã®ã¨ã: time < k[i]
     *   i == upper ã®ã¨ã: k[i-1] <= time
     *   ããä»¥å¤ã®ã¨ã: k[i-1] <= time < k[i]
     * </pre>
     *
     * <p>äºåæ¡ä»¶: upper - lower >= 1</p>
     *
     * <p>è¨ç®é: upper - lower ã n ã¨ããã¨ããO(log n)</p>
     *
     * @param {mapray.animation.Time}   time       æ¤ç´¢ã­ã¼
     * @param {mapray.animation.Time[]} key_times  æ¤ç´¢å¯¾è±¡éå
     * @param {number}                  lower      ä¸éã¤ã³ããã¯ã¹
     * @param {number}                  upper      ä¸éã¤ã³ããã¯ã¹
     *
     * @return {number}  æ¤ç´¢ãããã¤ã³ããã¯ã¹
     */

  }, {
    key: "findKeyFrameIndex",
    value: function findKeyFrameIndex(time, key_times, lower, upper) {
      var l_idx = lower;
      var u_idx = upper;

      for (;;) {
        if (u_idx - l_idx >= 2) {
          var m_idx = Math.floor((l_idx + u_idx) / 2); // ä¸­éã¤ã³ããã¯ã¹

          var m_time = key_times[m_idx];

          if (m_time.lessThan(time)) {
            // m_time < time ãªã®ã§ [m_idx, u_idx) ã«å­å¨ãããããããªã
            l_idx = m_idx;
          } else if (time.lessThan(m_time)) {
            // m_time > time ãªã®ã§ [l_idx, m_idx) ãç¢ºèª
            u_idx = m_idx;
          } else {
            // m_time == time ãªã®ã§ m_idx ã®æ¬¡ãçµæã«ãªã
            return m_idx + 1;
          }
        } else {
          // u_idx - l_idx == 1
          var l_time = key_times[l_idx];
          return time.lessThan(l_time) ? l_idx : u_idx;
        }
      }

      return 0; // è­¦ååé¿
    }
    /**
     * @summary æåã«ãµãã¼ãããåãæ¤ç´¢
     *
     * @desc
     * <p>types ã®ä¸­ã§ curve ããµãã¼ãããæåã®åãè¿ãã</p>
     * <p>types ã« curve ããµãã¼ãããåãå­å¨ããªããã° null ãè¿ãã</p>
     *
     * @param {mapray.animation.Curve}           curve
     * @param {iterable.<mapray.animation.Type>} types
     *
     * @return {?mapray.animation.Type}
     */

  }, {
    key: "findFirstTypeSupported",
    value: function findFirstTypeSupported(curve, types) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = types[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var type = _step.value;

          if (curve.isTypeSupported(type)) {
            return type;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }
  }]);

  return AnimUtil;
}();

/**
 * @summary ã­ã¼ãã¬ã¼ã ã«ããç·å½¢é¢æ°
 *
 * @classdesc
 * <p>ã­ã¼ãã¬ã¼ã éãæ°å¤ã¾ãã¯ãã¯ãã«ãç·å½¢ã«è£éããé¢æ°ã§ããã</p>
 * <p>é¢æ°å¤ã®åã¯æ§ç¯å­ã®ãã©ã¡ã¼ã¿ã«ãã number, vector2, vector3 ã¾ãã¯ vector4 ãæå®ããã</p>
 *
 * @memberof mapray.animation
 * @extends mapray.animation.Curve
 */

var KFLinearCurve =
/*#__PURE__*/
function (_Curve) {
  _inherits(KFLinearCurve, _Curve);

  /**
   * <p>type åã®é¢æ°ã keyframes ã«ããçæããã</p>
   * <p>type ã¯ number, vector2, vector3 ã¾ãã¯ vector4 ãæå®ãããã¨ãã§ããã</p>
   * <p>keyframes ãçç¥ããã¨ãã¯ type åã®æ¢å®å¤ãè¿ãå®æ°é¢æ°ã¨åç­ã«ãªããkeyframes ã®å½¢å¼ã«é¢ãã¦ã¯
   *    {@link mapray.animation.KFLinearCurve#setKeyFrames setKeyFrames()} ãåç§ã®ãã¨ã</p>
   *
   * @param {mapray.animation.Type} type  é¢æ°å¤ã®å
   * @param {object[]}       [keyframes]  åæã­ã¼ãã¬ã¼ã 
   */
  function KFLinearCurve(type, keyframes) {
    var _this;

    _classCallCheck(this, KFLinearCurve);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(KFLinearCurve).call(this));
    var dimension = AnimUtil.getDimension(type);

    if (dimension == 0) {
      throw AnimationError("unsupported type");
    }

    _this._value_type = type; // number | vector2 | vector3 | vector4

    _this._dimension = dimension; // 1ã4

    _this._num_keyframes = undefined; // >= 2

    _this._key_times = undefined; // Time[]

    _this._key_values = undefined; // Float64Array

    if (keyframes !== undefined) {
      // åæã®ã­ã¼ãã¬ã¼ã ãè¨­å®
      _this.setKeyFrames(keyframes);
    } else {
      // æ¢å®ã®ã­ã¼ãã¬ã¼ã ãè¨­å®
      var t0 = Time.fromNumber(0);
      var t1 = Time.fromNumber(1);
      var dv = type.getDefaultValue();

      _this.setKeyFrames([t0, dv, t1, dv]);
    }

    return _this;
  }
  /**
   * @summary ã­ã¼ãã¬ã¼ã è¨­å®
   *
   * @desc
   * <p>keyframes ã«ããããã¹ã¦ã®ã­ã¼ãã¬ã¼ã ãæå®ããã</p>
   *
   * <p>
   * æ¡ä»¶1: keyframes.length >= 4 (ã­ã¼ãã¬ã¼ã æ° >= 2)<br>
   * æ¡ä»¶2: ãã¹ã¦ã® i, j ã«ããã¦ãi < j â æå»i < æå»j<br>
   * æ¡ä»¶3: ãã¹ã¦ã® i ã«ããã¦ãå¤i ã¯æ§ç¯å­ã® type å¼æ°ã§æå®ããåã®ã¤ã³ã¹ã¿ã³ã¹
   * </p>
   *
   * @param {object[]} keyframes  [æå»0, å¤0, æå»1, å¤1, ...]
   */


  _createClass(KFLinearCurve, [{
    key: "setKeyFrames",
    value: function setKeyFrames(keyframes) {
      var dimension = this._dimension;
      this._num_keyframes = keyframes.length / 2;
      this._key_times = new Array(this._num_keyframes);
      this._key_values = new Float64Array(this._num_keyframes * dimension); // ã­ã¼ãã¬ã¼ã ãè¨­å®

      for (var ti = 0, vi = 0; ti < this._num_keyframes; ++ti, vi += dimension) {
        var time = keyframes[2 * ti];
        var value = keyframes[2 * ti + 1]; // æå»ãéåã«è¨­å®

        this._key_times[ti] = time; // å¤ãéåã«è¨­å®

        if (dimension == 1) {
          // ã¹ã«ã©ã¼
          this._key_values[vi] = value;
        } else {
          // ãã¯ãã«
          for (var j = 0; j < dimension; ++j) {
            this._key_values[vi + j] = value[j];
          }
        }
      } // å¨æå»ã®å¤ãå¤å


      this.notifyValueChange(Interval.UNIVERSAL);
    }
    /**
     * @override
     */

  }, {
    key: "isTypeSupported",
    value: function isTypeSupported(type) {
      var from_type = this._value_type;
      return type.isConvertible(from_type);
    }
    /**
     * @override
     */

  }, {
    key: "getValue",
    value: function getValue(time, type) {
      var from_type = this._value_type;

      var from_value = this._getInterpolatedValue(time);

      return type.convertValue(from_type, from_value);
    }
    /**
     * @override
     */

  }, {
    key: "getInvariance",
    value: function getInvariance(interval) {
      var first_time = this._key_times[0];
      var last_time = this._key_times[this._num_keyframes - 1];
      var ival_inner = new Interval(first_time, last_time, true, true); // å¨ä½ã®ä¸å¤æ§æå ± (2åºéç¨åº¦ãªã®ã§æ¯åçæ)

      var invr_full = new Invariance();
      invr_full.write(ival_inner.getPrecedings()); // æåã®ã­ã¼ã®æå»ã¨ãã®åã®åºé

      invr_full.write(ival_inner.getFollowings()); // æå¾ã®ã­ã¼ã®æå»ã¨ãã®å¾ã®åºé
      // interval ç¯å²ã«çµã£ã¦è¿ã

      return invr_full.getNarrowed(interval);
    }
    /**
     * @summary time ã§ã®è£éå¤ãåå¾
     *
     * @param {mapray.animation.Time} time
     *
     * @return {object}  è£éå¤ (this._value_type ã«é©å¿ããå)
     *
     * @private
     */

  }, {
    key: "_getInterpolatedValue",
    value: function _getInterpolatedValue(time) {
      // this._key_times ã« time ããå¾ã®æå»ãå­å¨ããã°ããã®ä¸­ã§æå°ã®ã¤ã³ããã¯ã¹
      // ãã®ãããªæå»ãå­å¨ããªããã° this._num_keyframes
      var index = AnimUtil.findKeyFrameIndex(time, this._key_times, 0, this._num_keyframes);

      if (index == 0) {
        // time ãæåã®ã­ã¼æå»ã¨åããããã®åã®ã¨ãã¯æåã®ã­ã¼å¤ã§ä¸å®
        return this._createKeyFrameValue(0);
      } else if (index == this._num_keyframes) {
        // time ãæå¾ã®ã­ã¼æå»ã¨åããããã®å¾ã®ã¨ãã¯æå¾ã®ã­ã¼å¤ã§ä¸å®
        return this._createKeyFrameValue(index - 1);
      } else {
        // ãã®ä»ã®ã¨ãã¯åå¾ã®ã­ã¼å¤ã§ç·å½¢è£é
        return this._createValueBy2Keys(index - 1, index, time);
      }
    }
    /**
     * @summary ã­ã¼ãã¬ã¼ã å¤ãçæ
     *
     * @param {number} index  ã­ã¼ãã¬ã¼ã ã®ã¤ã³ããã¯ã¹
     *
     * @return {object}  ã­ã¼ãã¬ã¼ã å¤ (this._value_type ã«é©å¿ããå)
     *
     * @private
     */

  }, {
    key: "_createKeyFrameValue",
    value: function _createKeyFrameValue(index) {
      var dimension = this._dimension;
      var key_values = this._key_values;

      if (dimension == 1) {
        // ã¹ã«ã©ã¼
        return key_values[index];
      } else {
        // ãã¯ãã«
        var vi = dimension * index;
        var vec = new Float64Array(dimension);

        for (var i = 0; i < dimension; ++i) {
          vec[i] = key_values[vi + i];
        }

        return vec;
      }
    }
    /**
     * @summary ã­ã¼ãã¬ã¼ã éã®è£éå¤ãçæ
     *
     * @param {number} i0  åã­ã¼ãã¬ã¼ã ã®ã¤ã³ããã¯ã¹
     * @param {number} i1  å¾ã­ã¼ãã¬ã¼ã ã®ã¤ã³ããã¯ã¹
     * @param {mapray.animation.Time} time
     *
     * @return {object}  è£éå¤ (this._value_type ã«é©å¿ããå)
     *
     * @private
     */

  }, {
    key: "_createValueBy2Keys",
    value: function _createValueBy2Keys(i0, i1, time) {
      var x0 = this._key_times[i0].toNumber();

      var x1 = this._key_times[i1].toNumber();

      var r1 = (time.toNumber() - x0) / (x1 - x0);
      var r0 = 1 - r1;
      var dimension = this._dimension;
      var key_values = this._key_values;

      if (dimension == 1) {
        // ã¹ã«ã©ã¼
        return r0 * key_values[i0] + r1 * key_values[i1];
      } else {
        // ãã¯ãã«
        var vi0 = dimension * i0;
        var vi1 = dimension * i1;
        var vec = new Float64Array(dimension);

        for (var i = 0; i < dimension; ++i) {
          vec[i] = r0 * key_values[vi0 + i] + r1 * key_values[vi1 + i];
        }

        return vec;
      }
    }
  }]);

  return KFLinearCurve;
}(Curve);

/**
 * @summary ã­ã¼ãã¬ã¼ã ã«ããéæ®µé¢æ°
 *
 * @classdesc
 * <p>ããã­ã¼ãã¬ã¼ã ããæ¬¡ã®ã­ã¼ãã¬ã¼ã ã®ç´åã¾ã§ä¸å®ã®å¤ãè¿ãéæ®µé¢æ°ã§ããã</p>
 * <p>æ§ç¯å­ã«ããä»»æã®é¢æ°å¤ã®åãæå®ãããã¨ãã§ããã</p>
 *
 * @memberof mapray.animation
 * @extends mapray.animation.Curve
 */

var KFStepCurve =
/*#__PURE__*/
function (_Curve) {
  _inherits(KFStepCurve, _Curve);

  /**
   * @desc
   * <p>type åã®éæ®µé¢æ°ã keyframes ã«ããçæããã</p>
   * <p>type ã¯ä»»æã®åãæå®ãããã¨ãã§ããã</p>
   * <p>keyframes ãçç¥ããã¨ãã¯ type åã®æ¢å®å¤ãè¿ãå®æ°é¢æ°ã¨åç­ã«ãªããkeyframes ã®å½¢å¼ã«é¢ãã¦ã¯
   *    {@link mapray.animation.KFStepCurve#setKeyFrames setKeyFrames()} ãåç§ã®ãã¨ã</p>
   *
   * @param {mapray.animation.Type} type  é¢æ°å¤ã®å
   * @param {object[]}       [keyframes]  åæã­ã¼ãã¬ã¼ã 
   */
  function KFStepCurve(type, keyframes) {
    var _this;

    _classCallCheck(this, KFStepCurve);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(KFStepCurve).call(this));
    _this._value_type = type; // any type

    _this._num_keyframes = undefined; // >= 1

    _this._key_times = undefined; // Time[]

    _this._key_values = undefined; // object[]

    if (keyframes !== undefined) {
      // åæã®ã­ã¼ãã¬ã¼ã ãè¨­å®
      _this.setKeyFrames(keyframes);
    } else {
      // æ¢å®ã®ã­ã¼ãã¬ã¼ã ãè¨­å®
      var t0 = Time.fromNumber(0);
      var dv = type.getDefaultValue();

      _this.setKeyFrames([t0, dv]);
    }

    return _this;
  }
  /**
   * @summary ã­ã¼ãã¬ã¼ã è¨­å®
   *
   * @desc
   * <p>keyframes ã«ããããã¹ã¦ã®ã­ã¼ãã¬ã¼ã ãæå®ããã</p>
   *
   * <p>
   * æ¡ä»¶1: keyframes.length >= 2 (ã­ã¼ãã¬ã¼ã æ° >= 1)<br>
   * æ¡ä»¶2: ãã¹ã¦ã® i, j ã«ããã¦ãi < j â æå»i < æå»j<br>
   * æ¡ä»¶3: ãã¹ã¦ã® i ã«ããã¦ãå¤i ã¯æ§ç¯å­ã® type å¼æ°ã§æå®ããåã®ã¤ã³ã¹ã¿ã³ã¹
   * </p>
   *
   * @param {object[]} keyframes  [æå»0, å¤0, æå»1, å¤1, ...]
   */


  _createClass(KFStepCurve, [{
    key: "setKeyFrames",
    value: function setKeyFrames(keyframes) {
      this._num_keyframes = keyframes.length / 2;
      this._key_times = new Array(this._num_keyframes);
      this._key_values = new Array(this._num_keyframes); // ã­ã¼ãã¬ã¼ã ãè¨­å®

      for (var i = 0; i < this._num_keyframes; ++i) {
        var time = keyframes[2 * i];
        var value = keyframes[2 * i + 1];
        this._key_times[i] = time;
        this._key_values[i] = this._value_type.getCloneValue(value);
      } // å¨æå»ã®å¤ãå¤å


      this.notifyValueChange(Interval.UNIVERSAL);
    }
    /**
     * @override
     */

  }, {
    key: "isTypeSupported",
    value: function isTypeSupported(type) {
      var from_type = this._value_type;
      return type.isConvertible(from_type);
    }
    /**
     * @override
     */

  }, {
    key: "getValue",
    value: function getValue(time, type) {
      var from_type = this._value_type;

      var from_value = this._getInterpolatedValue(time);

      return type.convertValue(from_type, from_value);
    }
    /**
     * @override
     */

  }, {
    key: "getInvariance",
    value: function getInvariance(interval) {
      if (this._num_keyframes == 1) {
        // ã­ã¼ãã¬ã¼ã ã 1 åã®ã¨ãã¯ ConstantCurve ã¨åãããå¨æéã§ä¸å®å¤
        // (UNIVERSAL ã¨éç©ºåºéã¯å¿ãäº¤å·®ããã®ã§ interval ã®åç§ã¯ä¸è¦)
        return new Invariance().write(Interval.UNIVERSAL);
      } else {
        // assert: this._num_keyframes >= 2
        var invr = new Invariance(); // æåãã2çªç®ã®ã­ã¼æå»ããåã¯ä¸å®å¤

        var first = this._key_times[1];
        invr.write(new Interval(first, first).getPrecedings()); // æå¾ã®ã­ã¼æå»ã¨ãã®å¾ã¯ä¸å®å¤

        var lastL = this._key_times[this._num_keyframes - 2];
        var lastU = this._key_times[this._num_keyframes - 1];
        invr.write(new Interval(lastL, lastU, false, true).getFollowings()); // interval ç¯å²ã«çµã£ã¦è¿ã

        return invr.getNarrowed(interval);
      }
    }
    /**
     * @summary time ã§ã®è£éå¤ãåå¾
     *
     * @param {mapray.animation.Time} time
     *
     * @return {object}  è£éå¤ (this._value_type ã«é©å¿ããå)
     *
     * @private
     */

  }, {
    key: "_getInterpolatedValue",
    value: function _getInterpolatedValue(time) {
      // this._key_times ã« time ããå¾ã®æå»ãå­å¨ããã°ããã®ä¸­ã§æå°ã®ã¤ã³ããã¯ã¹
      // ãã®ãããªæå»ãå­å¨ããªããã° this._num_keyframes
      var found = AnimUtil.findKeyFrameIndex(time, this._key_times, 0, this._num_keyframes); // ã­ã¼å¤ã®ã¤ã³ããã¯ã¹

      var index = found > 0 ? found - 1 : 0; // è£éå¤ãçæ

      return this._value_type.getCloneValue(this._key_values[index]);
    }
  }]);

  return KFStepCurve;
}(Curve);

var $map$1 = arrayIteration.map;
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map'); // FF49- issue

var USES_TO_LENGTH$3 = arrayMethodUsesToLength('map'); // `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species

_export({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH$3
}, {
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/**
 * @summary è¤åãã¯ãã«é¢æ°
 *
 * @classdesc
 * <p>è¤æ°ã®æ°å¤é¢æ°ããæ§æããããã¯ãã«é¢æ°ã§ããã</p>
 * <p>é¢æ°å¤ã®åã¯æ§ç¯å­ã®ãã©ã¡ã¼ã¿ã«ãã vector2, vector3 ã¾ãã¯ vector4 ãæå®ããã</p>
 * <p>å­é¢æ°ã¯ number ã¾ãã¯ number ã¸å¤æå¯è½ãªåã§ãªããã°ãªããªãã</p>
 *
 * @memberof mapray.animation
 * @extends mapray.animation.Curve
 */

var ComboVectorCurve =
/*#__PURE__*/
function (_Curve) {
  _inherits(ComboVectorCurve, _Curve);

  /**
   * @desc
   * <p>type åã®ãã¯ãã«é¢æ°ãçæããããã¯ãã«ã®åè¦ç´ ã®å¤ã¯å­é¢æ°ã®å¤ã«ãªãã</p>
   *
   * <p>children ãçç¥ããã¨ãã¯ããã¯ãã«ã®å¨è¦ç´ ã 0 ã¨ãªãå®æ°é¢æ°ã¨åç­ã«ãªããchildren ã®å½¢å¼ã«é¢ãã¦ã¯
   *    {@link mapray.animation.ComboVectorCurve#setChildren setChildren()} ãåç§ã®ãã¨ã</p>
   *
   * @param {mapray.animation.Type}       type     é¢æ°å¤ã®å (ãã¯ãã«å)
   * @param {mapray.animation.Curve[]} [children]  åæã®å¨å­é¢æ°
   *
   * @throws {@link mapray.animation.TypeMismatchError}  type ã¾ãã¯ children ã«éå¯¾å¿ã®åãå­å¨ããã¨ã
   */
  function ComboVectorCurve(type, children) {
    var _this;

    _classCallCheck(this, ComboVectorCurve);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ComboVectorCurve).call(this));
    var dimension = AnimUtil.getDimension(type);

    if (dimension < 2 && dimension > 4) {
      // type ã¯ãã¯ãã«åã§ã¯ãªã
      throw new TypeMismatchError("unexpected type");
    }

    _this._vector_type = type;
    _this._dimension = dimension; // 2ã4

    _this._children = new Array(dimension); // å­é¢æ°ã®éå

    _this._listeners = new Array(dimension); // å­é¢æ°ã«å¯¾å¿ãã ValueChangeListener

    _this._setupInitialChildren(); // åæå¤ãæå®ããã¦ããã¨ãã¯è¨­å®


    if (children !== undefined) {
      _this.setChildren(children);
    }

    return _this;
  }
  /**
   * @summary å­é¢æ°ãè¨­å® (åå¥)
   *
   * @desc
   * <p>index ã®è¦ç´ ã®ã¿ã®å­é¢æ°ãè¨­å®ããããã®ä»ã®è¦ç´ ã¯å¤æ´ãããªãã</p>
   *
   * @param {number}                 index  è¦ç´ ã¤ã³ããã¯ã¹
   * @param {mapray.animation.Curve} curve  å­é¢æ°
   *
   * @throws {@link mapray.animation.TypeMismatchError}  curve ãéå¯¾å¿ã®åã®ã¨ã
   */


  _createClass(ComboVectorCurve, [{
    key: "setChild",
    value: function setChild(index, curve) {
      this._setChildCommon(index, curve); // curve ãæªç¥ãªã®ã§å¨æå»ã®å¤ãå¤åãããã¨ã«ãã


      this.notifyValueChange(Interval.UNIVERSAL);
    }
    /**
     * @summary å­é¢æ°ãè¨­å® (ä¸æ¬)
     *
     * @desc
     * <p>curves ã«ãã¹ã¦ã®å­é¢æ°ãæå®ãããcurves ã®è¦ç´ æ°ã¯ãã¯ãã«ã®æ¬¡æ°ã¨åæ°ã§ããã</p>
     *
     * @param {mapray.animation.Curve[]} curves  å¨å­é¢æ°
     *
     * @throws {@link mapray.animation.TypeMismatchError}  curves ã«éå¯¾å¿ã®åãå­å¨ããã¨ã
     */

  }, {
    key: "setChildren",
    value: function setChildren(curves) {
      for (var i = 0; i < this._dimension; ++i) {
        this._setChildCommon(i, curves[i]);
      } // curves ãæªç¥ãªã®ã§å¨æå»ã®å¤ãå¤åãããã¨ã«ãã


      this.notifyValueChange(Interval.UNIVERSAL);
    }
    /**
     * @override
     */

  }, {
    key: "isTypeSupported",
    value: function isTypeSupported(type) {
      var from_type = this._vector_type;
      return type.isConvertible(from_type);
    }
    /**
     * @override
     */

  }, {
    key: "getValue",
    value: function getValue(time, type) {
      var from_type = this._vector_type;

      var from_value = this._getCompoundValue(time);

      return type.convertValue(from_type, from_value);
    }
    /**
     * @override
     */

  }, {
    key: "getInvariance",
    value: function getInvariance(interval) {
      // ãã¹ã¦ã®å­é¢æ°ã®ä¸å¤æ§æå ±ã®äº¤å·®
      var invariances = this._children.map(function (child) {
        return child.getInvariance(interval);
      });

      return Invariance.merge(invariances);
    }
    /**
     * åæã®å­é¢æ°ã¨ãªã¹ãã¼ãè¨­å®
     *
     * @private
     */

  }, {
    key: "_setupInitialChildren",
    value: function _setupInitialChildren() {
      var _this2 = this;

      var init_child = new ConstantCurve(vec_compo_type);

      for (var i = 0; i < this._dimension; ++i) {
        var listener = function listener(interval) {
          _this2.notifyValueChange(interval);
        };

        init_child.addValueChangeListener(listener);
        this._children[i] = init_child;
        this._listeners[i] = listener;
      }
    }
    /**
     * @summary å­è¦ç´ ãè¨­å® (å±éã«ã¼ãã³)
     *
     * @param {number}                 index
     * @param {mapray.animation.Curve} curve
     *
     * @throws {@link mapray.animation.TypeMismatchError}
     *
     * @private
     */

  }, {
    key: "_setChildCommon",
    value: function _setChildCommon(index, curve) {
      var _this3 = this;

      if (!curve.isTypeSupported(vec_compo_type)) {
        // curve ã®åããã¯ãã«ã®è¦ç´ ã®åã«å¤æã§ããªã
        throw new TypeMismatchError("type mismatch error");
      } // ä»¥åã®å­ã®ãªã¹ãã¼ãè§£é¤


      var old_child = this._children[index];
      var old_listener = this._listeners[index];
      old_child.removeValueChangeListener(old_listener); // æ°ããå­ã®ãªã¹ãã¼ãè¨­å®

      var listener = function listener(interval) {
        _this3.notifyValueChange(interval);
      };

      curve.addValueChangeListener(listener); // æ°ããå­ãè¨­å®

      this._children[index] = curve;
      this._listeners[index] = listener;
    }
    /**
     * @summary time ã§ã®è¤åå¤ãåå¾
     *
     * @param {mapray.animation.Time} time
     *
     * @return {number[]}  è¤åå¤ (this._vector_type ã«é©å¿ããå)
     *
     * @private
     */

  }, {
    key: "_getCompoundValue",
    value: function _getCompoundValue(time) {
      var dimension = this._dimension;
      var vec = new Float64Array(dimension);

      for (var i = 0; i < dimension; ++i) {
        vec[i] = this._children[i].getValue(time, vec_compo_type);
      }

      return vec;
    }
  }]);

  return ComboVectorCurve;
}(Curve);
/**
 * ãã¯ãã«ã®è¦ç´ å
 * @private
 */


var vec_compo_type = Type.find("number");

/**
 * ã¢ãã¡ã¼ã·ã§ã³é¢é£ã®æ©è½å¨ä½ãå«ã¾ããååç©ºé
 *
 * @namespace animation
 * @memberof mapray
 */

var animation = {
  AnimationError: AnimationError,
  Time: Time,
  Interval: Interval,
  Invariance: Invariance,
  Type: Type,
  Curve: Curve,
  Updater: Updater,
  Binder: Binder,
  TypeMismatchError: TypeMismatchError,
  BindingBlock: BindingBlock,
  EasyBindingBlock: EasyBindingBlock,
  ConstantCurve: ConstantCurve,
  KFLinearCurve: KFLinearCurve,
  KFStepCurve: KFStepCurve,
  ComboVectorCurve: ComboVectorCurve
};

var $forEach$2 = arrayIteration.forEach;
var STRICT_METHOD$1 = arrayMethodIsStrict('forEach');
var USES_TO_LENGTH$4 = arrayMethodUsesToLength('forEach'); // `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach

var arrayForEach = !STRICT_METHOD$1 || !USES_TO_LENGTH$4 ? function forEach(callbackfn
/* , thisArg */
) {
  return $forEach$2(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;

// https://tc39.github.io/ecma262/#sec-array.prototype.foreach


_export({
  target: 'Array',
  proto: true,
  forced: [].forEach != arrayForEach
}, {
  forEach: arrayForEach
});

var nativePromiseConstructor = global_1.Promise;

var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

var location = global_1.location;
var set$2 = global_1.setImmediate;
var clear = global_1.clearImmediate;
var process$1 = global_1.process;
var MessageChannel = global_1.MessageChannel;
var Dispatch = global_1.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global_1.postMessage(id + '', location.protocol + '//' + location.host);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!set$2 || !clear) {
  set$2 = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) args.push(arguments[i++]);

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };

    defer(counter);
    return counter;
  };

  clear = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (classofRaw(process$1) == 'process') {
    defer = function (id) {
      process$1.nextTick(runner(id));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    }; // Browsers with MessageChannel, includes WebWorkers
    // except iOS - https://github.com/zloirock/core-js/issues/624

  } else if (MessageChannel && !engineIsIos) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = functionBindContext(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global_1.addEventListener && typeof postMessage == 'function' && !global_1.importScripts && !fails(post)) {
    defer = post;
    global_1.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
    defer = function (id) {
      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    }; // Rest old browsers

  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

var task = {
  set: set$2,
  clear: clear
};

var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;
var macrotask = task.set;
var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
var process$2 = global_1.process;
var Promise$1 = global_1.Promise;
var IS_NODE = classofRaw(process$2) == 'process'; // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`

var queueMicrotaskDescriptor = getOwnPropertyDescriptor$3(global_1, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush, head, last, notify, toggle, node, promise, then; // modern engines have queueMicrotask method

if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process$2.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (error) {
        if (head) notify();else last = undefined;
        throw error;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  }; // Node.js


  if (IS_NODE) {
    notify = function () {
      process$2.nextTick(flush);
    }; // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339

  } else if (MutationObserver && !engineIsIos) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, {
      characterData: true
    });

    notify = function () {
      node.data = toggle = !toggle;
    }; // environments with maybe non-completely correct, but existent Promise

  } else if (Promise$1 && Promise$1.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise$1.resolve(undefined);
    then = promise.then;

    notify = function () {
      then.call(promise, flush);
    }; // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout

  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global_1, flush);
    };
  }
}

var microtask = queueMicrotask || function (fn) {
  var task = {
    fn: fn,
    next: undefined
  };
  if (last) last.next = task;

  if (!head) {
    head = task;
    notify();
  }

  last = task;
};

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction$1(resolve);
  this.reject = aFunction$1(reject);
}; // 25.4.1.5 NewPromiseCapability(C)


var f$7 = function (C) {
  return new PromiseCapability(C);
};

var newPromiseCapability = {
  f: f$7
};

var promiseResolve = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var hostReportErrors = function (a, b) {
  var console = global_1.console;

  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};

var perform = function (exec) {
  try {
    return {
      error: false,
      value: exec()
    };
  } catch (error) {
    return {
      error: true,
      value: error
    };
  }
};

var task$1 = task.set;
var SPECIES$4 = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState$4 = internalState.get;
var setInternalState$5 = internalState.set;
var getInternalPromiseState = internalState.getterFor(PROMISE);
var PromiseConstructor = nativePromiseConstructor;
var TypeError$1 = global_1.TypeError;
var document$2 = global_1.document;
var process$3 = global_1.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability$1 = newPromiseCapability.f;
var newGenericPromiseCapability = newPromiseCapability$1;
var IS_NODE$1 = classofRaw(process$3) == 'process';
var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
var FORCED$5 = isForced_1(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);

  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (engineV8Version === 66) return true; // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test

    if (!IS_NODE$1 && typeof PromiseRejectionEvent != 'function') return true;
  } // We need Promise#finally in the pure version for preventing prototype pollution
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679

  if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false; // Detect correctness of subclassing with @@species support

  var promise = PromiseConstructor.resolve(1);

  var FakePromise = function (exec) {
    exec(function () {
      /* empty */
    }, function () {
      /* empty */
    });
  };

  var constructor = promise.constructor = {};
  constructor[SPECIES$4] = FakePromise;
  return !(promise.then(function () {
    /* empty */
  }) instanceof FakePromise);
});
var INCORRECT_ITERATION$1 = FORCED$5 || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () {
    /* empty */
  });
}); // helpers

var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify$1 = function (promise, state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0; // variable length - can't use forEach

    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
            state.rejection = HANDLED;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // can throw

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError$1('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }

    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(promise, state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;

  if (DISPATCH_EVENT) {
    event = document$2.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global_1.dispatchEvent(event);
  } else event = {
    promise: promise,
    reason: reason
  };

  if (handler = global_1['on' + name]) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (promise, state) {
  task$1.call(global_1, function () {
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;

    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE$1) {
          process$3.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (promise, state) {
  task$1.call(global_1, function () {
    if (IS_NODE$1) {
      process$3.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, promise, state, unwrap) {
  return function (value) {
    fn(promise, state, value, unwrap);
  };
};

var internalReject = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify$1(promise, state, true);
};

var internalResolve = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;

  try {
    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
    var then = isThenable(value);

    if (then) {
      microtask(function () {
        var wrapper = {
          done: false
        };

        try {
          then.call(value, bind(internalResolve, promise, wrapper, state), bind(internalReject, promise, wrapper, state));
        } catch (error) {
          internalReject(promise, wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify$1(promise, state, false);
    }
  } catch (error) {
    internalReject(promise, {
      done: false
    }, error, state);
  }
}; // constructor polyfill


if (FORCED$5) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction$1(executor);
    Internal.call(this);
    var state = getInternalState$4(this);

    try {
      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
    } catch (error) {
      internalReject(this, state, error);
    }
  }; // eslint-disable-next-line no-unused-vars


  Internal = function Promise(executor) {
    setInternalState$5(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };

  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE$1 ? process$3.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify$1(this, state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState$4(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, promise, state);
    this.reject = bind(internalReject, promise, state);
  };

  newPromiseCapability.f = newPromiseCapability$1 = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };

  if ( typeof nativePromiseConstructor == 'function') {
    nativeThen = nativePromiseConstructor.prototype.then; // wrap native Promise#then for native async functions

    redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected); // https://github.com/zloirock/core-js/issues/640
    }, {
      unsafe: true
    }); // wrap fetch result

    if (typeof $fetch == 'function') _export({
      global: true,
      enumerable: true,
      forced: true
    }, {
      // eslint-disable-next-line no-unused-vars
      fetch: function fetch(input
      /* , init */
      ) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global_1, arguments));
      }
    });
  }
}

_export({
  global: true,
  wrap: true,
  forced: FORCED$5
}, {
  Promise: PromiseConstructor
});
setToStringTag(PromiseConstructor, PROMISE, false);
setSpecies(PROMISE);
PromiseWrapper = getBuiltIn(PROMISE); // statics

_export({
  target: PROMISE,
  stat: true,
  forced: FORCED$5
}, {
  // `Promise.reject` method
  // https://tc39.github.io/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability$1(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});
_export({
  target: PROMISE,
  stat: true,
  forced:  FORCED$5
}, {
  // `Promise.resolve` method
  // https://tc39.github.io/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve( this, x);
  }
});
_export({
  target: PROMISE,
  stat: true,
  forced: INCORRECT_ITERATION$1
}, {
  // `Promise.all` method
  // https://tc39.github.io/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability$1(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction$1(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate_1(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.github.io/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability$1(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction$1(C.resolve);
      iterate_1(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

for (var COLLECTION_NAME$1 in domIterables) {
  var Collection$1 = global_1[COLLECTION_NAME$1];
  var CollectionPrototype$1 = Collection$1 && Collection$1.prototype; // some Chrome versions have non-configurable methods on DOMTokenList

  if (CollectionPrototype$1 && CollectionPrototype$1.forEach !== arrayForEach) try {
    createNonEnumerableProperty(CollectionPrototype$1, 'forEach', arrayForEach);
  } catch (error) {
    CollectionPrototype$1.forEach = arrayForEach;
  }
}

var runtime_1 = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function () {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function (record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    }; // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.

    return exports;
  }( // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
});

/**
 * @summary å§ç¹ã¨æ¹å
 * @classdesc
 * <p>å§ç¹ã¨æ¹åã§è¡¨ç¾ãããåç´ç·ã§ããã</p>
 * @memberof mapray
 * @see mapray.Viewer#getRayIntersection
 * @see mapray.Camera#getCanvasRay
 */

var Ray =
/**
 * @desc
 * <p>pos ã®åç§ã {@link mapray.Ray#position}, dir ã®åç§ã {@link mapray.Ray#direction} ã«ä»£å¥ããã</p>
 * <p>ãã ãå¼æ°ãçç¥ããã¨ããå¯¾å¿ããã¡ã³ãã¼ã«ã¯æ°ãã«çæããããã¯ãã«ãä»£å¥ãããã</p>
 * @param {mapray.Vector3} [pos]  ã¬ã¤ã®å§ç¹
 * @param {mapray.Vector3} [dir]  ã¬ã¤ã®æ¹å
 */
function Ray(pos, dir) {
  _classCallCheck(this, Ray);

  /**
   *  @summary ã¬ã¤ã®å§ç¹
   *  @member mapray.Ray#position
   *  @type {mapray.Vector3}
   *  @default [0, 0, 0]
   */
  this.position = pos || GeoMath.createVector3();
  /**
   *  @summary ã¬ã¤ã®æ¹å
   *  @desc
   *  <p>éé¶ãã¯ãã«ã§ãªããã°ãªããªãã</p>
   *  @member mapray.Ray#direction
   *  @type {mapray.Vector3}
   *  @default [0, 0, -1]
   */

  this.direction = dir || GeoMath.createVector3([0, 0, -1]);
};

/**
 * @summary è¦ç¹ãè¡¨ç¾ããã«ã¡ã©
 *
 * @classdesc
 * <p>è¦ç¹ãè¡¨ç¾ããã«ã¡ã©ã§ããã</p>
 * <p>ã¤ã³ã¹ã¿ã³ã¹ã¯ {@link mapray.Viewer#camera} ããå¾ããã¨ãã§ããã</p>
 *
 * @hideconstructor
 * @memberof mapray
 * @see mapray.Viewer
 */

var Camera =
/*#__PURE__*/
function () {
  /**
   * @summary Cameraãªãã¸ã§ã¯ããçæ
   * canvas_sizeã«ã¯ãwidth, heightãã­ããã£ãæã¤ãªãã¸ã§ã¯ããæå®ããã
   * createRenderInfo()ãå¼ã°ããåº¦ã«width, heightå¤ãåç§ãããã
   * canvasè¦ç´ ãæå®ãããä»ããªãã¹ã¯ãªã¼ã³ã¬ã³ããªã³ã°æã«ã¯width, heightå¤ãæã£ããªãã¸ã§ã¯ããæå®ããã¾ãã
   *
   * @param {object}  canvas_size  ã¬ã³ããªã³ã°åãµã¤ãº
   * @param {number}  canvas_size.width å¹
   * @param {number}  canvas_size.height é«ã
   * @package
   */
  function Camera(canvas_size) {
    _classCallCheck(this, Camera);

    /**
     *  @summary ã¬ã³ããªã³ã°åã®ãµã¤ãº
     *  @type {object}
     */
    this._canvas_size = canvas_size;
    /**
     *  @summary ã«ã¡ã©ã®ç»è§ (Degrees)
     *  @member mapray.Camera#fov
     *  @type {number}
     *  @default 46
     */

    this.fov = 46;
    /**
     *  @summary è¿æ¥å¹³é¢è·é¢ (Meters)
     *  @member mapray.Camera#near
     *  @type {number}
     *  @default 1
     */

    this.near = 1;
    /**
     *  @summary é æ¹å¹³é¢è·é¢ (Meters)
     *  @member mapray.Camera#far
     *  @type {number}
     *  @default 1000
     */

    this.far = 1000;
    /**
     *  @summary è¦ç¹ç©ºéãã GOCS ã¸ã®å¤æè¡å
     *  @member mapray.Camera#view_to_gocs
     *  @type {mapray.Matrix}
     *  @default æç­è¡å
     */

    this.view_to_gocs = GeoMath.createMatrix();
    GeoMath.setIdentity(this.view_to_gocs);
  }
  /**
   * @summary ã«ã¡ã©ã®å§¿å¢ãè¦ä½ç©ã«é¢ãããã©ã¡ã¼ã¿ãã³ãã¼ãã¾ãã
   * ã­ã£ã³ãã¹ãµã¤ãºã¯ã³ãã¼ããã¾ããã
   * @private
   */


  _createClass(Camera, [{
    key: "copyViewParameters",
    value: function copyViewParameters(camera) {
      this.fov = camera.fov;
      this.near = camera.near;
      this.far = camera.far;
      GeoMath.copyMatrix(camera.view_to_gocs, this.view_to_gocs);
    }
    /**
     * @summary å¤æè¡å canvas_to_view ãåå¾
     * @desc
     * <p>ã­ã£ã³ãã¹åº§æ¨ç³»ããè¦ç¹åº§æ¨ç³»ã¸åº§æ¨ãå¤æããããã®å¤æè¡åãåå¾ããã</p>
     * <p>çµæã¯ omat ã«è¨­å®ããããomat ãçç¥ããå ´åã¯æ°è¦ã«çæããè¡åãªãã¸ã§ã¯ããä½¿ç¨ããã</p>
     * <p>ã­ã£ã³ãã¹ã®å¹ã¾ãã¯é«ãã 0 ã®ã¨ãã¯çµæã¯ä¸å®å¤ã¨ãªãã</p>
     * @param  {mapray.Matrix} [omat]  çµæãè¨­å®ããè¡åãªãã¸ã§ã¯ã
     * @return {mapray.Matrix}         omat ã¾ãã¯æ°è¦ã«çæããè¡å
     */

  }, {
    key: "getCanvasToView",
    value: function getCanvasToView(omat) {
      var dst = omat || GeoMath.createMatrix(); // ã­ã£ã³ãã¹ç»ç´ æ° -> sx, sy

      var sx = this._canvas_size.width;
      var sy = this._canvas_size.height; // è¿æ¥é æ¹å¹³é¢è·é¢ -> n, f

      var n = this.near;
      var f = this.far; // n å¾é (å¯¾è§ç·ç»è§ãæ³å®) -> gx, gy

      var hfov = this.fov * GeoMath.DEGREE / 2;
      var aspect = sy / sx;
      var gx = n * Math.tan(hfov) / Math.sqrt(1 + aspect * aspect);
      var gy = gx * aspect; // è¡åã®è¦ç´ ãè¨­å®

      dst[0] = 2 * gx / (n * sx);
      dst[1] = 0;
      dst[2] = 0;
      dst[3] = 0;
      dst[4] = 0;
      dst[5] = -2 * gy / (n * sy);
      dst[6] = 0;
      dst[7] = 0;
      dst[8] = 0;
      dst[9] = 0;
      dst[10] = 0;
      dst[11] = (n - f) / (n * f);
      dst[12] = -gx / n;
      dst[13] = gy / n;
      dst[14] = -1;
      dst[15] = 1 / n;
      return dst;
    }
    /**
     * @summary å¤æè¡å canvas_to_gocs ãåå¾
     * @desc
     * <p>ã­ã£ã³ãã¹åº§æ¨ç³»ããå°å¿åº§æ¨ç³» (GOCS) ã¸åº§æ¨ãå¤æããããã®å¤æè¡åãåå¾ããã</p>
     * <p>çµæã¯ omat ã«è¨­å®ããããomat ãçç¥ããå ´åã¯æ°è¦ã«çæããè¡åãªãã¸ã§ã¯ããä½¿ç¨ããã</p>
     * <p>ã­ã£ã³ãã¹ã®å¹ã¾ãã¯é«ãã 0 ã®ã¨ãã¯çµæã¯ä¸å®å¤ã¨ãªãã</p>
     * @param  {mapray.Matrix} [omat]  çµæãè¨­å®ããè¡åãªãã¸ã§ã¯ã
     * @return {mapray.Matrix}         omat ã¾ãã¯æ°è¦ã«çæããè¡å
     */

  }, {
    key: "getCanvasToGocs",
    value: function getCanvasToGocs(omat) {
      /*==  canvas_to_view  ==*/
      var nMat = this.getCanvasToView(omat);
      var n00 = nMat[0]; //  n10 = 0
      //  n20 = 0
      //  n30 = 0
      //  n01 = 0

      var n11 = nMat[5]; //  n21 = 0
      //  n31 = 0
      //  n03 = 0
      //  n13 = 0
      //  n23 = 0

      var n32 = nMat[11];
      var n03 = nMat[12];
      var n13 = nMat[13]; //  n23 = -1

      var n33 = nMat[15];
      /*==  view_to_gocs  ==*/

      var mMat = this.view_to_gocs;
      var m00 = mMat[0];
      var m10 = mMat[1];
      var m20 = mMat[2]; //  m30 = 0

      var m01 = mMat[4];
      var m11 = mMat[5];
      var m21 = mMat[6]; //  m31 = 0

      var m02 = mMat[8];
      var m12 = mMat[9];
      var m22 = mMat[10]; //  m32 = 0

      var m03 = mMat[12];
      var m13 = mMat[13];
      var m23 = mMat[14]; //  m33 = 1

      /*==  dst = view_to_gocs * canvas_to_view  ==*/

      var dst = nMat;
      dst[0] = m00 * n00;
      dst[1] = m10 * n00;
      dst[2] = m20 * n00; // dst[ 3] = 0

      dst[4] = m01 * n11;
      dst[5] = m11 * n11;
      dst[6] = m21 * n11; // dst[ 7] = 0

      dst[8] = m03 * n32;
      dst[9] = m13 * n32;
      dst[10] = m23 * n32; // dst[ 11] = n32

      dst[12] = m00 * n03 + m01 * n13 - m02 + m03 * n33;
      dst[13] = m10 * n03 + m11 * n13 - m12 + m13 * n33;
      dst[14] = m20 * n03 + m21 * n13 - m22 + m23 * n33; // dst[ 12] = n33

      return dst;
    }
    /**
     * @summary å¤æè¡å view_to_canvas ãåå¾
     * @desc
     * <p>è¦ç¹åº§æ¨ç³»ããã­ã£ã³ãã¹åº§æ¨ç³»ã¸åº§æ¨ãå¤æããããã®å¤æè¡åãåå¾ããã</p>
     * <p>çµæã¯ omat ã«è¨­å®ããããomat ãçç¥ããå ´åã¯æ°è¦ã«çæããè¡åãªãã¸ã§ã¯ããä½¿ç¨ããã</p>
     * <p>ã­ã£ã³ãã¹ã®å¹ã¾ãã¯é«ãã 0 ã®ã¨ãã¯çµæã¯ä¸å®å¤ã¨ãªãã</p>
     * @param  {mapray.Matrix} [omat]  çµæãè¨­å®ããè¡åãªãã¸ã§ã¯ã
     * @return {mapray.Matrix}         omat ã¾ãã¯æ°è¦ã«çæããè¡å
     */

  }, {
    key: "getViewToCanvas",
    value: function getViewToCanvas(omat) {
      var dst = omat || GeoMath.createMatrix(); // ã­ã£ã³ãã¹ç»ç´ æ° -> sx, sy

      var sx = this._canvas_size.width;
      var sy = this._canvas_size.height; // è¿æ¥é æ¹å¹³é¢è·é¢ -> n, f

      var n = this.near;
      var f = this.far; // n å¾é (å¯¾è§ç·ç»è§ãæ³å®) -> gx, gy

      var hfov = this.fov * GeoMath.DEGREE / 2;
      var aspect = sy / sx;
      var gx = n * Math.tan(hfov) / Math.sqrt(1 + aspect * aspect);
      var gy = gx * aspect; // è¡åã®è¦ç´ ãè¨­å®

      dst[0] = n * sx / (2 * gx);
      dst[1] = 0;
      dst[2] = 0;
      dst[3] = 0;
      dst[4] = 0;
      dst[5] = -n * sy / (2 * gy);
      dst[6] = 0;
      dst[7] = 0;
      dst[8] = -sx / 2;
      dst[9] = -sy / 2;
      dst[10] = f / (n - f);
      dst[11] = -1;
      dst[12] = 0;
      dst[13] = 0;
      dst[14] = n * f / (n - f);
      dst[15] = 0;
      return dst;
    }
    /**
     * @summary ã­ã£ã³ãã¹åº§æ¨ã«å¯¾å¿ããã¬ã¤ãåå¾
     * @desc
     * <p>ã­ã£ã³ãã¹ä¸ã® cpos ã§ç¤ºããç¹ã«å¯¾å¿ããã¬ã¤ãåå¾ããã</p>
     * <p>å§ç¹ã¯è¿æ¥å¹³é¢ä¸ã«ç½®ããæ¹åã¯é·ã 1 ã«æ­£è¦åãããã</p>
     * <p>è¿ãããã¬ã¤ã®åº§æ¨ç³»ã¯ GOCS ã§ããã</p>
     * @param  {mapray.Vector2} cpos    ã­ã£ã³ãã¹ä¸ã®ä½ç½®
     * @param  {mapray.Ray}     [oray]  çµæãè¨­å®ãã Ray ãªãã¸ã§ã¯ã
     * @return {mapray.Ray}             oray ã¾ãã¯æ°è¦ã«çæãã Ray
     */

  }, {
    key: "getCanvasRay",
    value: function getCanvasRay(cpos, oray) {
      var x = cpos[0];
      var y = cpos[1];
      var dst = oray || new Ray(); // Q = Mr (x, y, 0, 1)^t

      var mr = this.getCanvasToGocs(Camera._temp_mat);
      var qx = x * mr[0] + y * mr[4] + mr[12];
      var qy = x * mr[1] + y * mr[5] + mr[13];
      var qz = x * mr[2] + y * mr[6] + mr[14];
      var qw = x * mr[3] + y * mr[7] + mr[15]; // Q ãéå¸¸ã®åº§æ¨ã«å¤æ

      var pos = dst.position;
      pos[0] = qx / qw;
      pos[1] = qy / qw;
      pos[2] = qz / qw; // Vr = pos - Mg (0, 0, 0)^t

      var mg = this.view_to_gocs;
      var dir = dst.direction;
      dir[0] = pos[0] - mg[12];
      dir[1] = pos[1] - mg[13];
      dir[2] = pos[2] - mg[14];
      GeoMath.normalize3(dir, dir);
      return dst;
    }
    /**
     * @summary ã¬ã³ããªã³ã°åã®ãµã¤ãº
     * @type {object}
     * @private
     */

  }, {
    key: "createRenderInfo",

    /**
     * @summary ã¬ã³ããªã³ã°æå ±ãçæãã¾ãã
     * ãã¥ã¼ãã¼ãåã§å®éã«ã¬ã³ããªã³ã°ãè¡ãé åãæå®ãã¾ããï¼ã¬ã³ããªã³ã°é åãæå®ãããªãã£ãå ´åã¯ãã¥ã¼ãã¼ãå¨ä½ã«ã¬ã³ããªã³ã°ãè¡ãã¾ãï¼
     * @param  {number} [sx] ã¬ã³ããªã³ã°é åã®xä½ç½®
     * @param  {number} [sy] ã¬ã³ããªã³ã°é åã®yä½ç½®
     * @param  {number} [swidth] ã¬ã³ããªã³ã°é åã®å¹
     * @param  {number} [sheight] ã¬ã³ããªã³ã°é åã®é«ã
     * @return {mapray.Camera.RenderInfo}
     * @package
     */
    value: function createRenderInfo(sx, sy, swidth, sheight) {
      var canvas_size = this._canvas_size;
      return new RenderInfo(this, canvas_size.width, canvas_size.height, sx, sy, swidth, sheight);
    }
  }, {
    key: "canvas_size",
    get: function get() {
      return this._canvas_size;
    }
  }]);

  return Camera;
}();

Camera._temp_mat = GeoMath.createMatrix();
/**
 * @summary ã«ã¡ã©ããå¾ãã¬ã³ããªã³ã°æå ±
 * @memberof mapray.Camera
 * @private
 */

var RenderInfo =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Camera} camera  å¯¾è±¡ã«ã¡ã©
   * @param {number} width          ãã¥ã¼ãã¼ãã®å¹
   * @param {number} height         ãã¥ã¼ãã¼ãã®é«ã
   * @param {number} [sx]           ã¬ã³ããªã³ã°é åã®xä½ç½®(ãã¥ã¼ãã¼ãä¸­å¤®ã0, å³æ¹åãæ­£ã¨ãã)
   * @param {number} [sy]           ã¬ã³ããªã³ã°é åã®yä½ç½®(ãã¥ã¼ãã¼ãä¸­å¤®ã0, ä¸æ¹åãæ­£ã¨ãã)
   * @param {number} [swidth]       ã¬ã³ããªã³ã°é åã®å¹
   * @param {number} [sheight]      ã¬ã³ããªã³ã°é åã®é«ã
   */
  function RenderInfo(camera, width, height, sx, sy, swidth, sheight) {
    _classCallCheck(this, RenderInfo);

    /*
    *                  y    swidth                  
    *  Viewport        |   |<--->|                  
    *   +--------------+--------------+  -----------
    *   |              |              |           ^ 
    *   |              |   +-----+    |  --       | 
    *   |            sy+---|  +  |    |  sheight  | 
    *   |              |   +-----+    |  --       | 
    *   |              |      |       |           | 
    * --+--------------+------+-------+--x        | 
    *   |              |      sx      |           | 
    *   |              |              |       height
    *   |              |              |           | 
    *   |              |              |           | 
    *   |              |              |           V 
    *   +--------------+--------------+  -----------
    *                                               
    *   |<---------- width ---------->|             
    */
    // ãªãã¸ã§ã¯ããçæ
    this._view_to_clip = GeoMath.createMatrix();
    this._volume_planes = [];

    for (var i = 0; i < 6; ++i) {
      this._volume_planes.push(GeoMath.createVector4());
    }

    this._pixel_step = 0; // ãªãã¸ã§ã¯ããè¨­å®

    this._setup_view_to_clip(camera, width, height, sx, sy, swidth, sheight);

    this._setup_volume_planes();

    this._setup_pixel_step(width, height);
  }
  /**
   * @summary è¦ç¹ç©ºéããã¯ãªããåæ¬¡ç©ºéã¸ã®å¤æè¡å
   * @type {mapray.Matrix}
   * @readonly
   */


  _createClass(RenderInfo, [{
    key: "_setup_view_to_clip",

    /**
     * @private
     */
    value: function _setup_view_to_clip(camera, width, height) {
      var sx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var sy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var swidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : width;
      var sheight = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : height;
      // ç©å½¢ã®ä¸­å¿ä½ç½® (åä½ç©ºé)
      var cx = 2 * sx / width;
      var cy = 2 * sy / height; // ç©å½¢ã®åãµã¤ãº (åä½ç©ºé)

      var dx = swidth / width;
      var dy = sheight / height; // ã­ã£ã³ãã¹ã®æ¨ªå¹ã«å¯¾ããé«ãã®æ¯

      var aspect = height / width; // fov ãå¯¾è§ç·ç»è§ã¨è§£éãã¦åä½ãµã¤ãºãæ±ãã
      // (åä½ç©ºéã®æ°´å¹³æ¹å 1 ã«å¯¾ããè¿æ¥å¹³é¢ä¸ã§ã®å¯¸æ³)

      var hfov = camera.fov * GeoMath.DEGREE / 2; // åç»è§ (radians)

      var unit = camera.near * Math.tan(hfov) / Math.sqrt(1 + aspect * aspect); // è¿æ¥å¹³é¢ä¸ã§ã®å¹³é¢ä½ç½®

      var left = (cx - dx) * unit;
      var right = (cx + dx) * unit;
      var bottom = (cy - dy) * unit * aspect;
      var top = (cy + dy) * unit * aspect;
      GeoMath.frustum_matrix(left, right, bottom, top, camera.near, camera.far, this._view_to_clip);
    }
    /**
     * @private
     */

  }, {
    key: "_setup_volume_planes",
    value: function _setup_volume_planes() {
      var matrix = this._view_to_clip;
      var plane = this._volume_planes; // è¦ä½ç©ã®åå´ãåããå¹³é¢ãåå¾
      // ãããã®å¼ã¯ä»»æã®å°å½±è¡åã«å¯¾ãã¦æå¹

      this._add_matrix_rows(matrix, 3, 2, plane[0]); //   near = m3 + m2


      this._sub_matrix_rows(matrix, 3, 2, plane[1]); //    far = m3 - m2


      this._add_matrix_rows(matrix, 3, 0, plane[2]); //   left = m3 + m0


      this._sub_matrix_rows(matrix, 3, 0, plane[3]); //  right = m3 - m0


      this._add_matrix_rows(matrix, 3, 1, plane[4]); // bottom = m3 + m1


      this._sub_matrix_rows(matrix, 3, 1, plane[5]); //    top = m3 - m1
      // æ³ç·ãæ­£è¦å


      for (var i = 0; i < 6; ++i) {
        var p = plane[i];
        var x = p[0];
        var y = p[1];
        var z = p[2];
        var ilen = 1 / Math.sqrt(x * x + y * y + z * z); // é·ãã®éæ°

        p[0] *= ilen;
        p[1] *= ilen;
        p[2] *= ilen;
        p[3] *= ilen;
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setup_pixel_step",
    value: function _setup_pixel_step(width, height) {
      // mIJ ã¯ view_to_clip ã® I è¡ J åã®æå
      //
      //         2 (m33 - m32)
      //   dx = ---------------
      //           m00 width
      //
      //         2 (m33 - m32)
      //   dy = ---------------
      //          m11 height
      var mat = this._view_to_clip;
      var m00 = mat[0];
      var m11 = mat[5];
      var m32 = mat[11];
      var m33 = mat[15];
      var n = 2 * (m33 - m32);
      var dx = n / (m00 * width);
      var dy = n / (m11 * height);
      this._pixel_step = Math.sqrt(dx * dx + dy * dy) * Math.SQRT1_2;
    }
    /**
     * @private
     */

  }, {
    key: "_add_matrix_rows",
    value: function _add_matrix_rows(mat, row1, row2, dst) {
      dst[0] = mat[row1] + mat[row2];
      dst[1] = mat[row1 + 4] + mat[row2 + 4];
      dst[2] = mat[row1 + 8] + mat[row2 + 8];
      dst[3] = mat[row1 + 12] + mat[row2 + 12];
      return dst;
    }
    /**
     * @private
     */

  }, {
    key: "_sub_matrix_rows",
    value: function _sub_matrix_rows(mat, row1, row2, dst) {
      dst[0] = mat[row1] - mat[row2];
      dst[1] = mat[row1 + 4] - mat[row2 + 4];
      dst[2] = mat[row1 + 8] - mat[row2 + 8];
      dst[3] = mat[row1 + 12] - mat[row2 + 12];
      return dst;
    }
  }, {
    key: "view_to_clip",
    get: function get() {
      return this._view_to_clip;
    }
    /**
     * @summary è¦ä½ç©ã®å¹³é¢ãã¯ãã«éå
     * @desc
     * <p>ä»¥ä¸ã®é åºã§ 6 æã®å¹³é¢ãã¯ãã«ãæ ¼ç´ããã¦ããã</p>
     *
     * <pre>
     * [near, far, left, right, bottom, top]
     * </pre>
     *
     * <p>åå¹³é¢ã® x, y, z ã¯é·ã 1 ã«æ­£è¦åããã¦ããã</p>
     *
     * @type {mapray.Vector4[]}
     * @readonly
     */

  }, {
    key: "volume_planes",
    get: function get() {
      return this._volume_planes;
    }
    /**
     * @summary è¦ç¹ç©ºéã§ã®ç»ç´ ã®å¤åé
     * @desc
     * <p>ãã¥ã¼ãã¼ãã®ç»ç´ ã«å¯¾å¿ããè¦ç¹ç©ºéã® Z = -1 å¹³é¢ã§ã®å¤åéãè¿ãã</p>
     *
     * @type {number}
     * @readonly
     */

  }, {
    key: "pixel_step",
    get: function get() {
      return this._pixel_step;
    }
  }]);

  return RenderInfo;
}();

/**
 * @summary WebGL ã®ç°å¢
 * @desc
 * WebGL ã¬ã³ããªã³ã°ã³ã³ãã­ã¹ããçæãããã®ã³ã³ãã­ã¹ãã«é¢é£ããæå ±ãæä¾ããã
 * @memberof mapray
 * @private
 */
var GLEnv =
/*#__PURE__*/
function () {
  /**
   * @param canvas {HTMLCanvasElement}  ã¬ã³ããªã³ã°ã¿ã¼ã²ããã¨ããã­ã£ã³ãã¹
   */
  function GLEnv(canvas) {
    _classCallCheck(this, GLEnv);

    var ctx_attribs = {
      depth: true,
      antialias: true
    };

    var context = this._getContextWebGL(canvas, ctx_attribs);

    if (!context) {
      throw new Error("It doesn't appear your computer can support WebGL.");
    }

    this._canvas = canvas;
    this._context = context;

    this._setupExtensions(context);
  }
  /** 
   * @summary WebGL ã³ã³ãã­ã¹ããåå¾
   * @param  {HTMLCanvasElement}      canvas       Canvas è¦ç´ 
   * @param  {WebGLContextAttributes} ctx_attribs  çæå±æ§ (çç¥å¯è½)
   * @return {WebGLRenderingContext}               åå¾ããã WebGL ã³ã³ãã­ã¹ã (ã³ã³ãã­ã¹ããæããªãã¨ãã¯ null)
   * @private
   *
   * @see https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2
   */


  _createClass(GLEnv, [{
    key: "_getContextWebGL",
    value: function _getContextWebGL(canvas, ctx_attribs) {
      var contextTypes = ["webgl", "experimental-webgl"];

      for (var i = 0; i < contextTypes.length; ++i) {
        var context = canvas.getContext(contextTypes[i], ctx_attribs);

        if (context) {
          return context;
        }
      }

      return null;
    }
    /** 
     * @summary æ¢ç¥ã® WebGL æ¡å¼µãè¨­å®
     * @param  {WebGLRenderingContext} gl  WebGL ã³ã³ãã­ã¹ã
     * @private
     * @see https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.14
     */

  }, {
    key: "_setupExtensions",
    value: function _setupExtensions(gl) {
      // OES_element_index_uint
      this.OES_element_index_uint = gl.getExtension("OES_element_index_uint"); // EXT_texture_filter_anisotropic

      this.EXT_texture_filter_anisotropic = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic"); // WEBGL_depth_texture

      this.WEBGL_depth_texture = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture");
    }
    /**
     * @summary ã¬ã³ããªã³ã°ã¿ã¼ã²ããã¨ããã­ã£ã³ãã¹
     * @type {HTMLCanvasElement}
     * @readonly
     */

  }, {
    key: "canvas",
    get: function get() {
      return this._canvas;
    }
    /**
     * @summary WebGL ã¬ã³ããªã³ã°ã³ã³ãã­ã¹ã
     * @type {WebGLRenderingContext}
     * @readonly
     */

  }, {
    key: "context",
    get: function get() {
      return this._context;
    }
  }]);

  return GLEnv;
}();

var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('slice');
var USES_TO_LENGTH$5 = arrayMethodUsesToLength('slice', {
  ACCESSORS: true,
  0: 0,
  1: 2
});
var SPECIES$5 = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max$1 = Math.max; // `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects

_export({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$5
}, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

    var Constructor, result, n;

    if (isArray(O)) {
      Constructor = O.constructor; // cross-realm fallback

      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES$5];
        if (Constructor === null) Constructor = undefined;
      }

      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }

    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));

    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);

    result.length = n;
    return result;
  }
});

var test$1 = [];
var nativeSort = test$1.sort; // IE8-

var FAILS_ON_UNDEFINED = fails(function () {
  test$1.sort(undefined);
}); // V8 bug

var FAILS_ON_NULL = fails(function () {
  test$1.sort(null);
}); // Old WebKit

var STRICT_METHOD$2 = arrayMethodIsStrict('sort');
var FORCED$6 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$2; // `Array.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-array.prototype.sort

_export({
  target: 'Array',
  proto: true,
  forced: FORCED$6
}, {
  sort: function sort(comparefn) {
    return comparefn === undefined ? nativeSort.call(toObject(this)) : nativeSort.call(toObject(this), aFunction$1(comparefn));
  }
});

var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('splice');
var USES_TO_LENGTH$6 = arrayMethodUsesToLength('splice', {
  ACCESSORS: true,
  0: 0,
  1: 2
});
var max$2 = Math.max;
var min$4 = Math.min;
var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species

_export({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$6
}, {
  splice: function splice(start, deleteCount
  /* , ...items */
  ) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;

    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min$4(max$2(toInteger(deleteCount), 0), len - actualStart);
    }

    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }

    A = arraySpeciesCreate(O, actualDeleteCount);

    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }

    A.length = actualDeleteCount;

    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];else delete O[to];
      }

      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];else delete O[to];
      }
    }

    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }

    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});

var nativeExpm1 = Math.expm1;
var exp = Math.exp; // `Math.expm1` method implementation
// https://tc39.github.io/ecma262/#sec-math.expm1

var mathExpm1 = !nativeExpm1 // Old FF bug
|| nativeExpm1(10) > 22025.465794806719 || nativeExpm1(10) < 22025.4657948067165168 // Tor Browser bug
|| nativeExpm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
} : nativeExpm1;

var nativeCosh = Math.cosh;
var abs$1 = Math.abs;
var E = Math.E; // `Math.cosh` method
// https://tc39.github.io/ecma262/#sec-math.cosh

_export({
  target: 'Math',
  stat: true,
  forced: !nativeCosh || nativeCosh(710) === Infinity
}, {
  cosh: function cosh(x) {
    var t = mathExpm1(abs$1(x) - 1) + 1;
    return (t + 1 / (t * E * E)) * (E / 2);
  }
});

// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags


var regexpFlags = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

// so we use an intermediate function.


function RE(s, f) {
  return RegExp(s, f);
}

var UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});
var BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});
var regexpStickyHelpers = {
  UNSUPPORTED_Y: UNSUPPORTED_Y,
  BROKEN_CARET: BROKEN_CARET
};

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}();

var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET; // nonparticipating capturing group, copied from es5-shim's String#split patch.

var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y$1 && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');

      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = String(str).slice(re.lastIndex); // Support anchored sticky behavior.

      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      } // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.


      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

var regexpExec = patchedExec;

_export({
  target: 'RegExp',
  proto: true,
  forced: /./.exec !== regexpExec
}, {
  exec: regexpExec
});

var SPECIES$6 = wellKnownSymbol('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
}); // IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0

var REPLACE_KEEPS_$0 = function () {
  return 'a'.replace(/./, '$0') === '$0';
}();

var REPLACE = wellKnownSymbol('replace'); // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string

var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }

  return false;
}(); // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper


var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {}; // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.

      re.constructor = {};

      re.constructor[SPECIES$6] = function () {
        return re;
      };

      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () {
      execCalled = true;
      return null;
    };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    }, {
      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];
    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return regexMethod.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return regexMethod.call(string, this);
    });
  }

  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};

var charAt$1 = stringMultibyte.charAt; // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex

var advanceStringIndex = function (S, index, unicode) {
  return index + (unicode ? charAt$1(S, index).length : 1);
};

// https://tc39.github.io/ecma262/#sec-regexpexec

var regexpExecAbstract = function (R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classofRaw(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};

fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = requireObjectCoercible(this);
    var matcher = regexp == undefined ? undefined : regexp[MATCH];
    return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative(nativeMatch, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regexpExecAbstract(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regexpExecAbstract(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

// https://tc39.github.io/ecma262/#sec-dataview-constructor

_export({
  global: true,
  forced: !arrayBufferNative
}, {
  DataView: arrayBuffer.DataView
});

/**
 * @summary DEM ãµã³ãã©ã¼
 *
 * @desc
 * <p>DEM ãã¤ããªã¼ã®ãã¼ã¿ããµã³ãã«ããããã«ä½¿ç¨ããã<p>
 * <p>ã¤ã³ã¹ã¿ã³ã¹ã¯ [DemBinary#newSampler()]{@link mapray.DemBinary#newSampler} ã«ããä½æããã<p>
 *
 * @memberof mapray
 * @private
 * @see mapray.DemBinary
 * @see mapray.DemSamplerLinear
 * @see mapray.DemSamplerNearest
 */
var DemSampler =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Area} area  DEM é å
   * @param {number}      Ï    DEM ãã¤ããªã®è§£ååº¦ã®ææ°
   * @param {DataView}    body  DEM éåãã¼ã¿ã®æ¨é«ãã¼ã¿é¨å
   */
  function DemSampler(area, Ï, body) {
    _classCallCheck(this, DemSampler);

    var FLT_BYTES = 4;
    var p = Math.pow(2, area.z - 1); // 2^(ze-1)

    var c = 1 << Ï; // ç»ç´ æ°

    this._sx = p / Math.PI * c;
    this._sy = -this._sx;
    this._ox = (p - area.x) * c;
    this._oy = (p - area.y) * c;
    this._body = body;
    this._pitch = FLT_BYTES * (c + 1);
    this._max = c;
  }
  /**
   * @summary æ¨é«å¤ããµã³ãã«
   * @param  {number}  x  X åº§æ¨ (åä½çã¡ã«ã«ãã«åº§æ¨ç³»)
   * @param  {number}  y  Y åº§æ¨ (åä½çã¡ã«ã«ãã«åº§æ¨ç³»)
   * @return {number}     æ¨é«å¤ (ã¡ã¼ãã«)
   * @abstract
   */


  _createClass(DemSampler, [{
    key: "sample",
    value: function sample(x, y) {
      return 0;
    }
  }]);

  return DemSampler;
}();

/**
 * @summary ç·å½¢ DEM ãµã³ãã©ã¼
 * @memberof mapray
 * @private
 * @extends mapray.DemSampler
 */

var DemSamplerLinear =
/*#__PURE__*/
function (_DemSampler) {
  _inherits(DemSamplerLinear, _DemSampler);

  function DemSamplerLinear(area, Ï, body) {
    _classCallCheck(this, DemSamplerLinear);

    return _possibleConstructorReturn(this, _getPrototypeOf(DemSamplerLinear).call(this, area, Ï, body));
  }
  /**
   * @override
   */


  _createClass(DemSamplerLinear, [{
    key: "sample",
    value: function sample(x, y) {
      var u = this._sx * x + this._ox;
      var u0 = Math.floor(u); // å³ä½ç½®

      var u1 = u0 + 1; // å·¦ä½ç½®

      var v = this._sy * y + this._oy;
      var v0 = Math.floor(v); // ä¸ä½ç½®

      var v1 = v0 + 1; // ä¸ä½ç½®

      var h00 = this._sampleInt(u0, v0); // å·¦ä¸æ¨é«


      var h10 = this._sampleInt(u1, v0); // å³ä¸æ¨é«


      var h01 = this._sampleInt(u0, v1); // å·¦ä¸æ¨é«


      var h11 = this._sampleInt(u1, v1); // å³ä¸æ¨é«
      // æ¨é«å¤ãè£é


      var fu = u - u0; // æ°´å¹³å°æ°é¨

      var fv = v - v0; // åç´å°æ°é¨

      return (h00 * (1 - fu) + h10 * fu) * (1 - fv) + (h01 * (1 - fu) + h11 * fu) * fv;
    }
  }, {
    key: "_sampleInt",
    value: function _sampleInt(u, v) {
      var FLT_BYTES = 4;
      var cu = GeoMath.clamp(u, 0, this._max);
      var cv = GeoMath.clamp(v, 0, this._max);
      var offset = this._pitch * cv + FLT_BYTES * cu;
      return this._body.getFloat32(offset, true);
    }
  }]);

  return DemSamplerLinear;
}(DemSampler);

/**
 * @summary æè¿å DEM ãµã³ãã©ã¼
 * @memberof mapray
 * @private
 * @extends mapray.DemSampler
 */

var DemSamplerNearest =
/*#__PURE__*/
function (_DemSampler) {
  _inherits(DemSamplerNearest, _DemSampler);

  function DemSamplerNearest(area, Ï, body) {
    _classCallCheck(this, DemSamplerNearest);

    return _possibleConstructorReturn(this, _getPrototypeOf(DemSamplerNearest).call(this, area, Ï, body));
  }
  /**
   * @override
   */


  _createClass(DemSamplerNearest, [{
    key: "sample",
    value: function sample(x, y) {
      var FLT_BYTES = 4;
      var u = Math.round(this._sx * x + this._ox);
      var v = Math.round(this._sy * y + this._oy);
      var offset = this._pitch * v + FLT_BYTES * u;
      return this._body.getFloat32(offset, true);
    }
  }]);

  return DemSamplerNearest;
}(DemSampler);

/**
 * @summary å¹³åæ¨é«ããã
 * @memberof mapray
 * @private
 * @see mapray.DemBinary
 * @see mapray.DemBinaryCache
 */
var AvgHeightMaps =
/*#__PURE__*/
function () {
  /**
   * @param {number}   Ï    è§£ååº¦ã®ææ°
   * @param {DataView} body  DEM éåãã¼ã¿ã®æ¨é«ãã¼ã¿é¨å
   */
  function AvgHeightMaps(Ï, body) {
    _classCallCheck(this, AvgHeightMaps);

    this._Ï = Ï;
    this._maps = []; // Level: -1, -2, ..., -Ï

    if (Ï >= 1) {
      // Level: -1
      var first_map = this._create_first_map(body);

      this._maps.push(first_map); // Level: -2 .. -Ï


      var src_map = first_map;

      for (var lv = -2; lv >= -Ï; --lv) {
        var next_map = this._create_next_map(lv, src_map);

        this._maps.push(next_map);

        src_map = next_map;
      }
    }
  }
  /**
   * ã¬ãã« -1 ã®å¹³åæ¨é«ããããçæ
   * @param  {DataView}     src  DEM éåãã¼ã¿ã®æ¨é«ãã¼ã¿é¨å
   * @return {Float32Array}      ã¬ãã« -1 ã®å¹³åæ¨é«ããã
   * @private
   */


  _createClass(AvgHeightMaps, [{
    key: "_create_first_map",
    value: function _create_first_map(src) {
      var FLT_BYTES = 4;
      var size = 1 << this._Ï - 1;
      var dst = new Float32Array(size * size);
      var src_pitch = (2 * size + 1) * FLT_BYTES;
      var dst_pitch = size;

      for (var j = 0; j < size; ++j) {
        var src_index = 2 * j * src_pitch;
        var dst_index = j * dst_pitch;

        for (var i = 0; i < size; ++i) {
          // æ¨é«ãã¼ã¿ãåãåºã
          var h00 = src.getFloat32(src_index, true);
          var h10 = src.getFloat32(src_index + FLT_BYTES, true);
          var h20 = src.getFloat32(src_index + 2 * FLT_BYTES, true);
          var h01 = src.getFloat32(src_index + src_pitch, true);
          var h11 = src.getFloat32(src_index + src_pitch + FLT_BYTES, true);
          var h21 = src.getFloat32(src_index + src_pitch + 2 * FLT_BYTES, true);
          var h02 = src.getFloat32(src_index + 2 * src_pitch, true);
          var h12 = src.getFloat32(src_index + 2 * src_pitch + FLT_BYTES, true);
          var h22 = src.getFloat32(src_index + 2 * (src_pitch + FLT_BYTES), true); // å¹³åæ¨é«ãæ¸ãè¾¼ã

          dst[dst_index] = (h00 + 2 * h10 + h20 + 2 * h01 + 4 * h11 + 2 * h21 + h02 + 2 * h12 + h22) / 16;
          src_index += 2 * FLT_BYTES;
          dst_index += 1;
        }
      }

      return dst;
    }
    /**
     * ã¬ãã« -2 .. -Ï ã®å¹³åæ¨é«ããããçæ
     * @param  {number}       lv   çæãããããã®ã¬ãã«
     * @param  {Float32Array} src  åã¨ãªãå¹³åæ¨é«ããã (ã¬ãã« lv + 1)
     * @return {Float32Array}      ã¬ãã« lv ã®å¹³åæ¨é«ããã
     * @private
     */

  }, {
    key: "_create_next_map",
    value: function _create_next_map(lv, src) {
      var size = 1 << this._Ï + lv;
      var dst = new Float32Array(size * size);
      var src_pitch = 2 * size;
      var dst_pitch = size;

      for (var j = 0; j < size; ++j) {
        var src_index = 2 * j * src_pitch;
        var dst_index = j * dst_pitch;

        for (var i = 0; i < size; ++i) {
          // æ¨é«ãã¼ã¿ãåãåºã
          var h00 = src[src_index];
          var h10 = src[src_index + 1];
          var h01 = src[src_index + src_pitch];
          var h11 = src[src_index + src_pitch + 1]; // å¹³åæ¨é«ãæ¸ãè¾¼ã

          dst[dst_index] = (h00 + h10 + h01 + h11) / 4;
          src_index += 2;
          dst_index += 1;
        }
      }

      return dst;
    }
    /**
     * @summary å¹³åæ¨é«ãåå¾
     * @desc
     * <p>å°è¡¨æ­ç <zg, xg, yg> ã®å¹³åæ¨é«ãåå¾ããã</p>
     * @param  {number} zg  å°è¡¨æ­çåå²ã¬ãã« (0 <= zg < Ï)
     * @param  {number} xg  å°è¡¨æ­ç X åº§æ¨
     * @param  {number} yg  å°è¡¨æ­ç Y åº§æ¨
     * @return {number}     å¹³åæ¨é«
     */

  }, {
    key: "sample",
    value: function sample(zg, xg, yg) {
      var map = this._maps[this._Ï - zg - 1];
      var size = 1 << zg;
      return map[yg * size + xg];
    }
  }]);

  return AvgHeightMaps;
}();

/**
 * @summary DEM ãã¤ããªã¼ãã¼ã¿
 * @memberof mapray
 * @private
 * @see mapray.DemSampler
 */

var DemBinary =
/*#__PURE__*/
function () {
  /**
   * @param {number}      z      ãºã¼ã ã¬ãã«
   * @param {number}      x      X ã¿ã¤ã«åº§æ¨
   * @param {number}      y      Y ã¿ã¤ã«åº§æ¨
   * @param {number}      Ï     è§£ååº¦ã®ææ°
   * @param {ArrayBuffer} array  DEM éåãã¼ã¿
   */
  function DemBinary(z, x, y, Ï, array) {
    _classCallCheck(this, DemBinary);

    this._z = z;
    this._x = x;
    this._y = y;
    this._Ï = Ï; // ãããã¼æå ±ãåå¾

    var header = new DataView(array);
    this._qlevels = [header.getUint8(DemBinary.OFFSET_QLEVEL_00), // ååå­å¨ã¬ãã« (å·¦ä¸)
    header.getUint8(DemBinary.OFFSET_QLEVEL_10), // ååå­å¨ã¬ãã« (å³ä¸)
    header.getUint8(DemBinary.OFFSET_QLEVEL_01), // ååå­å¨ã¬ãã« (å·¦ä¸)
    header.getUint8(DemBinary.OFFSET_QLEVEL_11) // ååå­å¨ã¬ãã« (å³ä¸)
    ];
    this._hmin = header.getFloat32(DemBinary.OFFSET_HMIN, true); // æå°æ¨é«

    this._hmax = header.getFloat32(DemBinary.OFFSET_HMAX, true); // æå¤§æ¨é«

    this._Ï = this._createÏArray(header); // è¤éåº¦
    // æ¨é«éåã¸ã®åç§ãåå¾

    this._body = new DataView(array, DemBinary.HEADER_BYTES); // æ¨é«éåã® 1 è¡ã®æ¨é«æ°

    this._size = (1 << Ï) + 1;
  }
  /**
   * @summary ãºã¼ã ã¬ãã«
   * @type {number}
   * @readonly
   */


  _createClass(DemBinary, [{
    key: "isLeaf",

    /**
     * @summary å°è¡¨æ­çã«å¯¾ãã¦èã¿ã¤ã«ãï¼
     * @desc
     * <p>å°è¡¨æ­ç [zg, xg, yg] ã«å¯¾ãã¦ãthis ã¯ãµã¼ãã¼åã§æãè©³ç´°ãª DEM ãã¼ã¿ã§ãããã©ãããè¿ãã</p>
     * <p>å¶ç´: [zg, xg, yg] ã®é åã¯ this ã¨åãã¾ãã¯åå«ããã¦ãããã¨ã</p>
     * @param  {number}   zg  åå²ã¬ãã«
     * @param  {number}   xg  X åº§æ¨
     * @param  {number}   yg  Y åº§æ¨
     * @return {boolean}      èã¿ã¤ã«ã®ã¨ã true, ããä»¥å¤ã¯ false
     */
    value: function isLeaf(zg, xg, yg) {
      if (zg > this._z) {
        return this.getQuadLevel(zg, xg, yg) == 0;
      } else {
        var q = this._qlevels;
        return q[0] == 0 || q[1] == 0 || q[2] == 0 || q[3] == 0;
      }
    }
    /**
     * @summary ååå­å¨ã¬ãã«ãåå¾
     * @desc
     * <p>å¶ç´: zg > this.z ãã¤ [zg, xg, yg] ã®é åã¯ this ã«åå«ããã¦ãããã¨ã</p>
     * @param  {number}   zg  åå²ã¬ãã«
     * @param  {number}   xg  X åº§æ¨
     * @param  {number}   yg  Y åº§æ¨
     * @return {number}       ååå­å¨ã¬ãã«
     */

  }, {
    key: "getQuadLevel",
    value: function getQuadLevel(zg, xg, yg) {
      var pow = Math.pow(2, this._z - zg);
      var u = Math.floor(2 * ((xg + 0.5) * pow - this._x));
      var v = Math.floor(2 * ((yg + 0.5) * pow - this._y));
      return this._qlevels[2 * v + u];
    }
    /**
     * @summary ååå­å¨ã¬ãã«ãåå¾
     * @desc
     * <p>åºåºã¿ã¤ã«åº§æ¨ (å·¦ä¸(0, 0)ãå³ä¸(1, 1)) [xt, yt] ãå«ãé åã®ååå­å¨ã¬ãã«ãåå¾ããã</p>
     * <p>å¶ç´: [xt, yt] ã®é åã¯ this ã«åå«ããã¦ãããã¨ã</p>
     * @param  {number} xt  X åº§æ¨
     * @param  {number} yt  Y åº§æ¨
     * @return {number}     ååå­å¨ã¬ãã«
     */

  }, {
    key: "getQuadLevelDirect",
    value: function getQuadLevelDirect(xt, yt) {
      var pow = Math.round(Math.pow(2, this._z + 1));
      var u = GeoMath.clamp(Math.floor(xt * pow), 0, pow - 1) % 2;
      var v = GeoMath.clamp(Math.floor(yt * pow), 0, pow - 1) % 2;
      return this._qlevels[2 * v + u];
    }
    /**
     * @summary æ¨é«ç¹æ­£æ¹å½¢ã®4éã®æ¨é«ãåå¾
     * @desc
     * <p>æ³¨æ: æ¬¡ã®å¼ã³åºãã§ãçµæéåã¯ä¸æ¸ããããã</p>
     * @param  {number} u  æ°´å¹³æ¹åã®æ¨é«ç¹æ­£æ¹å½¢ä½ç½®
     * @param  {number} v  åç´æ¹åã®æ¨é«ç¹æ­£æ¹å½¢ä½ç½®
     * @return {array}     4éã®æ¨é«ã®éå [å·¦ä¸, å³ä¸, å·¦ä¸, å³ä¸]
     */

  }, {
    key: "getHeights",
    value: function getHeights(u, v) {
      var FLT_BYTES = 4;
      var origin = FLT_BYTES * (v * this._size + u);
      var pitch = FLT_BYTES * this._size;
      var h = DemBinary._getHeights_result;
      h[0] = this._body.getFloat32(origin, true);
      h[1] = this._body.getFloat32(origin + FLT_BYTES, true);
      h[2] = this._body.getFloat32(origin + pitch, true);
      h[3] = this._body.getFloat32(origin + pitch + FLT_BYTES, true);
      return h;
    }
    /**
     * @summary å°è¡¨æ­çã®åå²ææ°ãåå¾
     * @desc
     * <p>æ³¨æ: æ¬¡ã®å¼ã³åºãã§ãçµæéåã¯ä¸æ¸ããããã</p>
     *
     * @param  {mapray.Area} flake_area  å°è¡¨æ­çã®é å
     * @param  {number}      lod         å°è¡¨è©³ç´°ã¬ãã« (LOD)
     * @param  {number}      cu          æ°´å¹³çé¢åå²ã¬ãã«
     * @param  {number}      cv          åç´çé¢åå²ã¬ãã«
     *
     * @return {array}  [æ°´å¹³åå²ææ°, åç´åå²ææ°]
     */

  }, {
    key: "getDivisionPowers",
    value: function getDivisionPowers(flake_area, lod, cu, cv) {
      var zg = flake_area.z;
      var ze = this._z;
      var b = GeoMath.LOG2PI - this._Ï + 1; // b = log2Ï - Ï + 1

      var Ï = this._getComplexity(zg, flake_area.x, flake_area.y); // {gu, gv} = max( {cu, cv}, min( ze + Ï, round( lod + b + Ï ) ) â zg )


      var arg = Math.min(ze + this._Ï, Math.round(lod + b + Ï)) - zg;
      var result = DemBinary._getDivisionPowers_result;
      result[0] = Math.max(cu, arg); // æ°´å¹³åå²ææ°

      result[1] = Math.max(cv, arg); // åç´åå²ææ°

      return result;
    }
    /**
     * @summary DEM ãµã³ãã©ã¼ãçæ
     *
     * @param {mapray.Area} flake_area  å°è¡¨æ­çã®é å
     *
     * @return {mapray.DemSampler}  DEM ãµã³ãã©ã¼
     */

  }, {
    key: "newSampler",
    value: function newSampler(flake_area) {
      // ä»ã®ã¨ãããå°è¡¨æ­çã 1 æ¨é«ç¹ã¾ãã¯ããä»¥ä¸ã®ã¨ããæè¿åãµã³ãã©ã¼ã§ãçµæã
      // å¤ãããªãã®ã§ãæé©åã®ããã«ãµã³ãã©ã¼ãå¥ãã¦ãã
      var samplerClass = flake_area.z - this._z > this._Ï ? DemSamplerLinear : DemSamplerNearest;
      return new samplerClass(this, this._Ï, this._body);
    }
    /**
     * @summary ç·å½¢ DEM ãµã³ãã©ã¼ãçæ
     *
     * @return {mapray.DemSamplerLinear}  DEM ãµã³ãã©ã¼
     */

  }, {
    key: "newLinearSampler",
    value: function newLinearSampler() {
      return new DemSamplerLinear(this, this._Ï, this._body);
    }
    /**
     * @summary å¹³åæ¨é«ããããçæ
     * @return {mapray.AvgHeightMaps}  å¹³åæ¨é«ããã
     */

  }, {
    key: "newAvgHeightMaps",
    value: function newAvgHeightMaps() {
      return new AvgHeightMaps(this._Ï, this._body);
    }
    /**
     * @private
     */

  }, {
    key: "_create\u03C9Array",
    value: function _createArray(header) {
      var FLT_BYTES = 4;
      var Ïs = [];
      var offset = 0;

      for (var down = 0; down < 3; ++down) {
        var count = 1 << 2 * down;
        var array = new Float32Array(count);

        for (var i = 0; i < count; ++i) {
          array[i] = header.getFloat32(DemBinary.OFFSET_Ï + offset, true);
          offset += FLT_BYTES;
        }

        Ïs.push(array);
      }

      return Ïs;
    }
    /**
     * @summary è¤éåº¦ãåå¾
     * @desc
     * <p>this ä¸ã®å°è¡¨æ­ç (zg, xg, yg) ã®è¤éåº¦ (Ï) ãåå¾ããã</p>
     * @param  {number}  zg  åå²ã¬ãã«
     * @param  {number}  xg  X åº§æ¨
     * @param  {number}  yg  Y åº§æ¨
     * @return {number}      è¤éåº¦
     * @private
     */

  }, {
    key: "_getComplexity",
    value: function _getComplexity(zg, xg, yg) {
      var d = zg - this._z;
      var p = Math.round(Math.pow(2, d));
      var dmax = 2; // this._Ï.length - 1

      var smax = 4; // 2^c

      var u;
      var v;

      if (d <= dmax) {
        u = xg - p * this._x;
        v = yg - p * this._y;
      } else {
        u = Math.floor(smax * ((xg + 0.5) / p - this._x));
        v = Math.floor(smax * ((yg + 0.5) / p - this._y));
      }

      var index = Math.min(d, dmax);
      var array = this._Ï[index];
      return Math.min(array[v * (1 << index) + u], DemBinary.Ï_limit);
    }
  }, {
    key: "z",
    get: function get() {
      return this._z;
    }
    /**
     * @summary X ã¿ã¤ã«åº§æ¨
     * @type {number}
     * @readonly
     */

  }, {
    key: "x",
    get: function get() {
      return this._x;
    }
    /**
     * @summary Y ã¿ã¤ã«åº§æ¨
     * @type {number}
     * @readonly
     */

  }, {
    key: "y",
    get: function get() {
      return this._y;
    }
    /**
     * @summary æå°æ¨é«
     * @desc
     * <p>ãã®ã¿ã¤ã«ã«å¯¾å¿ããå°è¡¨ã®é åã§æãä½ãç¹ã®æ¨é«ãè¿ãã</p>
     * <p>ãã®å¤ã¯ this ã®èã¿ã¤ã«ã®ãã¼ã¿ã«åºã¥ãã¦ããã®ã§ãthis ã®åãã®ãµã³ãã«å¤ã®æå°å¤ãããå°ããå¤ã®å¯è½æ§ããããã¨ã«æ³¨æããããã</p>
     * @type {number}
     * @readonly
     */

  }, {
    key: "height_min",
    get: function get() {
      return this._hmin;
    }
    /**
     * @summary æå¤§æ¨é«
     * <p>ãã®ã¿ã¤ã«ã«å¯¾å¿ããå°è¡¨ã®é åã§æãé«ãç¹ã®æ¨é«ãè¿ãã</p>
     * <p>ãã®å¤ã¯ this ã®èã¿ã¤ã«ã®ãã¼ã¿ã«åºã¥ãã¦ããã®ã§ãthis ã®åãã®ãµã³ãã«å¤ã®æå¤§å¤ãããå¤§ããå¤ã®å¯è½æ§ããããã¨ã«æ³¨æããããã</p>
     * @type {number}
     * @readonly
     */

  }, {
    key: "height_max",
    get: function get() {
      return this._hmax;
    }
  }]);

  return DemBinary;
}();

DemBinary.OFFSET_QLEVEL_00 = 0;
DemBinary.OFFSET_QLEVEL_10 = 1;
DemBinary.OFFSET_QLEVEL_01 = 2;
DemBinary.OFFSET_QLEVEL_11 = 3;
DemBinary.OFFSET_HMIN = 4;
DemBinary.OFFSET_HMAX = 8;
DemBinary.OFFSET_Ï = 12;
DemBinary.HEADER_BYTES = 96;
DemBinary.Ï_limit = 6;
DemBinary._getHeights_result = new Array(4);
DemBinary._getDivisionPowers_result = new Array(2);

// https://tc39.github.io/ecma262/#sec-typedarray-objects

typedArrayConstructor('Int16', function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// https://tc39.github.io/ecma262/#sec-typedarray-objects

typedArrayConstructor('Int32', function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/**
 * @summary å°è¡¨é åã¦ã¼ãã£ãªãã£ã¼
 *
 * @hideconstructor
 * @memberof mapray
 * @private
 */

var AreaUtil =
/*#__PURE__*/
function () {
  function AreaUtil() {
    _classCallCheck(this, AreaUtil);
  }

  _createClass(AreaUtil, null, [{
    key: "getCenter",

    /**
     * @summary å°è¡¨é åã®ä¸­å¿ä½ç½®ã GOCS ã§åå¾
     *
     * @desc
     * <p>é å area ã®ä¸­å¿ä½ç½® (GOCS) ã dst ã«æ ¼ç´ããã</p>
     *
     * @param {mapray.Area}    area  å°è¡¨é å
     * @param {mapray.Vector3} dst   çµæãæ ¼ç´ãããªãã¸ã§ã¯ã (GOCS)
     *
     * @return {mapray.Vector3} dst
     */
    value: function getCenter(area, dst) {
      switch (area.z) {
        case 0:
          return getCenter_0(dst);

        case 1:
          return getCenter_1(area.x, area.y, dst);

        default:
          return getCenter_N(area.z, area.x, area.y, dst);
      }
    }
  }]);

  return AreaUtil;
}();
/**
 * @summary å°è¡¨ã® ZXY é åãè¡¨ç¾
 *
 * @desc
 * <p>ãã®ã¯ã©ã¹ã¯ä¾¿å®çãªãã®ã§ããå®å¨ããªãã</p>
 * <p>z, x, y ãã­ããã£ããå°è¡¨ã®é åãè¡¨ã ZXY åº§æ¨ãèª­ã¿åºãããªãã¸ã§ã¯ãã¯ããã®ã¯ã©ã¹ã®ã¤ã³ã¹ã¿ã³ã¹ã¨è§£éããã</p>
 *
 * @class mapray.Area
 * @private
 *
 * @see mapray.AreaUtil
 */
// AreaUtil.getCenter() ã®ä¸é¨


function getCenter_0(dst) {
  dst[0] = 0;
  dst[1] = 0;
  dst[2] = 0;
  return dst;
} // AreaUtil.getCenter() ã®ä¸é¨


function getCenter_1(x, y, dst) {
  var r = GeoMath.EARTH_RADIUS;
  dst[0] = 0;
  dst[1] = r * (x - 0.5);
  dst[2] = r * (0.5 - y);
  return dst;
} // AreaUtil.getCenter() ã®ä¸é¨


function getCenter_N(z, x, y, dst) {
  var pi = Math.PI; // åº§æ¨ç¯å² (åä½çã¡ã«ã«ãã«åº§æ¨ç³»)

  var msize = Math.pow(2, 1 - z) * pi;
  var mx_min = -pi + x * msize;
  var mx_max = -pi + (x + 1) * msize;
  var my_min = pi - (y + 1) * msize;
  var my_max = pi - y * msize; // äºåè¨ç®å¤æ°

  var Î»min = mx_min;
  var Î»max = mx_max;
  var emin = Math.exp(my_min); // Exp[my_min]

  var emax = Math.exp(my_max); // Exp[my_max]

  var e2min = emin * emin; // Exp[my_min]^2

  var e2max = emax * emax; // Exp[my_max]^2
  // åº§æ¨ç¯å² (å°å¿ç´äº¤åº§æ¨ç³»)
  //
  // z >= 2 ã®ã¨ããÎ»ã¨Ïã®ç¯å²ã¯ä»¥ä¸ã®åºéã®ã©ããã«å¥ã
  //   Ï:                (-Ï/2, 0] [0, Ï/2)
  //   Î»:   [-Ï, -Ï/2] [-Ï/2, 0] [0, Ï/2] [Ï/2, Ï]
  //
  // åºéãã¨ã®é¢æ°ã®å¤å (ååºéã§åèª¿å¢å ã¾ãã¯åèª¿æ¸å°)
  //   Sin[Ï]:            (-1 â 0] [0 â 1)
  //   Cos[Ï]:            ( 0 â 1] [1 â 0)
  //   Sin[Î»]: [ 0 â -1] [-1 â 0] [0 â 1] [1 â  0]
  //   Cos[Î»]: [-1 â  0] [ 0 â 1] [1 â 0] [0 â -1]

  var rh = GeoMath.EARTH_RADIUS / 2;
  var cosÏmin = 2 * emin / (e2min + 1);
  var cosÏmax = 2 * emax / (e2max + 1); // gx = r Cos[Ï] Cos[Î»]
  // gy = r Cos[Ï] Sin[Î»]

  if (my_min + my_max < 0) {
    //     Ï : (-Ï/2, 0]
    // Cos[Ï]: ( 0 â  1]
    if (Î»min + Î»max < -pi) {
      //     Î» : [-Ï, -Ï/2]
      // Cos[Î»]: [-1  â   0]
      // Sin[Î»]: [ 0  â  -1]
      dst[0] = rh * (cosÏmax * Math.cos(Î»min) + cosÏmin * Math.cos(Î»max));
      dst[1] = rh * (cosÏmax * Math.sin(Î»max) + cosÏmin * Math.sin(Î»min));
    } else if (Î»min + Î»max < 0) {
      //     Î» : [-Ï/2, 0]
      // Cos[Î»]: [ 0  â 1]
      // Sin[Î»]: [-1  â 0]
      dst[0] = rh * (cosÏmin * Math.cos(Î»min) + cosÏmax * Math.cos(Î»max));
      dst[1] = rh * (cosÏmax * Math.sin(Î»min) + cosÏmin * Math.sin(Î»max));
    } else if (Î»min + Î»max < pi) {
      //     Î» : [0, Ï/2]
      // Cos[Î»]: [1  â 0]
      // Sin[Î»]: [0  â 1]
      dst[0] = rh * (cosÏmin * Math.cos(Î»max) + cosÏmax * Math.cos(Î»min));
      dst[1] = rh * (cosÏmin * Math.sin(Î»min) + cosÏmax * Math.sin(Î»max));
    } else {
      //     Î» : [Ï/2, Ï]
      // Cos[Î»]: [0  â -1]
      // Sin[Î»]: [1  â  0]
      dst[0] = rh * (cosÏmax * Math.cos(Î»max) + cosÏmin * Math.cos(Î»min));
      dst[1] = rh * (cosÏmin * Math.sin(Î»max) + cosÏmax * Math.sin(Î»min));
    }
  } else {
    //     Ï : [0, Ï/2)
    // Cos[Ï]: [1  â 0)
    if (Î»min + Î»max < -pi) {
      //     Î» : [-Ï, -Ï/2]
      // Cos[Î»]: [-1  â   0]
      // Sin[Î»]: [ 0  â  -1]
      dst[0] = rh * (cosÏmin * Math.cos(Î»min) + cosÏmax * Math.cos(Î»max));
      dst[1] = rh * (cosÏmin * Math.sin(Î»max) + cosÏmax * Math.sin(Î»min));
    } else if (Î»min + Î»max < 0) {
      //     Î» : [-Ï/2, 0]
      // Cos[Î»]: [ 0  â 1]
      // Sin[Î»]: [-1  â 0]
      dst[0] = rh * (cosÏmax * Math.cos(Î»min) + cosÏmin * Math.cos(Î»max));
      dst[1] = rh * (cosÏmin * Math.sin(Î»min) + cosÏmax * Math.sin(Î»max));
    } else if (Î»min + Î»max < pi) {
      //     Î» : [0, Ï/2]
      // Cos[Î»]: [1  â 0]
      // Sin[Î»]: [0  â 1]
      dst[0] = rh * (cosÏmax * Math.cos(Î»max) + cosÏmin * Math.cos(Î»min));
      dst[1] = rh * (cosÏmax * Math.sin(Î»min) + cosÏmin * Math.sin(Î»max));
    } else {
      //     Î» : [Ï/2, Ï]
      // Cos[Î»]: [0  â -1]
      // Sin[Î»]: [1  â  0]
      dst[0] = rh * (cosÏmin * Math.cos(Î»max) + cosÏmax * Math.cos(Î»min));
      dst[1] = rh * (cosÏmax * Math.sin(Î»max) + cosÏmin * Math.sin(Î»min));
    }
  } // rh * (Sin[Ïmin] + Sin[Ïmax])


  dst[2] = rh * 2 * (e2max / (e2max + 1) - 1 / (e2min + 1));
  return dst;
}

/**
 * @summary å°è¡¨æ­çã¡ãã·ã¥
 * @memberof mapray
 * @private
 */

var FlakeMesh =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.GLEnv}     glenv  WebGL ç°å¢
   * @param {mapray.Area}      area   å°è¡¨æ­çã®é å
   * @param {number[]}         dpows  å°è¡¨æ­çã®åå²ææ°
   * @param {mapray.DemBinary} dem    DEM ãã¤ããª
   */
  function FlakeMesh(glenv, area, dpows, dem) {
    _classCallCheck(this, FlakeMesh);

    var gl = glenv.context; // ãªãã¸ã§ã¯ãåº§æ¨ç³»ã®ä¸­å¿ä½ç½® (GOCS)

    this._center = this._createCenter(area); // é ç¹ãããã¡

    this._vertices = null; // é ç¹æ°

    this._num_vertices = 0; // é ç¹å±æ§è¾æ¸

    this._vertex_attribs = {}; // XY ã°ãªãããµã¤ãº

    this._num_quads_x = 0;
    this._num_quads_y = 0; // é ç¹ãã¼ã¿ãçæ

    this._createVertices(gl, area, dpows, dem); // é ç¹å±æ§è¾æ¸ãè¨­å®


    this._setupVertexAttribs(gl); // ã¤ã³ããã¯ã¹å


    this._index_type = this._num_vertices < 65536 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT; // ã¤ã³ããã¯ã¹ (GL_TRIANGLES)

    this._indices = null;
    this._num_indices = 0; // ã¤ã³ããã¯ã¹ (GL_LINES)

    this._wire_indices = null;
    this._num_wire_indices = 0;
    this._gl = gl;
  }
  /**
   * @summary ä¸­å¿ä½ç½®ãçæ
   *
   * @param {mapray.Area} area  å°è¡¨æ­çã®é å
   *
   * @return {mapray.Vector3}  ä¸­å¿ä½ç½® (GOCS)
   *
   * @private
   */


  _createClass(FlakeMesh, [{
    key: "_createCenter",
    value: function _createCenter(area) {
      return AreaUtil.getCenter(area, GeoMath.createVector3());
    }
  }, {
    key: "_createVertices",
    value: function _createVertices(gl, area, dpows, dem) {
      var target = gl.ARRAY_BUFFER;
      var vbo = gl.createBuffer();

      var data = this._createVerticesData(area, dpows, dem);

      gl.bindBuffer(target, vbo);
      gl.bufferData(target, data.array, gl.STATIC_DRAW);
      gl.bindBuffer(target, null);
      this._vertices = vbo;
      this._num_vertices = data.num_vertices;
      this._num_quads_x = data.num_quads_x;
      this._num_quads_y = data.num_quads_y;
    }
  }, {
    key: "_createVerticesData",
    value: function _createVerticesData(area, dpows, dem) {
      // éå§ä½ç½® (åä½çã¡ã«ã«ãã«åº§æ¨ç³»)
      var msize = Math.pow(2, 1 - area.z) * Math.PI;
      var mx_min = area.x * msize - Math.PI;
      var my_min = Math.PI - (area.y + 1) * msize; // åå²æ°

      var u_count = 1 << dpows[0];
      var v_count = 1 << dpows[1]; // å»ã¿å¹

      var u_step = 1 / u_count;
      var v_step = 1 / v_count;
      var mx_step = msize / u_count;
      var my_step = msize / v_count;
      var center = this._center;
      var demSampler = dem.newSampler(area);
      var num_vertices = (u_count + 1) * (v_count + 1);
      var array = new Float32Array(FlakeMesh.VERTEX_SIZE * num_vertices);
      var index = 0;

      for (var iv = 0, my = my_min; iv < v_count + 1; ++iv, my += my_step) {
        var ey = Math.exp(my);
        var ey2 = ey * ey;
        var sinÏ = (ey2 - 1) / (ey2 + 1);
        var cosÏ = 2 * ey / (ey2 + 1);

        for (var iu = 0, mx = mx_min; iu < u_count + 1; ++iu, mx += mx_step) {
          var sinÎ» = Math.sin(mx);
          var cosÎ» = Math.cos(mx);
          var height = demSampler.sample(mx, my);
          var radius = GeoMath.EARTH_RADIUS + height; // æ³ç· (GOCS)

          var nx = cosÏ * cosÎ»;
          var ny = cosÏ * sinÎ»;
          var nz = sinÏ; // ä½ç½® (GOCS)

          var gx = radius * nx;
          var gy = radius * ny;
          var gz = radius * nz;
          array[index++] = gx - center[0]; // x

          array[index++] = gy - center[1]; // y

          array[index++] = gz - center[2]; // z

          array[index++] = nx; // nx

          array[index++] = ny; // ny

          array[index++] = nz; // nz

          array[index++] = iu * u_step; // mu

          array[index++] = iv * v_step; // mv
        }
      }

      return {
        array: array,
        num_vertices: num_vertices,
        num_quads_x: u_count,
        num_quads_y: v_count
      };
    }
    /**
     * @summary é ç¹å±æ§ã®è¾æ¸ãè¨­å®
     * @desc
     * <p>this._vertex_attribs ã« Mesh.AttribData ã®è¾æ¸ãè¨­å®ããã</p>
     *
     * @param {WebGLRenderingContext} gl
     * @private
     */

  }, {
    key: "_setupVertexAttribs",
    value: function _setupVertexAttribs(gl) {
      var type = gl.FLOAT;
      var stride = FlakeMesh.VERTEX_BYTES; // Mesh.AttribData ã®è¾æ¸

      this._vertex_attribs = {
        "a_position": {
          buffer: this._vertices,
          num_components: 3,
          component_type: type,
          normalized: false,
          byte_stride: stride,
          byte_offset: FlakeMesh.OFFSET_P
        },
        "a_normal": {
          buffer: this._vertices,
          num_components: 3,
          component_type: type,
          normalized: false,
          byte_stride: stride,
          byte_offset: FlakeMesh.OFFSET_N
        },
        "a_uv": {
          buffer: this._vertices,
          num_components: 2,
          component_type: type,
          normalized: false,
          byte_stride: stride,
          byte_offset: FlakeMesh.OFFSET_UV
        }
      };
    }
  }, {
    key: "_createIndices",
    value: function _createIndices() {
      var gl = this._gl;
      var num_quads = this._num_quads_x * this._num_quads_y;
      var num_indices = 6 * num_quads;
      var typedArray = this._index_type === gl.UNSIGNED_INT ? Int32Array : Int16Array;
      var array = new typedArray(num_indices);
      var index = 0;

      for (var y = 0; y < this._num_quads_y; ++y) {
        for (var x = 0; x < this._num_quads_x; ++x) {
          var i00 = (this._num_quads_x + 1) * y + x; // å·¦ä¸é ç¹

          var i10 = i00 + 1; // å³ä¸é ç¹

          var i01 = i00 + this._num_quads_x + 1; // å·¦ä¸é ç¹

          var i11 = i01 + 1; // å³ä¸é ç¹
          // å·¦ä¸ä¸è§å½¢

          array[index++] = i00;
          array[index++] = i10;
          array[index++] = i01; // å³ä¸ä¸è§å½¢

          array[index++] = i01;
          array[index++] = i10;
          array[index++] = i11;
        }
      }

      var target = gl.ELEMENT_ARRAY_BUFFER;
      var vbo = gl.createBuffer();
      gl.bindBuffer(target, vbo);
      gl.bufferData(target, array, gl.STATIC_DRAW);
      gl.bindBuffer(target, null);
      this._indices = vbo;
      this._num_indices = num_indices;
    }
  }, {
    key: "_createWireIndices",
    value: function _createWireIndices() {
      var gl = this._gl;
      var typedArray = this._index_type === gl.UNSIGNED_INT ? Int32Array : Int16Array;
      var num_indices = 2 * (2 * this._num_quads_x * this._num_quads_y + this._num_quads_x + this._num_quads_y);
      var array = new typedArray(num_indices);
      var index = 0; // æ°´å¹³ç·

      for (var y = 0; y < this._num_quads_y + 1; ++y) {
        for (var x = 0; x < this._num_quads_x; ++x) {
          var i00 = (this._num_quads_x + 1) * y + x; // å·¦ä¸é ç¹

          var i10 = i00 + 1; // å³ä¸é ç¹
          // ä¸æ°´å¹³ç·

          array[index++] = i00;
          array[index++] = i10;
        }
      } // åç´ç·


      for (x = 0; x < this._num_quads_x + 1; ++x) {
        for (y = 0; y < this._num_quads_y; ++y) {
          var j00 = (this._num_quads_x + 1) * y + x; // å·¦ä¸é ç¹

          var j01 = j00 + this._num_quads_x + 1; // å·¦ä¸é ç¹
          // å·¦åç´ç·

          array[index++] = j00;
          array[index++] = j01;
        }
      }

      var target = gl.ELEMENT_ARRAY_BUFFER;
      var vbo = gl.createBuffer();
      gl.bindBuffer(target, vbo);
      gl.bufferData(target, array, gl.STATIC_DRAW);
      gl.bindBuffer(target, null);
      this._wire_indices = vbo;
      this._num_wire_indices = num_indices;
    }
    /**
     *  @summary é ç¹æ°
     *  @type {number}
     *  @readonly
     */

  }, {
    key: "dispose",

    /**
     * @summary ãªã½ã¼ã¹ãç ´æ£
     */
    value: function dispose() {
      var gl = this._gl;
      this._vertex_attribs = {};
      gl.deleteBuffer(this._vertices);
      this._vertices = null;

      if (this._indices) {
        gl.deleteBuffer(this._indices);
        this._indices = null;
      }

      if (this._wire_indices) {
        gl.deleteBuffer(this._wire_indices);
        this._wire_indices = null;
      }
    }
    /** 
     * @summary å¤æè¡åãè¨ç®
     * @desc
     * mat ã«å°è¡¨æ­çåº§æ¨ç³»ãã GOCS ã¸ã®å¤æè¡åãæããã
     * @param  {mapray.Matrix} mat  è¡å
     * @param  {mapray.Matrix} dst  çµæ
     * @return {mapray.Matrix}      dst
     */

  }, {
    key: "mul_flake_to_gocs",
    value: function mul_flake_to_gocs(mat, dst) {
      var m00 = mat[0],
          m01 = mat[4],
          m02 = mat[8],
          m03 = mat[12],
          m10 = mat[1],
          m11 = mat[5],
          m12 = mat[9],
          m13 = mat[13],
          m20 = mat[2],
          m21 = mat[6],
          m22 = mat[10],
          m23 = mat[14],
          m30 = mat[3],
          m31 = mat[7],
          m32 = mat[11],
          m33 = mat[15];
      var t03 = this._center[0],
          t13 = this._center[1],
          t23 = this._center[2];
      dst[0] = m00;
      dst[1] = m10;
      dst[2] = m20;
      dst[3] = m30;
      dst[4] = m01;
      dst[5] = m11;
      dst[6] = m21;
      dst[7] = m31;
      dst[8] = m02;
      dst[9] = m12;
      dst[10] = m22;
      dst[11] = m32;
      dst[12] = m00 * t03 + m01 * t13 + m02 * t23 + m03;
      dst[13] = m10 * t03 + m11 * t13 + m12 * t23 + m13;
      dst[14] = m20 * t03 + m21 * t13 + m22 * t23 + m23;
      dst[15] = m30 * t03 + m31 * t13 + m32 * t23 + m33;
      return dst;
    }
    /**
     * @summary ã¡ãã·ã¥ãæç»
     * @desc
     * <p>äºåã« material.bindProgram() ãããã¨ã</p>
     * @param  {mapray.RenderStage.FlakeMaterial} material  ãããªã¢ã«
     */

  }, {
    key: "draw",
    value: function draw(material) {
      var gl = this._gl;
      var isWire = material.isWireframe(); // é ç¹å±æ§ã®ãã¤ã³ã

      material.bindVertexAttribs(this._vertex_attribs); // ã¤ã³ããã¯ã¹ã®ãã¤ã³ã

      var indices = isWire ? this.wire_indices : this.indices;
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices); // æç»å¦ç

      var mode = isWire ? gl.LINES : gl.TRIANGLES;
      var num_indices = isWire ? this.num_wire_indices : this.num_indices;
      gl.drawElements(mode, num_indices, this._index_type, 0);
    }
  }, {
    key: "num_vertices",
    get: function get() {
      return this._num_vertices;
    }
    /**
     *  @summary ã¤ã³ããã¯ã¹ (GL_TRIANGLES)
     *  @type {WebGLBuffer}
     *  @readonly
     */

  }, {
    key: "indices",
    get: function get() {
      if (this._indices === null) {
        this._createIndices();
      }

      return this._indices;
    }
    /**
     *  @summary ã¤ã³ããã¯ã¹æ° (GL_TRIANGLES)
     *  @type {number}
     *  @readonly
     */

  }, {
    key: "num_indices",
    get: function get() {
      if (this._indices === null) {
        this._createIndices();
      }

      return this._num_indices;
    }
    /**
     *  @summary ã¤ã³ããã¯ã¹ (GL_LINES)
     *  @type {WebGLBuffer}
     *  @readonly
     */

  }, {
    key: "wire_indices",
    get: function get() {
      if (this._wire_indices === null) {
        this._createWireIndices();
      }

      return this._wire_indices;
    }
    /**
     *  @summary ã¤ã³ããã¯ã¹æ° (GL_LINES)
     *  @type {number}
     *  @readonly
     */

  }, {
    key: "num_wire_indices",
    get: function get() {
      if (this._wire_indices === null) {
        this._createWireIndices();
      }

      return this._num_wire_indices;
    }
  }]);

  return FlakeMesh;
}(); // ã¯ã©ã¹å®æ°ã®å®ç¾©


{
  FlakeMesh.VERTEX_SIZE = 8; // 1é ç¹ã® float æ°

  /**
   * @summary 1é ç¹ã®ãã¤ãæ°
   * @member mapray.FlakeMesh.VERTEX_BYTES
   * @type {number}
   * @static
   * @constant
   */

  FlakeMesh.VERTEX_BYTES = 4 * FlakeMesh.VERTEX_SIZE;
  /**
   * @summary ä½ç½®åº§æ¨ã®ãªãã»ãã
   * @member mapray.FlakeMesh.OFFSET_P
   * @type {number}
   * @static
   * @constant
   */

  FlakeMesh.OFFSET_P = 0;
  /**
   * @summary æ³ç·åº§æ¨ã®ãªãã»ãã
   * @member mapray.FlakeMesh.OFFSET_N
   * @type {number}
   * @static
   * @constant
   */

  FlakeMesh.OFFSET_N = 12;
  /**
   * @summary UV åº§æ¨ã®ãªãã»ãã
   * @member mapray.FlakeMesh.OFFSET_UV
   * @type {number}
   * @static
   * @constant
   */

  FlakeMesh.OFFSET_UV = 24;
}

/**
 * @summary æç»ããªããã£ã
 * @memberof mapray
 * @private
 * @see mapray.PropSet
 * @see mapray.Entity#getPrimitives
 */

var Primitive =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.GLEnv}          glenv      WebGL ç°å¢
   * @param {mapray.Mesh}           mesh       ã¡ãã·ã¥
   * @param {mapray.EntityMaterial} material   ãããªã¢ã«
   * @param {mapray.Matrix}         transform  å¤æè¡å
   */
  function Primitive(glenv, mesh, material, transform) {
    _classCallCheck(this, Primitive);

    this._glenv = glenv;
    /**
     * @summary æç»ãããã¡ãã·ã¥
     * @desc
     * <p>æ§ç¯å­ã® mesh å¼æ°ãè¨­å®ããã¦ããã</p>
     * @member mapray.Primitive#mesh
     * @type {mapray.Mesh}
     */

    this.mesh = mesh;
    /**
     * @summary æç»ã«ä½¿ç¨ãããããªã¢ã«
     * @desc
     * <p>æ§ç¯å­ã® material å¼æ°ãè¨­å®ããã¦ããã</p>
     * @member mapray.Primitive#material
     * @type {mapray.EntityMaterial}
     */

    this.material = material;
    /**
     * @summary ã¢ãã«åº§æ¨ç³»ãã GOCS ã¸ã®å¤æè¡å
     * @desc
     * <p>æ§ç¯å­ã® transform å¼æ°ãè¨­å®ããã¦ããã</p>
     * @member mapray.Primitive#transform
     * @type {mapray.Matrix}
     */

    this.transform = transform;
    /**
     * @summary ä¸­å¿ç¹ (ã¢ãã«åº§æ¨ç³»)
     * @desc
     * <p>null ã®ã¨ãã¯é¶ãã¯ãã«ã¨è¦ãªãã</p>
     * @member mapray.Primitive#pivot
     * @type {?mapray.Vector3}
     * @default null
     */

    this.pivot = null;
    /**
     * @summary å¢çç®± (ã¢ãã«åº§æ¨ç³»)
     * @desc
     * <p>bbox[0] ã¯åº§æ¨ã®æå°å¤ãbbox[1] ã¯åº§æ¨ã®æå¤§å¤ã¨ããã</p>
     * <p>null ã®ã¨ãã¯ç¡éå¤§ã®å¢çç®±ã¨è¦ãªãã</p>
     * @member mapray.Primitive#bbox
     * @type {?Array.<mapray.Vector3>}
     * @default null
     */

    this.bbox = null;
    /**
     * @summary ãã­ããã£éå
     * @desc
     * <p>null ã®ã¨ãã¯ç©ºéåã¨è¦ãªãã</p>
     * @member mapray.Primitive#properties
     * @type {?mapray.PropSet}
     * @default null
     */

    this.properties = null;
    /**
     * @summary ã½ã¼ãæ·±åº¦
     * @member mapray.Primitive#sort_z
     * @type {number}
     * @readonly
     * @package
     */

    this.sort_z = undefined;
  }
  /**
   * @summary ã¤ã³ã¹ã¿ã³ã¹ã®è¤è£½ãè¿ã
   *
   * @desc
   * <p>å¬éãã­ããã£ã this ã¨åãã¤ã³ã¹ã¿ã³ã¹ãçæãã¦è¿ãã</p>
   * <p>ãã ããã­ããã£ mesh, material, properties ã¯åç§ã³ãã¼ã§ãããä»¥å¤ã¯æ·±ãã³ãã¼ã¨ãªãã</p>
   *
   * @return {mapray.Primitive}  ã¤ã³ã¹ã¿ã³ã¹ã®è¤è£½
   */


  _createClass(Primitive, [{
    key: "fastClone",
    value: function fastClone() {
      var clone = new Primitive(this._glenv, this.mesh, this.material, GeoMath.createMatrix(this.transform));

      if (this.pivot) {
        clone.pivot = GeoMath.createVector3(this.pivot);
      }

      if (this.bbox) {
        clone.bbox = this.bbox.map(function (v) {
          return GeoMath.createVector3(v);
        });
      }

      clone.properties = this.properties;
      return clone;
    }
    /**
     * @summary ããªããã£ããè¦ãããï¼
     * @desc
     * <p>true ãè¿ããã¨ãã¯ã½ã¼ãæ·±åº¦ this.sort_z ãè¨­å®ãããã</p>
     * @param  {mapray.RenderStage} stage  ã¬ã³ããªã³ã°ã¹ãã¼ã¸
     * @return {boolean}                   ããªããã£ãã®ä¸é¨ãè¦ä½ç©ã«å«ã¾ããã¨ã true, ããä»¥å¤ã®ã¨ã false
     * @package
     */

  }, {
    key: "isVisible",
    value: function isVisible(stage) {
      // obj_to_view = stage._gocs_to_view * this.transform
      var matrix = Primitive._obj_to_view;
      GeoMath.mul_AA(stage._gocs_to_view, this.transform, matrix);
      var bbox = this.bbox;

      if (bbox) {
        // å¢çç®±ã®é ç¹åº§æ¨ãå¤æ (è¦ç¹ç©ºé) -> bbox_points
        Primitive._transformBBox(bbox, matrix); // è¦ä½ç©å¹³é¢ã¨æ¯è¼


        var planes = stage._volume_planes;

        for (var i = 0; i < planes.length; ++i) {
          if (Primitive._isBBoxBackSide(planes[i])) {
            // å®å¨ã«è¦ä½ç©ã«å«ã¾ããªã
            return false;
          }
        }
      } // ã½ã¼ãæ·±åº¦ãè¨­å®


      var pivot = this.pivot;

      if (pivot) {
        this.sort_z = matrix[2] * pivot[0] + matrix[6] * pivot[1] + matrix[10] * pivot[2] + matrix[14];
      } else {
        this.sort_z = matrix[14];
      }

      return true;
    }
    /**
     * @summary èæ¯ã¨ã®æ··åãå¿è¦ãï¼
     * @param  {mapray.RenderStage} stage  ã¬ã³ããªã³ã°ã¹ãã¼ã¸
     * @return {boolean}                   èæ¯ã¨ã®æ··åãå¿è¦ãªã¨ã true, ããä»¥å¤ã®ã¨ã false
     * @package
     */

  }, {
    key: "isTranslucent",
    value: function isTranslucent(stage) {
      return this.material.isTranslucent(stage, this);
    }
    /**
     * @summary ããªããã£ããæç»
     * @param {mapray.RenderStage} stage  ã¬ã³ããªã³ã°ã¹ãã¼ã¸
     */

  }, {
    key: "draw",
    value: function draw(stage) {
      var material = this.material;
      material.bindProgram();
      material.setParameters(stage, this);
      this.mesh.draw(material);
    }
    /**
     * å¢çç®±ã®é ç¹åº§æ¨ãå¤æ (è¦ç¹ç©ºé) -> bbox_points
     * @private
     */

  }], [{
    key: "_transformBBox",
    value: function _transformBBox(bbox, matrix) {
      for (var iz = 0; iz < 2; ++iz) {
        var zm = bbox[iz][2];

        for (var iy = 0; iy < 2; ++iy) {
          var ym = bbox[iy][1];

          for (var ix = 0; ix < 2; ++ix) {
            var xm = bbox[ix][0];
            var bbox_point = Primitive._bbox_points[ix + 2 * iy + 4 * iz];
            bbox_point[0] = matrix[0] * xm + matrix[4] * ym + matrix[8] * zm + matrix[12];
            bbox_point[1] = matrix[1] * xm + matrix[5] * ym + matrix[9] * zm + matrix[13];
            bbox_point[2] = matrix[2] * xm + matrix[6] * ym + matrix[10] * zm + matrix[14];
          }
        }
      }
    }
    /**
     * bbox_points ã¯ãã¹ã¦ plane ã®è£å´ãï¼
     * @private
     */

  }, {
    key: "_isBBoxBackSide",
    value: function _isBBoxBackSide(plane) {
      var bbox_points = Primitive._bbox_points;

      for (var i = 0; i < bbox_points.length; ++i) {
        var point = bbox_points[i];
        var dist = point[0] * plane[0] + point[1] * plane[1] + point[2] * plane[2] + plane[3];

        if (dist >= 0) {
          // è¡¨å´ã«é ç¹ãå­å¨
          return false;
        }
      }

      return true; // ãã¹ã¦ã®é ç¹ãè£å´
    }
  }]);

  return Primitive;
}(); // ã¯ã©ã¹å®æ°ã®å®ç¾©


{
  // ä¸æé å
  Primitive._obj_to_view = GeoMath.createMatrix(); // ã¢ãã«ç©ºéããè¦ç¹ç©ºéã¸ã®å¤æè¡å

  Primitive._bbox_points = []; // å¢çç®±ã®é ç¹åº§æ¨ (è¦ç¹ç©ºé)

  for (var i = 0; i < 8; ++i) {
    Primitive._bbox_points.push(GeoMath.createVector3());
  }
}

/**
 * @summary å°è¡¨æ­çã¬ã³ããªã³ã°ããã®ãªãã¸ã§ã¯ã
 *
 * @memberof mapray
 * @private
 */

var FlakeRenderObject =
/*#__PURE__*/
function () {
  /**
   * @param {mapary.Area}      area       å°è¡¨æ­çã®é å
   * @param {mapary.GLEnv}     glenv      WebGL ç°å¢
   * @param {mapray.FlakeMesh} base_mesh  å°è¡¨æ­çã®åºæ¬ã¡ãã·ã¥
   */
  function FlakeRenderObject(area, glenv, base_mesh) {
    _classCallCheck(this, FlakeRenderObject);

    /**
     * @summary å°è¡¨åå²ã¬ãã«
     * @member mapray.FlakeRenderObject#z
     * @type {number}
     */
    this.z = area.z;
    /**
     * @summary å°è¡¨ã¿ã¤ã« X åº§æ¨
     * @member mapray.FlakeRenderObject#x
     * @type {number}
     */

    this.x = area.x;
    /**
     * @summary å°è¡¨ã¿ã¤ã« Y åº§æ¨
     * @member mapray.FlakeRenderObject#y
     * @type {number}
     */

    this.y = area.y;
    this._glenv = glenv;
    this._base_mesh = base_mesh;
    this._edata_list = []; //  { mesh: Mesh, producer: FlakePrimitiveProducer }

    this._transform = null;
  }
  /**
   * @summary ã¨ã³ãã£ãã£ã»ãã¼ã¿ãè¿½å 
   *
   * @param {mapray.Mesh} mesh
   * @param {mapray.Entity.FlakePrimitiveProducer} producer
   */


  _createClass(FlakeRenderObject, [{
    key: "addEntityData",
    value: function addEntityData(mesh, producer) {
      var edata = {
        mesh: mesh,
        producer: producer
      };

      this._edata_list.push(edata);
    }
    /**
     * @summary å°è¡¨æ­çä¸ã®ã¨ã³ãã£ãã£æ°
     *
     * @type {number}
     * @readonly
     */

  }, {
    key: "getBaseMesh",

    /**
     * @summary å°è¡¨æ­çã®åºæ¬ã¡ãã·ã¥ãåå¾
     *
     * @return {mapray.FlakeMesh}
     */
    value: function getBaseMesh() {
      return this._base_mesh;
    }
    /**
     * @summary ã¨ã³ãã£ãã£ã®ããªããã£ããåå¾
     *
     * @param {number}             index  ã¨ã³ãã£ãã£ã®ã¤ã³ããã¯ã¹
     * @param {mapray.RenderStage} stage  ã¬ã³ããªã³ã°ã¹ãã¼ã¸
     *
     * @return {mapray.FlakeRenderObject.EntityPrimitivePair}
     */

  }, {
    key: "getEntityPrimitive",
    value: function getEntityPrimitive(index, stage) {
      var edata = this._edata_list[index];

      var _edata$producer$getMa = edata.producer.getMaterialAndProperties(stage),
          material = _edata$producer$getMa.material,
          properties = _edata$producer$getMa.properties; // this._transform ãè¨­å®


      if (this._transform === null) {
        this._transform = GeoMath.setIdentity(GeoMath.createMatrix());
        var pos = AreaUtil.getCenter(this, GeoMath.createVector3());
        this._transform[12] = pos[0];
        this._transform[13] = pos[1];
        this._transform[14] = pos[2];
      }

      var primitive = new Primitive(this._glenv, edata.mesh, material, this._transform);
      primitive.properties = properties;
      return {
        entity: edata.producer.entity,
        primitive: primitive
      };
    }
  }, {
    key: "num_entities",
    get: function get() {
      return this._edata_list.length;
    }
  }]);

  return FlakeRenderObject;
}();

// https://tc39.github.io/ecma262/#sec-array.prototype.fill

_export({
  target: 'Array',
  proto: true
}, {
  fill: arrayFill
}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables('fill');

// https://tc39.github.io/ecma262/#sec-typedarray-objects

typedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/**
 * @summary æ´æ°ãããã¿ã¤ã«é å
 *
 * @memberof mapray
 * @private
 */
var UpdatedTileArea =
/*#__PURE__*/
function () {
  /**
   */
  function UpdatedTileArea() {
    _classCallCheck(this, UpdatedTileArea);

    this._area_list = [];
    this._flat_area_list = null;
  }
  /**
   * @summary æ´æ°ãããé åã¯ç©ºãï¼
   *
   * @return {boolean}  æ´æ°é åãå­å¨ããã¨ã false, ããä»¥å¤ã®ã¨ã true
   */


  _createClass(UpdatedTileArea, [{
    key: "isEmpty",
    value: function isEmpty() {
      return this._area_list.length == 0;
    }
    /**
     * @summary æ´æ°é åãç©ºã«ãã
     */

  }, {
    key: "clear",
    value: function clear() {
      this._area_list.length = 0;
      this._flat_area_list = null;
    }
    /**
     * @summary æ´æ°é åãè¿½å 
     *
     * @param {object} area    é å
     * @param {number} area.z  ã¬ãã«
     * @param {number} area.x  X ã¿ã¤ã«åº§æ¨
     * @param {number} area.y  Y ã¿ã¤ã«åº§æ¨
     */

  }, {
    key: "addTileArea",
    value: function addTileArea(area) {
      this._area_list.push({
        z: area.z,
        x: area.x,
        y: area.y
      });

      this._flat_area_list = null;
    }
    /**
     * @summary ãã©ããé åéåãåå¾
     *
     * @desc
     * <p>ãã©ããé åéåã®åé åã¯ãåãéååã«ç¥åé åãå«ã¾ãªãã</p>
     * <p>åé åã¯å­é åã®ç´¢å¼ã®éåã¨ãã¦è¡¨ãã</p>
     *
     * @return {Uint8Array[]}
     */

  }, {
    key: "getFlatAreaList",
    value: function getFlatAreaList() {
      if (this._flat_area_list === null) {
        this._flat_area_list = this._createFlatAreaList();
      }

      return this._flat_area_list;
    }
    /**
     * @summary ãã©ããé åéåãçæ
     *
     * @return {Uint8Array[]}
     *
     * @private
     */

  }, {
    key: "_createFlatAreaList",
    value: function _createFlatAreaList() {
      var root_node = new Node();

      for (var i = 0; i < this._area_list.length; ++i) {
        var area = this._area_list[i];
        root_node.addDescendant(area.z, area.x, area.y);
      }

      root_node.reduceTree();
      return root_node.collectFlatAreas(0, new Uint8Array(64), []);
    }
  }]);

  return UpdatedTileArea;
}();
/**
 * @summary UpdatedTileArea ã®ãã¼ã
 *
 * @memberof mapray.UpdatedTileArea
 * @private
 */


var Node =
/*#__PURE__*/
function () {
  /**
   */
  function Node() {
    _classCallCheck(this, Node);

    this.present = false;
    this.children = new Array(4).fill(null);
  }
  /**
   * @summary å­å­«ãã¼ã (èªèº«å¯) ãè¿½å 
   *
   * @param {number} z
   * @param {number} x
   * @param {number} y
   */


  _createClass(Node, [{
    key: "addDescendant",
    value: function addDescendant(z, x, y) {
      if (this.present === true) {
        // this ã¯ãã§ã«æ±ºå®ãã¦ããã®ã§å­å­«ã¯è¿½å ããªã
        return;
      }

      if (z == 0) {
        this.present = true;
        this.children.fill(null); // ãã§ã«å­å¨ããå­å­«ãåãæ¶ã
      } else {
        // z >= 1
        var p = Math.round(Math.pow(2, z - 1)); // 2^(z - 1)

        var u = Math.floor(x / p);
        var v = Math.floor(y / p);
        var i = u + 2 * v;

        if (this.children[i] === null) {
          this.children[i] = new Node();
        }

        this.children[i].addDescendant(z - 1, x % p, y % p);
      }
    }
    /**
     * @summary ããªã¼ãæé©å
     *
     * @return {number}  this ãæ«ç«¯ãªã 1, ããä»¥å¤ãªã 0
     */

  }, {
    key: "reduceTree",
    value: function reduceTree() {
      if (this.present === true) {
        return 1;
      } // æ«ç«¯ã®å­ä¾ã®æ°


      var count = 0;

      for (var i = 0; i < 4; ++i) {
        var child = this.children[i];

        if (child !== null) {
          count += child.reduceTree();
        }
      }

      if (count == 4) {
        // ãã¹ã¦ã®å­ä¾ãå­å¨ãããããããã¹ã¦æ«ç«¯ãªã this ãæ«ç«¯å
        this.present = true;
        this.children.fill(null);
        return 1;
      } else {
        // this ãæ«ç«¯åããªã
        return 0;
      }
    }
    /**
     * @summary æ«ç«¯ãã¼ããåé
     *
     * @param  {number}       z        ã¬ãã«
     * @param  {Uint8Array}   indices  é åãè¡¨ãç´¢å¼éå
     * @param  {Uint8Array[]} olist    åéçµæãæ ¼ç´ããéå
     * @return {Uint8Array[]}          olist
     */

  }, {
    key: "collectFlatAreas",
    value: function collectFlatAreas(z, indices, olist) {
      if (this.present === true) {
        olist.push(new Uint8Array(indices.slice(0, z)));
      } else {
        for (var i = 0; i < 4; ++i) {
          var child = this.children[i];

          if (child !== null) {
            indices[z] = i;
            child.collectFlatAreas(z + 1, indices, olist);
          }
        }
      }

      return olist;
    }
  }]);

  return Node;
}();

// https://tc39.github.io/ecma262/#sec-array.isarray

_export({
  target: 'Array',
  stat: true
}, {
  isArray: isArray
});

var ARRAY_BUFFER$1 = 'ArrayBuffer';
var ArrayBuffer$3 = arrayBuffer[ARRAY_BUFFER$1];
var NativeArrayBuffer$1 = global_1[ARRAY_BUFFER$1]; // `ArrayBuffer` constructor
// https://tc39.github.io/ecma262/#sec-arraybuffer-constructor

_export({
  global: true,
  forced: NativeArrayBuffer$1 !== ArrayBuffer$3
}, {
  ArrayBuffer: ArrayBuffer$3
});
setSpecies(ARRAY_BUFFER$1);

// https://tc39.github.io/ecma262/#sec-typedarray-objects

typedArrayConstructor('Uint16', function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

// https://tc39.github.io/ecma262/#sec-typedarray-objects

typedArrayConstructor('Uint32', function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/**
 * @summary ã¡ãã·ã¥ç¨ã®ãããã¡
 * @memberof mapray
 * @package
 */
var MeshBuffer =
/*#__PURE__*/
function () {
  /**
   * <p>æ³¨æ: ARRAY_BUFFER ã¸ã®ãã¤ã³ãã¯ null ã«è¨­å®ãããã</p>
   *
   * @param {mapray.GLEnv}                glenv
   * @param {ArrayBuffer|ArrayBufferView} src    åãã¼ã¿
   * @param {object}                      [options]                          ãªãã·ã§ã³
   * @param {mapray.MeshBuffer.Target}    [options.target=Target.ATTRIBUTE]  ä½¿ç¨ç®ç
   */
  function MeshBuffer(glenv, src, options) {
    _classCallCheck(this, MeshBuffer);

    this._glenv = glenv;
    var opts = options || {}; // VBO ãçæ

    var gl = glenv.context;

    var target = MeshBuffer._getBindingPoint(gl, opts.target);

    var vbo = gl.createBuffer();
    gl.bindBuffer(target, vbo);
    gl.bufferData(target, src, gl.STATIC_DRAW);
    gl.bindBuffer(target, null);
    this._handle = vbo;
  }
  /**
   * @summary ãããã¡ã®ãã³ãã«
   * @type {WebGLBuffer}
   * @readonly
   */


  _createClass(MeshBuffer, [{
    key: "dispose",

    /**
     * @summary ãªã½ã¼ã¹ãç ´æ£
     */
    value: function dispose() {
      var gl = this._glenv.context;
      gl.deleteBuffer(this._handle);
      this._handle = null;
    }
    /**
     * @private
     */

  }, {
    key: "handle",
    get: function get() {
      return this._handle;
    }
  }], [{
    key: "_getBindingPoint",
    value: function _getBindingPoint(gl, target) {
      switch (target) {
        default:
        case Target.ATTRIBUTE:
          return gl.ARRAY_BUFFER;

        case Target.INDEX:
          return gl.ELEMENT_ARRAY_BUFFER;
      }
    }
  }]);

  return MeshBuffer;
}();
/**
 * @summary ãããã¡ã®ä½¿ç¨ç®ç
 *
 * @enum {object}
 * @memberof mapray.MeshBuffer
 * @constant
 */


var Target = {
  /**
   * é ç¹å±æ§
   */
  ATTRIBUTE: {
    id: "ATTRIBUTE"
  },

  /**
   * ã¤ã³ããã¯ã¹
   */
  INDEX: {
    id: "INDEX"
  }
};
MeshBuffer.Target = Target;

/**
 * @summary ã¢ãã«ã¡ãã·ã¥
 * @memberof mapray
 * @package
 */

var Mesh =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.GLEnv}       glenv
   * @param {mapray.Mesh.Initializer|ArrayBuffer|object} data   ã¡ãã·ã¥ãã¼ã¿
   */
  function Mesh(glenv, data) {
    _classCallCheck(this, Mesh);

    this._glenv = glenv;
    this._draw_mode = undefined;
    this._num_vertices = 0;
    this._attrib_data = {};
    this._index_data = null;

    if (data instanceof Initializer) {
      // Mesh.Initializer
      this._initByInitializer(data);
    } else if (data instanceof ArrayBuffer) {
      // ã¡ãã·ã¥ãã¤ããª
      this._initByInitializer(new BinaryInit(glenv, data).initializer);
    } else {
      // JSON ãªãã¸ã§ã¯ã
      this._initByInitializer(new JsonInit(glenv, data).initializer);
    }
  }
  /**
   * @summary Initializer ã«ããåæå
   *
   * @param {mapray.Mesh.Initializer} init  åæåãã¼ã¿
   * @private
   */


  _createClass(Mesh, [{
    key: "_initByInitializer",
    value: function _initByInitializer(init) {
      this._draw_mode = this._convertDrawMode(init.draw_mode);
      this._num_vertices = init.num_vertices; // this._attrib_data

      var src_attrib_data = init.attribute_data; // Mesh.Initializer#addAttribute() ãåç§

      for (var i = 0; i < src_attrib_data.length; ++i) {
        var sad = src_attrib_data[i];
        this._attrib_data[sad.id] = {
          mesh_buffer: sad.buffer,
          buffer: sad.buffer.handle,
          num_components: sad.num_components,
          component_type: this._convertComponentType(sad.component_type),
          normalized: sad.normalized,
          byte_stride: sad.byte_stride,
          byte_offset: sad.byte_offset
        };
      } // this._index_data


      if (init.index_data) {
        var src_index_data = init.index_data; // Mesh.Initializer#addIndex() ãåç§

        this._index_data = {
          mesh_buffer: src_index_data.buffer,
          buffer: src_index_data.buffer.handle,
          num_indices: src_index_data.num_indices,
          type: this._convertComponentType(src_index_data.type),
          byte_offset: src_index_data.byte_offset
        };
      }
    }
    /**
     * @summary DrawMode åãã GL æç»ã¢ã¼ãã¸å¤æ
     *
     * @param  {mapray.Mesh.DrawMode} mode  æç»ã¢ã¼ã
     * @return {number}                     GL æç»ã¢ã¼ã
     * @private
     */

  }, {
    key: "_convertDrawMode",
    value: function _convertDrawMode(mode) {
      var gl = this._glenv.context;

      switch (mode) {
        case DrawMode.POINTS:
          return gl.POINTS;

        case DrawMode.LINES:
          return gl.LINES;

        case DrawMode.TRIANGLES:
          return gl.TRIANGLES;

        case DrawMode.LINE_LOOP:
          return gl.LINE_LOOP;

        case DrawMode.LINE_STRIP:
          return gl.LINE_STRIP;

        case DrawMode.TRIANGLE_STRIP:
          return gl.TRIANGLE_STRIP;

        case DrawMode.TRIANGLE_FAN:
          return gl.TRIANGLE_FAN;

        default:
          throw new Error("mapray: invalid Mesh.DrawMode: " + mode);
      }
    }
    /**
     * @summary ComponentType åãã GL è¦ç´ åã¸å¤æ
     *
     * @param  {mapray.Mesh.ComponentType} type  è¦ç´ å
     * @return {number}                          GL è¦ç´ å
     * @private
     */

  }, {
    key: "_convertComponentType",
    value: function _convertComponentType(type) {
      var gl = this._glenv.context;

      switch (type) {
        case ComponentType.BYTE:
          return gl.BYTE;

        case ComponentType.UNSIGNED_BYTE:
          return gl.UNSIGNED_BYTE;

        case ComponentType.SHORT:
          return gl.SHORT;

        case ComponentType.UNSIGNED_SHORT:
          return gl.UNSIGNED_SHORT;

        case ComponentType.UNSIGNED_INT:
          return gl.UNSIGNED_INT;

        case ComponentType.FLOAT:
          return gl.FLOAT;

        default:
          throw new Error("mapray: invalid Mesh.ComponentType: " + type);
      }
    }
    /**
     * @summary ãªã½ã¼ã¹ãç ´æ£
     */

  }, {
    key: "dispose",
    value: function dispose() {
      this._attrib_data = {};
      this._index_data = null;
    }
    /**
     * @summary ã¡ãã·ã¥ãæç»
     *
     * @desc
     * <p>äºåã« material.bindProgram(), material.setParameters() ãããã¨ã</p>
     *
     * @param {mapray.EntityMaterial} material  ãããªã¢ã«
     */

  }, {
    key: "draw",
    value: function draw(material) {
      var gl = this._glenv.context; // é ç¹å±æ§ã®ãã¤ã³ã

      material.bindVertexAttribs(this._attrib_data);
      var index_data = this._index_data;

      if (index_data !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_data.buffer);
        gl.drawElements(this._draw_mode, index_data.num_indices, index_data.type, index_data.byte_offset);
      } else {
        gl.drawArrays(this._draw_mode, 0, this._num_vertices);
      }
    }
  }]);

  return Mesh;
}();
/**
 * @summary ã¡ãã·ã¥ã®åæåãªãã¸ã§ã¯ã
 *
 * @memberof mapray.Mesh
 * @package
*/


var Initializer =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Mesh.DrawMode} draw_mode     æç»ã¢ã¼ã
   * @param {number}               num_vertices  é ç¹æ°
   */
  function Initializer(draw_mode, num_vertices) {
    _classCallCheck(this, Initializer);

    this.draw_mode = draw_mode;
    this.num_vertices = num_vertices;
    this.index_data = null;
    this.attribute_data = [];
  }
  /**
   * @summary ã¤ã³ããã¯ã¹ãã¼ã¿ãè¿½å 
   *
   * @param {mapray.MeshBuffer}         buffer       ãããã¡
   * @param {number}                    num_indices  ã¤ã³ããã¯ã¹æ°
   * @param {mapray.Mesh.ComponentType} type         ã¤ã³ããã¯ã¹å (UNSIGNED_BYTE | UNSIGNED_SHORT | UNSIGNED_INT)
   * @param {object}                    [options]                ãªãã·ã§ã³
   * @param {number}                    [options.byte_offset=0]  ãããã¡åé ­ããã®ãã¤ããªãã»ãã
   */


  _createClass(Initializer, [{
    key: "addIndex",
    value: function addIndex(buffer, num_indices, type, options) {
      var opts = options || {};
      this.index_data = {
        buffer: buffer,
        num_indices: num_indices,
        type: type,
        byte_offset: opts.byte_offset !== undefined ? opts.byte_offset : 0
      };
    }
    /**
     * @summary é ç¹å±æ§ãã¼ã¿ãè¿½å 
     *
     * @param {string}                    id              å±æ§å
     * @param {mapray.MeshBuffer}         buffer          ãããã¡
     * @param {number}                    num_components  è¦ç´ æ°
     * @param {mapray.Mesh.ComponentType} component_type  è¦ç´ å
     * @param {object}                    [options]                   ãªãã·ã§ã³
     * @param {boolean}                   [options.normalized=false]  æ­£è¦åãããï¼
     * @param {number}                    [options.byte_stride=0]     é ç¹éã®ãã¤ãã¹ãã©ã¤ã
     * @param {number}                    [options.byte_offset=0]     ãããã¡åé ­ããã®ãã¤ããªãã»ãã
     */

  }, {
    key: "addAttribute",
    value: function addAttribute(id, buffer, num_components, component_type, options) {
      var opts = options || {};
      var data = {
        id: id,
        buffer: buffer,
        num_components: num_components,
        component_type: component_type,
        normalized: opts.normalized !== undefined ? opts.normalized : false,
        byte_stride: opts.byte_stride !== undefined ? opts.byte_stride : 0,
        byte_offset: opts.byte_offset !== undefined ? opts.byte_offset : 0
      };
      this.attribute_data.push(data);
    }
  }]);

  return Initializer;
}();
/**
 * @summary æç»ã¢ã¼ãã®åæå
 * @enum {object}
 * @memberof mapray.Mesh
 * @constant
 */


var DrawMode = {
  /**
   * ç¹ãªã¹ã
   */
  POINTS: {
    id: "POINTS"
  },

  /**
   * ç·åãªã¹ã
   */
  LINES: {
    id: "LINES"
  },

  /**
   * ä¸è§å½¢ãªã¹ã
   */
  TRIANGLES: {
    id: "TRIANGLES"
  },

  /**
   * ç·åã«ã¼ã
   */
  LINE_LOOP: {
    id: "LINE_LOOP"
  },

  /**
   * ç·åã¹ããªãã
   */
  LINE_STRIP: {
    id: "LINE_STRIP"
  },

  /**
   * ä¸è§å½¢ã¹ããªãã
   */
  TRIANGLE_STRIP: {
    id: "TRIANGLE_STRIP"
  },

  /**
   * ä¸è§å½¢ãã¡ã³
   */
  TRIANGLE_FAN: {
    id: "TRIANGLE_FAN"
  }
};
/**
 * @summary è¦ç´ åã®åæå
 * @enum {object}
 * @memberof mapray.Mesh
 * @constant
 */

var ComponentType = {
  /**
   * ç¬¦å·ä»ã 8 ãããæ´æ°å
   */
  BYTE: {
    id: "BYTE"
  },

  /**
   * ç¬¦å·ãªã 8 ãããæ´æ°å
   */
  UNSIGNED_BYTE: {
    id: "UNSIGNED_BYTE"
  },

  /**
   * ç¬¦å·ä»ã 16 ãããæ´æ°å
   */
  SHORT: {
    id: "SHORT"
  },

  /**
   * ç¬¦å·ãªã 16 ãããæ´æ°å
   */
  UNSIGNED_SHORT: {
    id: "UNSIGNED_SHORT"
  },

  /**
   * ç¬¦å·ãªã 32 ãããæ´æ°å
   */
  UNSIGNED_INT: {
    id: "UNSIGNED_INT"
  },

  /**
   * 32 ãããæµ®åå°æ°ç¹æ°å
   */
  FLOAT: {
    id: "FLOAT"
  }
};
/**
 * @summary JSON ãªãã¸ã§ã¯ãã Mesh.Initializer ã«å¤æ
 *
 * @memberof mapray.Mesh
 * @private
 */

var JsonInit =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.GLEnv} glenv
   * @param {object}       data   ã¡ãã·ã¥ãã¼ã¿
   */
  function JsonInit(glenv, data) {
    _classCallCheck(this, JsonInit);

    var vinfo = InitHelper.createVertexInfo(data.vtype);
    var num_vcompos = InitHelper.numVertexComponents(vinfo);
    var num_vertices = data.vertices.length / num_vcompos;
    this._initializer = new Initializer(JsonInit._toDrawMode(data), num_vertices);

    this._addIndex(glenv, data.indices, num_vertices);

    var FLT_BYTES = 4;
    var buffer = new MeshBuffer(glenv, InitHelper.toTypedArray(data.vertices, ComponentType.FLOAT));
    var byteStride = num_vcompos * FLT_BYTES;
    var byteOffset = 0;

    for (var i = 0; i < vinfo.length; ++i) {
      var num_compos = vinfo[i].size;

      this._initializer.addAttribute(vinfo[i].name, buffer, num_compos, ComponentType.FLOAT, {
        byte_stride: byteStride,
        byte_offset: byteOffset
      });

      byteOffset += num_compos * FLT_BYTES;
    }
  }
  /**
   * @summary Mesh.Initializer ã¤ã³ã¹ã¿ã³ã¹ãåå¾
   * @type {Mesh.Initializer}
   * @readonly
   */


  _createClass(JsonInit, [{
    key: "_addIndex",

    /**
     * @summary ã¤ã³ããã¯ã¹ãã¼ã¿ãè¿½å 
     *
     * @param {mapray.GLEnv} glenv
     * @param {object}       indices       ã¤ã³ããã¯ã¹éå
     * @param {number}       num_vertices  é ç¹æ°
     */
    value: function _addIndex(glenv, indices, num_vertices) {
      // ã¤ã³ããã¯ã¹ã®åã¯é ç¹æ°ã«ããèªåçã«æ±ºãã
      var type = num_vertices < 65536 ? ComponentType.UNSIGNED_SHORT : ComponentType.UNSIGNED_INT;
      var buffer = new MeshBuffer(glenv, InitHelper.toTypedArray(indices, type), {
        target: MeshBuffer.Target.INDEX
      });

      this._initializer.addIndex(buffer, indices.length, type);
    }
    /**
     * @summary Mesh.DrawMode ã«å¤æ
     *
     * @param  {object} data           ã¡ãã·ã¥ãã¼ã¿
     * @return {mapray.Mesh.DrawMode}  æç»ã¢ã¼ã
     * @private
     */

  }, {
    key: "initializer",
    get: function get() {
      return this._initializer;
    }
  }], [{
    key: "_toDrawMode",
    value: function _toDrawMode(data) {
      // ptype?: ("triangles" | "lines") = "triangles"
      switch (data.ptype) {
        case "triangles":
          return DrawMode.TRIANGLES;

        case "lines":
          return DrawMode.LINES;

        default:
          return DrawMode.TRIANGLES;
      }
    }
  }]);

  return JsonInit;
}();
/**
 * @summary ã¡ãã·ã¥ãã¤ããªã Mesh.Initializer ã«å¤æ
 *
 * @memberof mapray.Mesh
 * @private
 */


var BinaryInit =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.GLEnv} glenv
   * @param {ArrayBuffer}  data   ã¡ãã·ã¥ãã¼ã¿
   */
  function BinaryInit(glenv, data) {
    _classCallCheck(this, BinaryInit);

    var header = new DataView(data, 0);
    var vtype = header.getUint8(BinaryInit.OFFSET_VTYPE);
    var itype = header.getUint8(BinaryInit.OFFSET_ITYPE);
    var ptype = header.getUint8(BinaryInit.OFFSET_PTYPE);
    var num_vertices = header.getUint32(BinaryInit.OFFSET_NUM_VERTICES, true);
    var num_indices = header.getUint32(BinaryInit.OFFSET_NUM_INDICES, true);
    this._initializer = new Initializer(BinaryInit._toDrawMode(ptype), num_vertices);
    var vinfo = InitHelper.createVertexInfo(vtype);

    var indices = this._createIndexArray(glenv, data, itype, num_indices, vinfo, num_vertices);

    this._addIndex(glenv, itype, indices);

    var FLT_BYTES = 4;
    var buffer = new MeshBuffer(glenv, this._createVertexArray(data, vinfo, num_vertices));
    var byteStride = InitHelper.numVertexComponents(vinfo) * FLT_BYTES;
    var byteOffset = 0;

    for (var i = 0; i < vinfo.length; ++i) {
      var num_compos = vinfo[i].size;

      this._initializer.addAttribute(vinfo[i].name, buffer, num_compos, ComponentType.FLOAT, {
        byte_stride: byteStride,
        byte_offset: byteOffset
      });

      byteOffset += num_compos * FLT_BYTES;
    }
  }
  /**
   * @summary Mesh.Initializer ã¤ã³ã¹ã¿ã³ã¹ãåå¾
   * @type {Mesh.Initializer}
   * @readonly
   */


  _createClass(BinaryInit, [{
    key: "_createIndexArray",

    /**
     * @summary ã¤ã³ããã¯ã¹ãããã¡ãä½æ (ãã¤ããªãã¼ã¿ãã)
     *
     * @param  {mapray.GLEnv} glenv
     * @param  {ArrayBuffer}  src_buffer   ãã¤ããªãã¼ã¿
     * @param  {number}       itype        ã¤ã³ããã¯ã¹å (ENUM_ITYPE_UINT16 | ENUM_ITYPE_UINT32)
     * @param  {number}       num_indices  ã¤ã³ããã¯ã¹æ°
     * @param  {array}        vinfo        é ç¹æå ±
     * @param  {number}       num_vertices é ç¹æ°
     * @return {Uint16Array|Uint32Array}   ã¤ã³ããã¯ã¹éå
     * @private
     */
    value: function _createIndexArray(glenv, src_buffer, itype, num_indices, vinfo, num_vertices) {
      // å¥åéåãä½æ
      var FLT_BYTES = 4;
      var vertices_bytes = InitHelper.numVertexComponents(vinfo) * num_vertices * FLT_BYTES;
      var src_view = new DataView(src_buffer, BinaryInit.OFFSET_BODY + vertices_bytes);
      var i;
      var dst_array;
      var index_bytes;

      switch (itype) {
        case BinaryInit.ENUM_ITYPE_UINT16:
          dst_array = new Uint16Array(num_indices);
          index_bytes = 2;

          for (i = 0; i < num_indices; ++i) {
            dst_array[i] = src_view.getUint16(index_bytes * i, true);
          }

          break;

        case BinaryInit.ENUM_ITYPE_UINT32:
          dst_array = new Uint32Array(num_indices);
          index_bytes = 4;

          for (i = 0; i < num_indices; ++i) {
            dst_array[i] = src_view.getUint32(index_bytes * i, true);
          }

          break;

        default:
          throw new Error("mapray: unknown itype: " + itype);
      }

      return dst_array;
    }
    /**
     * @summary é ç¹ãããã¡ãä½æ (ãã¤ããªãã¼ã¿ãã)
     *
     * @param  {ArrayBuffer} src_buffer    ãã¤ããªãã¼ã¿
     * @param  {array}       vinfo         é ç¹æå ±
     * @param  {number}      num_vertices  é ç¹æ°
     * @return {Float32Array}              é ç¹ãã¼ã¿ãæ ¼ç´ããéå
     * @private
     */

  }, {
    key: "_createVertexArray",
    value: function _createVertexArray(src_buffer, vinfo, num_vertices) {
      var FLT_BYTES = 4; // å¥åéåãä½æ

      var num_elements = InitHelper.numVertexComponents(vinfo) * num_vertices;
      var src_view = new DataView(src_buffer, BinaryInit.OFFSET_BODY);
      var dst_array = new Float32Array(num_elements);

      for (var i = 0; i < num_elements; ++i) {
        dst_array[i] = src_view.getFloat32(i * FLT_BYTES, true);
      }

      return dst_array;
    }
    /**
     * @summary ã¤ã³ããã¯ã¹ãã¼ã¿ãè¿½å 
     *
     * @param {mapray.GLEnv}            glenv
     * @param {number}                  itype    ã¤ã³ããã¯ã¹å (ENUM_ITYPE_UINT16 | ENUM_ITYPE_UINT32)
     * @param {Uint16Array|Uint32Array} indices  ã¤ã³ããã¯ã¹éå
     * @private
     */

  }, {
    key: "_addIndex",
    value: function _addIndex(glenv, itype, indices) {
      var buffer = new MeshBuffer(glenv, indices, {
        target: MeshBuffer.Target.INDEX
      });

      var type = BinaryInit._indexTypeToComponentType(itype);

      this._initializer.addIndex(buffer, indices.length, type);
    }
    /**
     * @summary Mesh.DrawMode ã«å¤æ
     *
     * @param  {number} ptype          ããªããã£ãã¿ã¤ã
     * @return {mapray.Mesh.DrawMode}  æç»ã¢ã¼ã
     * @private
     */

  }, {
    key: "initializer",
    get: function get() {
      return this._initializer;
    }
  }], [{
    key: "_toDrawMode",
    value: function _toDrawMode(ptype) {
      switch (ptype) {
        case BinaryInit.ENUM_PTYPE_TRIANGLES:
          return DrawMode.TRIANGLES;

        case BinaryInit.ENUM_PTYPE_LINES:
          return DrawMode.LINES;

        default:
          throw new Error("mapray: invalid ptype: " + ptype);
      }
    }
    /**
     * @summary ã¤ã³ããã¯ã¹åããè¦ç´ åã¸å¤æ
     *
     * @param  {number} itype               ã¤ã³ããã¯ã¹å (ENUM_ITYPE_UINT16 | ENUM_ITYPE_UINT32)
     * @return {mapray.Mesh.ComponentType}  è¦ç´ å (UNSIGNED_SHORT | UNSIGNED_INT)
     * @private
     */

  }, {
    key: "_indexTypeToComponentType",
    value: function _indexTypeToComponentType(itype) {
      switch (itype) {
        case BinaryInit.ENUM_ITYPE_UINT16:
          return ComponentType.UNSIGNED_SHORT;

        case BinaryInit.ENUM_ITYPE_UINT32:
        default:
          return ComponentType.UNSIGNED_INT;
      }
    }
  }]);

  return BinaryInit;
}();

{
  // ãã¤ããªãã¼ã¿ã®ãªãã»ãã
  BinaryInit.OFFSET_VTYPE = 0;
  BinaryInit.OFFSET_ITYPE = 1;
  BinaryInit.OFFSET_PTYPE = 2;
  BinaryInit.OFFSET_NUM_VERTICES = 4;
  BinaryInit.OFFSET_NUM_INDICES = 8;
  BinaryInit.OFFSET_BODY = 12; // ITYPE åæå¤

  BinaryInit.ENUM_ITYPE_UINT16 = 0;
  BinaryInit.ENUM_ITYPE_UINT32 = 1; // PTYPE åæå¤

  BinaryInit.ENUM_PTYPE_TRIANGLES = 0;
  BinaryInit.ENUM_PTYPE_LINES = 1;
}
/**
 * @summary åæåãã«ãã¼
 *
 * @memberof mapray.Mesh
 * @private
 */

var InitHelper =
/*#__PURE__*/
function () {
  function InitHelper() {
    _classCallCheck(this, InitHelper);
  }

  _createClass(InitHelper, null, [{
    key: "createVertexInfo",

    /**
     * @summary é ç¹æå ±ãçæ
     * @desc
     * <p>vtype ãä»¥ä¸ã®å½¢å¼ã«å¤æãã¦è¿ãããã ã vtype ãéåãªã vtype ãè¿ãã</p>
     * <pre>
     *   [ { name: é ç¹å±æ§å, size: è¦ç´ æ° }, ... ]
     * </pre>
     * @param  {string|number|array} vtype  é ç¹ã¿ã¤ãã¾ãã¯é ç¹æå ±
     * @return {array}                      é ç¹æå ±
     */
    value: function createVertexInfo(vtype) {
      if (Array.isArray(vtype)) {
        // vtype ã¯æåããé ç¹æå ±
        return vtype;
      }

      var vinfo = null; // vtype: ("P" | "PN" | "PT" | "PNT")

      switch (vtype) {
        case "P":
        case InitHelper.ENUM_VTYPE_P:
          vinfo = [{
            name: InitHelper.ANAME_P,
            size: InitHelper.FSIZE_P
          }];
          break;

        case "PN":
        case InitHelper.ENUM_VTYPE_PN:
          vinfo = [{
            name: InitHelper.ANAME_P,
            size: InitHelper.FSIZE_P
          }, {
            name: InitHelper.ANAME_N,
            size: InitHelper.FSIZE_N
          }];
          break;

        case "PT":
        case InitHelper.ENUM_VTYPE_PT:
          vinfo = [{
            name: InitHelper.ANAME_P,
            size: InitHelper.FSIZE_P
          }, {
            name: InitHelper.ANAME_T,
            size: InitHelper.FSIZE_T
          }];
          break;

        case "PNT":
        case InitHelper.ENUM_VTYPE_PNT:
          vinfo = [{
            name: InitHelper.ANAME_P,
            size: InitHelper.FSIZE_P
          }, {
            name: InitHelper.ANAME_N,
            size: InitHelper.FSIZE_N
          }, {
            name: InitHelper.ANAME_T,
            size: InitHelper.FSIZE_T
          }];
          break;

        default:
          throw new Error("mapray: unknown vtype: " + vtype);
      }

      return vinfo;
    }
    /**
     * @summary é ç¹ãã¼ã¿ã®è¦ç´ æ°ãåå¾
     *
     * @param  {object[]} vinfo  é ç¹æå ±
     * @return {number}          é ç¹ãã¼ã¿ã®è¦ç´ æ°
     */

  }, {
    key: "numVertexComponents",
    value: function numVertexComponents(vinfo) {
      var length = vinfo.length;
      var num_compos = 0;

      for (var i = 0; i < length; ++i) {
        num_compos += vinfo[i].size;
      }

      return num_compos;
    }
    /**
     * @summary åéåã«å¤æ
     *
     * @param  {object}                    array  å¥åéå
     * @param  {mapray.Mesh.ComponentType} type   å¤æåã®è¦ç´ å
     * @return {TypedArray}                       å¤æãããéå
     */

  }, {
    key: "toTypedArray",
    value: function toTypedArray(array, type) {
      switch (type) {
        case ComponentType.UNSIGNED_SHORT:
          return array instanceof Uint16Array ? array : new Uint16Array(array);

        case ComponentType.UNSIGNED_INT:
          return array instanceof Uint32Array ? array : new Uint32Array(array);

        case ComponentType.FLOAT:
          return array instanceof Float32Array ? array : new Float32Array(array);

        default:
          throw new Error("mapray: invalid component type: " + type);
      }
    }
  }]);

  return InitHelper;
}();

{
  // VTYPE åæå¤
  InitHelper.ENUM_VTYPE_P = 0;
  InitHelper.ENUM_VTYPE_PN = 1;
  InitHelper.ENUM_VTYPE_PT = 2;
  InitHelper.ENUM_VTYPE_PNT = 3; // é ç¹å±æ§å

  InitHelper.ANAME_P = "a_position";
  InitHelper.ANAME_N = "a_normal";
  InitHelper.ANAME_T = "a_texcoord"; // è¦ç´ ã®ãµã¤ãº (è¦ç´ æ°)

  InitHelper.FSIZE_P = 3;
  InitHelper.FSIZE_N = 3;
  InitHelper.FSIZE_T = 2;
}
Mesh.Initializer = Initializer;
Mesh.DrawMode = DrawMode;
Mesh.ComponentType = ComponentType;

/**
 * @summary é«åº¦ã¢ã¼ã
 *
 * @desc
 * <p>{@link mapray.GeoPoint} ãªã©ã®é«åº¦å¤ãã©ã®ããã«è§£éããããæå®ããåæå¤ã®åã§ããã<p>
 *
 * @enum {object}
 * @memberof mapray
 * @constant
 * @see mapray.Entity
 */
var AltitudeMode = {
  /**
   * çµ¶å¯¾å¤
   */
  ABSOLUTE: {
    id: "ABSOLUTE"
  },

  /**
   * å°è¡¨ããã®ç¸å¯¾å¤
   */
  RELATIVE: {
    id: "RELATIVE"
  },

  /**
   * å°è¡¨ã¨åãé«ã (é«åº¦å¤ãç¡è¦)
   */
  CLAMP: {
    id: "CLAMP"
  }
};

/**
 * @summary ã·ã¼ã³ã»ã¨ã³ãã£ãã£
 * @classdesc
 * <p>ã·ã¼ã³ã»ã¨ã³ãã£ãã£ã®åºåºã¯ã©ã¹ã§ããã</p>
 * @memberof mapray
 * @see mapray.Scene
 * @protected
 * @abstract
 */

var Entity =
/*#__PURE__*/
function () {
  /**
   * @desc
   * <p>ã¤ã³ã¹ã¿ã³ã¹çæå¾ã«ãããã scene ã«è¿½å ãããã¨ãã§ããã</p>
   *
   * @param {mapray.Scene} scene  æå±å¯è½ã·ã¼ã³
   * @param {object} [opts]       ãªãã·ã§ã³éå
   * @param {object} [opts.json]  çææå ±
   * @param {object} [opts.refs]  åç§è¾æ¸
   */
  function Entity(scene, opts) {
    _classCallCheck(this, Entity);

    /**
     * @summary æå±å¯è½ã·ã¼ã³
     * @member mapray.Entity#scene
     * @type {mapray.Scene}
     * @readonly
     */
    this.scene = scene; // é«åº¦ã¢ã¼ã

    this._altitude_mode = AltitudeMode.ABSOLUTE;
    this._need_to_create_regions = false; // animation.BindingBlock
    //   ä»ã®ã¨ãã Entity (åºåºã¯ã©ã¹) èªä½ã®ã¢ãã¡ã¼ã·ã§ã³å¯è½ãã©ã¡ã¼ã¿ã¨
    //   å­å­«ã¯å­å¨ããªãã®ã§ animation ã«ã¯ä½ãè¿½å ããªã

    this._animation = new EasyBindingBlock();
    this._visibility = true; // çææå ±ããè¨­å®

    if (opts && opts.json) {
      this._setupEntityByJson(opts.json);
    }
  }
  /**
   * @summary å¯è¦æ§ãã©ã°ãåå¾
   * @type {boolean}
   * @readonly
   */


  _createClass(Entity, [{
    key: "setVisibility",

    /**
     * @summary å¯è¦æ§ãã©ã°ãè¨­å®
     *
     * @param {boolean} visibility  å¯è¦æ§ãã©ã°
     */
    value: function setVisibility(visibility) {
      this._visibility = visibility;
    }
    /**
     * @summary ã¢ã³ã«ã¼ã¢ã¼ãã
     * <p>é é¢å¦çã«ããæ¬æ¥è¡¨ç¤ºãããªãç¶æ³ã§ãã£ã¦ããä½ããã®æç»ãè¡ãä½ç½®ãè§åº¦ãç¢ºèªã§ãããã¦ã¹ããã¯å¯è½ã¨ãªãããã«ããæç»ã¢ã¼ãã
     * ç¾å¨ã¯ã{@link mapray.ModelEntity}ã®ã¿ãµãã¼ããããé é¢å¦çã«ããè¡¨ç¤ºãããªãé¨åãåéæã§æç»ãããã</p>
     * <p>ãã®ãã­ããã£ãæå¹ã«ããå ´åã¯ãä¸è¨ã®åé¡ç¹ã«æ³¨æããå¿è¦ãããã¾ãã</p>
     * <ul>
     * <li>éæã»åéæã¢ãã«ã«é©ç¨ãããã¨ã¯æ³å®ããã¦ãã¾ãããéæã»åéæã¢ãã«ã«å¯¾ãã¦ãã®ãã­ããã£ãæå¹ã«ããã¨è¡¨ç¤ºãä¹±ããå¯è½æ§ãããã¾ãã</li>
     * <li>ã¢ã³ã«ã¼ã¢ã¼ãã®ã¨ã³ãã£ãã£ã©ããã®åå¾å¤å®ã¯zã½ã¼ãã«ããå®è£ããã¦ããããã¯ã»ã«åä½ã®åå¾å¤å®ã¯è¡ããã¾ããã</li>
     * </ul>
     * @type {boolean}
     * @private
     * @readonly
     */

  }, {
    key: "getBounds",

    /**
     * @summary ãã¦ã³ãã£ã³ã°ããã¯ã¹ãç®åº
     *
     * @abstract
     * @return {mapray.GeoRegion}  ãã¦ã³ãã£ã³ã°ããã¯ã¹
     */
    value: function getBounds() {
      throw new Error("mapray.Entity#getBounds() method has not been overridden.");
    }
    /**
     * @summary é«åº¦ã¢ã¼ããå¤æ´ãããå¾ã®éç¥
     *
     * @desc
     * <p>this.altitude_mode ãå¤æ´ãããã¨ãã«å¼ã³åºãããã</p>
     * <p>æ¢å®ã®å®è£ã¯ä½ãããªãã</p>
     *
     * @param {mapray.AltitudeMode} prev_mode  ç´åã®ã¢ã¼ã
     *
     * @abstract
     * @private
     */

  }, {
    key: "onChangeAltitudeMode",
    value: function onChangeAltitudeMode(prev_mode) {}
    /**
     * @summary PrimitiveProducer ã¤ã³ã¿ãã§ã¼ã¹ãåå¾
     *
     * @desc
     * <p>PrimitiveProducer ã¤ã³ã¿ãã§ã¼ã¹ãåå¾ããããã«ã·ã¼ã³ã¬ã³ãã©ã¼ãå¼ã³åºãã
     *    PrimitiveProducer ã¤ã³ã¿ãã§ã¼ã¹ãå®è£ããã¦ããªããã° null ãè¿ãã</p>
     * <p>æ¢å®ã®å®è£ã¯ null ãè¿ãã</p>
     *
     * @return {?mapray.Entity.PrimitiveProducer}  PrimitiveProducer ã¤ã³ã¿ãã§ã¼ã¹
     *
     * @abstract
     * @package
     */

  }, {
    key: "getPrimitiveProducer",
    value: function getPrimitiveProducer() {
      return null;
    }
    /**
     * @summary FlakePrimitiveProducer ã¤ã³ã¿ãã§ã¼ã¹ãåå¾
     *
     * @desc
     * <p>FlakePrimitiveProducer ã¤ã³ã¿ãã§ã¼ã¹ãåå¾ããããã«ã·ã¼ã³ã¬ã³ãã©ã¼ãå¼ã³åºãã
     *    FlakePrimitiveProducer ã¤ã³ã¿ãã§ã¼ã¹ãå®è£ããã¦ããªããã° null ãè¿ãã</p>
     * <p>æ¢å®ã®å®è£ã¯ null ãè¿ãã</p>
     *
     * @return {?mapray.Entity.FlakePrimitiveProducer}  FlakePrimitiveProducer ã¤ã³ã¿ãã§ã¼ã¹
     *
     * @abstract
     * @package
     */

  }, {
    key: "getFlakePrimitiveProducer",
    value: function getFlakePrimitiveProducer() {
      return null;
    }
    /**
     * JSON ãã¼ã¿ã«ãã Entity å±éã®åæå
     * @private
     */

  }, {
    key: "_setupEntityByJson",
    value: function _setupEntityByJson(json) {
      // é«åº¦ã¢ã¼ã
      if (json.altitude_mode) {
        switch (json.altitude_mode) {
          case "absolute":
            this._altitude_mode = AltitudeMode.ABSOLUTE;
            break;

          case "relative":
            this._altitude_mode = AltitudeMode.RELATIVE;
            break;

          case "clamp":
            this._altitude_mode = AltitudeMode.CLAMP;
            break;

          default:
            console.error("unrecognized altitude_mode: " + json.altitude_mode);
        }
      }

      if (json.visibility !== undefined) this.setVisibility(json.visibility);
    }
  }, {
    key: "visibility",
    get: function get() {
      return this._visibility;
    }
  }, {
    key: "anchor_mode",
    get: function get() {
      return false;
    }
    /**
     * @summary ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿è¨­å®
     *
     * @type {mapray.animation.BindingBlock}
     * @readonly
     */

  }, {
    key: "animation",
    get: function get() {
      return this._animation;
    }
    /**
     * @summary é«åº¦ã¢ã¼ã
     * @type {mapray.AltitudeMode}
     */

  }, {
    key: "altitude_mode",
    set: function set(value) {
      if (this._altitude_mode !== value) {
        var prev_mode = this._altitude_mode;
        this._altitude_mode = value;
        this.onChangeAltitudeMode(prev_mode);
      }
    },
    get: function get() {
      return this._altitude_mode;
    }
  }]);

  return Entity;
}();
/**
 * @summary ã¨ã³ãã£ãã£ã®ããªããã£ããçç£
 *
 * @classdesc
 * <p>ã·ã¼ã³ã¬ã³ãã©ã¼ã«ã¨ã³ãã£ãã£ã®ããªããã£ããä¸ããã</p>
 *
 * @memberof mapray.Entity
 * @private
 * @abstract
 */


var PrimitiveProducer =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Entity} entity  PrimitiveProducer ã«å¯¾å¿ããã¨ã³ãã£ãã£
   */
  function PrimitiveProducer(entity) {
    _classCallCheck(this, PrimitiveProducer);

    this._entity = entity;
    this._need_to_create_regions = false;
  }
  /**
   * @summary ã¨ã³ãã£ãã£
   *
   * @type {mapray.Entity}
   * @readonly
   */


  _createClass(PrimitiveProducer, [{
    key: "needToCreateRegions",

    /**
     * @summary é åãæ´æ°ãããã¨ãå¼ã³åºã
     *
     * @desc
     * <p>é åãå¤æ´ãããå ´åã« PrimitiveProducer ã®å®è£èãå¼ã³åºãå¿è¦ãããã</p>
     */
    value: function needToCreateRegions() {
      this._need_to_create_regions = true;
    }
    /**
     * @summary need_to_create_regions ãåå¾
     *
     * @desc
     * <p>ã¨ã³ãã£ãã£ã®é åãå¤æ´ãã (createRegions() ãå¼ã³åºã) å¿è¦ããããã©ãããç¢ºèªããããã«ã·ã¼ã³ã¬ã³ãã©ã¼ãå¼ã³åºãã</p>
     *
     * @return {boolean}  é åãå¤æ´ããå¿è¦ãããã¨ã true, ããä»¥å¤ã®ã¨ã false
     *
     * @see needToCreateRegions()
     */

  }, {
    key: "checkToCreateRegions",
    value: function checkToCreateRegions() {
      var result = this._need_to_create_regions;
      this._need_to_create_regions = false;
      return result;
    }
    /**
     * @summary ã¨ã³ãã£ãã£ã«æ¨é«å¤ã¯å¿è¦ãï¼
     *
     * @desc
     * <p>ã¨ã³ãã£ãã£ãæ¨é«å¤ãå¿è¦ã¨ãã¦ãããã©ãããç¢ºèªããããã¬ã³ãã©ã¼ãå¼ã³åºãã<p>
     * <p>æ¢å®ã®å®è£ã§ã¯ entity.altitude_mode ã AltitudeMode.ABSOLUTE ãªã false, ããä»¥å¤ãªã true ãè¿ãã</p>
     *
     * @return {boolean}  ã¨ã³ãã£ãã£ã«æ¨é«å¤ãå¿è¦ãªã true, ããä»¥å¤ãªã false
     *
     * @abstract
     */

  }, {
    key: "needsElevation",
    value: function needsElevation() {
      return this._entity._altitude_mode !== AltitudeMode.ABSOLUTE;
    }
    /**
     * @summary ã¨ã³ãã£ãã£é åãçæ
     *
     * @desc
     * <p>ã¨ã³ãã£ãã£ã®é åãç¢ºèªããããã¬ã³ãã©ã¼ãå¼ã³åºãã<p>
     * <p>æ¢å®ã®å®è£ã§ã¯ [] ãè¿ãã</p>
     *
     * @return {mapray.EntityRegion[]}  ã¨ã³ãã£ãã£é åã®éå
     *
     * @abstract
     */

  }, {
    key: "createRegions",
    value: function createRegions() {
      return [];
    }
    /**
     * @summary æ´æ°ãããã¨ã³ãã£ãã£é åã®éç¥
     *
     * @desc
     * <p>ã¨ã³ãã£ãã£ã®é åã®æ¨é«ãå¤åãããã¨ãéç¥ããããã¬ã³ãã©ã¼ãå¼ã³åºããregions ã¯æ¨é«ãæ´æ°ãããã¨ã³ãã£ãã£é åãå«ãéåã§ããã</p>
     * <p>æ¢å®ã®å®è£ã§ã¯ä½ãããªãã</p>
     *
     * @param {mapray.EntityRegion[]} regions  ã¨ã³ãã£ãã£é åã®éå
     *
     * @abstract
     */

  }, {
    key: "onChangeElevation",
    value: function onChangeElevation(regions) {}
    /**
     * @summary ããªããã£ãéåãåå¾
     *
     * @desc
     * <p>ã¬ã³ããªã³ã°æã«ãã®ã¨ã³ãã£ãã£ãæç»ããããã® 0 åä»¥ä¸ã®ããªããã£ããå«ãéåãè¿ãã</p>
     * <p>ãã®ã¡ã½ãããå¼ã³åºããããã¬ã¼ã ã®ã¬ã³ããªã³ã°ãçµäºããã¾ã§ãè¿ããéåã¨ããã«å«ã¾ããããªããã£ãã¯å¤æ´ãã¦ã¯ãªããªãã</p>
     *
     * @param  {mapray.RenderStage} stage  ã¬ã³ããªã³ã°ã¹ãã¼ã¸
     * @return {Array.<mapray.Primitive>}  ããªããã£ãéå
     *
     * @abstract
     */

  }, {
    key: "getPrimitives",
    value: function getPrimitives(stage) {
      throw new Error("mapray.Entity.PrimitiveProducer#getPrimitives() method has not been overridden.");
    }
  }, {
    key: "entity",
    get: function get() {
      return this._entity;
    }
  }]);

  return PrimitiveProducer;
}();
/**
 * @summary å°è¡¨æ­çã¨ã³ãã£ãã£ã®ããªããã£ããçç£
 *
 * @classdesc
 * <p>ã·ã¼ã³ã¬ã³ãã©ã¼ã«å°è¡¨æ­çã¨ã³ãã£ãã£ã®ããªããã£ããä¸ããã</p>
 *
 * @memberof mapray.Entity
 * @private
 * @abstract
 */


var FlakePrimitiveProducer =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Entity} entity  FlakePrimitiveProducer ã«å¯¾å¿ããã¨ã³ãã£ãã£
   */
  function FlakePrimitiveProducer(entity) {
    _classCallCheck(this, FlakePrimitiveProducer);

    this._entity = entity;
    this._updated = false;
  }
  /**
   * @summary ã¨ã³ãã£ãã£
   *
   * @type {mapray.Entity}
   * @readonly
   */


  _createClass(FlakePrimitiveProducer, [{
    key: "notifyForUpdate",

    /**
     * @summary ä½ç½®ãå½¢ç¶ã®å¤åãéç¥
     */
    value: function notifyForUpdate() {
      this._updated = true;
    }
    /**
     * @summary é åç¶æãåå¾
     *
     * @desc
     * <p>area ãç¤ºãé åã®ç¶æãåå¾ããã</p>
     *
     * @param {mapray.Area} area  ç¢ºèªããé å
     *
     * @return {mapray.Entity.AreaStatus}  é åã®ç¶æ
     *
     * @abstract
     */

  }, {
    key: "getAreaStatus",
    value: function getAreaStatus(area) {
      return AreaStatus.EMPTY;
    }
    /**
     * @summary ã¡ãã·ã¥ãçæ
     *
     * @desc
     * <p>area ã®é åã«å¯¾å¿ããã¡ãã·ã¥ãåå¾ããã</p>
     * <p>area ã«å½¢ç¶ããªãã¨ãã¯ null ãè¿ãã</p>
     *
     * @param {mapray.Area}     area  ã¡ãã·ã¥ã®é å
     * @param {number[]}       dpows  é åã®åå²ææ°
     * @param {mapray.DemBinary} dem  DEM ãã¤ããª
     *
     * @return {?mapray.Mesh}
     *
     * @abstract
     */

  }, {
    key: "createMesh",
    value: function createMesh(area, dpows, dem) {
      return null;
    }
    /**
     * @summary ãããªã¢ã«ã¨ãã­ããã£ãåå¾
     *
     * @param {mapray.RenderStage} stage  ã¬ã³ããªã³ã°ã¹ãã¼ã¸
     *
     * @return {object}  { material: mapray.EntityMaterial, properties: mapray.PropSet }
     *
     * @abstract
     */

  }, {
    key: "getMaterialAndProperties",
    value: function getMaterialAndProperties(stage) {
      throw new Error("mapray.Entity.FlakePrimitiveProducer#getMaterialAndProperties() method has not been overridden.");
    }
    /**
     * @summary æ´æ°ç¶æãç¢ºèª
     *
     * @desc
     * <p>ã¬ã³ãã©ã¼ãå¼ã³åºãã</p>
     * <p>æ´æ°ç¶æãè¿ãã¦ãããæ´æ°ãªãç¶æã«è¨­å®ããã</p>
     *
     * @return {boolean}  æ´æ°ããã®ã¨ã true, ããä»¥å¤ã®ã¨ã false
     *
     * @package
     */

  }, {
    key: "checkForUpdate",
    value: function checkForUpdate() {
      var updated = this._updated;
      this._updated = false;
      return updated;
    }
  }, {
    key: "entity",
    get: function get() {
      return this._entity;
    }
  }]);

  return FlakePrimitiveProducer;
}();
/**
 * @summary é åç¶æã®åæå
 *
 * @enum {object}
 * @memberof mapray.Entity
 * @constant
 * @private
 */


var AreaStatus = {
  /**
   * ä½ããªãé å
   */
  EMPTY: {
    id: "EMPTY"
  },

  /**
   * å®å¨ã«æºããããé å
   */
  FULL: {
    id: "FULL"
  },

  /**
   * é¨åé åã¾ãã¯é åä¸æ
   */
  PARTIAL: {
    id: "PARTIAL"
  }
};
Entity.PrimitiveProducer = PrimitiveProducer;
Entity.FlakePrimitiveProducer = FlakePrimitiveProducer;
Entity.AreaStatus = AreaStatus;

/**
 * @summary å°è¡¨å½¢ç¶ã®ç®¡ç
 * @memberof mapray
 * @private
 */

var Globe =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.GLEnv}       glenv         WebGL ç°å¢
   * @param {mapray.DemProvider} dem_provider  DEM ãã­ãã¤ã
   */
  function Globe(glenv, dem_provider) {
    _classCallCheck(this, Globe);

    this._glenv = glenv;
    this._dem_provider = dem_provider;
    this._status = Status.NOT_READY;
    this._dem_area_updated = new UpdatedTileArea();
    this._prev_producers = new Set();
    this._Ï = dem_provider.getResolutionPower();
    this._dem_zbias = GeoMath.LOG2PI - this._Ï + 1; // b = log2(Ï) - Ï + 1

    this._hist_stats = new HistStats();
    this._flake_reduce_thresh = 1.5; // Flake åæ¸æ¯çé¾å¤

    this._flake_reduce_factor = 1.2; // Flake åæ¸æ¯çä¿æ°

    this._num_cache_flakes = 0; // ã­ã£ãã·ã¥åã® Flake æ° (_root_flake ã¨å­å­«ã®æ°)

    this._num_touch_flakes = 0; // ç¾è¡ãã¬ã¼ã ã§ã®ã¢ã¯ã»ã¹ Flake æ°

    this._mesh_reduce_lower = 300; // Mesh åæ¸ä¸éå¤

    this._mesh_reduce_thresh = 1.5; // Mesh åæ¸æ¯çé¾å¤

    this._mesh_reduce_factor = 1.2; // Mesh åæ¸æ¯çä¿æ°

    this._num_cache_meshes = 0; // ã­ã£ãã·ã¥åã® Mesh æ°

    this._num_touch_meshes = 0; // ç¾è¡ãã¬ã¼ã ã§ã®ã¢ã¯ã»ã¹ Mesh æ°

    this._max_dem_requesteds = 10; // æå¤§ REQUESTED æ°

    this._num_dem_requesteds = 0; // ç¾å¨ã® REQUESTED ç¶æã®æ°

    this._frame_counter = 0; // ç¾è¡ãã¬ã¼ã çªå·

    this._root_flake = null;
    this._avg_height = null;
    this._root_cancel_id = null;

    this._requestRoot();
  }
  /**
   * ãã¹ã¦ã®ãªã¯ã¨ã¹ããåãæ¶ã
   */


  _createClass(Globe, [{
    key: "cancel",
    value: function cancel() {
      if (this._status === Status.READY) {
        // root ã®çå­å­«ãç ´æ£ (ãªã¯ã¨ã¹ããã­ã£ã³ã»ã«)
        var children = this._root_flake._children;

        for (var i = 0; i < 4; ++i) {
          children[i].dispose();
        }
      } else if (this._status === Status.NOT_READY) {
        // ãªã¯ã¨ã¹ãä¸­ã® root ãã­ã£ã³ã»ã«
        this._dem_provider.cancelRequest(this._root_cancel_id);

        this._root_cancel_id = null;
      } // assert: this._num_dem_requesteds == 0

    }
    /**
     * WebGL ç°å¢
     * @type {mapray.GLEnv}
     * @readonly
     */

  }, {
    key: "putNextEntityProducers",

    /**
     * @summary ã¨ã³ãã£ãã£æå ±ãæ´æ°
     *
     * <p>getRenderObject() ã®åã«ã¨ã³ãã£ãã£ã®æå ±ãæ´æ°ããã</p>
     *
     * @param {iterable.<mapray.Entity.FlakePrimitiveProducer>} producers
     */
    value: function putNextEntityProducers(producers) {
      var next_producers = new Set(); // è¿½å ãåé¤ãæ´æ°ã®ãªã¹ããä½æ

      var added_producers = [];
      var updated_producers = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = producers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var prod = _step.value;
          var updated = prod.checkForUpdate(); // æ´æ°ãã§ãã¯ã¨ã¯ãªã¢

          if (this._prev_producers.has(prod)) {
            if (updated) {
              // æ´æ°ããã
              updated_producers.push(prod);
            }

            this._prev_producers["delete"](prod);
          } else {
            // æ°è¦è¿½å 
            added_producers.push(prod);
          }

          next_producers.add(prod);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var removed_producers = this._prev_producers; // ããªã¼ãæ´æ°

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = removed_producers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _prod = _step2.value;

          this._root_flake.removeEntityProducer(_prod);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      for (var _i = 0, _added_producers = added_producers; _i < _added_producers.length; _i++) {
        var _prod2 = _added_producers[_i];

        this._root_flake.addEntityProducer(_prod2);
      }

      for (var _i2 = 0, _updated_producers = updated_producers; _i2 < _updated_producers.length; _i2++) {
        var _prod3 = _updated_producers[_i2];

        this._root_flake.updateEntityProducer(_prod3);
      } // æ¬¡ã® prev_producers ãè¨­å®


      this._prev_producers = next_producers;
    }
    /**
     * @summary ãªã¯ã¨ã¹ãå¾ã¡ã® DEM ã¿ã¤ã«ã®åæ°ãåå¾
     *
     * @return {number}  ãªã¯ã¨ã¹ãå¾ã¡ã® DEM ã¿ã¤ã«ã®åæ°
     */

  }, {
    key: "getNumDemWaitingRequests",
    value: function getNumDemWaitingRequests() {
      return this._num_dem_requesteds;
    }
    /**
     * @summary æ­£ç¢ºåº¦ãæãé«ã DEM ã¿ã¤ã«ãã¼ã¿ãæ¤ç´¢
     * @desc
     * <p>åºåºã¿ã¤ã«åº§æ¨ (å·¦ä¸(0, 0)ãå³ä¸(1, 1)) [xt, yt] ã®æ¨é«ãã¼ã¿ãåå¾ãããã¨ãã§ãããæ­£ç¢ºåº¦ãæãé«ã DEM ã¿ã¤ã«ãã¼ã¿ãæ¤ç´¢ããã</p>
     * <p>ãµã¼ãã¼ã«ããã«æ­£ç¢ºåº¦ãé«ã DEM ã¿ã¤ã«ãã¼ã¿ãå­å¨ããã°ãããããªã¯ã¨ã¹ãããã</p>
     * @param  {number}         xt  X åº§æ¨ (åºåºã¿ã¤ã«åº§æ¨ç³»)
     * @param  {number}         yt  Y åº§æ¨ (åºåºã¿ã¤ã«åº§æ¨ç³»)
     * @return {?mapray.DemBinary}  DEM ã¿ã¤ã«ãã¼ã¿ (å­å¨ããªããã° null)
     */

  }, {
    key: "findHighestAccuracy",
    value: function findHighestAccuracy(xt, yt) {
      var flake = this._root_flake;

      if (flake === null) {
        // ã¾ã åºåºã¿ã¤ã«ãèª­ã¿è¾¼ã¾ãã¦ããªã
        return null;
      }

      var size = 2; // 2^(flake.z + 1)

      var xf = size * xt;
      var yf = size * yt;
      var dem_flake = flake; // DEM ãæã£ãå°è¡¨æ­ç

      for (;;) {
        var u = GeoMath.clamp(Math.floor(xf), 0, size - 1) % 2;
        var v = GeoMath.clamp(Math.floor(yf), 0, size - 1) % 2;
        var child = flake._children[u + 2 * v];
        flake.touch();

        if (child === null) {
          // ããä»¥ä¸ã®ã¬ãã«ã¯å­å¨ããªã
          break;
        } else if (flake._dem_state === DemState.LOADED) {
          // ããæ­£ç¢ºåº¦ãé«ã DEM ãæã¤å°è¡¨æ­çã«æ´æ°
          dem_flake = flake;
        }

        flake = child;
        size *= 2;
        xf *= 2;
        yf *= 2;
      }

      dem_flake._requestHighestAccuracy(xt, yt);

      return dem_flake._dem_data;
    }
    /**
     * @summary ç¾è¡ã®æ¨é« (è¤æ°) ãåå¾
     *
     * @desc
     * <p>ç¾å¨ã¡ã¢ãªã¼ã«ããæé«ç²¾åº¦ã®æ¨é«å¤ãä¸æ¬ã§åå¾ããã</p>
     * <p>ã¾ã  DEM ãã¼ã¿ãå­å¨ããªããã¾ãã¯çµåº¦, ç·¯åº¦ãç¯å²å¤ã®å ´æã¯æ¨é«ã 0 ã¨ããã</p>
     *
     * <p>ãã®ã¡ã½ããã¯ DEM ã®ãªã¯ã¨ã¹ãã¯çºçããªããã¾ã DEM ã®ã­ã£ãã·ã¥ã«ã¯å½±é¿ãä¸ããªãã</p>
     *
     * <p>ä¸è¬çã«ç»é¢ã«è¡¨ç¤ºããã¦ããªãå ´æã¯æ¨é«ã®ç²¾åº¦ãä½ãã</p>
     *
     * @param  {number}   num_points  å¥åºåãã¼ã¿æ°
     * @param  {number[]} src_array   å¥åéå (çµåº¦, ç·¯åº¦, ...)
     * @param  {number}   src_offset  å¥åãã¼ã¿ã®åé ­ã¤ã³ããã¯ã¹
     * @param  {number}   src_stride  å¥åãã¼ã¿ã®ã¹ãã©ã¤ã
     * @param  {number[]} dst_array   åºåéå (æ¨é«, ...)
     * @param  {number}   dst_offset  åºåãã¼ã¿ã®åé ­ã¤ã³ããã¯ã¹
     * @param  {number}   dst_stride  åºåãã¼ã¿ã®ã¹ãã©ã¤ã
     * @return {number[]}             dst_array
     *
     * @see mapray.Viewer#getExistingElevations
     */

  }, {
    key: "getExistingElevations",
    value: function getExistingElevations(num_points, src_array, src_offset, src_stride, dst_array, dst_offset, dst_stride) {
      var dPI = 2 * Math.PI;
      var demSize = 1 << this._Ï; // 2^Ï

      var src_index = src_offset;
      var dst_index = dst_offset;

      for (var i = 0; i < num_points; ++i) {
        // çµç·¯åº¦ (Degrees)
        var lon = src_array[src_index];
        var lat = src_array[src_index + 1]; // æ­£è¦åçµç·¯åº¦ (Degrees)

        var _lon = lon + 180 * Math.floor((90 - lat) / 360 + Math.floor((90 + lat) / 360));

        var nlon = _lon - 360 - 360 * Math.floor((_lon - 180) / 360); // æ­£è¦åçµåº¦ [-180,180)

        var nlat = 90 - Math.abs(90 - lat + 360 * Math.floor((90 + lat) / 360)); // æ­£è¦åç·¯åº¦ [-90,90]
        // åä½çã¡ã«ã«ãã«åº§æ¨

        var xm = nlon * GeoMath.DEGREE;
        var ym = GeoMath.invGudermannian(nlat * GeoMath.DEGREE); // åºåºã¿ã¤ã«åº§æ¨ (å·¦ä¸(0, 0)ãå³ä¸(1, 1))

        var xt = xm / dPI + 0.5;
        var yt = 0.5 - ym / dPI;

        if (yt >= 0 && yt <= 1) {
          // éå¸¸ç¯å²ã®ã¨ã
          var dem = this._findHighestAccuracy2(xt, yt);

          if (dem !== null) {
            var pow = Math.pow(2, dem.z); // 2^ze

            var uf = demSize * (pow * xt - dem.x);
            var vf = demSize * (pow * yt - dem.y);
            var ui = GeoMath.clamp(Math.floor(uf), 0, demSize - 1);
            var vi = GeoMath.clamp(Math.floor(vf), 0, demSize - 1);
            var heights = dem.getHeights(ui, vi);
            var h00 = heights[0];
            var h10 = heights[1];
            var h01 = heights[2];
            var h11 = heights[3]; // æ¨é«ãè£é

            var s = uf - ui;
            var t = vf - vi;
            dst_array[dst_index] = (h00 * (1 - s) + h10 * s) * (1 - t) + (h01 * (1 - s) + h11 * s) * t;
          } else {
            // ã¾ã æ¨é«ãåå¾ãããã¨ãã§ããªã
            dst_array[dst_index] = 0;
          }
        } else {
          // ç·¯åº¦ã Web ã¡ã«ã«ãã«ã®ç¯å²å¤ (æ¥µã«è¿ã)
          dst_array[dst_index] = 0;
        }

        src_index += src_stride;
        dst_index += dst_stride;
      }

      return dst_array;
    }
    /**
     * @summary æ­£ç¢ºåº¦ãæãé«ã DEM ã¿ã¤ã«ãã¼ã¿ãæ¤ç´¢
     *
     * @desc
     * <p>åºåºã¿ã¤ã«åº§æ¨ (å·¦ä¸(0, 0)ãå³ä¸(1, 1)) [xt, yt] ã®æ¨é«ãã¼ã¿ãåå¾ãããã¨ãã§ãããæ­£ç¢ºåº¦ãæãé«ã DEM ã¿ã¤ã«ãã¼ã¿ãæ¤ç´¢ããã</p>
     *
     * @param  {number}         xt  X åº§æ¨ (åºåºã¿ã¤ã«åº§æ¨ç³»)
     * @param  {number}         yt  Y åº§æ¨ (åºåºã¿ã¤ã«åº§æ¨ç³»)
     * @return {?mapray.DemBinary}  DEM ã¿ã¤ã«ãã¼ã¿ (å­å¨ããªããã° null)
     *
     * @private
     */

  }, {
    key: "_findHighestAccuracy2",
    value: function _findHighestAccuracy2(xt, yt) {
      var flake = this._root_flake;

      if (flake === null) {
        // ã¾ã åºåºã¿ã¤ã«ãèª­ã¿è¾¼ã¾ãã¦ããªã
        return null;
      }

      var size = 2; // 2^(flake.z + 1)

      var xf = size * xt;
      var yf = size * yt;
      var dem_flake = flake; // DEM ãæã£ãå°è¡¨æ­ç

      for (;;) {
        var u = GeoMath.clamp(Math.floor(xf), 0, size - 1) % 2;
        var v = GeoMath.clamp(Math.floor(yf), 0, size - 1) % 2;
        var child = flake._children[u + 2 * v];

        if (child === null) {
          // ããä»¥ä¸ã®ã¬ãã«ã¯å­å¨ããªã
          break;
        } else if (flake._dem_state === DemState.LOADED) {
          // ããæ­£ç¢ºåº¦ãé«ã DEM ãæã¤å°è¡¨æ­çã«æ´æ°
          dem_flake = flake;
        }

        flake = child;
        size *= 2;
        xf *= 2;
        yf *= 2;
      }

      return dem_flake._dem_data;
    }
    /**
     * @summary ãã¬ã¼ã ã®æå¾ã®å¦ç
     */

  }, {
    key: "endFrame",
    value: function endFrame() {
      var max_touch_flakes = this._hist_stats.getMaxValue(this._num_touch_flakes);

      if (this._num_cache_flakes > this._flake_reduce_thresh * max_touch_flakes) {
        this._reduceFlakes(max_touch_flakes);
      }

      if (this._num_cache_meshes > this._mesh_reduce_lower && this._num_cache_meshes > this._mesh_reduce_thresh * this._num_touch_meshes) {
        this._reduceMeshes();
      }

      this._dem_area_updated.clear();

      this._num_touch_flakes = 0;
      this._num_touch_meshes = 0;
      ++this._frame_counter;
    }
    /**
     * _root_flake, _avg_height, _status ãè¨­å®ããããã®ãªã¯ã¨ã¹ã
     * @private
     */

  }, {
    key: "_requestRoot",
    value: function _requestRoot() {
      var _this = this;

      var z = 0;
      var x = 0;
      var y = 0;
      this._root_cancel_id = this._dem_provider.requestTile(z, x, y, function (data) {
        if (data) {
          var dem = new DemBinary(z, x, y, _this._Ï, data);
          _this._avg_height = dem.newAvgHeightMaps();
          _this._root_flake = new Flake(null, z, x, y);

          _this._root_flake.setupRoot(_this, dem);

          _this._status = Status.READY;

          _this._dem_area_updated.addTileArea(dem);
        } else {
          // ãã¼ã¿åå¾ã«å¤±æ
          _this._status = Status.FAILED;
        }

        _this._root_cancel_id = null;
        --_this._num_dem_requesteds;
      });
      ++this._num_dem_requesteds;
    }
    /**
     * @private
     */

  }, {
    key: "_reduceFlakes",
    value: function _reduceFlakes(max_touch_flakes) {
      // Flake ãéãã¦ãåªååº¦ã§æ´å
      var flat_flakes = this._root_flake.flattenFlakes(); // assert: flat_flakes.length == this._num_cache_flakes


      flat_flakes.sort(function (a, b) {
        return a.compareForReduce(b);
      }); // åªååº¦ã®ä½ã Flake ãåé¤

      var num_cache_flakes = Math.floor(this._flake_reduce_factor * max_touch_flakes);
      flat_flakes.slice(num_cache_flakes).forEach(function (flake) {
        return flake.dispose();
      }); // assert: this._num_cache_flakes == num_cache_flakes
    }
    /**
     * @private
     */

  }, {
    key: "_reduceMeshes",
    value: function _reduceMeshes() {
      var flat_meshes = this._root_flake.flattenMeshes(); // assert: flat_meshes.length == this._num_cache_meshes


      flat_meshes.sort(function (a, b) {
        return a.compareForReduce(b);
      });
      var num_cache_meshes = Math.floor(this._mesh_reduce_factor * this._num_touch_meshes);
      flat_meshes.slice(num_cache_meshes).forEach(function (mnode) {
        return mnode.dispose();
      }); // assert: this._num_cache_meshes == num_cache_meshes
    }
  }, {
    key: "glenv",
    get: function get() {
      return this._glenv;
    }
    /**
     * DEM ãã¼ã¿ãã­ãã¤ã
     * @type {mapray.DemProvider}
     * @readonly
     */

  }, {
    key: "dem_provider",
    get: function get() {
      return this._dem_provider;
    }
    /**
     * @summary Globe ç¶æãåå¾
     * @type {mapray.Globe.Status}
     * @readonly
     */

  }, {
    key: "status",
    get: function get() {
      return this._status;
    }
    /**
     * @summary DEM ãæ´æ°ãããé åãåå¾
     * @type {mapray.UpdatedTileArea}
     * @readonly
     */

  }, {
    key: "dem_area_updated",
    get: function get() {
      return this._dem_area_updated;
    }
    /**
     * @summary åºåº Flake ãåå¾
     * @type {mapray.Globe.Flake}
     * @readonly
     */

  }, {
    key: "root_flake",
    get: function get() {
      var flake = this._root_flake;
      flake.touch();
      return flake;
    }
  }]);

  return Globe;
}();
/**
 * @summary Globe ç¶æã®åæå
 * @enum {object}
 * @memberof mapray.Globe
 * @constant
 * @see mapray.Globe#status
 */


var Status = {
  /**
   * æºåä¸­ (åæç¶æ)
   */
  NOT_READY: {
    id: "NOT_READY"
  },

  /**
   * æºåå®äº
   */
  READY: {
    id: "READY"
  },

  /**
   * å¤±æç¶æ
   */
  FAILED: {
    id: "FAILED"
  }
};
Globe.Status = Status;
/**
 * @summary å°è¡¨æ­ç
 * @memberof mapray.Globe
 * @private
 */

var Flake =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Globe.Flake} parent
   * @param {number}             z
   * @param {number}             x
   * @param {number}             y
   */
  function Flake(parent, z, x, y) {
    _classCallCheck(this, Flake);

    /**
     * @summary å°è¡¨åå²ã¬ãã«
     * @member mapray.Globe.Flake#z
     * @type {number}
     */
    this.z = z;
    /**
     * @summary å°è¡¨ã¿ã¤ã« X åº§æ¨
     * @member mapray.Globe.Flake#x
     * @type {number}
     */

    this.x = x;
    /**
     * @summary å°è¡¨ã¿ã¤ã« Y åº§æ¨
     * @member mapray.Globe.Flake#y
     * @type {number}
     */

    this.y = y; // Flake éå±¤

    this._parent = parent;
    this._children = [null, null, null, null];
    this._globe = parent !== null ? parent._globe : null; // DEM ãã¼ã¿

    this._dem_data = null; // DEM ãã¤ããªãã¾ãã¯åãæ¶ããªãã¸ã§ã¯ã

    this._dem_state = DemState.NONE; // ã¨ã³ãã£ãã£è¾æ¸  Map.<mapray.Entity.FlakePrimitiveProducer, boolean>

    this._entity_map = null; // MeshNode

    this._meshes = []; // æ¨é«ä»£è¡¨å¤

    this._prev_Za_dem = null; // ååã® Za (DemBinary) ã ã ããæ¨é«ä»£è¡¨ãæ±ºå®ãã¦ããã¨ãã¯ this

    this._prev_Zr_dem = null; // ååã® Zr (DemBinary)

    this._base_height = 0; // å¹³åæ¨é« (h~)

    this._height_min = 0; // æå¤§æ¨é« (hâ)

    this._height_max = 0; // æå°æ¨é« (hâ)

    this._dem_zlimit = 0; // ã¡ãã·ã¥çææã® DEM Z ã¬ãã«ä¸é (Zb)
    // å¢çç®± (AABB)

    this._gocs_x_min = 0;
    this._gocs_x_max = 0;
    this._gocs_y_min = 0;
    this._gocs_y_max = 0;
    this._gocs_z_min = 0;
    this._gocs_z_max = 0; // ã­ã£ãã·ã¥ç®¡ç

    this._aframe = -1;

    if (this._globe !== null) {
      this._globe._num_cache_flakes += 1;
    }
  }
  /**
   * åºæºã®æ¨é«
   * @type {number}
   * @readonly
   */


  _createClass(Flake, [{
    key: "setupRoot",

    /**
     * @summary åºåº Flake å°ç¨ã®è¨­å®
     * @package
     */
    value: function setupRoot(globe, dem) {
      this._globe = globe;
      this._dem_data = dem;
      this._dem_state = DemState.LOADED;
      this._entity_map = new Map();

      this._estimate();

      globe._num_cache_flakes += 1;
    }
    /**
     * @summary å­ Flake ãåå¾ã¾ãã¯çæ
     * @param  {number} u            å­ Flake U åº§æ¨ (0 ã¾ãã¯ 1)
     * @param  {number} v            å­ Flake V åº§æ¨ (0 ã¾ãã¯ 1)
     * @return {mapray.Globe.Flake}  å­ Flake ã¤ã³ã¹ã¿ã³ã¹
     */

  }, {
    key: "newChild",
    value: function newChild(u, v) {
      var index = u + 2 * v;
      var child = this._children[index];

      if (child === null) {
        // å­å¨ããªãã¨ãã¯ Flake ãçæãã
        child = new Flake(this, this.z + 1, 2 * this.x + u, 2 * this.y + v);
        this._children[index] = child;
      }

      child._estimate();

      child.touch();
      return child;
    }
    /**
     * @summary ã«ãªã³ã°ãããï¼
     * @param  {mapray.Vector4[]} clip_planes  ã¯ãªããå¹³é¢éå
     * @return {boolean}                       è¦ããªãã¨ã true, è¦ããã¾ãã¯ä¸æã®ã¨ã false
     */

  }, {
    key: "isInvisible",
    value: function isInvisible(clip_planes) {
      switch (this.z) {
        case 0:
          return this._isInvisible_0(clip_planes);

        default:
          return this._isInvisible_N(clip_planes);
      }
    }
    /**
     * @summary ã¬ã³ããªã³ã°ãªãã¸ã§ã¯ããæ¤ç´¢
     *
     * @param {number} lod  å°è¡¨è©³ç´°ã¬ãã« (LOD)
     *
     * @return {mapray.FlakeRenderObject}
     */

  }, {
    key: "getRenderObject",
    value: function getRenderObject(lod) {
      var Î· = Math.pow(2, -lod) * Flake.Îµ; // 2^-lod Îµ

      var cu; // æ°´å¹³çé¢åå²ã¬ãã«

      if (Î· <= 2) {
        cu = Math.max(Math.ceil(GeoMath.LOG2PI - this.z - Math.maprayLog2(Math.acos(1 - Î·))), 0);
      } else {
        cu = 0;
      }

      var cosÏ = this._getCosÏ();

      var cv; // åç´çé¢åå²ã¬ãã«

      if (Î· * cosÏ <= 2) {
        cv = Math.max(Math.ceil(GeoMath.LOG2PI - this.z + Math.maprayLog2(cosÏ / Math.acos(1 - Î· * cosÏ))), 0);
      } else {
        cv = 0;
      }

      var node = this._getMeshNode(lod, cu, cv);

      node.touch();
      return node.getRenderObject();
    }
    /**
     * @summary this ã¨äº¤å·®ãã FlakePrimitiveProducer ã¤ã³ã¹ã¿ã³ã¹ã®åæå­ãåå¾
     *
     * @return {iterable.<mapray.Entity.FlakePrimitiveProducer>}
     */

  }, {
    key: "getEntityProducers",
    value: function getEntityProducers() {
      var entity_map = this._getEntityMap();

      return entity_map.keys();
    }
    /**
     * @summary Flake ããªã¼ã« producer ãè¿½å 
     *
     * äºåæ¡ä»¶:
     *   - this._entity_map !== null
     *   - this ã¨ this ã®å­å­«ã« producer ãå­å¨ããªã
     *
     * @param {mapray.Entity.FlakePrimitiveProducer} producer
     */

  }, {
    key: "addEntityProducer",
    value: function addEntityProducer(producer) {
      switch (producer.getAreaStatus(this)) {
        case Entity.AreaStatus.PARTIAL:
          {
            // ã¨ã³ããªã« producer ãè¿½å 
            this._entity_map.set(producer, false); // this ã®å­å­«ãåæ§ã®å¦ç


            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = this._children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var child = _step3.value;

                if (child !== null && child._entity_map !== null) {
                  child.addEntityProducer(producer);
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
          break;

        case Entity.AreaStatus.FULL:
          {
            this._addEntityFullProducer(producer);
          }
          break;
      }
    }
    /**
     * @summary Flake ããªã¼ã« producer ãè¿½å 
     *
     * äºåæ¡ä»¶:
     *   - producer.getAreaStatus( this ) === Entity.AreaStatus.FULL
     *   - this._entity_map !== null
     *   - this ã¨ this ã®å­å­«ã« producer ãå­å¨ããªã
     *
     * @param {mapray.Entity.FlakePrimitiveProducer} producer
     *
     * @private
     */

  }, {
    key: "_addEntityFullProducer",
    value: function _addEntityFullProducer(producer) {
      // ã¨ã³ããªã« producer ãè¿½å 
      this._entity_map.set(producer, true); // this ã®å­å­«ãåæ§ã®å¦ç


      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var child = _step4.value;

          if (child !== null && child._entity_map !== null) {
            child._addEntityFullProducer(producer);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
    /**
     * @summary Flake ããªã¼ãã producer ãåé¤
     *
     * äºåæ¡ä»¶:
     *   - this._entity_map !== null
     * äºå¾æ¡ä»¶:
     *   - this ã¨ this ã®å­å­«ã« producer ãå­å¨ããªã
     *
     * @param {mapray.Entity.FlakePrimitiveProducer} producer
     */

  }, {
    key: "removeEntityProducer",
    value: function removeEntityProducer(producer) {
      if (!this._entity_map.has(producer)) {
        // ãã¨ãã¨ producer ã¯ this ã¨ this ã®å­å­«ã«å­å¨ããªã
        return;
      } // ã¨ã³ããªãã producer ãåé¤


      this._entity_map["delete"](producer); // this ã« producer ã«å¯¾å¿ããã¡ãã·ã¥ãå­å¨ããã°åé¤


      this._removeEntityMeshes(producer); // this ã®å­å­«ãåæ§ã®å¦ç


      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this._children[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var child = _step5.value;

          if (child !== null && child._entity_map !== null) {
            child.removeEntityProducer(producer);
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
    /**
     * @summary Flake ããªã¼ã® producer ãæ´æ°
     *
     * äºåæ¡ä»¶:
     *   - this._entity_map !== null
     *
     * @param {mapray.Entity.FlakePrimitiveProducer} producer
     */

  }, {
    key: "updateEntityProducer",
    value: function updateEntityProducer(producer) {
      this.removeEntityProducer(producer);
      this.addEntityProducer(producer);
    }
    /**
     * @summary å°è¡¨æ­çã¨ã¬ã¤ã®äº¤ç¹ã¾ã§ã®è·é¢ãæ¤ç´¢
     * <p>å°è¡¨æ­ç this ã¨ç·å (ray.position ãå§ç¹ã¨ãããããã ray.direction æ¹åã« limit è·é¢æªæºã«ããç¹) ã¨ã®äº¤ç¹ã®ä¸­ã§ãå§ç¹ããæãè¿ãäº¤ç¹ã¾ã§ã®è·é¢ãè¿ãã</p>
     * <p>ãã ãå°è¡¨æ­çã¨ç·åãäº¤å·®ããªãã¨ãã¯ limit ãè¿ãã</p>
     * <p>äºåæ¡ä»¶: this._globe.status === Status.READY</p>
     * @param  {mapray.Ray} ray    ray.position ãå§ç¹ã¨ãã¦ ray.direction æ¹åã«ä¼¸ã³ãåç´ç·
     * @param  {number}     limit  ãã®è·é¢ã¾ã§ã®äº¤ç¹ãæ¤ç´¢
     * @return {number}            ray.position ããäº¤ç¹ã¾ã§ã®è·é¢ããã ãäº¤å·®ããªãã£ãã¨ãã¯ limit
     */

  }, {
    key: "findRayDistance",
    value: function findRayDistance(ray, limit) {
      var dem_flake;

      for (dem_flake = this; dem_flake._dem_state !== DemState.LOADED; dem_flake = dem_flake._parent) {}

      if (this.z - dem_flake.z === this._globe._Ï) {
        return this._findQuadRayDistance(ray, limit, dem_flake);
      } else if (this._cullForRayDistance(ray, limit)) {
        return limit;
      } else {
        var dmin = limit;

        for (var v = 0; v < 2; ++v) {
          for (var u = 0; u < 2; ++u) {
            dmin = this.newChild(u, v).findRayDistance(ray, dmin);
          }
        }

        return dmin;
      }
    }
    /**
     * @summary èªå·±ã¨å­å­«ãç ´æ£
     */

  }, {
    key: "dispose",
    value: function dispose() {
      var i;
      var parent = this._parent;

      if (parent === null) {
        // ãã§ã«ç ´æ£æ¸ã¿
        return;
      }

      var globe = this._globe; // ã¡ãã·ã¥ãç ´æ£

      var meshes = this._meshes;

      while (meshes.length > 0) {
        meshes[0].dispose();
      } // å­å­« Flake ãç ´æ£


      var children = this._children;

      for (i = 0; i < 4; ++i) {
        var child = children[i];

        if (child !== null) {
          child.dispose();
        }
      } // è¦ª Flake ãã this ãåé¤


      var pchildren = parent._children;

      for (i = 0; i < 4; ++i) {
        if (pchildren[i] === this) {
          pchildren[i] = null;
          break;
        }
      }

      this._parent = null; // DEM ãªã¯ã¨ã¹ãã®åãæ¶ã

      if (this._dem_state === DemState.REQUESTED) {
        globe._dem_provider.cancelRequest(this._dem_data);

        --globe._num_dem_requesteds;
      } // Flake æ°ãæ¸ãã


      globe._num_cache_flakes -= 1;
    }
    /**
     * @summary èªå·±ã¨å­å­«ã® Flake ãªã¹ããåå¾
     * @return {array}
     * @package
     */

  }, {
    key: "flattenFlakes",
    value: function flattenFlakes() {
      var list = [];

      this._flattenFlakes(list);

      return list;
    }
    /**
     * @summary èªå·±ã¨å­å­«ã® MeshNode ãªã¹ããåå¾
     * @return {array}
     * @package
     */

  }, {
    key: "flattenMeshes",
    value: function flattenMeshes() {
      var list = [];

      this._flattenMeshes(list);

      return list;
    }
    /**
     * @summary åæ¸ç¨ã® Flake æ¯è¼
     * @param  {mapray.Globe.Flake} other  æ¯è¼å¯¾è±¡
     * @return {number}                    æ¯è¼å¤
     * @package
     */

  }, {
    key: "compareForReduce",
    value: function compareForReduce(other) {
      // æè¿ã¢ã¯ã»ã¹ãããã®ãåªå
      // åããªã Z ã¬ãã«ãå°ããæ¹ãåªå
      var a = this;
      var b = other;
      var aframe = b._aframe - a._aframe;
      return aframe !== 0 ? aframe : a.z - b.z;
    }
    /**
     * @private
     */

  }, {
    key: "_flattenFlakes",
    value: function _flattenFlakes(list) {
      list.push(this);
      var children = this._children;

      for (var i = 0; i < 4; ++i) {
        var child = children[i];

        if (child !== null) {
          child._flattenFlakes(list);
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "_flattenMeshes",
    value: function _flattenMeshes(list) {
      Array.prototype.push.apply(list, this._meshes);
      var children = this._children;

      for (var i = 0; i < 4; ++i) {
        var child = children[i];

        if (child !== null) {
          child._flattenMeshes(list);
        }
      }
    }
    /**
     * @summary ã¢ã¯ã»ã¹ãã¬ã¼ã ãæ´æ°
     * @package
     */

  }, {
    key: "touch",
    value: function touch() {
      var globe = this._globe;

      if (this._aframe !== globe._frame_counter) {
        this._aframe = globe._frame_counter;
        globe._num_touch_flakes += 1;
      }
    }
    /**
     * @summary ã¡ãã·ã¥ãã¼ããåå¾
     *
     * @param {number} lod  å°è¡¨è©³ç´°ã¬ãã« (LOD)
     * @param {number} cu   æ°´å¹³çé¢åå²ã¬ãã«
     * @param {number} cv   åç´çé¢åå²ã¬ãã«
     *
     * @return {mapray.Globe.MeshNode}  ã¡ãã·ã¥ãã¼ã
     *
     * @private
     */

  }, {
    key: "_getMeshNode",
    value: function _getMeshNode(lod, cu, cv) {
      var dem = this._getMeshDemBinary(lod);

      var dpows = dem.getDivisionPowers(this, lod, cu, cv); // ã­ã£ãã·ã¥ã«å­å¨ããã°ããããè¿ã

      var meshes = this._meshes;
      var length = meshes.length;

      for (var i = 0; i < length; ++i) {
        var item = meshes[i];

        if (item.match(dem, dpows)) {
          return item;
        }
      } // ã­ã£ãã·ã¥ã«å­å¨ããªãã®ã§æ°è¦ã«çæ


      var node = new MeshNode(this, dem, dpows);
      meshes.unshift(node); // æ¤ç´¢å¹çã®ããåé ­ã«è¿½å 

      return node;
    }
    /**
     * @summary ã¡ãã·ã¥ç¨ã® DEM ãã¤ããªãåå¾
     * @param  {number} lod        å°è¡¨è©³ç´°ã¬ãã« (LOD)
     * @return {mapray.DemBinary}  DEM ã¿ã¤ã«ãã¼ã¿
     * @private
     */

  }, {
    key: "_getMeshDemBinary",
    value: function _getMeshDemBinary(lod) {
      var zDesired = GeoMath.clamp(Math.round(lod + this._globe._dem_zbias), 0, this._dem_zlimit);

      var dem = this._findNearestDemTile(zDesired); // ä¸ã®ã¬ãã«ã® DEM ããªã¯ã¨ã¹ã


      if (dem.z < zDesired) {
        var qlevel = dem.getQuadLevel(this.z, this.x, this.y);

        if (qlevel > 0) {
          this._requestAncestorDemTile(Math.min(dem.z + qlevel, zDesired));
        }
      }

      return dem;
    }
    /**
     * @summary åç¥ DEM ã¿ã¤ã«ãã¼ã¿ãæ¤ç´¢
     * @desc
     * <p>this ã® (ã¬ãã«ã zlimit ã¾ãã¯ããä»¥ä¸ã®) ç¥åã®ä¸­ã§ãç¾å¨ã­ã£ãã·ã¥ã«å­å¨ããæå¤§ã¬ãã«ã® DEM ã¿ã¤ã«ãã¼ã¿ãæ¤ç´¢ããã</p>
     * @param  {number} zlimit     åç¥ã¬ãã«ã®ä¸é
     * @return {mapray.DemBinary}  åç¥ DEM ã¿ã¤ã«ãã¼ã¿
     */

  }, {
    key: "_findNearestDemTile",
    value: function _findNearestDemTile(zlimit) {
      var flake = this; // zlimit ã®å°è¡¨æ­çãæ¤ç´¢

      var count = this.z - zlimit;

      for (var i = 0; i < count; ++i) {
        flake = flake._parent;
      } // æ¬¡ã® DemBinary ãæã¤å°è¡¨æ­çãæ¤ç´¢


      while (flake._dem_state !== DemState.LOADED) {
        flake = flake._parent;
      } // è¦ã¤ããå°è¡¨æ­çã® DemBinary ãè¿ã


      return flake._dem_data;
    }
    /**
     * @summary å°è¡¨æ­çãåå«ãã DEM ã¿ã¤ã«ãã¼ã¿ãè¦æ±
     * @desc
     * <p>this ãåå«ã¾ãã¯ this ã¨ä¸è´ããããºã¼ã ã¬ãã« ze ã® DEM ã¿ã¤ã«ããµã¼ãã¼ã«è¦æ±ããã</p>
     * <p>ãã ããã§ã«ã­ã£ãã·ã¥ã«ãã® DEM ã¿ã¤ã«ãå­å¨ãã¾ãã¯ REQUESTED ç¶æã®ã¨ãã¯è¦æ±ããªãã</p>
     * <p>FAILED ç¶æãã¤ ze > 0 ã®ã¨ãã¯ãåå¸°çã« ze - 1 ãè¦æ±ããã</p>
     * <p>è¦æ±ãæå¤§æ°ã«éãã¦ããã¨ãã¯ç¡è¦ããã</p>
     * @param {number} ze  DEM ãºã¼ã ã¬ãã«
     */

  }, {
    key: "_requestAncestorDemTile",
    value: function _requestAncestorDemTile(ze) {
      var globe = this._globe;

      if (globe._num_dem_requesteds >= globe._max_dem_requesteds) {
        // è¦æ±ãæå¤§æ°ã«éãã¦ããã®ã§åãå¥ããªã
        return;
      }

      var flake = this; // zlimit ã®å°è¡¨æ­çãæ¤ç´¢

      var count = this.z - ze;

      for (var i = 0; i < count; ++i) {
        flake = flake._parent;
      }

      while (true) {
        var state = flake._dem_state;

        if (state === DemState.LOADED || state === DemState.REQUESTED) {
          // è¦æ±ããå¿è¦ããªã
          break;
        } else if (state === DemState.FAILED) {
          // è¦ªã§ãªãã©ã¤
          flake = flake._parent;
          continue;
        } else {
          // DEM ã¿ã¤ã«ãã¼ã¿ãè¦æ±
          // assert: state === DemState.NONE
          var provider = globe._dem_provider;
          flake._dem_data = provider.requestTile(flake.z, flake.x, flake.y, function (data) {
            if (flake._parent === null) {
              // ãã§ã«ç ´æ£æ¸ã¿ãªã®ã§ç¡è¦
              return;
            }

            if (data) {
              flake._dem_data = new DemBinary(flake.z, flake.x, flake.y, globe._Ï, data);
              flake._dem_state = DemState.LOADED;

              globe._dem_area_updated.addTileArea(flake);
            } else {
              // ãã¼ã¿åå¾ã«å¤±æ
              flake._dem_data = null;
              flake._dem_state = DemState.FAILED;
            }

            --globe._num_dem_requesteds;
          });
          flake._dem_state = DemState.REQUESTED;
          ++globe._num_dem_requesteds;
          break;
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "_isInvisible_0",
    value: function _isInvisible_0(clip_planes) {
      var r = GeoMath.EARTH_RADIUS + this._height_max;

      for (var i = 0; i < clip_planes.length; ++i) {
        var dist = clip_planes[i][3]; // å¹³é¢ãã GOCS åç¹ (å°çä¸­å¿) ã¾ã§ã®è·é¢

        if (dist < -r) {
          // å°çå¨ä½ããã®å¹³é¢ã®è£å´ã«ããã®ã§è¦ããªã
          return true;
        }
      }

      return false; // è¦ãã¦ããå¯è½æ§ããã
    }
    /**
     * @private
     */

  }, {
    key: "_isInvisible_N",
    value: function _isInvisible_N(clip_planes) {
      var xmin = this._gocs_x_min;
      var xmax = this._gocs_x_max;
      var ymin = this._gocs_y_min;
      var ymax = this._gocs_y_max;
      var zmin = this._gocs_z_min;
      var zmax = this._gocs_z_max;

      for (var i = 0; i < clip_planes.length; ++i) {
        var p = clip_planes[i];
        var px = p[0];
        var py = p[1];
        var pz = p[2];
        var pw = p[3]; // ä»¥ä¸ããã¹ã¦æãç«ã¤ã¨ããã¯ã¹å¨ä½ã¯å¹³é¢ã®è£å´ã«ãã
        //   px*xmin + py*ymin + pz*zmin + pw < 0
        //   px*xmax + py*ymin + pz*zmin + pw < 0
        //   px*xmin + py*ymax + pz*zmin + pw < 0
        //   px*xmax + py*ymax + pz*zmin + pw < 0
        //   px*xmin + py*ymin + pz*zmax + pw < 0
        //   px*xmax + py*ymin + pz*zmax + pw < 0
        //   px*xmin + py*ymax + pz*zmax + pw < 0
        //   px*xmax + py*ymax + pz*zmax + pw < 0

        var c0 = px * xmin + py * ymin;
        var c1 = px * xmax + py * ymin;
        var c2 = px * xmin + py * ymax;
        var c3 = px * xmax + py * ymax;
        var c4 = -pz * zmin - pw;
        var c5 = -pz * zmax - pw;

        if (c0 < c4 && c1 < c4 && c2 < c4 && c3 < c4 && c0 < c5 && c1 < c5 && c2 < c5 && c3 < c5) {
          // ããã¯ã¹å¨ä½ãå¹³é¢ã®è£å´ã«ããã®ã§è¦ããªã
          return true;
        }
      }

      return false; // è¦ãã¦ããå¯è½æ§ããã
    }
    /**
     * @summary ä¸­éç·¯åº¦ã®ä½å¼¦
     * @return {number}
     * @private
     */

  }, {
    key: "_getCos\u03C6",
    value: function _getCos() {
      var z = this.z;

      if (z > 0) {
        var y = this.y;
        var p = Math.pow(2, 1 - z);
        var y0 = Math.abs(1 - p * y);
        var y1 = Math.abs(1 - p * (y + 1));
        var ey = Math.exp(Math.PI * Math.min(y0, y1));
        return 2 * ey / (ey * ey + 1); // Cos[Ï] == Cos[gd[y]] == Sech[y]
      } else {
        // z == 0 ã®ã¨ãã¯ Ï == 0 ã¨ãã
        return 1; // Cos[0]
      }
    }
    /**
     * @summary æ¨é«ä»£è¡¨å¤ã¨å¢çç®±ãæ´æ°
     * @private
     */

  }, {
    key: "_estimate",
    value: function _estimate() {
      if (this._prev_Za_dem === this) {
        // ä»£è¡¨å¤ã¯æ±ºå®æ¸ã¿ãªã®ã§ä½ãããªã
        return;
      }

      var zg = this.z;
      var Ï = this._globe._Ï;
      var zr_dem;

      if (zg < Ï) {
        zr_dem = this._findNearestDemTile(zg);

        if (zr_dem === this._prev_Zr_dem) {
          // ååã¨ä»£è¡¨å¤ãå¤ãããªãã®ã§ä½ãããªã
          return;
        }

        this._prev_Zr_dem = zr_dem;

        this._estimate_low(zr_dem);

        this._dem_zlimit = zg;
      } else {
        var za_dem = this._findNearestDemTile(zg - Ï);

        if (za_dem.isLeaf(zg, this.x, this.y)) {
          this._estimate_leaf(za_dem);
        } else {
          zr_dem = this._findNearestDemTile(za_dem.z + Ï);

          if (za_dem === this._prev_Za_dem && zr_dem === this._prev_Zr_dem) {
            // ååã¨ä»£è¡¨å¤ãå¤ãããªãã®ã§ä½ãããªã
            return;
          }

          this._prev_Za_dem = za_dem;
          this._prev_Zr_dem = zr_dem;

          this._estimate_high(za_dem, zr_dem);
        }

        this._dem_zlimit = za_dem.z + Ï;
      } // å¢çç®±ã®æ´æ°


      switch (zg) {
        case 0:
          this._updataBoundingBox_0();

          break;

        case 1:
          this._updataBoundingBox_1();

          break;

        default:
          this._updataBoundingBox_N();

          break;
      }
    }
    /**
     * @summary æ¨é«ä»£è¡¨å¤ãè¨ç® (Zg < Ï)
     * @param {mapray.DemBinary} zr_dem  ã¬ãã«ã Zr ã® DEM
     * @private
     */

  }, {
    key: "_estimate_low",
    value: function _estimate_low(zr_dem) {
      var zg = this.z;
      var xg = this.x;
      var yg = this.y;

      var Î± = this._calcAlpha();

      this._base_height = this._globe._avg_height.sample(zg, xg, yg);
      this._height_min = Math.max(this._base_height + Î± * Flake.Fm, zr_dem.height_min);
      this._height_max = Math.min(this._base_height + Î± * Flake.Fp, zr_dem.height_max);

      if (zr_dem.z == zg || zr_dem.isLeaf(zg, xg, yg)) {
        // æ¨é«ä»£è¡¨å¤ãç¢ºå®ãã
        this._prev_Za_dem = this;
      }
    }
    /**
     * @summary æ¨é«ä»£è¡¨å¤ãè¨ç® (Zg >= Ï && !L(Za))
     * @param {mapray.DemBinary} za_dem  ã¬ãã«ã Za ã® DEM
     * @param {mapray.DemBinary} zr_dem  ã¬ãã«ã Zr ã® DEM
     * @private
     */

  }, {
    key: "_estimate_high",
    value: function _estimate_high(za_dem, zr_dem) {
      var globe = this._globe;
      var zg = this.z;
      var xg = this.x;
      var yg = this.y;
      var ze = za_dem.z; // -> za

      var xe = za_dem.x;
      var ye = za_dem.y;
      var Ï = globe._Ï;
      var pow = Math.pow(2, ze - zg);
      var size = 1 << Ï;
      var u = Math.floor(size * ((xg + 0.5) * pow - xe));
      var v = Math.floor(size * ((yg + 0.5) * pow - ye));
      var smin = size * (xg * pow - xe) - u;
      var smax = size * ((xg + 1) * pow - xe) - u;
      var tmin = size * (yg * pow - ye) - v;
      var tmax = size * ((yg + 1) * pow - ye) - v;
      var heights = za_dem.getHeights(u, v);
      var h00 = heights[0];
      var h10 = heights[1];
      var h01 = heights[2];
      var h11 = heights[3];
      var h0 = (h00 * (1 - smin) + h10 * smin) * (1 - tmin) + (h01 * (1 - smin) + h11 * smin) * tmin;
      var h1 = (h00 * (1 - smax) + h10 * smax) * (1 - tmin) + (h01 * (1 - smax) + h11 * smax) * tmin;
      var h2 = (h00 * (1 - smin) + h10 * smin) * (1 - tmax) + (h01 * (1 - smin) + h11 * smin) * tmax;
      var h3 = (h00 * (1 - smax) + h10 * smax) * (1 - tmax) + (h01 * (1 - smax) + h11 * smax) * tmax;

      var Î± = this._calcAlpha();

      this._base_height = 0.25 * (h0 + h1 + h2 + h3);
      this._height_min = Math.max(this._base_height + Î± * Flake.Fm, zr_dem.height_min);
      this._height_max = Math.min(this._base_height + Î± * Flake.Fp, zr_dem.height_max);

      if (ze < zg - Ï) {
        // ä¸ã®ã¬ãã«ã® DEM ããªã¯ã¨ã¹ã
        var qlevel = za_dem.getQuadLevel(zg, xg, yg); // assert: qlevel > 0

        this._requestAncestorDemTile(Math.min(ze + qlevel, zg - Ï));
      } else if (zr_dem.z == zg || zr_dem.isLeaf(zg, xg, yg)) {
        // æ¨é«ä»£è¡¨å¤ãç¢ºå®ãã
        // assert: ze == zg - Ï
        this._prev_Za_dem = this;
      }
    }
    /**
     * @summary æ¨é«ä»£è¡¨å¤ãè¨ç® (Zg >= Ï && L(Za))
     * @param {mapray.DemBinary} za_dem  ã¬ãã«ã Za ã® DEM
     * @private
     */

  }, {
    key: "_estimate_leaf",
    value: function _estimate_leaf(za_dem) {
      var zg = this.z;
      var xg = this.x;
      var yg = this.y;
      var ze = za_dem.z; // -> za

      var xe = za_dem.x;
      var ye = za_dem.y;
      var pow = Math.pow(2, ze - zg);
      var size = 1 << this._globe._Ï;
      var u = Math.floor(size * ((xg + 0.5) * pow - xe));
      var v = Math.floor(size * ((yg + 0.5) * pow - ye));
      var smin = size * (xg * pow - xe) - u;
      var smax = size * ((xg + 1) * pow - xe) - u;
      var tmin = size * (yg * pow - ye) - v;
      var tmax = size * ((yg + 1) * pow - ye) - v;
      var heights = za_dem.getHeights(u, v);
      var h00 = heights[0];
      var h10 = heights[1];
      var h01 = heights[2];
      var h11 = heights[3]; // Hi = Di( Za )

      var h0 = (h00 * (1 - smin) + h10 * smin) * (1 - tmin) + (h01 * (1 - smin) + h11 * smin) * tmin;
      var h1 = (h00 * (1 - smax) + h10 * smax) * (1 - tmin) + (h01 * (1 - smax) + h11 * smax) * tmin;
      var h2 = (h00 * (1 - smin) + h10 * smin) * (1 - tmax) + (h01 * (1 - smin) + h11 * smin) * tmax;
      var h3 = (h00 * (1 - smax) + h10 * smax) * (1 - tmax) + (h01 * (1 - smax) + h11 * smax) * tmax;
      this._base_height = 0.25 * (h0 + h1 + h2 + h3);
      this._height_min = Math.min(h0, h1, h2, h3);
      this._height_max = Math.max(h0, h1, h2, h3); // æ¨é«ä»£è¡¨å¤ãç¢ºå®ãã

      this._prev_Za_dem = this;
    }
    /**
     * @summary Î± ãè¨ç®
     * @desc
     * <p>ä¸­éç·¯åº¦ã®æ¨é« 0 ã§ã®ç·¯ç·ã®é·ããç¤ºãå¤ Î± ãè¨ç®ããã</p>
     * @return {number}  Î±
     * @private
     */

  }, {
    key: "_calcAlpha",
    value: function _calcAlpha() {
      var pow = Math.pow(2, 1 - this.z);
      return pow * Flake.Ïr / Math.cosh((1 - pow * (this.y + 0.5)) * Math.PI);
    }
    /**
     * @summary å¢çç®±ãæ´æ° (Z == 0)
     */

  }, {
    key: "_updataBoundingBox_0",
    value: function _updataBoundingBox_0() {
      var r = GeoMath.EARTH_RADIUS + this._height_max;
      this._gocs_x_min = -r;
      this._gocs_x_max = r;
      this._gocs_y_min = -r;
      this._gocs_y_max = r;
      this._gocs_z_min = -r;
      this._gocs_z_max = r;
    }
    /**
     * @summary å¢çç®±ãæ´æ° (Z == 1)
     */

  }, {
    key: "_updataBoundingBox_1",
    value: function _updataBoundingBox_1() {
      var r = GeoMath.EARTH_RADIUS + this._height_max;
      var x = this.x;
      var y = this.y;
      this._gocs_x_min = -r;
      this._gocs_x_max = r;
      this._gocs_y_min = r * (x - 1);
      this._gocs_y_max = r * x;
      this._gocs_z_min = -r * y;
      this._gocs_z_max = r * (1 - y);
    }
    /**
     * @summary å¢çç®±ãæ´æ° (Z >= 2)
     */

  }, {
    key: "_updataBoundingBox_N",
    value: function _updataBoundingBox_N() {
      var pi = Math.PI;
      var z = this.z;
      var x = this.x;
      var y = this.y; // åº§æ¨ç¯å² (åä½çã¡ã«ã«ãã«åº§æ¨ç³»)

      var msize = Math.pow(2, 1 - z) * pi;
      var mx_min = -pi + x * msize;
      var mx_max = -pi + (x + 1) * msize;
      var my_min = pi - (y + 1) * msize;
      var my_max = pi - y * msize; // äºåè¨ç®å¤æ°

      var Î»min = mx_min;
      var Î»max = mx_max;
      var emin = Math.exp(my_min); // Exp[my_min]

      var emax = Math.exp(my_max); // Exp[my_max]

      var e2min = emin * emin; // Exp[my_min]^2

      var e2max = emax * emax; // Exp[my_max]^2
      // åº§æ¨ç¯å² (å°å¿ç´äº¤åº§æ¨ç³»)
      //
      // z >= 2 ã®ã¨ããÎ»ã¨Ïã®ç¯å²ã¯ä»¥ä¸ã®åºéã®ã©ããã«å¥ã
      //   Ï:                (-Ï/2, 0] [0, Ï/2)
      //   Î»:   [-Ï, -Ï/2] [-Ï/2, 0] [0, Ï/2] [Ï/2, Ï]
      //
      // åºéãã¨ã®é¢æ°ã®å¤å (ååºéã§åèª¿å¢å ã¾ãã¯åèª¿æ¸å°)
      //   Sin[Ï]:            (-1 â 0] [0 â 1)
      //   Cos[Ï]:            ( 0 â 1] [1 â 0)
      //   Sin[Î»]: [ 0 â -1] [-1 â 0] [0 â 1] [1 â  0]
      //   Cos[Î»]: [-1 â  0] [ 0 â 1] [1 â 0] [0 â -1]

      var rmin = GeoMath.EARTH_RADIUS + this._height_min;
      var rmax = GeoMath.EARTH_RADIUS + this._height_max;
      var cosÏmin = 2 * emin / (e2min + 1);
      var cosÏmax = 2 * emax / (e2max + 1); // gx = r Cos[Ï] Cos[Î»]
      // gy = r Cos[Ï] Sin[Î»]
      // gz = r Sin[Ï]

      if (my_min + my_max < 0) {
        // Ï : (-Ï/2, 0]
        if (Î»min + Î»max < -pi) {
          // Î» : [-Ï, -Ï/2]
          this._gocs_x_min = rmax * cosÏmax * Math.cos(Î»min);
          this._gocs_x_max = rmin * cosÏmin * Math.cos(Î»max);
          this._gocs_y_min = rmax * cosÏmax * Math.sin(Î»max);
          this._gocs_y_max = rmin * cosÏmin * Math.sin(Î»min);
        } else if (Î»min + Î»max < 0) {
          // Î» : [-Ï/2, 0]
          this._gocs_x_min = rmin * cosÏmin * Math.cos(Î»min);
          this._gocs_x_max = rmax * cosÏmax * Math.cos(Î»max);
          this._gocs_y_min = rmax * cosÏmax * Math.sin(Î»min);
          this._gocs_y_max = rmin * cosÏmin * Math.sin(Î»max);
        } else if (Î»min + Î»max < pi) {
          // Î» : [0, Ï/2]
          this._gocs_x_min = rmin * cosÏmin * Math.cos(Î»max);
          this._gocs_x_max = rmax * cosÏmax * Math.cos(Î»min);
          this._gocs_y_min = rmin * cosÏmin * Math.sin(Î»min);
          this._gocs_y_max = rmax * cosÏmax * Math.sin(Î»max);
        } else {
          // Î» : [Ï/2, Ï]
          this._gocs_x_min = rmax * cosÏmax * Math.cos(Î»max);
          this._gocs_x_max = rmin * cosÏmin * Math.cos(Î»min);
          this._gocs_y_min = rmin * cosÏmin * Math.sin(Î»max);
          this._gocs_y_max = rmax * cosÏmax * Math.sin(Î»min);
        }

        this._gocs_z_min = rmax * (e2min - 1) / (e2min + 1);
        this._gocs_z_max = rmin * (e2max - 1) / (e2max + 1);
      } else {
        // Ï : [0, Ï/2)
        if (Î»min + Î»max < -pi) {
          // Î» : [-Ï, -Ï/2]
          this._gocs_x_min = rmax * cosÏmin * Math.cos(Î»min);
          this._gocs_x_max = rmin * cosÏmax * Math.cos(Î»max);
          this._gocs_y_min = rmax * cosÏmin * Math.sin(Î»max);
          this._gocs_y_max = rmin * cosÏmax * Math.sin(Î»min);
        } else if (Î»min + Î»max < 0) {
          // Î» : [-Ï/2, 0]
          this._gocs_x_min = rmin * cosÏmax * Math.cos(Î»min);
          this._gocs_x_max = rmax * cosÏmin * Math.cos(Î»max);
          this._gocs_y_min = rmax * cosÏmin * Math.sin(Î»min);
          this._gocs_y_max = rmin * cosÏmax * Math.sin(Î»max);
        } else if (Î»min + Î»max < pi) {
          // Î» : [0, Ï/2]
          this._gocs_x_min = rmin * cosÏmax * Math.cos(Î»max);
          this._gocs_x_max = rmax * cosÏmin * Math.cos(Î»min);
          this._gocs_y_min = rmin * cosÏmax * Math.sin(Î»min);
          this._gocs_y_max = rmax * cosÏmin * Math.sin(Î»max);
        } else {
          // Î» : [Ï/2, Ï]
          this._gocs_x_min = rmax * cosÏmin * Math.cos(Î»max);
          this._gocs_x_max = rmin * cosÏmax * Math.cos(Î»min);
          this._gocs_y_min = rmin * cosÏmax * Math.sin(Î»max);
          this._gocs_y_max = rmax * cosÏmin * Math.sin(Î»min);
        }

        this._gocs_z_min = rmin * (e2min - 1) / (e2min + 1);
        this._gocs_z_max = rmax * (e2max - 1) / (e2max + 1);
      }
    }
    /**
     * ãµã¼ãã¼ã«ããã«æ­£ç¢ºåº¦ãé«ã DEM ã¿ã¤ã«ãã¼ã¿ãå­å¨ããã°ãããããªã¯ã¨ã¹ãããã
     * @param  {number} xt  X åº§æ¨ (åºåºã¿ã¤ã«åº§æ¨ç³»)
     * @param  {number} yt  Y åº§æ¨ (åºåºã¿ã¤ã«åº§æ¨ç³»)
     * @private
     */

  }, {
    key: "_requestHighestAccuracy",
    value: function _requestHighestAccuracy(xt, yt) {
      var qlevel = this._dem_data.getQuadLevelDirect(xt, yt);

      if (qlevel == 0) {
        // ããã«æ­£ç¢ºåº¦ãé«ã DEM ã¿ã¤ã«ãã¼ã¿ã¯å­å¨ããªã
        return;
      }

      var flake = this;
      var size = Math.round(Math.pow(2, this.z + 1));
      var xf = size * xt;
      var yf = size * yt;

      for (var i = 0; i < qlevel; ++i) {
        var u = GeoMath.clamp(Math.floor(xf), 0, size - 1) % 2;
        var v = GeoMath.clamp(Math.floor(yf), 0, size - 1) % 2;
        flake = flake.newChild(u, v);
        size *= 2;
        xf *= 2;
        yf *= 2;
      }

      flake._requestAncestorDemTile(flake.z);
    }
    /**
     * @summary å°è¡¨æ­çã¨ã¬ã¤ã®äº¤ç¹ã¾ã§ã®è·é¢ãæ¤ç´¢
     * <p>å°è¡¨æ­ç this ã¨ç·å (ray.position ãå§ç¹ã¨ãããããã ray.direction æ¹åã« limit è·é¢æªæºã«ããç¹) ã¨ã®äº¤ç¹ã¾ã§ã®è·é¢ãè¿ãã</p>
     * <p>ãã ãå°è¡¨æ­çã¨ç·åãäº¤å·®ããªãã¨ãã¯ limit ãè¿ãã</p>
     * @private
     */

  }, {
    key: "_findQuadRayDistance",
    value: function _findQuadRayDistance(ray, limit, dem_flake) {
      var pts = this._getQuadPositions(dem_flake, Flake._temp_positions);

      var dist = Flake._findTriRayDistance(ray, limit, pts[0], pts[2], pts[1]);

      return dist === limit ? Flake._findTriRayDistance(ray, limit, pts[1], pts[2], pts[3]) : dist;
    }
    /**
     * @summary ä¸è§å½¢ã¨ã¬ã¤ã®äº¤ç¹ã¾ã§ã®è·é¢ãæ¤ç´¢
     * <p>ä¸è§å½¢ p0, p1, p2 ã¨ç·å (ray.position ãå§ç¹ã¨ãããããã ray.direction æ¹åã« limit è·é¢æªæºã«ããç¹) ã¨ã®äº¤ç¹ã¾ã§ã®è·é¢ãè¿ãã</p>
     * <p>ãã ãå°è¡¨æ­çã¨ç·åãäº¤å·®ããªãã¨ãã¯ limit ãè¿ãã</p>
     * @private
     */

  }, {
    key: "_getQuadPositions",

    /**
     * @summary åéã®ä½ç½®ãåå¾
     * @param  {mapray.Globe.Flake} dem_flake  DEM ã®å°è¡¨æ­ç
     * @param  {array}              positions  çµæã®æ ¼ç´å
     * @return {array}                         positions = [å·¦ä¸, å³ä¸, å·¦ä¸, å³ä¸]
     * @private
     */
    value: function _getQuadPositions(dem_flake, positions) {
      var xg = this.x;
      var yg = this.y;
      var xe = dem_flake.x;
      var ye = dem_flake.y;
      var size = 1 << this._globe._Ï;

      var heights = dem_flake._dem_data.getHeights(xg - size * xe, yg - size * ye);

      var msize = Math.pow(2, 1 - this.z) * Math.PI;
      var mx0 = xg * msize - Math.PI;
      var my0 = Math.PI - yg * msize;

      for (var iv = 0, my = my0; iv < 2; ++iv, my -= msize) {
        var ey = Math.exp(my);
        var ey2 = ey * ey;
        var sinÏ = (ey2 - 1) / (ey2 + 1);
        var cosÏ = 2 * ey / (ey2 + 1);

        for (var iu = 0, mx = mx0; iu < 2; ++iu, mx += msize) {
          var index = iu + 2 * iv;
          var radius = GeoMath.EARTH_RADIUS + heights[index];
          var sinÎ» = Math.sin(mx);
          var cosÎ» = Math.cos(mx);
          var pos = positions[index];
          pos[0] = radius * cosÏ * cosÎ»;
          pos[1] = radius * cosÏ * sinÎ»;
          pos[2] = radius * sinÏ;
        }
      }

      return positions;
    }
    /**
     * @summary å°è¡¨æ­çã¨ã¬ã¤ã®äº¤ç¹ã¾ã§ã®è·é¢ãæ¤ç´¢
     * <p>å°è¡¨æ­ç this ã¨ç·å (ray.position ãå§ç¹ã¨ãããããã ray.direction æ¹åã« limit è·é¢æªæºã«ããç¹) ãäº¤å·®ããªãã¨ãã¯ true, äº¤å·®ããã¾ãã¯ä¸æã®ã¨ã false ãè¿ãã
     * @private
     */

  }, {
    key: "_cullForRayDistance",
    value: function _cullForRayDistance(ray, limit) {
      var q = ray.position;
      var qx = q[0];
      var qy = q[1];
      var qz = q[2];
      var xmin = this._gocs_x_min;
      var xmax = this._gocs_x_max;
      var ymin = this._gocs_y_min;
      var ymax = this._gocs_y_max;
      var zmin = this._gocs_z_min;
      var zmax = this._gocs_z_max;

      if (xmin <= qx && qx <= xmax && ymin <= qy && qy <= ymax && zmin <= qz && qz <= zmax) {
        // ray ã®å§ç¹ã AABB ã®è¡¨é¢ã¾ãã¯åé¨ -> äº¤å·®ããå¯è½æ§ããã
        return false;
      }

      var v = ray.direction;
      var vx = v[0];
      var vy = v[1];
      var vz = v[2];
      var t;
      var px;
      var py;
      var pz; // yz

      if (qx < xmin && vx > 0) {
        t = (xmin - qx) / vx;

        if (t < limit) {
          py = qy + t * vy;
          pz = qz + t * vz;

          if (ymin <= py && py <= ymax && zmin <= pz && pz <= zmax) {
            // ray ç·åã¯ AABB ã® xmin é¢åã§äº¤å·®
            return false;
          }
        }
      } else if (qx > xmax && vx < 0) {
        t = (xmax - qx) / vx;

        if (t < limit) {
          py = qy + t * vy;
          pz = qz + t * vz;

          if (ymin <= py && py <= ymax && zmin <= pz && pz <= zmax) {
            // ray ç·åã¯ AABB ã® xmax é¢åã§äº¤å·®
            return false;
          }
        }
      } // xz


      if (qy < ymin && vy > 0) {
        t = (ymin - qy) / vy;

        if (t < limit) {
          px = qx + t * vx;
          pz = qz + t * vz;

          if (xmin <= px && px <= xmax && zmin <= pz && pz <= zmax) {
            // ray ç·åã¯ AABB ã® ymin é¢åã§äº¤å·®
            return false;
          }
        }
      } else if (qy > ymax && vy < 0) {
        t = (ymax - qy) / vy;

        if (t < limit) {
          px = qx + t * vx;
          pz = qz + t * vz;

          if (xmin <= px && px <= xmax && zmin <= pz && pz <= zmax) {
            // ray ç·åã¯ AABB ã® ymax é¢åã§äº¤å·®
            return false;
          }
        }
      } // xy


      if (qz < zmin && vz > 0) {
        t = (zmin - qz) / vz;

        if (t < limit) {
          px = qx + t * vx;
          py = qy + t * vy;

          if (xmin <= px && px <= xmax && ymin <= py && py <= ymax) {
            // ray ç·åã¯ AABB ã® zmin é¢åã§äº¤å·®
            return false;
          }
        }
      } else if (qz > zmax && vz < 0) {
        t = (zmax - qz) / vz;

        if (t < limit) {
          px = qx + t * vx;
          py = qy + t * vy;

          if (xmin <= px && px <= xmax && ymin <= py && py <= ymax) {
            // ray ç·åã¯ AABB ã® zmax é¢åã§äº¤å·®
            return false;
          }
        }
      } // ray ç·åã¨ AABB ã¯äº¤å·®ããªã


      return true;
    }
    /**
     * @summary ã¨ã³ãã£ãã£ã®ã¡ãã·ã¥ãåé¤
     *
     * @param {mapray.Entity.FlakePrimitiveProducer} producer
     *
     * @private
     */

  }, {
    key: "_removeEntityMeshes",
    value: function _removeEntityMeshes(producer) {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this._meshes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var node = _step6.value;
          node.removeEntityMesh(producer);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
    /**
     * @summary ã¨ã³ãã£ãã£è¾æ¸ãåå¾
     *
     * @return {Map.<mapray.Entity.FlakePrimitiveProducer, boolean>}
     *
     * @private
     */

  }, {
    key: "_getEntityMap",
    value: function _getEntityMap() {
      if (this._entity_map === null) {
        // å­å¨ããªãã®ã§æ°ãã«çæãã
        var parent_map = this._parent._getEntityMap(); // è¦ªã®è¾æ¸


        var entity_map = new Map();
        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
          for (var _iterator7 = parent_map[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var _step7$value = _slicedToArray(_step7.value, 2),
                producer = _step7$value[0],
                isfull = _step7$value[1];

            if (isfull) {
              // è¦ªã FULL ãªã®ã§ãå­ã FULL
              entity_map.set(producer, true);
            } else {
              switch (producer.getAreaStatus(this)) {
                case Entity.AreaStatus.PARTIAL:
                  entity_map.set(producer, false);
                  break;

                case Entity.AreaStatus.FULL:
                  entity_map.set(producer, true);
                  break;

                default:
                  // Entity.AreaStatus.EMPTY
                  break;
              }
            }
          }
        } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
              _iterator7["return"]();
            }
          } finally {
            if (_didIteratorError7) {
              throw _iteratorError7;
            }
          }
        }

        this._entity_map = entity_map;
      }

      return this._entity_map;
    }
  }, {
    key: "base_height",
    get: function get() {
      return this._base_height;
    }
    /**
     * æå°ã®æ¨é«
     * @type {number}
     * @readonly
     */

  }, {
    key: "height_min",
    get: function get() {
      return this._height_min;
    }
    /**
     * æå¤§ã®æ¨é«
     * @type {number}
     * @readonly
     */

  }, {
    key: "height_max",
    get: function get() {
      return this._height_max;
    }
  }], [{
    key: "_findTriRayDistance",
    value: function _findTriRayDistance(ray, limit, p0, p1, p2) {
      var v = ray.direction; // P1 - P0

      var p1_p0 = Flake._temp_ray_1;
      p1_p0[0] = p1[0] - p0[0];
      p1_p0[1] = p1[1] - p0[1];
      p1_p0[2] = p1[2] - p0[2]; // P2 - P0

      var p2_p0 = Flake._temp_ray_2;
      p2_p0[0] = p2[0] - p0[0];
      p2_p0[1] = p2[1] - p0[1];
      p2_p0[2] = p2[2] - p0[2]; // N = (P1 â P0) Ã (P2 â P0)

      var n = GeoMath.cross3(p1_p0, p2_p0, Flake._temp_ray_3); // N . V

      var nv = GeoMath.dot3(n, v);

      if (nv < 0) {
        var q = ray.position; // P0 - Q

        var p0_q = Flake._temp_ray_4;
        p0_q[0] = p0[0] - q[0];
        p0_q[1] = p0[1] - q[1];
        p0_q[2] = p0[2] - q[2]; //      N . (P0 - Q)
        // t = --------------
        //         N . V

        var t = GeoMath.dot3(n, p0_q) / nv;

        if (t >= 0 && t < limit) {
          // P = Q + t V
          var p = Flake._temp_ray_5;
          p[0] = q[0] + t * v[0];
          p[1] = q[1] + t * v[1];
          p[2] = q[2] + t * v[2]; // P0 - P

          var p0_p = Flake._temp_ray_6;
          p0_p[0] = p0[0] - p[0];
          p0_p[1] = p0[1] - p[1];
          p0_p[2] = p0[2] - p[2]; // P1 - P

          var p1_p = Flake._temp_ray_7;
          p1_p[0] = p1[0] - p[0];
          p1_p[1] = p1[1] - p[1];
          p1_p[2] = p1[2] - p[2]; // P2 - P

          var p2_p = Flake._temp_ray_8;
          p2_p[0] = p2[0] - p[0];
          p2_p[1] = p2[1] - p[1];
          p2_p[2] = p2[2] - p[2]; // ((P0 - P) Ã (P1 - P)) . N >= 0
          // ((P1 - P) Ã (P2 - P)) . N >= 0
          // ((P2 - P) Ã (P0 - P)) . N >= 0

          if (GeoMath.dot3(GeoMath.cross3(p0_p, p1_p, Flake._temp_ray_9), n) >= 0 && GeoMath.dot3(GeoMath.cross3(p1_p, p2_p, Flake._temp_ray_10), n) >= 0 && GeoMath.dot3(GeoMath.cross3(p2_p, p0_p, Flake._temp_ray_11), n) >= 0) {
            return t;
          }
        }
      }

      return limit;
    }
  }]);

  return Flake;
}();
/**
 * @summary çé¢åå²æ°ã®ä¿æ°
 * @type {number}
 * @constant
 */


Flake.Îµ = 0.0625;
/**
 * @summary æ¨é«ä¸éä¿æ°
 * @type {number}
 * @constant
 */

Flake.Fm = -2.0;
/**
 * @summary æ¨é«ä¸éä¿æ°
 * @type {number}
 * @constant
 */

Flake.Fp = 2.0;
Flake.Ïr = Math.PI * GeoMath.EARTH_RADIUS;

Flake._temp_positions = function () {
  var p = [];

  for (var i = 0; i < 4; ++i) {
    p.push(GeoMath.createVector3());
  }

  return p;
}();

Flake._temp_ray_1 = GeoMath.createVector3();
Flake._temp_ray_2 = GeoMath.createVector3();
Flake._temp_ray_3 = GeoMath.createVector3();
Flake._temp_ray_4 = GeoMath.createVector3();
Flake._temp_ray_5 = GeoMath.createVector3();
Flake._temp_ray_6 = GeoMath.createVector3();
Flake._temp_ray_7 = GeoMath.createVector3();
Flake._temp_ray_8 = GeoMath.createVector3();
Flake._temp_ray_9 = GeoMath.createVector3();
Flake._temp_ray_10 = GeoMath.createVector3();
Flake._temp_ray_11 = GeoMath.createVector3();
/**
 * @summary å±¥æ­´çµ±è¨
 * @memberof mapray.Globe
 * @private
 */

var HistStats =
/*#__PURE__*/
function () {
  function HistStats() {
    _classCallCheck(this, HistStats);

    this._history = [];
    this._max_value = 0;
    this._hsize = 200; // >= 3
  }
  /**
   * @summary æå¤§å¤ãåå¾
   */


  _createClass(HistStats, [{
    key: "getMaxValue",
    value: function getMaxValue(value) {
      var history = this._history;
      var old_max = this._max_value;

      if (history.length < this._hsize) {
        // è¿½å ã®ã¿
        if (value > old_max) {
          this._max_value = value;
        }
      } else {
        // è¿½å ã¨åé¤
        if (value >= old_max) {
          // æå¤§å¤ã¯ value ã«å¤ãã
          this._max_value = value;
          history.shift();
        } else if (history[0] < old_max) {
          // æå¤§å¤ã¯å¤ããã
          history.shift();
        } else {
          // æå¤§å¤ã¯å¤ããå¯è½æ§ããã
          history.shift();
          this._max_value = HistStats._find_max(history);
        }
      }

      history.push(value);
      return this._max_value;
    }
  }], [{
    key: "_find_max",
    value: function _find_max(history) {
      var max_value = history[0];
      var length = history.length;

      for (var i = 1; i < length; ++i) {
        var value = history[i];

        if (value > max_value) {
          max_value = value;
        }
      }

      return max_value;
    }
  }]);

  return HistStats;
}();
/**
 * @summary ã¡ãã·ã¥ç®¡çãã¼ã
 * @memberof mapray.Globe
 * @private
 */


var MeshNode =
/*#__PURE__*/
function () {
  /**
   * @summary åæå
   * @param  {mapray.Globe.Flake} flake  ææè
   * @param  {mapray.DemBinary}   dem    DEM ãã¤ããª
   * @param  {number[]}           dpows  åå²ææ°
   */
  function MeshNode(flake, dem, dpows) {
    _classCallCheck(this, MeshNode);

    this._flake = flake;
    this._dem = dem;
    this._dpows = Array.from(dpows);
    this._aframe = -1; // å°è¡¨ã®ã¡ãã·ã¥

    this._base_mesh = new FlakeMesh(flake._globe.glenv, flake, dpows, dem); // ã¨ã³ãã£ãã£ã®ã¡ãã·ã¥
    //   key:   FlakePrimitiveProducer
    //   value: Mesh | CACHED_EMPTY_MESH

    this._entity_meshes = new Map(); // ã¡ãã·ã¥æ°ãã«ã¦ã³ãã¢ãã

    flake._globe._num_cache_meshes += 1;
  }
  /**
   * @summary FlakeRenderObject ã¤ã³ã¹ã¿ã³ã¹ãåå¾
   *
   * @return {mapray.FlakeRenderObject}
   */


  _createClass(MeshNode, [{
    key: "getRenderObject",
    value: function getRenderObject() {
      var flake = this._flake;
      var fro = new FlakeRenderObject(flake, flake._globe.glenv, this._base_mesh); // fro ã«ã¨ã³ãã£ãã£æ¯ã®ãã¼ã¿ãè¿½å 

      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = flake.getEntityProducers()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var producer = _step8.value;

          // producer ã«å¯¾å¿ããã­ã£ãã·ã¥ããã Mesh
          var mesh = this._getEntityMesh(producer);

          if (mesh === CACHED_EMPTY_MESH) {
            // ç©ºã¡ãã·ã¥ã¨ãã¦ã­ã£ãã·ã¥ããã¦ãã --> fro ã«è¿½å ããªã
            continue;
          }

          if (mesh === null) {
            // ã¡ãã·ã¥ãã­ã£ãã·ã¥ã«å­å¨ããªãã®ã§ãã¡ãã·ã¥ãçæãã¦ã­ã£ãã·ã¥ãã
            mesh = producer.createMesh(flake, this._dpows, this._dem);

            this._setEntityMesh(producer, mesh);

            if (mesh === null) {
              // ç©ºã¡ãã·ã¥ã¨ãã¦ã­ã£ãã·ã¥ããã --> fro ã«è¿½å ããªã
              continue;
            }
          } // fro ã«ã¨ã³ãã£ãã£ãè¿½å 


          fro.addEntityData(mesh, producer);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      return fro;
    }
    /**
     * @summary ä¸è´ãããï¼
     * @param  {mapray.DemBinary} dem    DEM ãã¤ããª
     * @param  {number[]}         dpows  åå²ææ°
     * @return {boolean}                 ä¸è´ããã¨ã true, ä¸è´ããªãã¨ã false
     */

  }, {
    key: "match",
    value: function match(dem, dpows) {
      return this._dem === dem && this._dpows[0] === dpows[0] && this._dpows[1] === dpows[1];
    }
    /**
     * @summary ã¢ã¯ã»ã¹ãã¬ã¼ã ãæ´æ°
     */

  }, {
    key: "touch",
    value: function touch() {
      var globe = this._flake._globe;

      if (this._aframe !== globe._frame_counter) {
        this._aframe = globe._frame_counter;
        globe._num_touch_meshes += 1;
      }
    }
    /**
     * @summary ãã¼ããç ´æ£
     */

  }, {
    key: "dispose",
    value: function dispose() {
      if (this._base_mesh === null) {
        // ãã§ã«ç ´æ£ããã¦ãã
        return;
      }

      var flake = this._flake; // Flake ãã this ãã¼ããåé¤

      var meshes = flake._meshes;
      var length = meshes.length;

      for (var i = 0; i < length; ++i) {
        if (meshes[i] === this) {
          meshes.splice(i, 1);
          break;
        }
      } // ã¡ãã·ã¥ãç ´æ£


      this._base_mesh.dispose();

      this._base_mesh = null;
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = this._entity_meshes.values()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var mesh = _step9.value;

          if (mesh instanceof Mesh) {
            mesh.dispose();
          }
        } // ã¡ãã·ã¥æ°ãã«ã¦ã³ããã¦ã³

      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
            _iterator9["return"]();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      flake._globe._num_cache_meshes -= 1;
    }
    /**
     * @summary åæ¸ç¨ã® MeshNode æ¯è¼
     * @param  {mapray.Globe.MeshNode} other  æ¯è¼å¯¾è±¡
     * @return {number}                       æ¯è¼å¤
     * @package
     */

  }, {
    key: "compareForReduce",
    value: function compareForReduce(other) {
      // æè¿ã¢ã¯ã»ã¹ãããã®ãåªå
      var a = this;
      var b = other;
      return b._aframe - a._aframe;
    }
    /**
     * @summary ã¨ã³ãã£ãã£ã®ã¡ãã·ã¥ãåé¤
     *
     * @desc
     * <p>producer ã«å¯¾å¿ããã¡ãã·ã¥ãå­å¨ããã°åé¤ããã</p>
     *
     * @param {mapray.Entity.FlakePrimitiveProducer} producer
     */

  }, {
    key: "removeEntityMesh",
    value: function removeEntityMesh(producer) {
      this._entity_meshes["delete"](producer);
    }
    /**
     * @summary ã¨ã³ãã£ãã£ã®ã¡ãã·ã¥ãåå¾
     *
     * @desc
     * <p>producer ã«å¯¾å¿ããã¡ãã·ã¥ãåå¾ããã</p>
     * <p>ãã ãå­å¨ããªãã¨ã null, ç©ºã¡ãã·ã¥ãè¨­å®ããã¦ããã¨ãã¯ CACHED_EMPTY_MESH ãè¿ãã</p>
     *
     * @param {mapray.Entity.FlakePrimitiveProducer} producer
     *
     * @return {?(mapray.Mesh|CACHED_EMPTY_MESH)}
     *
     * @private
     */

  }, {
    key: "_getEntityMesh",
    value: function _getEntityMesh(producer) {
      var mesh = this._entity_meshes.get(producer);

      return mesh !== undefined ? mesh : null;
    }
    /**
     * @summary ã¨ã³ãã£ãã£ã®ã¡ãã·ã¥ãè¨­å®
     *
     * @desc
     * <p>producer ã«å¯¾å¿ããã¡ãã·ã¥ãè¨­å®ããã</p>
     * <p>ç©ºã¡ãã·ã¥ãè¨­å®ããã¨ãã¯ mesh ã« null ãæå®ããã</p>
     *
     * @param {mapray.Entity.FlakePrimitiveProducer} producer
     * @param {?mapray.Mesh}                         mesh
     *
     * @private
     */

  }, {
    key: "_setEntityMesh",
    value: function _setEntityMesh(producer, mesh) {
      var value = mesh !== null ? mesh : CACHED_EMPTY_MESH;

      this._entity_meshes.set(producer, value);
    }
  }]);

  return MeshNode;
}();
/**
 * @summary DEM ç¶æã®åæå
 * @enum {object}
 * @memberof mapray.Globe
 * @constant
 */


var DemState = {
  /**
   * DEM ã¿ã¤ã«ãå­å¨ããªã
   */
  NONE: {
    id: "NONE"
  },

  /**
   * DEM ã¿ã¤ã«ãå­å¨ãã
   */
  LOADED: {
    id: "LOADED"
  },

  /**
   * DEM ã¿ã¤ã«ããªã¯ã¨ã¹ãä¸­
   */
  REQUESTED: {
    id: "REQUESTED"
  },

  /**
   * DEM ã¿ã¤ã«ã®ãªã¯ã¨ã¹ãã«å¤±æ
   */
  FAILED: {
    id: "FAILED"
  }
};
/**
 * @summary ã­ã£ãã·ã¥ãããç©ºã¡ãã·ã¥ãè¡¨ã
 *
 * @memberof mapray.Globe
 * @constant
 */

var CACHED_EMPTY_MESH = {
  id: "CACHED_EMPTY_MESH"
};

/**
 * @summary æç»å°è¡¨æ­ç
 * @memberof mapray
 * @private
 */
var RenderFlake =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Globe.Flake} flake  å°è¡¨æ­ç
   */
  function RenderFlake(flake) {
    _classCallCheck(this, RenderFlake);

    /**
     *  @summary å°è¡¨æ­ç
     *  @member mapray.RenderFlake#flake
     *  @type {mapray.Globe.Flake}
     */
    this.flake = flake;
    /**
     *  @summary å°è¡¨è©³ç´°ã¬ãã« (LOD)
     *  @member mapray.RenderFlake#lod
     *  @type {number}
     */

    /**
     *  @summary LOD (å·¦ä¸)
     *  @member mapray.RenderFlake#lod_00
     *  @type {number}
     */

    /**
     *  @summary LOD (å³ä¸)
     *  @member mapray.RenderFlake#lod_10
     *  @type {number}
     */

    /**
     *  @summary LOD (å·¦ä¸)
     *  @member mapray.RenderFlake#lod_01
     *  @type {number}
     */

    /**
     *  @summary LOD (å³ä¸)
     *  @member mapray.RenderFlake#lod_11
     *  @type {number}
     */
  }
  /**
   * @summary ã¬ã³ããªã³ã°ãªãã¸ã§ã¯ããæ¤ç´¢
   *
   * @return {mapray.FlakeRenderObject}
   */


  _createClass(RenderFlake, [{
    key: "getRenderObject",
    value: function getRenderObject() {
      return this.flake.getRenderObject(this.lod);
    }
  }]);

  return RenderFlake;
}();

/**
 * @summary æç»å°è¡¨æ­çãåéãããã¼ã«
 * @memberof mapray.RenderStage
 * @private
 */

var FlakeCollector =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.RenderStage} stage   ææèã§ãã RenderStage
   */
  function FlakeCollector(stage) {
    _classCallCheck(this, FlakeCollector);

    this._setupViewVectors(stage);

    this._setupClipPlanes(stage);

    var viewer = stage._viewer;
    var dem_provider = viewer.dem_provider;
    var tile_texture_cache = viewer.tile_texture_cache;
    this._min_image_z = tile_texture_cache.getImageZMin();
    var dem_zbias = GeoMath.LOG2PI - dem_provider.getResolutionPower() + 1; // b = log2Ï - Ï + 1

    this._max_zbias = Math.max(tile_texture_cache.getImageZBias(), dem_zbias);
    this._globe = viewer.globe;
    this._rflake_list = []; // ãããã°çµ±è¨

    this._debug_stats = viewer.debug_stats;

    if (this._debug_stats) {
      this._num_procA_flakes = 0;
      this._num_procB_flakes = 0;
    } // äºåçæãªãã¸ã§ã¯ã


    this._view_dir_N = GeoMath.createVector3();
    this._view_dir_V = GeoMath.createVector3();
  }
  /**
   * @private
   */


  _createClass(FlakeCollector, [{
    key: "_setupViewVectors",
    value: function _setupViewVectors(stage) {
      var view_to_gocs = stage._view_to_gocs;
      var pixel_step = stage._pixel_step;
      var view_pos_Q = GeoMath.createVector3();
      var view_dir_wU = GeoMath.createVector3(); // å°è¡¨è©³ç´°ã¬ãã« (LOD) è¨ç®ç¨ã® Q, w*U ãã¯ãã«ãè¨­å®

      view_pos_Q[0] = view_to_gocs[12];
      view_pos_Q[1] = view_to_gocs[13];
      view_pos_Q[2] = view_to_gocs[14];
      view_dir_wU[0] = -view_to_gocs[8] * pixel_step;
      view_dir_wU[1] = -view_to_gocs[9] * pixel_step;
      view_dir_wU[2] = -view_to_gocs[10] * pixel_step;
      /**
       *  @summary ä½ç½®ãã¯ãã« Q
       *  @member mapray.FlakeCollector#_view_pos_Q
       *  @type {mapray.Vector3}
       *  @private
       *  @see doc/ImageLevelCalculation.txt
       */

      this._view_pos_Q = view_pos_Q;
      /**
       *  @summary ãã¯ãã« w * U
       *  @member mapray.FlakeCollector#_view_dir_wU
       *  @type {mapray.Vector3}
       *  @private
       *  @see doc/ImageLevelCalculation.txt
       */

      this._view_dir_wU = view_dir_wU;
    }
    /**
     * @private
     */

  }, {
    key: "_setupClipPlanes",
    value: function _setupClipPlanes(stage) {
      var view_to_gocs = stage._view_to_gocs;
      var gocs_to_view = stage._gocs_to_view;
      var volume_planes = stage._volume_planes;
      var clip_planes = []; // å°è¡¨é®è½ã«ãªã³ã°å¹³é¢

      var root_flake = stage._viewer._globe.root_flake;
      var rmin = GeoMath.EARTH_RADIUS + root_flake.height_min; // æå°åå¾

      var rmax = GeoMath.EARTH_RADIUS + root_flake.height_max; // æå¤§åå¾
      // P (è¦ç¹ä½ç½®)

      var px = view_to_gocs[12];
      var py = view_to_gocs[13];
      var pz = view_to_gocs[14]; // q = â[(P.P - rmin^2)(rmax^2 - rmin^2)] - rmin^2

      var p2 = px * px + py * py + pz * pz;
      var rmin2 = rmin * rmin;
      var rmax2 = rmax * rmax;
      var q = Math.sqrt((p2 - rmin2) * (rmax2 - rmin2)) - rmin2; // L = <P, q> / âPâ

      var plane = GeoMath.createVector4();
      var recip = 1 / Math.sqrt(p2);
      plane[0] = px * recip;
      plane[1] = py * recip;
      plane[2] = pz * recip;
      plane[3] = q * recip;
      clip_planes.push(plane); // L ãåºã¨ããé æ¹è·é¢

      var far_dist = Math.sqrt(p2 + rmax2 + 2 * q); // è¦ä½ç©å¹³é¢ãåå¾ãã¦ãå°å¿ç´äº¤åº§æ¨ç³»ã«å¤æ
      // (ç´äº¤å¤æãªã®ã§ x, y, z ã¯æ­£è¦åããã¦ãã)

      for (var i = 0; i < 6; ++i) {
        var src_plane = volume_planes[i];
        var dst_plane = GeoMath.createVector4();

        if (i == 1 && src_plane[3] > far_dist) {
          // é æ¹å¹³é¢ãå¿è¦ä»¥ä¸ã«é ãã¨ã far_dist ã«ç½®ãæãã
          src_plane = GeoMath.createVector4(src_plane);
          src_plane[3] = far_dist;
        }

        GeoMath.transformPlane_A(gocs_to_view, src_plane, dst_plane);
        clip_planes.push(dst_plane);
      }

      this._clip_planes = clip_planes;
    }
    /**
     * @summary æç»å°è¡¨æ­çãåé
     * @return {mapray.RenderFlake[]}  åéããæç»å°è¡¨æ­çã®éå
     */

  }, {
    key: "traverse",
    value: function traverse() {
      this._collectFlakes(this._globe.root_flake); // ãããã°çµ±è¨


      if (this._debug_stats) {
        this._debug_stats.num_procA_flakes = this._num_procA_flakes;
        this._debug_stats.num_procB_flakes = this._num_procB_flakes;
      }

      return this._rflake_list;
    }
    /**
     * @private
     */

  }, {
    key: "_collectFlakes",
    value: function _collectFlakes(flake) {
      if (this._debug_stats !== null) {
        this._num_procA_flakes += 1;
      }

      if (flake.isInvisible(this._clip_planes)) {
        // å°è¡¨ã¿ã¤ã«ãè¦ããªãã®ã§æç»ããªã
        return;
      }

      if (flake.z < this._min_image_z) {
        // å°è¡¨ã¿ã¤ã«ããå°ããªç»åã¿ã¤ã«ãããªã
        this._collectNextLevelFlakes(flake); // å°è¡¨ã¿ã¤ã«ãåå²


        return;
      }

      if (this._debug_stats !== null) {
        this._num_procB_flakes += 1;
      } // å°è¡¨æ­çã®è©³ç´°ã¬ãã«ã®ç¯å²


      var range = this._getLevelOfDetailRange(flake);

      var zt = range.mid + this._max_zbias; // æå¤§ã¿ã¤ã«ã¬ãã«

      if (range.max - range.min > FlakeCollector.MAX_LOD_INTERVAL || zt > flake.z) {
        //    å°è¡¨æ­çã® LOD å¹ãé¾å¤ããå¤§ãã
        // or æå¤§ã¿ã¤ã«ã¬ãã« > å°è¡¨æ­çã¬ãã«
        this._collectNextLevelFlakes(flake); // å°è¡¨æ­çãåå²


        return;
      } // ãªã¹ãã« RenderFlake ãè¿½å 


      this._addRenderFlake(flake, range);
    }
    /**
     * @private
     */

  }, {
    key: "_collectNextLevelFlakes",
    value: function _collectNextLevelFlakes(flake) {
      for (var v = 0; v < 2; ++v) {
        for (var u = 0; u < 2; ++u) {
          this._collectFlakes(flake.newChild(u, v));
        }
      }
    }
    /**
     * @summary å°è¡¨æ­çã®è©³ç´°ã¬ãã«ã®ç¯å²ãåå¾
     * @private
     */

  }, {
    key: "_getLevelOfDetailRange",
    value: function _getLevelOfDetailRange(flake) {
      var pi = Math.PI;
      var z = flake.z;
      var x = flake.x;
      var y = flake.y; // åº§æ¨ç¯å² (åä½çã¡ã«ã«ãã«åº§æ¨ç³»)

      var msize = Math.pow(2, 1 - z) * pi;
      var mx_min = -pi + x * msize;
      var my_min = pi - (y + 1) * msize;
      var max_mstep = pi / 32;
      var mcount = Math.ceil(msize / max_mstep);
      var mstep = msize / mcount;
      var r = GeoMath.EARTH_RADIUS + flake.base_height;
      var Q = this._view_pos_Q;
      var wU = this._view_dir_wU;
      var N = this._view_dir_N;
      var V = this._view_dir_V;
      var dMin = Number.MAX_VALUE;
      var dMax = -Number.MAX_VALUE;

      for (var iy = 0, my = my_min; iy < mcount + 1; ++iy, my += mstep) {
        var ey = Math.exp(my);
        var ey2 = ey * ey;
        var sinÏ = (ey2 - 1) / (ey2 + 1);
        var cosÏ = 2 * ey / (ey2 + 1);
        var denom = 1 / (r * cosÏ);

        for (var ix = 0, mx = mx_min; ix < mcount + 1; ++ix, mx += mstep) {
          var sinÎ» = Math.sin(mx);
          var cosÎ» = Math.cos(mx); // N

          N[0] = cosÏ * cosÎ»;
          N[1] = cosÏ * sinÎ»;
          N[2] = sinÏ; // V = r N - Q

          V[0] = r * N[0] - Q[0];
          V[1] = r * N[1] - Q[1];
          V[2] = r * N[2] - Q[2]; // w U.V

          var wUV = GeoMath.dot3(wU, V);

          if (wUV <= 0) {
            // é ç¹ãè¦ç¹ã®å¾ãå´
            return {
              min: -1000,
              max: 1000,
              mid: 0
            };
          } //      w U.(r N - Q)
          // d = ---------------
          //        r Cos[Ï]


          var deriv = wUV * denom; // æå¤§æå°ãæ´æ°

          dMin = Math.min(dMin, deriv);
          dMax = Math.max(dMax, deriv);
        }
      }

      var lodMin = -Math.maprayLog2(dMax); // Log2[1/dMax]

      var lodMax = -Math.maprayLog2(dMin); // Log2[1/dMin]

      return {
        min: lodMin,
        max: lodMax,
        mid: (lodMin + lodMax) / 2
      };
    }
    /**
     * @summary åä½çã¡ã«ã«ãã«åº§æ¨ x, y ã®å°è¡¨è©³ç´°ã¬ãã«ãè¨ç®
     * @desc
     * <p>ä»¥ä¸ã®å¤ãè¨­å®ããã¦ããªããã°ãªããªãã</p>
     * <ul>
     *   <li>this._view_pos_Q</li>
     *   <li>this._view_dir_wU</li>
     * </ul>
     * @param  {number} x  X åº§æ¨
     * @param  {number} y  Y åº§æ¨
     * @param  {number} r  GOGS åç¹ããã®è·é¢ (Meters)
     * @return {number}    å°è¡¨è©³ç´°ã¬ãã«
     * @private
     */

  }, {
    key: "_calcLOD",
    value: function _calcLOD(x, y, r) {
      var sinÎ» = Math.sin(x);
      var cosÎ» = Math.cos(x);
      var ey = Math.exp(y);
      var ey2 = ey * ey;
      var sinÏ = (ey2 - 1) / (ey2 + 1);
      var cosÏ = 2 * ey / (ey2 + 1); // N

      var N = this._view_dir_N;
      N[0] = cosÏ * cosÎ»;
      N[1] = cosÏ * sinÎ»;
      N[2] = sinÏ; // V = r N - Q

      var V = this._view_dir_V;
      var Q = this._view_pos_Q;
      V[0] = r * N[0] - Q[0];
      V[1] = r * N[1] - Q[1];
      V[2] = r * N[2] - Q[2]; // w U.V

      var wU = this._view_dir_wU;
      var wUV = GeoMath.dot3(wU, V); // > 0 (è¡¨ç¤ºããã Flake åæãªã®ã§æ­£æ°)
      //          r Cos[Ï]
      // 1/d = ---------------
      //        w U.(r N - Q)

      var inv_d = r * cosÏ / wUV; // Log2[1/d]

      return Math.maprayLog2(inv_d);
    }
    /**
     * @summary åéã® LOD ãè¨­å®
     * @desc
     * <p>rflake ã«ä»¥ä¸ã®ãã­ããã£ãè¨­å®ããã</p>
     * <ul>
     *   <li>rflake.lod_00</li>
     *   <li>rflake.lod_10</li>
     *   <li>rflake.lod_01</li>
     *   <li>rflake.lod_11</li>
     * </ul>
     * @private
     */

  }, {
    key: "_setCornerLODs",
    value: function _setCornerLODs(rflake) {
      var pi = Math.PI;
      var flake = rflake.flake;
      var z = flake.z;
      var x = flake.x;
      var y = flake.y; // åº§æ¨ç¯å² (åä½çã¡ã«ã«ãã«åº§æ¨ç³»)

      var msize = Math.pow(2, 1 - z) * pi;
      var mx_min = -pi + x * msize;
      var mx_max = -pi + (x + 1) * msize;
      var my_min = pi - (y + 1) * msize;
      var my_max = pi - y * msize; // GOCS åç¹ããã®è·é¢

      var r = GeoMath.EARTH_RADIUS + flake.base_height; // åéã®å°è¡¨è©³ç´°ã¬ãã«

      rflake.lod_00 = this._calcLOD(mx_min, my_min, r);
      rflake.lod_10 = this._calcLOD(mx_max, my_min, r);
      rflake.lod_01 = this._calcLOD(mx_min, my_max, r);
      rflake.lod_11 = this._calcLOD(mx_max, my_max, r);
    }
    /**
     * @summary æç»å°è¡¨æ­çãè¿½å 
     * @private
     */

  }, {
    key: "_addRenderFlake",
    value: function _addRenderFlake(flake, range) {
      var rflake = new RenderFlake(flake);
      rflake.lod = range.mid;

      this._setCornerLODs(rflake);

      this._rflake_list.push(rflake);
    }
  }]);

  return FlakeCollector;
}();
/**
 * @summary Flake ã«å¯¾ãã LOD ã®è¨±å®¹å¹
 * @desc
 * <p>1ã¤ã® Flake å¨ä½ã«å¯¾ããæå° LOD ã¨æå¤§ LOD ã®éã®æå¤§å¹ã§ããã</p>
 * <p>æå¹ãªç¯å²ã¯ 0.0 < MAX_LOD_INTERVAL < 1.0 ã§ããã</p>
 * @type {number}
 * @constant
 */


FlakeCollector.MAX_LOD_INTERVAL = 0.5;

var nativeJoin = [].join;
var ES3_STRINGS = indexedObject != Object;
var STRICT_METHOD$3 = arrayMethodIsStrict('join', ','); // `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join

_export({
  target: 'Array',
  proto: true,
  forced: ES3_STRINGS || !STRICT_METHOD$3
}, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});

/**
 * @summary WebGL ã·ã§ã¼ãã©ããã¼
 * @desc
 * é ç¹ã·ã§ã¼ãã¨ãã©ã°ã¡ã³ãã·ã§ã¼ãã®ã»ããã§ããã
 * @memberof mapray
 * @private
 */
var Shader =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.GLEnv} glenv    WebGL ç°å¢
   * @param {string}     vs_code  é ç¹ã·ã§ã¼ãã®ã½ã¼ã¹ã³ã¼ã
   * @param {string}     fs_code  ãã©ã°ã¡ã³ãã·ã§ã¼ãã®ã½ã¼ã¹ã³ã¼ã
   * @exception {Error}           ã³ã³ãã¤ã«ã¨ã©ã¼
   */
  function Shader(glenv, vs_code, fs_code) {
    _classCallCheck(this, Shader);

    this._glenv = glenv;

    try {
      /**
       * @summary é ç¹ã·ã§ã¼ããªãã¸ã§ã¯ã
       * @member mapray.Shader#vs_object
       * @type {WebGLShader}
       * @readonly
       */
      this.vs_object = this._compile_shader('VERTEX_SHADER', vs_code);
      /**
       * @summary ãã©ã°ã¡ã³ãã·ã§ã¼ããªãã¸ã§ã¯ã
       * @member mapray.Shader#fs_object
       * @type {WebGLShader}
       * @readonly
       */

      this.fs_object = this._compile_shader('FRAGMENT_SHADER', fs_code);
    } catch (e) {
      var gl = glenv.context;
      if (this.vs_object) gl.deleteShader(this.vs_object);
      if (this.fs_object) gl.deleteShader(this.fs_object);
      throw e;
    }
  }
  /**
   * @summary ã·ã§ã¼ããç ´æ£
   */


  _createClass(Shader, [{
    key: "dispose",
    value: function dispose() {
      var gl = this._glenv.context;

      if (this.vs_object) {
        gl.deleteShader(this.vs_object);
        this.vs_object = null;
      }

      if (this.fs_object) {
        gl.deleteShader(this.fs_object);
        this.fs_object = null;
      }
    }
    /**
     * @summary ã·ã§ã¼ããã³ã³ãã¤ã«
     * @param  {string}      type    'VERTEX_SHADER' or 'FRAGMENT_SHADER'
     * @param  {string}      source  ã½ã¼ã¹ã³ã¼ãæå­å
     * @return {WebGLShader}         ã³ã³ãã¤ã«ãããã·ã§ã¼ããªãã¸ã§ã¯ã
     * @exception {Error}            ã³ã³ãã¤ã«ã¨ã©ã¼
     * @private
     */

  }, {
    key: "_compile_shader",
    value: function _compile_shader(type, source) {
      var gl = this._glenv.context;
      var shader = gl.createShader(gl[type]);

      if (!shader) {
        throw new Error(type + " ãªãã¸ã§ã¯ãã®çæã«å¤±æãã¾ãã");
      }

      try {
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          // ã³ã³ãã¤ã«ã¨ã©ã¼
          var log = gl.getShaderInfoLog(shader);
          throw new Error(type + " ã®ã³ã³ãã¤ã«ã«å¤±æ: " + log);
        }
      } catch (e) {
        gl.deleteShader(shader);
        throw e;
      }

      return shader;
    }
  }]);

  return Shader;
}();

/**
 * @summary ãããªã¢ã«
 * @memberof mapray
 * @private
 */

var Material =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.GLEnv} glenv    WebGL ç°å¢
   * @param {string}       vs_code  é ç¹ã·ã§ã¼ãã®ã½ã¼ã¹ã³ã¼ã
   * @param {string}       fs_code  ãã©ã°ã¡ã³ãã·ã§ã¼ãã®ã½ã¼ã¹ã³ã¼ã
   */
  function Material(glenv, vs_code, fs_code) {
    _classCallCheck(this, Material);

    var shader = new Shader(glenv, vs_code, fs_code);
    this._gl = glenv.context;
    this._program = this._link_shaders(shader.vs_object, shader.fs_object);
    this._vertex_attribs = this._create_vertex_attribs();
    this._uniform_location = this._create_uniform_location();
    shader.dispose();
  }
  /**
   * @summary ã·ã§ã¼ãããªã³ã¯
   * @param  {WebGLShader}  vs  é ç¹ã·ã§ã¼ã
   * @param  {WebGLShader}  fs  ãã©ã°ã¡ã³ãã·ã§ã¼ã
   * @return {WebGLProgram}     ãªã³ã¯ããããã­ã°ã©ã ãªãã¸ã§ã¯ã
   * @exception {Error}         ãªã³ã¯ã¨ã©ã¼
   * @private
   */


  _createClass(Material, [{
    key: "_link_shaders",
    value: function _link_shaders(vs, fs) {
      var gl = this._gl;
      var program = gl.createProgram();

      if (!program) {
        throw new Error("ãã­ã°ã©ã ãªãã¸ã§ã¯ãã®çæã«å¤±æãã¾ãã");
      }

      try {
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          // ãªã³ã¯ã¨ã©ã¼
          var log = gl.getProgramInfoLog(program);
          gl.detachShader(program, fs);
          gl.detachShader(program, vs);
          throw new Error("ã·ã§ã¼ãã®ãªã³ã¯ã«å¤±æ: " + log);
        }
      } catch (e) {
        gl.deleteProgram(program);
        throw e;
      }

      return program;
    }
    /**
     * @summary é ç¹å±æ§æå ±ãä½æ
     *
     * @return {array}  é ç¹å±æ§ååã¨ã­ã±ã¼ã·ã§ã³ã®éå
     * @private
     */

  }, {
    key: "_create_vertex_attribs",
    value: function _create_vertex_attribs() {
      var gl = this._gl;
      var program = this._program;
      var attribs = [];
      var num_items = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

      for (var i = 0; i < num_items; ++i) {
        var info = gl.getActiveAttrib(program, i);
        var attrib = {
          name: info.name,
          location: gl.getAttribLocation(program, info.name)
        };
        attribs.push(attrib);
      }

      return attribs;
    }
    /**
     * @summary uniform å¤æ°ã®ã­ã±ã¼ã·ã§ã³è¾æ¸ãä½æ
     *
     * @return {object}  ã­ã±ã¼ã·ã§ã³è¾æ¸
     * @private
     */

  }, {
    key: "_create_uniform_location",
    value: function _create_uniform_location() {
      var gl = this._gl;
      var program = this._program;
      var location = {}; // Uniform å¤æ°ã®ã­ã±ã¼ã·ã§ã³

      var num_items = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

      for (var i = 0; i < num_items; ++i) {
        var info = gl.getActiveUniform(program, i);
        location[info.name] = gl.getUniformLocation(program, info.name);
      }

      return location;
    }
    /**
     * @summary ãªã½ã¼ã¹ãç ´æ£
     */

  }, {
    key: "dispose",
    value: function dispose() {
      var gl = this._gl;
      gl.deleteProgram(this._program);
      this._program = null;
    }
    /**
     * @summary ãã­ã°ã©ã ãæç¸
     */

  }, {
    key: "bindProgram",
    value: function bindProgram() {
      var gl = this._gl;
      gl.useProgram(this._program);
    }
    /**
     * @summary çå½å¤ãã©ã¡ã¼ã¿ãè¨­å®
     * @param {string}  name   å¤æ°å
     * @param {boolean} value  çå½å¤
     */

  }, {
    key: "setBoolean",
    value: function setBoolean(name, value) {
      var location = this._uniform_location[name];

      if (location) {
        var gl = this._gl;
        gl.uniform1i(location, value ? 1 : 0);
      }
    }
    /**
     * @summary æ´æ°ãã©ã¡ã¼ã¿ãè¨­å®
     * @param {string} name   å¤æ°å
     * @param {number} value  æ´æ°å¤
     */

  }, {
    key: "setInteger",
    value: function setInteger(name, value) {
      var location = this._uniform_location[name];

      if (location) {
        var gl = this._gl;
        gl.uniform1i(location, value);
      }
    }
    /**
     * @summary float ãã©ã¡ã¼ã¿ãè¨­å®
     * @param {string} name   å¤æ°å
     * @param {number} value  float å¤
     */

  }, {
    key: "setFloat",
    value: function setFloat(name, value) {
      var location = this._uniform_location[name];

      if (location) {
        var gl = this._gl;
        gl.uniform1f(location, value);
      }
    }
    /**
     * @summary 2æ¬¡ãã¯ãã«ãã©ã¡ã¼ã¿ãè¨­å®
     * @param {string}         name   å¤æ°å
     * @param {mapray.Vector2} value  2æ¬¡ãã¯ãã«
     */

  }, {
    key: "setVector2",
    value: function setVector2(name, value) {
      var location = this._uniform_location[name];

      if (location) {
        var gl = this._gl;
        gl.uniform2fv(location, value);
      }
    }
    /**
     * @summary 3æ¬¡ãã¯ãã«ãã©ã¡ã¼ã¿ãè¨­å®
     * @param {string}         name   å¤æ°å
     * @param {mapray.Vector3} value  3æ¬¡ãã¯ãã«
     */

  }, {
    key: "setVector3",
    value: function setVector3(name, value) {
      var location = this._uniform_location[name];

      if (location) {
        var gl = this._gl;
        gl.uniform3fv(location, value);
      }
    }
    /**
     * @summary 4æ¬¡ãã¯ãã«ãã©ã¡ã¼ã¿ãè¨­å®
     * @param {string}         name   å¤æ°å
     * @param {mapray.Vector4} value  4æ¬¡ãã¯ãã«
     */

  }, {
    key: "setVector4",
    value: function setVector4(name, value) {
      var location = this._uniform_location[name];

      if (location) {
        var gl = this._gl;
        gl.uniform4fv(location, value);
      }
    }
    /**
     * @summary è¡åãã©ã¡ã¼ã¿ãè¨­å®
     * @param {string}        name   å¤æ°å
     * @param {mapray.Matrix} value  è¡å
     */

  }, {
    key: "setMatrix",
    value: function setMatrix(name, value) {
      var location = this._uniform_location[name];

      if (location) {
        var gl = this._gl;
        gl.uniformMatrix4fv(location, false, value);
      }
    }
    /**
     * @summary é ç¹å±æ§ãã¼ã¿ãæç¸
     *
     * @desc
     * <p>mesh_attribs ã¯é ç¹å±æ§åãã Mesh.AttribData ã¤ã³ã¹ã¿ã³ã¹ãåå¾ããè¾æ¸ã§ããã</p>
     *
     * @param {object} mesh_attribs  ã¡ãã·ã¥å´ã®é ç¹å±æ§ãã¼ã¿ã®è¾æ¸
     */

  }, {
    key: "bindVertexAttribs",
    value: function bindVertexAttribs(mesh_attribs) {
      var gl = this._gl;
      var mtl_attribs = this._vertex_attribs; // ãããªã¢ã«å´ã®é ç¹å±æ§ãã¼ã¿éå

      var num_attribs = mtl_attribs.length;

      for (var i = 0; i < num_attribs; ++i) {
        var mtl_attrib = mtl_attribs[i];
        var mesh_attrib = mesh_attribs[mtl_attrib.name];
        var location = mtl_attrib.location;

        if (mesh_attrib !== undefined) {
          // é ç¹å±æ§ãã¼ã¿ãæç¸
          gl.bindBuffer(gl.ARRAY_BUFFER, mesh_attrib.buffer);
          gl.enableVertexAttribArray(location);
          gl.vertexAttribPointer(location, mesh_attrib.num_components, mesh_attrib.component_type, mesh_attrib.normalized, mesh_attrib.byte_stride, mesh_attrib.byte_offset);
        } else {
          // ã¡ãã·ã¥å´ã«å¿è¦ãªé ç¹å±æ§ããªãã¨ã
          gl.disableVertexAttribArray(location);
        }
      }
    }
    /**
     * @summary ãã¯ã¹ãã£ããã¤ã³ã
     * @desc
     * <p>æ³¨æ: ç¾è¡ãã¯ã¹ãã£ (Active Texture) ãå¤æ´ãããã</p>
     * @param {number}       unit     ãã¯ã¹ãã£ã¦ãããçªå·
     * @param {WebGLTexture} texture  ãã¯ã¹ãã£ãªãã¸ã§ã¯ã
     */

  }, {
    key: "bindTexture2D",
    value: function bindTexture2D(unit, texture) {
      var gl = this._gl;
      gl.activeTexture(gl.TEXTURE0 + unit);
      gl.bindTexture(gl.TEXTURE_2D, texture);
    }
  }]);

  return Material;
}();

/**
 * @summary å°è¡¨æ­çãããªã¢ã«
 * @memberof mapray.RenderStage
 * @extends mapray.Material
 * @private
 */

var FlakeMaterial =
/*#__PURE__*/
function (_Material) {
  _inherits(FlakeMaterial, _Material);

  /**
   * @param {mapray.Viewer} viewer   ææèã§ãã Viewer
   * @param {string}      vs_code  é ç¹ã·ã§ã¼ãã®ã½ã¼ã¹ã³ã¼ã
   * @param {string}      fs_code  ãã©ã°ã¡ã³ãã·ã§ã¼ãã®ã½ã¼ã¹ã³ã¼ã
   */
  function FlakeMaterial(viewer, vs_code, fs_code) {
    var _this;

    _classCallCheck(this, FlakeMaterial);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(FlakeMaterial).call(this, viewer.glenv, vs_code, fs_code)); // ã·ã§ã¼ãç¨ã®äºåçæãªãã¸ã§ã¯ã

    _this._flake_to_clip = GeoMath.createMatrixf();
    return _this;
  }
  /**
   * @summary æç»åæ°
   * @return {number}
   * @abstract
   */


  _createClass(FlakeMaterial, [{
    key: "numDrawings",
    value: function numDrawings() {
      return 1;
    }
    /**
     * @summary ã¯ã¤ã¤ã¼ãã¬ã¼ã è¡¨ç¤ºãï¼
     * @return {boolean}
     * @abstract
     */

  }, {
    key: "isWireframe",
    value: function isWireframe() {
      return false;
    }
    /**
     * @summary å°è¡¨æ­çã®ãã©ã¡ã¼ã¿ãè¨­å®
     *
     * @param  {mapray.RenderStage} stage   å¼ã³åºãå´ãªãã¸ã§ã¯ã
     * @param  {mapray.RenderFlake} rflake  æç»å°è¡¨æ­ç
     * @param  {mapray.FlakeMesh}   mesh    å°è¡¨æ­çã¡ãã·ã¥
     * @param  {number}             index   æç»ã¤ã³ããã¯ã¹
     * @return {boolean}  æç»ã®æç¡
     *
     * @abstract
     */

  }, {
    key: "setFlakeParameter",
    value: function setFlakeParameter(stage, rflake, mesh, index) {
      return false;
    }
    /**
     * @summary å°è¡¨æ­çã®å±éãã©ã¡ã¼ã¿ãè¨­å®
     *
     * @param {mapray.RenderStage} stage  å¼ã³åºãå´ãªãã¸ã§ã¯ã
     * @param {mapray.FlakeMesh}   mesh   å°è¡¨æ­çã¡ãã·ã¥
     * @protected
     */

  }, {
    key: "setCommonParameter",
    value: function setCommonParameter(stage, mesh) {
      mesh.mul_flake_to_gocs(stage._gocs_to_clip, this._flake_to_clip);
      this.setMatrix("u_obj_to_clip", this._flake_to_clip);
    }
  }]);

  return FlakeMaterial;
}(Material);

/**
 * @summary å°å³ç»åãã­ãã¤ã
 * @classdesc
 * <p>ã¬ã³ãã©ã¼ã«å°å³ç»åãä¸ããããã®æ½è±¡ã¯ã©ã¹ã§ããã</p>
 *
 * <p>ãã®ã¤ã³ã¹ã¿ã³ã¹ã«ã¯ç¶æ ( {@link mapray.ImageProvider.Status} å) ãããã{@link mapray.ImageProvider#status|status()}
 *    ã¡ã½ããã«ããç¶æãç¢ºèªãããã¨ãã§ããã<p>
 *
 * <p>åæç¶æã¯ READY ã¾ãã¯ NOT_READY ã§ãªããã°ãªãããç¶æã®å¤åã¯ NOT_READY ãã READY ã¾ãã¯ NOT_READY ãã FAILED ããå­å¨ããªãã<p>
 * <p>READY ä»¥å¤ã®ç¶æã§ã¯ {@link mapray.ImageProvider#status|status()} ãé¤ãã¡ã½ãããå¼ã³åºããã¨ã¯ã§ããªãã<p>
 *
 * <p>åæç¶æã NOT_READY ã«ãªãå¯è½æ§ããããã­ãã¤ãã¯ã{@link mapray.ImageProvider#status|status()} ã¡ã½ããããªã¼ãã¼ã©ã¤ãããå¿è¦ãããã</p>
 *
 * <p>ä»¥ä¸ã®æ½è±¡ã¡ã½ããã¯æ¢å®ã®åä½ããªãã®ã§ãå©ç¨èã¯ãããã®ã¡ã½ããããªã¼ãã¼ã©ã¤ãããå·è±¡ã¯ã©ã¹ãä½¿ç¨ããªããã°ãªããªãã</p>
 * <ul>
 *   <li>{@link mapray.ImageProvider#requestTile|requestTile()}</li>
 *   <li>{@link mapray.ImageProvider#cancelRequest|cancelRequest()}</li>
 *   <li>{@link mapray.ImageProvider#getImageSize|getImageSize()}</li>
 *   <li>{@link mapray.ImageProvider#getZoomLevelRange|getZoomLevelRange()}</li>
 * </ul>
 *
 * @memberof mapray
 * @abstract
 * @protected
 * @see mapray.StandardImageProvider
 * @see mapray.Viewer
 */
var ImageProvider =
/*#__PURE__*/
function () {
  function ImageProvider() {
    _classCallCheck(this, ImageProvider);
  }

  _createClass(ImageProvider, [{
    key: "status",

    /**
     * @summary ç¶æã®åå¾
     * @desc
     * <p>ç¾å¨ã® ImageProvider ç¶æãè¿ãã</p>
     * <p>callback ãä¸ããã¨ããç¶æã NOT_READY ãã READY ã¾ãã¯ FAILED ã«å¤åããã¨ãã« callback ãå¼ã³åºãããã
     * NOT_READY ä»¥å¤ã®ç¶æã§ callback ä¸ãã¦ããããã¯ç¡è¦ããã³ã¼ã«ããã¯é¢æ°ã¯ç»é²ãããªãã</p>
     *
     * @param  {mapray.ImageProvider.StatusCallback} [callback]  ç¶æå¤åã³ã¼ã«ããã¯é¢æ°
     * @return {mapray.ImageProvider.Status}                     ç¾å¨ã® ImageProvider ç¶æ
     * @abstract
     */
    value: function status(callback) {
      return Status$1.READY;
    }
    /**
     * @summary å°å³ã¿ã¤ã«ç»åãè¦æ±
     * @desc
     * <p>åº§æ¨ã (z, x, y) ã®å°å³ã¿ã¤ã«ç»åãè¦æ±ããã</p>
     * <p>æå®ããã¿ã¤ã«ç»åã®åå¾ãæåã¾ãã¯å¤±æããã¨ãã« callback ãéåæã«å¼ã³åºãããªããã°ãªããªãã</p>
     * <p>ã ãã [cancelRequest()]{@link mapray.ImageProvider#cancelRequest} ã«ããè¦æ±ãåãæ¶ãããã¨ããcallback ã¯å¼ã³åºãã¦ãå¼ã³åºããªãã¦ããããã¾ãéåæå¼ã³åºãã§ããå¿è¦ããªãã</p>
     * @param  {number}   z  ãºã¼ã ã¬ãã«
     * @param  {number}   x  X ã¿ã¤ã«åº§æ¨
     * @param  {number}   y  Y ã¿ã¤ã«åº§æ¨
     * @param  {mapray.ImageProvider.RequestCallback} callback  è¦æ±ã³ã¼ã«ããã¯é¢æ°
     * @return {object}   è¦æ± ID ([cancelRequest()]{@link mapray.ImageProvider#cancelRequest} ã«ä¸ãããªãã¸ã§ã¯ã)
     * @abstract
     */

  }, {
    key: "requestTile",
    value: function requestTile(z, x, y, callback) {
      throw new Error("mapray.ImageProvider#requestTile() method has not been overridden.");
    }
    /**
     * @summary å°å³ã¿ã¤ã«ç»åã®è¦æ±ãåãæ¶ã
     * <p>[requestTile()]{@link mapray.ImageProvider#requestTile} ã«ããè¦æ±ãå¯è½ã§ããã°åãæ¶ãã</p>
     * @param {object} id  è¦æ± ID ([requestTile()]{@link mapray.ImageProvider#requestTile} ããå¾ããªãã¸ã§ã¯ã)
     * @abstract
     */

  }, {
    key: "cancelRequest",
    value: function cancelRequest(id) {
      throw new Error("mapray.ImageProvider#cancelRequest() method has not been overridden.");
    }
    /**
     * @summary å°å³ã¿ã¤ã«ç»åã®å¯¸æ³ãåå¾
     * @desc
     * <p>ãµã¼ãã¼ãæä¾ããå°å³ã¿ã¤ã«ç»åã®å¯¸æ³ãããã</p>
     * <p>å°å³ã¿ã¤ã«ç»åã¯æ­£æ¹å½¢ãåæã¨ããæ°´å¹³æ¹åã®ç»ç´ æ°ãè¿ãã</p>
     * <p>å¶é: this ãåããªãå¸¸ã«åãå¤ãè¿ããªããã°ãªããªãã</p>
     * @return {number}  å°å³ã¿ã¤ã«ç»åã®ç»ç´ æ°
     * @abstract
     */

  }, {
    key: "getImageSize",
    value: function getImageSize() {
      throw new Error("mapray.ImageProvider#getImageSize() method has not been overridden.");
    }
    /**
     * @summary å°å³ç»åãºã¼ã ã¬ãã«ã®ç¯å²ãåå¾
     * @desc
     * <p>ãµã¼ãã¼ãæä¾ããå°å³ã¿ã¤ã«ç»åã®ãºã¼ã ã¬ãã«ã®ç¯å²ãåå¾ããã</p>
     * <p>å¶é: this ãåããªãå¸¸ã«åãç¯å²ãè¿ããªããã°ãªããªãã</p>
     * @return {mapray.ImageProvider.Range}  ãºã¼ã ã¬ãã«ã®ç¯å²
     * @abstract
     */

  }, {
    key: "getZoomLevelRange",
    value: function getZoomLevelRange() {
      throw new Error("mapray.ImageProvider#getZoomLevelRange() method has not been overridden.");
    }
  }]);

  return ImageProvider;
}();
/**
 * @summary å°å³ç»åãºã¼ã ã¬ãã«ç¯å²
 * @memberof mapray.ImageProvider
 * @see mapray.ImageProvider#getZoomLevelRange
 */


var Range =
/*#__PURE__*/
function () {
  /**
   * @param {number} min  æå°ãºã¼ã ã¬ãã« (0 ã¾ãã¯ 0 ããå¤§ããæ´æ°)
   * @param {number} max  æå¤§ãºã¼ã ã¬ãã« (min ã¾ãã¯ min ããå¤§ããæ´æ°)
   */
  function Range(min, max) {
    _classCallCheck(this, Range);

    this._min = min;
    this._max = max;
  }
  /**
   * @summary æå°ãºã¼ã ã¬ãã«
   * @type {number}
   * @readonly
   */


  _createClass(Range, [{
    key: "min",
    get: function get() {
      return this._min;
    }
    /**
     * @summary æå¤§ãºã¼ã ã¬ãã«
     * @type {number}
     * @readonly
     */

  }, {
    key: "max",
    get: function get() {
      return this._max;
    }
  }]);

  return Range;
}();

ImageProvider.Range = Range;
/**
 * @summary å°å³ã¿ã¤ã«ç»åè¦æ±ã³ã¼ã«ããã¯é¢æ°å
 * @desc
 * <p>å°å³ã¿ã¤ã«ç»åã®åå¾ã«æåã¾ãã¯å¤±æããã¨ãã«å¼ã³åºãããé¢æ°ã®åã§ããã</p>
 * <p>ãã®é¢æ°ã¯ [requestTile()]{@link mapray.ImageProvider#requestTile} ã® callback å¼æ°ã«ä¸ããã</p>
 * <p>ç»åã®åå¾ã«æåããã¨ãã¯ãimage ã« Image ã®ã¤ã³ã¹ã¿ã³ã¹ãå¤±æããã¨ãã¯ null ãä¸ããã</p>
 * <p>ãã ã [cancelRequest()]{@link mapray.ImageProvider#cancelRequest} ã«ããè¦æ±ãåãæ¶ãããã¨ããã³ã¼ã«ããã¯é¢æ°ã®å¼ã³åºãã¯ç¡è¦ãããã®ã§ image ã¯ä»»æã®å¤ã§ããã<p>
 * @param {Image} image  å°å³ã¿ã¤ã«ç»åã¾ãã¯ null
 * @callback RequestCallback
 * @memberof mapray.ImageProvider
 */

/**
 * @summary ImageProvider ç¶æã®åæå
 * @enum {object}
 * @memberof mapray.ImageProvider
 * @constant
 * @see mapray.ImageProvider#status
 */

var Status$1 = {
  /**
   * æºåä¸­
   */
  NOT_READY: {
    id: "NOT_READY"
  },

  /**
   * æºåå®äº
   */
  READY: {
    id: "READY"
  },

  /**
   * å¤±æç¶æ
   */
  FAILED: {
    id: "FAILED"
  }
};
ImageProvider.Status = Status$1;

/**
 * @summary ããã¼ç»åãã­ãã¤ã
 *
 * ç¶æã¯å¸¸ã« READYãã¬ãã« 0 ã®ã¿ã®å·¨å¤§ç»åããã ãç»åã¯æ°¸é ã«è¿ããªãã
 *
 * @memberof mapray
 * @extends mapray.ImageProvider
 * @private
 */

var EmptyImageProvider =
/*#__PURE__*/
function (_ImageProvider) {
  _inherits(EmptyImageProvider, _ImageProvider);

  /**
   */
  function EmptyImageProvider() {
    _classCallCheck(this, EmptyImageProvider);

    return _possibleConstructorReturn(this, _getPrototypeOf(EmptyImageProvider).call(this));
  }
  /**
   * @override
   */


  _createClass(EmptyImageProvider, [{
    key: "requestTile",
    value: function requestTile(z, x, y, callback) {
      return this;
    }
    /**
     * @override
     */

  }, {
    key: "cancelRequest",
    value: function cancelRequest(id) {}
    /**
     * @override
     */

  }, {
    key: "getImageSize",
    value: function getImageSize() {
      return 4096;
    }
    /**
     * @override
     */

  }, {
    key: "getZoomLevelRange",
    value: function getZoomLevelRange() {
      return new ImageProvider.Range(0, 0);
    }
  }]);

  return EmptyImageProvider;
}(ImageProvider);

/**
 * @summary ã¿ã¤ã«ãã¯ã¹ãã£
 * @memberof mapray
 * @private
 * @see mapray.TileTextureCache
 */
var TileTexture =
/*#__PURE__*/
function () {
  /**
   * @param {number}       z        å°å³ãºã¼ã ã¬ãã«
   * @param {number}       x        X ã¿ã¤ã«åº§æ¨
   * @param {number}       y        Y ã¿ã¤ã«åº§æ¨
   * @param {WebGLTexture} texture  ãã¯ã¹ãã£ãªãã¸ã§ã¯ã
   */
  function TileTexture(z, x, y, texture) {
    _classCallCheck(this, TileTexture);

    /**
     * @summary å°å³ãºã¼ã ã¬ãã«
     * @member mapray.TileTexture#z
     * @type {number}
     */
    this.z = z;
    /**
     * @summary X ã¿ã¤ã«åº§æ¨
     * @member mapray.TileTexture#x
     * @type {number}
     */

    this.x = x;
    /**
     * @summary Y ã¿ã¤ã«åº§æ¨
     * @member mapray.TileTexture#y
     * @type {number}
     */

    this.y = y;
    /**
     * @summary ãã¯ã¹ãã£ãªãã¸ã§ã¯ã
     * @member mapray.TileTexture#texture
     * @type {WebGLTexture}
     */

    this.texture = texture;
  }
  /**
   * @summary ãªã½ã¼ã¹ãç ´æ£
   * @param {WebGLRenderingContext} gl  WebGL ã¬ã³ããªã³ã°ã³ã³ãã­ã¹ã
   */


  _createClass(TileTexture, [{
    key: "dispose",
    value: function dispose(gl) {
      gl.deleteTexture(this.texture);
      this.texture = null;
    }
  }]);

  return TileTexture;
}();

/**
 * @summary ã¿ã¤ã«ãã¯ã¹ãã£ã®ç®¡ç
 * @memberof mapray
 * @private
 * @see mapray.TileTexture
 */

var TileTextureCache =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.GLEnv}         glenv     WebGL ç°å¢
   * @param {mapray.ImageProvider} provider  å°å³ç»åãã­ãã¤ã
   */
  function TileTextureCache(glenv, provider) {
    var _this = this;

    _classCallCheck(this, TileTextureCache);

    this._glenv = glenv;
    this._provider = null;
    this._min_image_z = 0;
    this._max_image_z = 0;
    this._image_zbias = 0;

    var status_callback = function status_callback(status) {
      if (status === ImageProvider.Status.READY) {
        // EmptyImageProvider ããæ¬æ¥ã® provider ã«åãæ¿ãã
        _this._flush();

        _this._resetImageProvider(provider);
      } else if (status === ImageProvider.Status.FAILED) {
        // provider ã READY ç¶æã«ãªããªãã£ã
        console.error("ImageProvider.Status.FAILED in TileTextureCache");
      }
    };

    this._resetImageProvider(provider.status(status_callback) === ImageProvider.Status.READY ? provider : new EmptyImageProvider()); // ã­ã£ãã·ã¥ãåæå


    this._croot = new CacheNode(); // ã­ã£ãã·ã¥å¶å¾¡å¤æ°

    this._max_accesses = 0; // æè¿ã®ãã¬ã¼ã ã®æå¤§ã¢ã¯ã»ã¹ãã¼ãæ°

    this._frame_counter = 0; // ç¾è¡ãã¬ã¼ã çªå·

    this._lower_bound = 1.0; // >= 1.0

    this._upper_bound = 1.2; // >= lower_bound
    // ãªã¯ã¨ã¹ãå¶å¾¡å¤æ°

    this._num_requesteds = 0; // ç¾å¨ã® REQUESTED ç¶æã®ãã¼ãæ°

    this._max_requesteds = 75; // æå¤§ REQUESTED ãã¼ãæ°

    this._new_requesteds = []; // æ°è¦ãªã¯ã¨ã¹ãã®ãªã¹ã
    // WebGL é¢é£

    var gl = glenv.context;
    var aniso_ext = glenv.EXT_texture_filter_anisotropic;

    if (aniso_ext) {
      this._aniso_ext = aniso_ext;
      this._max_aniso = gl.getParameter(aniso_ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    }

    this._use_mipmap = false;
  }
  /**
   * ç»åãã­ãã¤ããåè¨­å®
   *
   *   _provider
   *   _min_image_z
   *   _max_image_z
   *   _image_zbias
   *
   * @private
   */


  _createClass(TileTextureCache, [{
    key: "_resetImageProvider",
    value: function _resetImageProvider(provider) {
      this._provider = provider;
      var renge = provider.getZoomLevelRange();
      this._min_image_z = renge.min;
      this._max_image_z = renge.max;
      this._image_zbias = Math.maprayLog2(2 * Math.PI / provider.getImageSize());
    }
    /**
     * ãã¹ã¦ã®ãªã¯ã¨ã¹ããåãæ¶ã
     */

  }, {
    key: "cancel",
    value: function cancel() {
      this._flush();
    }
    /**
     * ã­ã£ãã·ã¥ããã©ãã·ã¥
     * @private
     */

  }, {
    key: "_flush",
    value: function _flush() {
      new NodeCanceller(this, this._croot); // ãªã¯ã¨ã¹ããåãæ¶ã

      this._croot = new CacheNode(); // åãæ¶ãããã¼ãã¯ä½¿ããªãã®ã§ãåç´ã«ãã¹ã¦æ¨ã¦ã

      this._max_accesses = 0; // assert: this._num_requesteds == 0
    }
    /**
     * LOD ãããã¯ã¹ãã£ã® Z ã¬ãã«ãè¨ç®ãããã¤ã¢ã¹å¤ãåå¾
     *
     * @return {number}  Log2[2Pi / size]
     */

  }, {
    key: "getImageZBias",
    value: function getImageZBias() {
      return this._image_zbias;
    }
    /**
     * @return {number}  ã¿ã¤ã«ã® Z ã¬ãã«ã®æå°å¤
     */

  }, {
    key: "getImageZMin",
    value: function getImageZMin() {
      return this._min_image_z;
    }
    /**
     * @summary ãªã¯ã¨ã¹ãå¾ã¡ã®ã¿ã¤ã«ã®åæ°ãåå¾
     *
     * @return {number}  ãªã¯ã¨ã¹ãå¾ã¡ã®ã¿ã¤ã«ã®åæ°
     */

  }, {
    key: "getNumWaitingRequests",
    value: function getNumWaitingRequests() {
      return this._num_requesteds;
    }
    /**
     * @summary åç¥ã¿ã¤ã«ãã¯ã¹ãã£ãæ¤ç´¢
     * @desc
     * <p>[x, y, z] ã¿ã¤ã«ã®ç¥åã®ä¸­ã§ãç¾å¨ã­ã£ãã·ã¥ã«å­å¨ããæå¤§ã¬ãã«ã®ã¿ã¤ã«ãã¯ã¹ãã£ãæ¤ç´¢ããhi ã«è¨­å®ããã</p>
     *
     * <p>ãã ãæ¤ç´¢ãããã¿ã¤ã«ã®ãºã¼ã ã¬ãã«ã Z ã¨ããã¨ãZ <= max( zlimit, this._min_image_z )
     *    ã¨ããæ¡ä»¶ããæ¤ç´¢ããå­å¨ããªããã° null ã¨ãªãã</p>
     *
     *  <p>hi ããä½ãã¬ãã«ã«ã¿ã¤ã«ãå­å¨ããã°ãããã lo ã«è¨­å®ããå­å¨ããªããã° lo ã« hi ã¨åãã¿ã¤ã«ãè¨­å®ãã</p>
     *
     * <p>ãã­ãã¤ãã«ãã£ã¨ç¸å¿ãããã¯ã¹ãã£ãå­å¨ããå¯è½æ§ãããã°ããã®ãã¯ã¹ãã£ãè¦æ±ããã</p>
     *
     * <p>åæ: z >= this._min_image_z && z >= zlimit</p>
     *
     * @param  {number}          z   å°å³ãºã¼ã ã¬ãã«
     * @param  {number}          x   X ã¿ã¤ã«åº§æ¨
     * @param  {number}          y   Y ã¿ã¤ã«åº§æ¨
     * @param  {number}     zlimit   åç¥ã¬ãã«ã®ä¸é
     * @return {mapray.TileTexture[]}  åç¥ã¿ã¤ã«ãã¯ã¹ãã£éå [hi, lo]
     */

  }, {
    key: "findNearestAncestors",
    value: function findNearestAncestors(z, x, y, zlimit) {
      var depth = 0;
      var d_min = this._min_image_z;
      var pow = Math.pow(2, 1 - z);
      var xf = (x + 0.5) * pow;
      var yf = (y + 0.5) * pow;
      var node = this._croot;
      var u;
      var v;
      var index;
      var children;
      var child; // æå°ã¬ãã«ã®ãã¼ã  --->  node, depth

      for (; depth < d_min; ++depth) {
        u = Math.floor(xf) % 2;
        v = Math.floor(yf) % 2;
        index = u + 2 * v;
        children = node.children;
        child = children[index];

        if (child === null) {
          child = new CacheNode();
          children[index] = child;
        }

        xf *= 2;
        yf *= 2;
        node = child;
      }

      var d_max = this._max_image_z;
      var d_lo = GeoMath.clamp(zlimit - 1, d_min, d_max);
      var d_hi = GeoMath.clamp(zlimit, d_min, d_max);
      var tex_lo = null;
      var tex_hi = null;

      if (d_lo < d_hi) {
        /* assert: (d_min < d_max) && (d_min < zlimit <= d_max) */
        for (; depth <= d_lo; ++depth) {
          if (node.state === NodeState.LOADED) {
            // åè£ãã¯ã¹ãã£ãæ´æ°
            tex_lo = node;
          } else if (node.state === NodeState.NONE) {
            // æ°è¦ãªã¯ã¨ã¹ã
            node.state = NodeState.REQUESTED;
            node.req_power = zlimit - depth;

            this._new_requesteds.push([node, depth, Math.floor(0.5 * xf), Math.floor(0.5 * yf)]);
          } else if (node.state === NodeState.REQUESTED) {
            // è¦æ±åº¦ãæ´æ°
            node.updateRequestPower(zlimit - depth);
          }

          u = Math.floor(xf) % 2;
          v = Math.floor(yf) % 2;
          index = u + 2 * v;
          children = node.children;
          child = children[index];

          if (child === null) {
            child = new CacheNode();
            children[index] = child;
          }

          xf *= 2;
          yf *= 2;
          node = child;
        }

        tex_hi = tex_lo;

        if (node.state === NodeState.LOADED) {
          // åè£ãã¯ã¹ãã£ãæ´æ°
          tex_hi = node;
        } else if (node.state === NodeState.NONE) {
          // æ°è¦ãªã¯ã¨ã¹ã
          node.state = NodeState.REQUESTED;
          node.req_power = zlimit - depth;

          this._new_requesteds.push([node, depth, Math.floor(0.5 * xf), Math.floor(0.5 * yf)]);
        } else if (node.state === NodeState.REQUESTED) {
          // è¦æ±åº¦ãæ´æ°
          node.updateRequestPower(zlimit - depth);
        }
      } else {
        // if d_lo == d_hi

        /* assert: (d_min == d_max) || (zlimit <= d_min) || (zlimit > d_max) */
        for (;; ++depth) {
          if (node.state === NodeState.LOADED) {
            // åè£ãã¯ã¹ãã£ãæ´æ°
            tex_lo = node;
          } else if (node.state === NodeState.NONE) {
            // æ°è¦ãªã¯ã¨ã¹ã
            node.state = NodeState.REQUESTED;
            node.req_power = zlimit - depth;

            this._new_requesteds.push([node, depth, Math.floor(0.5 * xf), Math.floor(0.5 * yf)]);
          } else if (node.state === NodeState.REQUESTED) {
            // è¦æ±åº¦ãæ´æ°
            node.updateRequestPower(zlimit - depth);
          }

          if (depth == d_lo) {
            tex_hi = tex_lo;
            break;
          }

          u = Math.floor(xf) % 2;
          v = Math.floor(yf) % 2;
          index = u + 2 * v;
          children = node.children;
          child = children[index];

          if (child === null) {
            child = new CacheNode();
            children[index] = child;
          }

          xf *= 2;
          yf *= 2;
          node = child;
        } // assert: tex_hi === tex_lo

      }

      node.touch();
      var result = TileTextureCache._findNearestAncestors_result;
      result[0] = tex_hi !== null ? tex_hi.data : null;
      result[1] = tex_lo !== null ? tex_lo.data : null;
      return result;
    }
    /**
     * @summary ãã¬ã¼ã ã®æå¾ã®å¦ç
     */

  }, {
    key: "endFrame",
    value: function endFrame() {
      this._performNewRequests();

      var counter = new NodeCounter(this._croot, this._frame_counter);
      this._max_accesses = Math.max(counter.num_accesses, this._max_accesses);

      if (counter.num_loadeds > this._upper_bound * this._max_accesses) {
        var num_nodes = Math.floor(this._lower_bound * this._max_accesses);

        this._reduceCache(num_nodes);
      }

      ++this._frame_counter;
    }
    /**
     * @summary æ°è¦ãªã¯ã¨ã¹ããå®è¡
     * @private
     */

  }, {
    key: "_performNewRequests",
    value: function _performNewRequests() {
      // ãªã¯ã¨ã¹ãæ°
      var num_requests = Math.min(this._max_requesteds - this._num_requesteds, this._new_requesteds.length); // åºæºã«åºã¥ããæ°è¦ãªã¯ã¨ã¹ããåå (num_requests å) ã¨å¾åã«åå²

      this._new_requesteds.sort(function (a, b) {
        var anode = a[0];
        var bnode = b[0];
        return bnode.req_power - anode.req_power;
      }); // ãªã¯ã¨ã¹ããå®è¡


      var self = this;

      this._new_requesteds.slice(0, num_requests).forEach(function (req) {
        var node = req[0];
        var z = req[1];
        var x = req[2];
        var y = req[3];

        self._requestTileTexture(z, x, y, node);
      }); // ãªã¯ã¨ã¹ãããªãã£ããã¼ããç©ºã«æ»ã


      this._new_requesteds.slice(num_requests).forEach(function (req) {
        var node = req[0];
        node.state = NodeState.NONE; // assert: node.data === null
      }); // æ°è¦ãªã¯ã¨ã¹ãã®ãªã¹ããã¯ãªã¢


      this._new_requesteds.length = 0;
    }
    /**
     * @summary ã¿ã¤ã«ãã¯ã¹ãã£ãè¦æ±
     * @param {number} z  å°å³ãºã¼ã ã¬ãã«
     * @param {number} x  X ã¿ã¤ã«åº§æ¨
     * @param {number} y  Y ã¿ã¤ã«åº§æ¨
     * @param {mapray.TileTextureCache.CacheNode} node  å¯¾è±¡ãã¼ã
     * @private
     */

  }, {
    key: "_requestTileTexture",
    value: function _requestTileTexture(z, x, y, node) {
      var _this2 = this;

      node.data = this._provider.requestTile(z, x, y, function (image) {
        if (node.state !== NodeState.REQUESTED) {
          // ã­ã£ã³ã»ã«ããã¦ããã®ã§ç¡è¦
          return;
        }

        if (image) {
          node.data = new TileTexture(z, x, y, _this2._createTexture(image));
          node.state = NodeState.LOADED;
        } else {
          node.data = null;
          node.state = NodeState.FAILED;
        }

        --_this2._num_requesteds;
      });
      ++this._num_requesteds;
    }
    /**
     * @summary ãã¯ã¹ãã£ãçæ
     * @desc
     * <p>GL ã¹ãã¼ãã®å¤æ´</p>
     * <ul>
     *   <li>TEXTURE_2D_BINDING:   null</li>
     *   <li>UNPACK_FLIP_Y_WEBGL:  false</li>
     * </ul>
     * @param  {Image}  image  åç»å
     * @return {WebGLTexture}  çæããããã¯ã¹ãã£
     * @private
     */

  }, {
    key: "_createTexture",
    value: function _createTexture(image) {
      var gl = this._glenv.context;
      var aniso_ext = this._aniso_ext;
      var target = gl.TEXTURE_2D;
      var texture = gl.createTexture();
      gl.bindTexture(target, texture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.texImage2D(target, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

      if (this._use_mipmap) {
        gl.generateMipmap(target);
      }

      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this._use_mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      if (aniso_ext) {
        gl.texParameterf(gl.TEXTURE_2D, aniso_ext.TEXTURE_MAX_ANISOTROPY_EXT, this._max_aniso);
      }

      gl.bindTexture(target, null);
      return texture;
    }
    /**
     * @summary ã­ã£ãã·ã¥ãåæ¸
     * @param  {number} num_cnodes  ç®æ¨ãã¼ãæ°
     * @private
     */

  }, {
    key: "_reduceCache",
    value: function _reduceCache(num_nodes) {
      var collector = new NodeCollector(this._croot); // åºæºã«åºã¥ãããã¼ããåå (num_cnodes å) ã¨å¾åã«åå²

      collector.nodes.sort(function (a, b) {
        var aframe = b.aframe - a.aframe;

        if (aframe == 0) {
          if (a.state === NodeState.LOADED && b.state === NodeState.LOADED) {
            return a.data.z - b.data.z;
          }
        }

        return aframe;
      }); // å¾åã®ãã¼ããåé¤

      var gl = this._glenv.context;
      collector.nodes.slice(num_nodes).forEach(function (node) {
        if (node.state === NodeState.LOADED) {
          node.data.dispose(gl);
        }

        node.state = NodeState.NONE;
        node.data = null;
      }); // NodeState.NONE ã®èãã¼ããæ¶å»

      collector.clean();
    }
  }]);

  return TileTextureCache;
}(); // ã¯ã©ã¹å®æ°ãå®ç¾©


TileTextureCache._findNearestAncestors_result = new Array(2);
/**
 * @summary ã­ã£ãã·ã¥ãã¼ã
 *
 * @memberof mapray.TileTextureCache
 * @private
 */

var CacheNode =
/*#__PURE__*/
function () {
  function CacheNode() {
    _classCallCheck(this, CacheNode);

    this.children = [null, null, null, null];
    this.state = NodeState.NONE;
    this.data = null; // TileTexture ãªãã¸ã§ã¯ããã¾ãã¯åãæ¶ããªãã¸ã§ã¯ã

    this.req_power = -1; // è¦æ±åº¦

    this.aframe = -1; // æçµã¢ã¯ã»ã¹ãã¬ã¼ã 
  }
  /**
   * è¦æ±åº¦ãæ´æ°
   */


  _createClass(CacheNode, [{
    key: "updateRequestPower",
    value: function updateRequestPower(req_power) {
      if (req_power > this.req_power) {
        this.req_power = req_power;
      }
    }
    /**
     * ãã®ã¿ã¤ã«ã«ã¢ã¯ã»ã¹ãããã¨ã«ãã
     */

  }, {
    key: "touch",
    value: function touch() {
      this.aframe = true;
    }
  }]);

  return CacheNode;
}();
/**
 * @summary ãã¼ãæ°ã®è¨ä¸
 *
 * this.num_loadeds:  ã­ã¼ãããã¦ããã¿ã¤ã«æ°
 * this.num_accesses: ã­ã¼ãããã¦ããã¿ã¤ã«ã®ãã¡ãã¢ã¯ã»ã¹ãããã¿ã¤ã«æ°
 *
 * ã¢ã¯ã»ã¹ããã£ããã¼ãã«å¯¾ãã¦ aframe ãæ´æ°ããã
 *
 * @memberof mapray.TileTextureCache
 * @private
 */


var NodeCounter =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.TileTextureCache.CacheNode} root   æä¸ä½ãã¼ã
   * @param {number}                            frame  ç¾å¨ã®ãã¬ã¼ã 
   */
  function NodeCounter(root, frame) {
    _classCallCheck(this, NodeCounter);

    this.num_loadeds = 0;
    this.num_accesses = 0;
    this._frame = frame;

    this._traverse(root);
  }
  /**
   * @private
   */


  _createClass(NodeCounter, [{
    key: "_traverse",
    value: function _traverse(node) {
      var children = node.children;
      var isAccessed = node.aframe === true;

      for (var i = 0; i < 4; ++i) {
        var child = children[i];

        if (child !== null) {
          isAccessed = this._traverse(child) || isAccessed;
        }
      }

      if (node.state === NodeState.LOADED) {
        ++this.num_loadeds;

        if (isAccessed) {
          ++this.num_accesses;
        }
      }

      if (isAccessed) {
        // ã¢ã¯ã»ã¹ãã¬ã¼ã ãæ´æ°
        node.aframe = this._frame;
      }

      return isAccessed;
    }
  }]);

  return NodeCounter;
}();
/**
 * @summary ãã¼ãåé
 * @desc
 * <p>NodeState.LOADED ã¾ãã¯ NodeState.FAILED ã®ãã¼ãã this.nodes ã«åéããã</p>
 *
 * @memberof mapray.TileTextureCache
 * @private
 */


var NodeCollector =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.TileTextureCache.CacheNode} root  æä¸ä½ãã¼ã
   */
  function NodeCollector(root) {
    _classCallCheck(this, NodeCollector);

    this._root = root;
    this.nodes = [];

    this._traverse(root);
  }
  /**
   * @private
   */


  _createClass(NodeCollector, [{
    key: "_traverse",
    value: function _traverse(node) {
      var state = node.state;

      if (state === NodeState.LOADED || state === NodeState.FAILED) {
        // LOADED ã¾ãã¯ FAILED ãªãè¿½å 
        this.nodes.push(node);
      }

      var children = node.children;

      for (var i = 0; i < 4; ++i) {
        var child = children[i];

        if (child !== null) {
          this._traverse(child);
        }
      }
    }
    /**
     * @summary NodeState.NONE ã®èãã¼ããæ¶å»
     */

  }, {
    key: "clean",
    value: function clean() {
      this._clean_recur(this._root);
    }
    /**
     * @return èªå·±ã¨å­å­«ããã¹ã¦ NodeState.NONE ã®ã¨ã true, ãããããã®ã¨ã false
     * @private
     */

  }, {
    key: "_clean_recur",
    value: function _clean_recur(node) {
      var isNodeNone = node.state === NodeState.NONE;
      var children = node.children;

      for (var i = 0; i < 4; ++i) {
        var child = children[i];

        if (child !== null) {
          var isChildNone = this._clean_recur(child);

          if (isChildNone === true) {
            children[i] = null;
          }

          isNodeNone = isChildNone && isNodeNone;
        }
      }

      return isNodeNone;
    }
  }]);

  return NodeCollector;
}();
/**
 * @summary ãã¹ã¦ã®ãªã¯ã¨ã¹ããåãæ¶ã
 * @memberof mapray.TileTextureCache
 * @private
 */


var NodeCanceller =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.TileTextureCache}          owner  æä¸ä½ãã¼ã
   * @param {mapray.TileTextureCache.CacheNode} root  æä¸ä½ãã¼ã
   */
  function NodeCanceller(owner, root) {
    _classCallCheck(this, NodeCanceller);

    this._owner = owner;

    this._traverse(root);
  }
  /**
   * @private
   */


  _createClass(NodeCanceller, [{
    key: "_traverse",
    value: function _traverse(node) {
      var children = node.children;

      for (var i = 0; i < 4; ++i) {
        var child = children[i];

        if (child !== null) {
          this._traverse(child);
        }
      }

      if (node.state === NodeState.REQUESTED) {
        var owner = this._owner;
        node.state = NodeState.NONE;

        owner._provider.cancelRequest(node.data);

        --owner._num_requesteds;
      }
    }
  }]);

  return NodeCanceller;
}();
/**
 * @summary ãã¼ãç¶æã®åæå
 * @enum {object}
 * @memberof mapray.TileTextureCache
 * @constant
 */


var NodeState = {
  /**
   * ã¿ã¤ã«ãå­å¨ããªã
   */
  NONE: {
    id: "NONE"
  },

  /**
   * ã¿ã¤ã«ãå­å¨ãã
   */
  LOADED: {
    id: "LOADED"
  },

  /**
   * ã¿ã¤ã«ããªã¯ã¨ã¹ãä¸­
   */
  REQUESTED: {
    id: "REQUESTED"
  },

  /**
   * ã¿ã¤ã«ã®ãªã¯ã¨ã¹ãã«å¤±æ
   */
  FAILED: {
    id: "FAILED"
  }
};

var surface_vs_code = "attribute vec4 a_position;         // ä½ç½® (å°è¡¨æ­çåº§æ¨ç³»)\nattribute vec2 a_uv;               // uv åº§æ¨\n\nuniform mat4  u_obj_to_clip;       // å°è¡¨æ­çåº§æ¨ç³»ããã¯ãªããåº§æ¨ç³»ã¸ã®å¤æ\n\nuniform vec4  u_texcoord_rect_hi;  // é«ã¬ãã«ç»å å·¦ä¸åº§æ¨: (x, y), åº§æ¨ãµã¤ãº: (z, w)\nuniform vec4  u_texcoord_rect_lo;  // ä½ã¬ãã«ç»å å·¦ä¸åº§æ¨: (x, y), åº§æ¨ãµã¤ãº: (z, w)\nuniform vec4  u_corner_lod;        // uv = (0,0), (1,0), (0,1), (1,1) ã® LOD\n\n#ifdef NIGHTIMAGE\nuniform mat4  u_obj_to_gocs;       // å°è¡¨æ­çåº§æ¨ç³»ããGOCSåº§æ¨ç³»ã¸ã®å¤æ\nuniform float u_opacity;           // ä¸éæåº¦\nuniform vec3  u_sun_direction;     // å¤ªé½æ¹å\n\nvarying float v_opacity;           // ä¸éæåº¦(å¤ªé½æ¹åã«ããå¦ç)\n#endif\n\nvarying vec2  v_texcoord_hi;       // é«ã¬ãã«ç»åã®ãã¯ã¹ãã£åº§æ¨\nvarying vec2  v_texcoord_lo;       // ä½ã¬ãã«ç»åã®ãã¯ã¹ãã£åº§æ¨\nvarying float v_lod;               // è£éããã LOD\n\n#ifdef NIGHTIMAGE\nfloat sigmoid( float a, float x )\n{\n  return 1.0 / ( 1.0 + exp( -( a * x )) );\n}\n#endif\n\nvoid main()\n{\n    gl_Position = u_obj_to_clip * a_position;\n\n    // uv åº§æ¨ããã¯ã¹ãã£åº§æ¨ã«å¤æ\n    v_texcoord_hi = u_texcoord_rect_hi.xy + u_texcoord_rect_hi.zw * a_uv;\n    v_texcoord_lo = u_texcoord_rect_lo.xy + u_texcoord_rect_lo.zw * a_uv;\n\n    // LOD ã®è£é\n    float u = a_uv.x;\n    float v = a_uv.y;\n\n    float lod_00 = u_corner_lod.x;  // uv = (0,0) ã® LOD\n    float lod_10 = u_corner_lod.y;  // uv = (1,0) ã® LOD\n    float lod_01 = u_corner_lod.z;  // uv = (0,1) ã® LOD\n    float lod_11 = u_corner_lod.w;  // uv = (1,1) ã® LOD\n\n    float lod_u0 = mix( lod_00, lod_10, u );  // uv = (u, 0) ã® LOD\n    float lod_u1 = mix( lod_01, lod_11, u );  // uv = (u, 1) ã® LOD\n    float lod_uv = mix( lod_u0, lod_u1, v );  // uv = (u, v) ã® LOD\n\n    v_lod = lod_uv;\n\n#ifdef NIGHTIMAGE\n    vec3 ground_vector = normalize( vec3( u_obj_to_gocs * a_position ) );\n    float dir = dot( ground_vector, u_sun_direction );\n    float sun_opacity = 1.0 - sigmoid( 5.0, dir );\n    v_opacity = sun_opacity * u_opacity;  // ä¸éæåº¦ãé©ç¨\n#endif\n}\n";

var surface_fs_code = "precision mediump float;\n\nvarying vec2  v_texcoord_hi;    // é«ã¬ãã«ç»åã®ãã¯ã¹ãã£åº§æ¨\nvarying vec2  v_texcoord_lo;    // ä½ã¬ãã«ç»åã®ãã¯ã¹ãã£åº§æ¨\nvarying float v_lod;            // è£éããã LOD\n\n#ifdef NIGHTIMAGE\nvarying float v_opacity;           // ä¸éæåº¦(å¤ªé½æ¹åã«ããå¦ç)\n#else\nuniform float u_opacity;           // ä¸éæåº¦\n#endif\n\nuniform sampler2D u_image_hi;   // é«ã¬ãã«ç»å\nuniform sampler2D u_image_lo;   // ä½ã¬ãã«ç»å\n\n/** ç»åãã©ã¡ã¼ã¿\n *\n *  x = u_image_lo ã® LOD\n *  y = 1 / (u_image_hi ã® LOD - x)\n *\n *  ãã ã u_image_hi ã¨ u_image_lo ãåãç»åã®ã¨ãã¯ y = 0\n */\nuniform vec2 u_image_param;\n\n\nvoid main()\n{\n    vec4 color_hi = texture2D( u_image_hi, v_texcoord_hi );\n    vec4 color_lo = texture2D( u_image_lo, v_texcoord_lo );\n\n    // ç»åã®æ··åç\n    float lo_lod = u_image_param.x;\n    float  delta = u_image_param.y;\n    float  ratio = clamp( (v_lod - lo_lod) * delta, 0.0, 1.0 );\n\n    gl_FragColor = mix( color_lo, color_hi, ratio );\n    // ä¸éæåº¦ãé©ç¨\n#ifdef NIGHTIMAGE\n    gl_FragColor.a *= v_opacity;\n#else\n    gl_FragColor.a *= u_opacity;\n#endif\n}\n";

var rid_fs_code = "/**\n * ãã¦ã¹ããã¯ç¨IDæç»ã·ã§ã¼ã (ãã©ã°ã¡ã³ãã·ã§ã¼ã)\n */\n\nprecision highp float;\nuniform vec4 u_rid; // rid\n\nvoid main()\n{\n    gl_FragColor = u_rid;\n}\n";

var wireframe_vs_code = "attribute vec4 a_position;\nattribute vec2 a_uv;\n\nuniform mat4 u_obj_to_clip;\n\nvarying vec2 v_uv;\n\nvoid main()\n{\n    gl_Position = u_obj_to_clip * a_position;\n    v_uv  = a_uv;\n}\n";

var wireframe_fs_code = "precision mediump float;\n\nvarying vec2 v_uv;\n\nvoid main()\n{\n    vec4 color = (v_uv.x < 0.005 || v_uv.y < 0.005 || v_uv.x > 0.995 || v_uv.y > 0.995) ?\n                 vec4( 1, 1, 0, 1 ) : vec4( 0.5, 0.5, 0.5, 1 );\n    gl_FragColor = color;\n}\n";

/**
 * @summary å°è¡¨ã¯ã¤ã¤ã¼ãã¬ã¼ã ãããªã¢ã«
 * @memberof mapray.RenderStage
 * @extends mapray.RenderStage.FlakeMaterial
 * @private
 */

var WireframeMaterial =
/*#__PURE__*/
function (_FlakeMaterial) {
  _inherits(WireframeMaterial, _FlakeMaterial);

  /**
   * @param {mapray.Viewer} viewer   ææè Viewer
   */
  function WireframeMaterial(viewer) {
    _classCallCheck(this, WireframeMaterial);

    return _possibleConstructorReturn(this, _getPrototypeOf(WireframeMaterial).call(this, viewer, wireframe_vs_code, wireframe_fs_code));
  }
  /**
   * @override
   */


  _createClass(WireframeMaterial, [{
    key: "isWireframe",
    value: function isWireframe() {
      return true;
    }
    /**
     * @override
     */

  }, {
    key: "setFlakeParameter",
    value: function setFlakeParameter(stage, rflake, mesh, index) {
      this.setCommonParameter(stage, mesh);
      return true;
    }
  }]);

  return WireframeMaterial;
}(FlakeMaterial);

/**
 * @summary å°å³ã¬ã¤ã¤ã¼
 * @classdesc
 * <p>å°å³ã¬ã¤ã¤ã¼ãè¡¨ç¾ãããªãã¸ã§ã¯ãã§ããã</p>
 *
 * @hideconstructor
 * @memberof mapray
 * @see mapray.LayerCollection
 */

var Layer =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.LayerCollection}      owner         å°å³ã¬ã¤ã¤ã¼ç®¡ç
   * @param {object|mapray.ImageProvider} init          åæåãã­ããã£
   * @param {mapray.ImageProvider} init.image_provider  ç»åãã­ãã¤ã
   * @param {boolean}              [init.visibility]    å¯è¦æ§ãã©ã°
   * @param {number}               [init.opacity]       ä¸éæåº¦
   * @param {Layer.LayerType}      [init.type]          ã¬ã¤ã¤ã¼ã¿ã¤ã
   */
  function Layer(owner, init) {
    _classCallCheck(this, Layer);

    this._owner = owner;
    this._glenv = owner.glenv;
    this._viewer = owner.viewer;
    var props = init instanceof ImageProvider ? {
      image_provider: init
    } : init;
    this._image_provider = props.image_provider;
    this._visibility = props.visibility || true;
    this._opacity = props.opacity || 1.0;
    this._type = props.type === Layer.LayerType.NIGHT ? Layer.LayerType.NIGHT : Layer.LayerType.NORMAL;
    this._material = null;
    this._tile_cache = new TileTextureCache(this._glenv, this._image_provider);
    var render_cache = this._viewer._render_cache || (this._viewer._render_cache = {});

    if (this._type === Layer.LayerType.NIGHT) {
      if (!render_cache.surface_night_material) {
        render_cache.surface_night_material = new SurfaceMaterial(this._viewer, {
          nightMaterial: true
        });
      }

      this._material = render_cache.surface_night_material;
    } else {
      if (!render_cache.surface_material) {
        render_cache.surface_material = new SurfaceMaterial(this._viewer);
        render_cache.wireframe_material = new WireframeMaterial(this._viewer);
      }

      this._material = render_cache.surface_material;
    } // ãã­ãã¤ãã®ç¶æãå¤åãããæç»ã¬ã¤ã¤ã¼ãæ´æ°


    this._image_provider.status(function (status) {
      owner.dirtyDrawingLayers();
    });
  }
  /**
   * @summary ç»åãã­ãã¤ããåå¾
   * @type {mapray.ImageProvider}
   * @readonly
   */


  _createClass(Layer, [{
    key: "setImageProvider",

    /**
     * @summary ç»åãã­ãã¤ããè¨­å®
     *
     * @param {mapray.ImageProvider} provider  ç»åãã­ãã¤ã
     */
    value: function setImageProvider(provider) {
      var _this = this;

      if (this._image_provider !== provider) {
        // ãã­ãã¤ããå¤æ´ã¾ãã¯ãã­ãã¤ãã®ç¶æãå¤åãããæç»ã¬ã¤ã¤ã¼ãæ´æ°
        this._owner.dirtyDrawingLayers();

        provider.status(function (status) {
          _this._owner.dirtyDrawingLayers();
        });
      }

      this._image_provider = provider; // ã¿ã¤ã«ã­ã£ãã·ã¥ãåæ§ç¯

      this._tile_cache.cancel();

      this._tile_cache = new TileTextureCache(this._glenv, provider);
    }
    /**
     * @summary å¯è¦æ§ãã©ã°ãè¨­å®
     *
     * @param {boolean} visibility  å¯è¦æ§ãã©ã°
     */

  }, {
    key: "setVisibility",
    value: function setVisibility(visibility) {
      if (this._visibility != visibility) {
        // ã¬ã¤ã¤ã¼ã®å¯è¦æ§ãå¤åãããæç»ã¬ã¤ã¤ã¼ãæ´æ°
        this._owner.dirtyDrawingLayers();
      }

      this._visibility = visibility;
    }
    /**
     * @summary ä¸éæåº¦ãè¨­å®
     *
     * @param {number} opacity  ä¸éæåº¦
     */

  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      this._opacity = opacity;
    }
    /**
     * @summary ãããªã¢ã«ãåå¾
     *
     * @return {mapray.SurfaceMaterial} ãããªã¢ã«
     * @package
     */

  }, {
    key: "getMateral",
    value: function getMateral() {
      return this._material;
    }
  }, {
    key: "image_provider",
    get: function get() {
      return this._image_provider;
    }
    /**
     * @summary å¯è¦æ§ãã©ã°ãåå¾
     * @type {boolean}
     * @readonly
     */

  }, {
    key: "visibility",
    get: function get() {
      return this._visibility;
    }
    /**
     * @summary ä¸éæåº¦ãåå¾
     * @type {number}
     * @readonly
     */

  }, {
    key: "opacity",
    get: function get() {
      return this._opacity;
    }
    /**
     * @summary ã¿ã¤ããåå¾
     * @type {LayerType}
     * @readonly
     */

  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
    /**
     * @summary ã¿ã¤ã«ãã¯ã¹ãã£ã­ã£ãã·ã¥ãåå¾
     * @type {mapray.TileTextureCache}
     * @readonly
     * @package
     */

  }, {
    key: "tile_cache",
    get: function get() {
      return this._tile_cache;
    }
  }]);

  return Layer;
}();
/**
 * @summary ã¬ã¤ã¤ã¼ã¿ã¤ã
 * @enum {object}
 * @memberof mapray.Layer
 * @constant
 */


var LayerType = {
  /**
   * éå¸¸ã®ã¬ã¤ã¤ã¼
   */
  NORMAL: {
    id: "NORMAL"
  },

  /**
   * å¤é¨åã®ã¿æç»ããã¬ã¤ã¤ã¼
   */
  NIGHT: {
    id: "NIGHT"
  }
};
Layer.LayerType = LayerType;

/**
 * @summary å°è¡¨é¢ãããªã¢ã«
 * @memberof mapray.RenderStage
 * @extends mapray.RenderStage.FlakeMaterial
 * @private
 */

var SurfaceMaterial =
/*#__PURE__*/
function (_FlakeMaterial) {
  _inherits(SurfaceMaterial, _FlakeMaterial);

  /**
   * @param {mapray.Viewer} viewer  ææèã§ãã Viewer
   */
  function SurfaceMaterial(viewer) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, SurfaceMaterial);

    var preamble = SurfaceMaterial._getPreamble(options);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SurfaceMaterial).call(this, viewer, preamble + surface_vs_code, preamble + (options.ridMaterial ? rid_fs_code : surface_fs_code)));

    _this.bindProgram();

    _this.setInteger("u_image_hi", SurfaceMaterial.TEXUNIT_IMAGE_HI);

    _this.setInteger("u_image_lo", SurfaceMaterial.TEXUNIT_IMAGE_LO);

    _this._viewer = viewer;
    _this._tile_texture_cache = viewer.tile_texture_cache;
    _this._layers = viewer.layers;
    _this._dummy_tile_texture = _this._createDummyTileTexture(viewer.glenv);
    _this._image_zbias = 0;
    _this._identity_matrix = GeoMath.setIdentity(GeoMath.createMatrix());
    _this._flake_to_gocs = GeoMath.createMatrixf();
    return _this;
  }
  /**
   * @summary ã·ã§ã¼ãã®åæãåå¾
   *
   * @param {object}  options  ãªãã·ã§ã³æå®
   * @param {boolean} [options.nightMaterial=false]  å¤ç¨ãããªã¢ã«ã®å ´å true
   *
   * @private
   */


  _createClass(SurfaceMaterial, [{
    key: "numDrawings",

    /**
     * @override
     */
    value: function numDrawings() {
      return 1 + this._layers.numDrawingLayers();
    }
    /**
     * @override
     */

  }, {
    key: "setFlakeParameter",
    value: function setFlakeParameter(stage, rflake, mesh, index) {
      this.setCommonParameter(stage, mesh);

      var param = this._getMaterialParamater(rflake, index);

      if (param !== null) {
        var layer = this._layers.getDrawingLayer(index - 1);

        this.setVector4("u_corner_lod", param.corner_lod);
        this.setVector4("u_texcoord_rect_hi", param.image_hi.texcoord_rect);
        this.setVector4("u_texcoord_rect_lo", param.image_lo.texcoord_rect);
        this.setVector2("u_image_param", [param.image_lo.lod, param.image_hi.lod == param.image_lo.lod ? 0 : 1 / (param.image_hi.lod - param.image_lo.lod)]);
        this.setFloat("u_opacity", index == 0 ? 1.0 : layer.opacity);

        if (index > 0 && layer.type === Layer.LayerType.NIGHT) {
          this.setVector3("u_sun_direction", this._viewer.sun_direction);
          mesh.mul_flake_to_gocs(this._identity_matrix, this._flake_to_gocs);
          this.setMatrix("u_obj_to_gocs", this._flake_to_gocs);
        }

        this.bindTexture2D(SurfaceMaterial.TEXUNIT_IMAGE_HI, param.image_hi.texture);
        this.bindTexture2D(SurfaceMaterial.TEXUNIT_IMAGE_LO, param.image_lo.texture);
        return true;
      } else {
        return false;
      }
    }
    /**
     * @summary SurfaceMaterial ã®ãã©ã¡ã¼ã¿ãåå¾
     * @desc
     * <pre>
     * ãªãã¸ã§ã¯ãæ§é 
     * {
     *    // åéã®å°è¡¨è©³ç´°ã¬ãã«
     *    corner_lod: [lod_00, lod_10, lod_01, lod_11],
     *
     *    // é«ã¬ãã«ç»åã®æå ±
     *    image_hi: { lod: (number), texture: (WebGLTexture), texcoord_rect: [s, t, w, h] },
     *
     *    // ä½ã¬ãã«ç»åã®æå ±
     *    image_lo: { lod: (number), texture: (WebGLTexture), texcoord_rect: [s, t, w, h] }
     * }
     * </pre>
     * @private
     */

  }, {
    key: "_getMaterialParamater",
    value: function _getMaterialParamater(rflake, index) {
      var tex_cache = index == 0 ? this._tile_texture_cache : this._layers.getDrawingLayer(index - 1).tile_cache;
      this._image_zbias = tex_cache.getImageZBias();
      var flake = rflake.flake;
      var zg = flake.z;

      if (zg < tex_cache.getImageZMin()) {
        return null;
      }

      var x = flake.x;
      var y = flake.y;
      var zi = Math.ceil(rflake.lod + this._image_zbias);

      if (zg < zi) {
        return null;
      }

      var tiles = tex_cache.findNearestAncestors(zg, x, y, zi);

      if (index >= 1 && tiles[0] === null) {
        return null;
      }

      return {
        corner_lod: [rflake.lod_00, rflake.lod_10, rflake.lod_01, rflake.lod_11],
        image_hi: this._getImageParamater(tiles[0], zg, x, y, zi),
        image_lo: this._getImageParamater(tiles[1], zg, x, y, zi - 1)
      };
    }
    /**
     * @summary ç»åãã©ã¡ã¼ã¿ãåå¾
     * @desc
     * <pre>
     * ãªãã¸ã§ã¯ãæ§é 
     * {
     *    lod:           (number),
     *    texture:       (WebGLTexture),
     *    texcoord_rect: [s, t, w, h]
     * }
     * </pre>
     * @private
     */

  }, {
    key: "_getImageParamater",
    value: function _getImageParamater(tile, zg, x, y, zi) {
      var pow;

      if (tile !== null) {
        pow = Math.pow(2, tile.z - zg);
        return {
          lod: tile.z - this._image_zbias,
          texture: tile.texture,
          texcoord_rect: [x * pow - tile.x, 1 - (y + 1) * pow + tile.y, pow, pow]
        };
      } else {
        pow = Math.pow(2, -zg);
        return {
          lod: -this._image_zbias,
          texture: this._dummy_tile_texture,
          texcoord_rect: [x * pow - Math.floor(pow * (x + 0.5)), 1 - (y + 1) * pow + Math.floor(pow * (y + 0.5)), pow, pow]
        };
      }
    }
    /**
     * @private
     */

  }, {
    key: "_createDummyTileTexture",
    value: function _createDummyTileTexture(glenv) {
      var gl = glenv.context;
      var target = gl.TEXTURE_2D;
      var texture = gl.createTexture();
      var pixels = [128, 128, 128, 255];
      gl.bindTexture(target, texture);
      gl.texImage2D(target, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(pixels));
      gl.bindTexture(target, null);
      return texture;
    }
  }], [{
    key: "_getPreamble",
    value: function _getPreamble(options) {
      var is_night = options.nightMaterial === true;
      var lines = []; // ãã¯ã­ã®å®ç¾©

      if (is_night) {
        lines.push("#define NIGHTIMAGE");
      } // lines ãæå­åã«ãã¦è¿ã


      return lines.join("\n") + "\n\n";
    }
  }]);

  return SurfaceMaterial;
}(FlakeMaterial);

SurfaceMaterial.TEXUNIT_IMAGE_HI = 0; // é«ã¬ãã«ç»åã®ãã¯ã¹ãã£ã¦ããã

SurfaceMaterial.TEXUNIT_IMAGE_LO = 1; // ä½ã¬ãã«ç»åã®ãã¯ã¹ãã£ã¦ããã

var $indexOf$1 = arrayIncludes.indexOf;
var nativeIndexOf = [].indexOf;
var NEGATIVE_ZERO$1 = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var STRICT_METHOD$4 = arrayMethodIsStrict('indexOf');
var USES_TO_LENGTH$7 = arrayMethodUsesToLength('indexOf', {
  ACCESSORS: true,
  1: 0
}); // `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof

_export({
  target: 'Array',
  proto: true,
  forced: NEGATIVE_ZERO$1 || !STRICT_METHOD$4 || !USES_TO_LENGTH$7
}, {
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO$1 // convert -0 to +0
    ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf$1(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var $reduce$1 = arrayReduce.left;
var STRICT_METHOD$5 = arrayMethodIsStrict('reduce');
var USES_TO_LENGTH$8 = arrayMethodUsesToLength('reduce', {
  1: 0
}); // `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce

_export({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD$5 || !USES_TO_LENGTH$8
}, {
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce$1(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-date.now

_export({
  target: 'Date',
  stat: true
}, {
  now: function now() {
    return new Date().getTime();
  }
});

var FAILS_ON_PRIMITIVES = fails(function () {
  objectKeys(1);
}); // `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys

_export({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  keys: function keys(it) {
    return objectKeys(toObject(it));
  }
});

var TO_STRING$1 = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING$1];
var NOT_GENERIC = fails(function () {
  return nativeToString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
}); // FF44- RegExp#toString has a wrong name

var INCORRECT_NAME = nativeToString.name != TO_STRING$1; // `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring

if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING$1, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? regexpFlags.call(R) : rf);
    return '/' + p + '/' + f;
  }, {
    unsafe: true
  });
}

// ãã®ããã«ããçç±ã¯ GeoMath.js ã®æå¾ãåç§

var point_cloud_vs_code = "attribute vec4 a_position;\nattribute vec3 a_color;\n\nuniform mat4 u_obj_to_clip; // ã¢ãã«åº§æ¨ç³»ããã¯ãªããåº§æ¨ç³»ã¸ã®å¤æ\nuniform float u_point_size; // ç¹æç»ãµã¤ãº(è² ã®å ´åã¯[m]ãæ­£ã®å ´åã¯[px])\n\nuniform float u_debug;      // ãããã°ç¨ãã©ã¡ã¼ã¿(æ­£ã®å ´åã®ã¿æå¹)\n\nvarying vec3 v_color;       // è²\n\n\nvoid main(void) {\n    gl_Position = u_obj_to_clip * a_position;\n\n    if ( u_point_size < 0.0 ) {\n        gl_PointSize = -u_point_size / gl_Position.w;\n    }\n    else {\n        gl_PointSize = u_point_size;\n    }\n\n    if ( u_debug < 0.0 ) {\n        v_color = a_color;\n    }\n    else {\n        float alpha = min( 1.0, u_debug );\n        v_color = vec3( alpha, 0.0, 1.0 - alpha );\n    }\n}\n";

var point_cloud_fs_code = "precision highp float;\n\n\nvarying vec3 v_color;       // è²\n\n\nvoid main(void) {\n#if POINT_SHAPE_TYPE == 0 // RECTANGLE\n    gl_FragColor = vec4( v_color,  1.0 );\n\n#elif POINT_SHAPE_TYPE == 1 // CIRCLE\n    if ( length( gl_PointCoord - 0.5 ) > 0.5 ) {\n        discard;\n    }\n    else {\n        gl_FragColor = vec4( v_color,  1.0 );\n    }\n\n#elif POINT_SHAPE_TYPE == 2 // CIRCLE_WITH_BORDER\n    float distance = length( gl_PointCoord - 0.5 );\n    if ( distance > 0.5 ) {\n        discard;\n    }\n    else if ( distance > 0.45 ) {\n        gl_FragColor = vec4( 0, 0, 0, 1.0 );\n    }\n    else {\n        gl_FragColor = vec4( v_color,  1.0 );\n    }\n\n#elif POINT_SHAPE_TYPE == 3 // GRADIENT_CIRCLE\n    vec2 p = 2.0 * gl_PointCoord - 1.0;\n    if ( length(p) > 1.0 ) {\n        discard;\n    }\n    else {\n        gl_FragColor = vec4( v_color * (1.0 - 0.3 * tan((p.x + p.y)*0.7853981633)),  1.0 );\n    }\n\n#endif\n}\n";

var point_cloud_debug_wire_vs_code = "attribute vec4 a_position;\n\nuniform mat4 u_obj_to_clip;\n\nvoid main(void) {\n    gl_Position = u_obj_to_clip * a_position;\n}\n";

var point_cloud_debug_wire_fs_code = "precision highp float;\n\nuniform vec3 u_color;\n\nvoid main(void) {\n    gl_FragColor = vec4(u_color, 1.0);\n}\n";

var point_cloud_debug_face_vs_code = "attribute vec4 a_position;\n\nuniform mat4 u_obj_to_clip;\nvarying vec4 pos;\n\nvoid main(void) {\n    pos = gl_Position;\n    gl_Position = u_obj_to_clip * a_position;\n}\n";

var point_cloud_debug_face_fs_code = "precision highp float;\n\nuniform vec4 u_color;\nvarying vec4 pos;\n\nvoid main(void) {\n    // gl_FragCoord.x, gl_FragCoord.y\n    if (mod(gl_FragCoord.x, 3.0) < 1.0 && mod(gl_FragCoord.y, 3.0) < 1.0) {\n        gl_FragColor = vec4(u_color.x, u_color.y, u_color.z, 1.0);\n    }\n    else {\n        discard;\n    }\n}\n";

/**
 * @summary ç¹ç¾¤ãããªã¢ã«
 * @memberof mapray.RenderStage
 * @extends mapray.RenderStage.Material
 * @private
 */

var PointCloudMaterial =
/*#__PURE__*/
function (_Material) {
  _inherits(PointCloudMaterial, _Material);

  /**
   * @param {mapray.Viewer} viewer  ææèã§ãã Viewer
   */
  function PointCloudMaterial(viewer) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, PointCloudMaterial);

    var preamble = PointCloudMaterial._getPreamble(options);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PointCloudMaterial).call(this, viewer.glenv, preamble + point_cloud_vs_code, preamble + point_cloud_fs_code));

    _this.bindProgram();

    _this.setFloat("u_point_size", 10);

    _this.setFloat("u_debug", -1.0);

    _this._local_to_clip = GeoMath.createMatrixf();
    return _this;
  }
  /**
   * @summary ç¹ã®å¤§ãããè¨­å®
   * @param {number} val è¨­å®ããå¤
   */


  _createClass(PointCloudMaterial, [{
    key: "setPointSize",
    value: function setPointSize(val) {
      this.setFloat("u_point_size", val);
    }
    /**
     * @summary ãããã°å¤ãè¨­å®
     * @param {number} val è¨­å®ããå¤
     */

  }, {
    key: "setDebug",
    value: function setDebug(val) {
      this.setFloat("u_debug", val);
    }
    /**
     * @summary æç»ä½ç½®ãè¨­å®
     * @param {number} val è¨­å®ããå¤
     */

  }, {
    key: "setDebugBoundsParameter",
    value: function setDebugBoundsParameter(stage, center) {
      mul_local_to_gocs(stage._gocs_to_clip, center, this._local_to_clip);
      this.setMatrix("u_obj_to_clip", this._local_to_clip);
      return true;
    }
    /**
     * @summary ã·ã§ã¼ãã®åæãåå¾
     * @private
     */

  }], [{
    key: "_getPreamble",
    value: function _getPreamble(options) {
      var lines = [];
      var point_shape_type = options.point_shape_type || PointCloud.PointShapeType.CIRCLE;
      lines.push("#define POINT_SHAPE_TYPE " + point_shape_type.shader_code); // lines ãæå­åã«ãã¦è¿ã

      return lines.join("\n") + "\n\n";
    }
  }]);

  return PointCloudMaterial;
}(Material);

var mul_local_to_gocs = function mul_local_to_gocs(mat, center, dst) {
  var m00 = mat[0],
      m01 = mat[4],
      m02 = mat[8],
      m03 = mat[12],
      m10 = mat[1],
      m11 = mat[5],
      m12 = mat[9],
      m13 = mat[13],
      m20 = mat[2],
      m21 = mat[6],
      m22 = mat[10],
      m23 = mat[14],
      m30 = mat[3],
      m31 = mat[7],
      m32 = mat[11],
      m33 = mat[15];
  var t03 = center[0],
      t13 = center[1],
      t23 = center[2];
  dst[0] = m00;
  dst[1] = m10;
  dst[2] = m20;
  dst[3] = m30;
  dst[4] = m01;
  dst[5] = m11;
  dst[6] = m21;
  dst[7] = m31;
  dst[8] = m02;
  dst[9] = m12;
  dst[10] = m22;
  dst[11] = m32;
  dst[12] = m00 * t03 + m01 * t13 + m02 * t23 + m03;
  dst[13] = m10 * t03 + m11 * t13 + m12 * t23 + m13;
  dst[14] = m20 * t03 + m21 * t13 + m22 * t23 + m23;
  dst[15] = m30 * t03 + m31 * t13 + m32 * t23 + m33;
  return dst;
};
/**
 * @summary ãããã°ç¨ç¹ç¾¤ãããªã¢ã«(ã¯ã¤ã¤ã¼ãã¬ã¼ã )
 * @memberof mapray.RenderStage
 * @extends mapray.RenderStage.Material
 * @private
 */


var PointCloudDebugWireMaterial =
/*#__PURE__*/
function (_Material2) {
  _inherits(PointCloudDebugWireMaterial, _Material2);

  /**
   * @param {mapray.Viewer} viewer  ææèã§ãã Viewer
   */
  function PointCloudDebugWireMaterial(viewer) {
    var _this2;

    _classCallCheck(this, PointCloudDebugWireMaterial);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(PointCloudDebugWireMaterial).call(this, viewer.glenv, point_cloud_debug_wire_vs_code, point_cloud_debug_wire_fs_code));

    _this2.bindProgram();

    _this2._color = GeoMath.createVector3([0.0, 0.2, 0.4]);

    _this2.setVector3("u_color", _this2._color);

    _this2._local_to_clip = GeoMath.createMatrixf();
    return _this2;
  }

  _createClass(PointCloudDebugWireMaterial, [{
    key: "setDebugBoundsParameter",
    value: function setDebugBoundsParameter(stage, center, color) {
      mul_local_to_gocs(stage._gocs_to_clip, center, this._local_to_clip);
      this.setMatrix("u_obj_to_clip", this._local_to_clip);

      if (color) {
        this._color[0] = color[0];
        this._color[1] = color[1];
        this._color[2] = color[2];
      }

      this.setVector3("u_color", this._color);
      return true;
    }
  }]);

  return PointCloudDebugWireMaterial;
}(Material);
/**
 * @summary ãããã°ç¨ç¹ç¾¤ãããªã¢ã«(ãµã¼ãã§ã¹)
 * @memberof mapray.RenderStage
 * @extends mapray.RenderStage.Material
 * @private
 */


var PointCloudDebugFaceMaterial =
/*#__PURE__*/
function (_Material3) {
  _inherits(PointCloudDebugFaceMaterial, _Material3);

  /**
   * @param {mapray.Viewer} viewer  ææèã§ãã Viewer
   */
  function PointCloudDebugFaceMaterial(viewer) {
    var _this3;

    _classCallCheck(this, PointCloudDebugFaceMaterial);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(PointCloudDebugFaceMaterial).call(this, viewer.glenv, point_cloud_debug_face_vs_code, point_cloud_debug_face_fs_code));

    _this3.bindProgram();

    _this3._color = GeoMath.createVector4([0.3, 0.9, 1.0, 0.5]);

    _this3.setVector4("u_color", _this3._color);

    _this3._local_to_clip = GeoMath.createMatrixf();
    return _this3;
  }

  _createClass(PointCloudDebugFaceMaterial, [{
    key: "setDebugBoundsParameter",
    value: function setDebugBoundsParameter(stage, center, color) {
      mul_local_to_gocs(stage._gocs_to_clip, center, this._local_to_clip);
      this.setMatrix("u_obj_to_clip", this._local_to_clip);

      if (color) {
        this._color[0] = color[0];
        this._color[1] = color[1];
        this._color[2] = color[2];
        this._color[3] = color[3] || 0.0;
      }

      this.setVector4("u_color", this._color);
      return true;
    }
  }]);

  return PointCloudDebugFaceMaterial;
}(Material);

/**
 * @summary ç¹ç¾¤ãã¼ã¿ãè¡¨ç¾ããã¯ã©ã¹
 * @example
 * <caption>ã¤ã³ã¹ã¿ã³ã¹ã®çæã¯ä¸è¨ã®ããã«è¡ãã</caption>
 * const provider = new {@link mapray.RawPointCloudProvider}({
 *     resource: {
 *         prefix: "https://..."
 *     }
 * });
 * const point_cloud = viewer.point_cloud_collection.add( provider );
 * point_cloud.setPointShape( {@link mapray.PointCloud.PointShapeType}.GRADIENT_CIRCLE );
 *
 * @see mapray.PointCloudProvider
 * @see mapray.PointCloudCollection
 * @memberof mapray
 */

var PointCloud =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Scene} scene æå±ããã·ã¼ã³
   * @param {mapray.PointCloudProvider} provider ãã­ãã¤ã
   */
  function PointCloud(scene, provider) {
    _classCallCheck(this, PointCloud);

    this._glenv = scene.glenv;
    this._scene = scene;
    this._provider = provider;
    this._root = Box.createRoot(this); // properties

    this._points_per_pixel = 0.7;
    this._point_shape = PointCloud.PointShapeType.CIRCLE;
    this._point_size_type = PointCloud.PointSizeType.FLEXIBLE;
    this._point_size = 1;
    this._point_size_limit = 10; // hidden properties

    this._dispersion = true;
    this._debug_shader = false;
    this._debug_render_box = false;
    this._debug_render_ellipsoid = false;
    this._debug_render_axis = false;
    this._debug_render_section = false;

    this._checkMaterials();

    PointCloud._instances.push(this);
  }

  _createClass(PointCloud, [{
    key: "init",

    /**
     * @summary åæå
     * mapray.PointCloudBoxCollectorã¸è¿½å æã«èªåçã«å¼ã°ããã
     * @private
     */
    value: function () {
      var _init = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._provider.init();

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
    /**
     * @summary ç ´æ£
     * mapray.PointCloudBoxCollectorããåé¤æã«èªåçã«å¼ã°ããã
     * @private
     */

  }, {
    key: "destroy",
    value: function () {
      var _destroy = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var index;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this._provider) {
                  _context2.next = 3;
                  break;
                }

                _context2.next = 3;
                return this._provider.destroy();

              case 3:
                if (!this._root) {
                  _context2.next = 7;
                  break;
                }

                _context2.next = 6;
                return this._root.dispose(null);

              case 6:
                this._root = null;

              case 7:
                index = PointCloud._instances.indexOf(this);

                if (index !== -1) {
                  PointCloud._instances.splice(index, 1);
                }

                this._provider = null;

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function destroy() {
        return _destroy.apply(this, arguments);
      }

      return destroy;
    }()
    /**
     * @summary ãã­ãã¤ã
     * @type {mapray.PointCloudProvider}
     */

  }, {
    key: "getPointsPerPixel",
    // Properties

    /**
     * @summary ç¹ç¾¤Boxèª­ã¿è¾¼ã¿ãè¡ãéã®è§£ååº¦[points/pixel]
     * @return {number}
     */
    value: function getPointsPerPixel() {
      return this._points_per_pixel;
    }
    /**
     * @summary ç¹ç¾¤Boxèª­ã¿è¾¼ã¿ãè¡ãéã®è§£ååº¦[points/pixel]ãè¨­å®
     * @param {number} val è¨­å®ããå¤
     */

  }, {
    key: "setPointsPerPixel",
    value: function setPointsPerPixel(val) {
      console.assert(val <= 1);
      this._points_per_pixel = val;
    }
    /**
     * @summary ç¹ãæç»ããéã®å½¢ç¶
     * @return {mapray.PointCloud.PointShapeType}
     */

  }, {
    key: "getPointShape",
    value: function getPointShape() {
      return this._point_shape;
    }
    /**
     * @summary ç¹ãæç»ããéã®å½¢ç¶ãè¨­å®
     * @param {mapray.PointCloud.PointShapeType} val è¨­å®ããå¤
     */

  }, {
    key: "setPointShape",
    value: function setPointShape(val) {
      this._point_shape = val;
    }
    /**
     * @summary ç¹ãæç»ããéã®ãµã¤ãºã®æå®æ¹æ³
     * @return {mapray.PointCloud.PointSizeType}
     */

  }, {
    key: "getPointSizeType",
    value: function getPointSizeType() {
      return this._point_size_type;
    }
    /**
     * @summary ç¹ãæç»ããéã®ãµã¤ãºã®æå®æ¹æ³ãè¨­å®
     * @param {mapray.PointCloud.PointSizeType} val è¨­å®ããå¤
     */

  }, {
    key: "setPointSizeType",
    value: function setPointSizeType(val) {
      this._point_size_type = val;
    }
    /**
     * @summary ç¹ãæç»ããéã®ãµã¤ãº
     * point_size_typeã«ããåä½ãç°ãªã
     * @see mapray.PointCloud#getPointSizeType
     * @return {number}
     */

  }, {
    key: "getPointSize",
    value: function getPointSize() {
      return this._point_size;
    }
    /**
     * @summary ç¹ãæç»ããéã®ãµã¤ãºãè¨­å®ã
     * {@link mapray.PointCloud#setPointSizeType}ã«ããæå®ãããå¤ã«ãã£ã¦è§£éãããåä½ãç°ãªãã
     * @param {number} val è¨­å®ããå¤
     */

  }, {
    key: "setPointSize",
    value: function setPointSize(val) {
      console.assert(val > 0);
      this._point_size = val;
    }
    /**
     * @summary ç¹ãæç»ããéã®æå¤§ãã¯ã»ã«ãµã¤ãº
     * @return {number}
     */

  }, {
    key: "getPointSizeLimit",
    value: function getPointSizeLimit() {
      return this._point_size_limit;
    }
    /**
     * @summary ç¹ãæç»ããéã®æå¤§ãã¯ã»ã«ãµã¤ãºãè¨­å®
     * @param {number} val è¨­å®ããå¤
     */

  }, {
    key: "setPointSizeLimit",
    value: function setPointSizeLimit(val) {
      console.assert(val > 0);
      this._point_size_limit = val;
    } // hidden properties

    /**
     * @private
     */

  }, {
    key: "getDispersion",
    value: function getDispersion() {
      return this._dispersion;
    }
    /**
     * @private
     */

  }, {
    key: "setDispersion",
    value: function setDispersion(val) {
      this._dispersion = val;
    }
    /**
     * @private
     */

  }, {
    key: "getDebugShader",
    value: function getDebugShader() {
      return this._debug_shader;
    }
    /**
     * @private
     */

  }, {
    key: "setDebugShader",
    value: function setDebugShader(val) {
      this._debug_shader = val;
    }
    /**
     * @private
     */

  }, {
    key: "setDebugRenderBox",
    value: function setDebugRenderBox(val) {
      this._debug_render_box = val;

      this._updateDebugMesh();
    }
    /**
     * @private
     */

  }, {
    key: "setDebugRenderEllipsoid",
    value: function setDebugRenderEllipsoid(val) {
      this._debug_render_ellipsoid = val;

      this._updateDebugMesh();
    }
    /**
     * @private
     */

  }, {
    key: "setDebugRenderAxis",
    value: function setDebugRenderAxis(val) {
      this._debug_render_axis = val;

      this._updateDebugMesh();
    }
    /**
     * @private
     */

  }, {
    key: "setDebugRenderSection",
    value: function setDebugRenderSection(val) {
      this._debug_render_section = val;

      this._updateDebugMesh();
    }
    /**
     * @private
     */

  }, {
    key: "_updateDebugMesh",
    value: function _updateDebugMesh() {
      if (this._root) {
        this._root._updateDebugMeshes();
      }
    }
    /**
     * @summary Traverseçµæã®çµ±è¨æå ±ãåå¾ã
     * ãªã¯ã¨ã¹ãã­ã¥ã¼ã«ç»é²ãã{@link mapray.RenderStage}ãå¦çãå®äºããã®ãå¾ã¤ã
     * @return {Promise}
     * @private
     */

  }, {
    key: "getURL",

    /**
     * @summary æå®ããã level, x, y, z ã®URLãçæãã¾ã
     * @param {number} level
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @return {string}
     * @private
     */
    value: function getURL(level, x, y, z) {
      return this._urlGenerator(level, x, y, z);
    }
    /**
     * @private
     */

  }, {
    key: "_checkMaterials",
    value: function _checkMaterials() {
      var viewer = this._scene.viewer;
      var render_cache = viewer._render_cache || (viewer._render_cache = {});

      if (!render_cache.point_cloud_materials) {
        render_cache.point_cloud_materials = Object.keys(PointShapeType).reduce(function (map, key) {
          var point_shape_type = PointShapeType[key];
          map[point_shape_type.id] = new PointCloudMaterial(viewer, {
            point_shape_type: point_shape_type
          });
          return map;
        }, {});
      }

      if (!render_cache.point_cloud_debug_wire_material) {
        render_cache.point_cloud_debug_wire_material = new PointCloudDebugWireMaterial(viewer);
      }

      if (!render_cache.point_cloud_debug_face_material) {
        render_cache.point_cloud_debug_face_material = new PointCloudDebugFaceMaterial(viewer);
      }
    }
    /**
     * @private
     */

  }, {
    key: "_getMaterial",
    value: function _getMaterial(point_shape) {
      return this._scene.viewer._render_cache.point_cloud_materials[point_shape.id];
    }
    /**
     * @private
     */

  }, {
    key: "provider",
    get: function get() {
      return this._provider;
    }
    /**
     * @summary ã«ã¼ãBox
     * @type {Box}
     * @private
     */

  }, {
    key: "root",
    get: function get() {
      return this._root;
    }
  }], [{
    key: "requestTraverseSummary",
    value: function () {
      var _requestTraverseSummary = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", new Promise(function (onSuccess) {
                  var notifier = function notifier(statistics) {
                    onSuccess(statistics);
                    var index = PointCloud.getTraverseDataRequestQueue().indexOf(notifier);
                    if (index !== -1) PointCloud.getTraverseDataRequestQueue().splice(index, 1);
                  };

                  PointCloud.getTraverseDataRequestQueue().push(notifier);
                }));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function requestTraverseSummary() {
        return _requestTraverseSummary.apply(this, arguments);
      }

      return requestTraverseSummary;
    }()
    /**
     * @summary Traverseçµæåå¾ç¨ã®ãªã¯ã¨ã¹ãã­ã¥ã¼ãåå¾
     * @return {Array}
     * @private
     */

  }, {
    key: "getTraverseDataRequestQueue",
    value: function getTraverseDataRequestQueue() {
      return PointCloud._traverseDataRequestQueue || (PointCloud._traverseDataRequestQueue = []);
    }
  }, {
    key: "setStatisticsHandler",
    value: function setStatisticsHandler(statistics_handler) {
      if (statistics_handler) {
        PointCloud._statistics = {
          statistics_obj: new Statistics(),
          statistics_handler: statistics_handler
        };
      }
    }
    /**
     * @private
     */

  }, {
    key: "getStatistics",
    value: function getStatistics() {
      return PointCloud._statistics;
    }
    /**
     * @private
     */

  }, {
    key: "getStatisticsHandler",
    value: function getStatisticsHandler() {
      return PointCloud._statistics_handler;
    }
  }, {
    key: "PointShapeType",
    get: function get() {
      return PointShapeType;
    }
  }, {
    key: "PointSizeType",
    get: function get() {
      return PointSizeType;
    }
  }]);

  return PointCloud;
}();

PointCloud._instances = [];
/**
 * @private
 */

var Statistics =
/*#__PURE__*/
function () {
  function Statistics() {
    _classCallCheck(this, Statistics);

    this._now = performance ? function () {
      return performance.now();
    } : function () {
      return Date.now();
    };
    this.clear();
  }

  _createClass(Statistics, [{
    key: "start",
    value: function start() {
      this._start_time = this._now();
    }
  }, {
    key: "doneTraverse",
    value: function doneTraverse() {
      this._done_traverse_time = this._now();
      this.traverse_time += this._done_traverse_time - this._start_time;
    }
  }, {
    key: "done",
    value: function done() {
      this._done_time = this._now();
      this.render_time += this._done_time - this._done_traverse_time;
      this.total_time += this._done_time - this._start_time;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.render_point_count = 0;
      this.total_point_count = 0;
      this.render_boxes = 0;
      this.total_boxes = 0;
      this.loading_boxes = 0;
      this.created_boxes = 0;
      this.disposed_boxes = 0;
      this.total_time = 0.0;
      this.traverse_time = 0.0;
      this.render_time = 0.0;
    }
  }]);

  return Statistics;
}();
/**
 * @summary ç¹æç»ã®ç¨®é¡
 * @constant
 * @enum {object}
 * @memberof mapray.PointCloud
 */


var PointShapeType = {
  /**
   * ç©å½¢
   */
  RECTANGLE: {
    id: "RECTANGLE",
    shader_code: 0
  },

  /**
   * å
   */
  CIRCLE: {
    id: "CIRCLE",
    shader_code: 1
  },

  /**
   * å¢çç·ä»ãã®å
   */
  CIRCLE_WITH_BORDER: {
    id: "CIRCLE_WITH_BORDER",
    shader_code: 2
  },

  /**
   * ã°ã©ãã¼ã·ã§ã³ã§å¡ãæ½°ããå
   */
  GRADIENT_CIRCLE: {
    id: "GRADIENT_CIRCLE",
    shader_code: 3
  }
};
/**
 * @summary ç¹æç»ã®ãµã¤ãºæå®æ¹æ³ã®ç¨®é¡
 * @enum {object}
 * @constant
 * @memberof mapray.PointCloud
 */

var PointSizeType = {
  /**
   * setPointSize()ã«ããæå®ãããå¤ããã¯ã»ã«ã¨ãã¦è§£éãã
   */
  PIXEL: {
    id: "PIXEL"
  },

  /**
   * setPointSize()ã«ããæå®ãããå¤ãmmã¨ãã¦è§£éãã
   */
  MILLIMETERS: {
    id: "MILLIMETERS"
  },

  /**
   * setPointSize()ã«ããæå®ãããå¤ãåç§ãããè¡¨ç¤ºä½ç½®ã«å¿ãã¦é©åãªãµã¤ãºãèªåçã«æå®ããã
   */
  FLEXIBLE: {
    id: "FLEXIBLE"
  }
};
/**
 * @summary ç¹ç¾¤ããªã¼ãæ§æãããã¼ãã
 * ã«ã¼ãè¦ç´ (level === 0) ã¯ãBox.createRoot()ãç¨ãã¦ä½æããã
 * @memberof mapray.PointCloud
 * @private
 */

var Box =
/*#__PURE__*/
function () {
  /**
   * @param {Box|null} parent è¦ªBox(level === 0ã®å ´åã¯null)
   * @param {number} level ã¬ãã«
   * @param {number} x x
   * @param {number} y y
   * @param {number} z z
   * @private
   */
  function Box(parent, level, x, y, z) {
    _classCallCheck(this, Box);

    /**
     * @summary è¦ªBox
     * @type {Box}
     */
    this._parent = parent;
    /**
     * @summary æå±ããPointCloudã
     * ã«ã¼ãè¦ç´ ã®å ´åã¯ Box.createRoot() ã§è¨­å®ãããã
     * @type {mapray.PointCloud}
     */

    this._owner = parent ? parent._owner : null;
    /**
     * @summary ã¬ãã«
     * @type {number}
     */

    this.level = level;
    /**
     * @summary x
     * @type {number}
     */

    this.x = x;
    /**
     * @summary y
     * @type {number}
     */

    this.y = y;
    /**
     * @summary z
     * @type {number}
     */

    this.z = z;
    /*
    2æ¬¡å(X,Y)ã¾ã§ãä¸è¨ã«å³ç¤ºãããZè»¸ã«ã¤ãã¦ãåæ§ã
    ^ Y
    |
    +-------------+-------------M
    | cell (0, 1) | cell (1, 1) |
    |             |             |   c: gocs_center [GOCS]
    |             |             |   m: gocs_min [GOCS]
    |             |             |   M: gocs_max [GOCS]
    |             |             |
    +-------------c-------------+
    | cell (0, 0) | cell (1, 0) |
    |             |             |
    |             |             |
    |             |             |
    |             |             |
    m-------------+-------------+ --> X
                  |<--size[m]-->|
    */

    /**
     * @summary Boxä¸è¾ºã®ååã®é·ã
     * @type {number}
     * @private
     */

    var size = this.size = level === 0 ? 2147483648 : // 2^31
    level < 31 ? 1 << 31 - level : Math.pow(0.5, level - 31);
    /**
     * @summary è»¸æ¹åã«æå½±ããéã®é¢ç©
     * @type {number}
     * @private
     */

    this.proj_area = 4.0 * this.size * this.size;
    /**
     * @summary GOCSåº§æ¨ç³»ã§ã®Boxã®ä¸­å¿ä½ç½®
     * @type {mapray.Vector3}
     * @private
     */

    this.gocs_center = GeoMath.createVector3([MIN_INT + (2 * x + 1) * size, MIN_INT + (2 * y + 1) * size, MIN_INT + (2 * z + 1) * size]);
    /**
     * @summary GOCSåº§æ¨ç³»ã§ã®Boxã®æå°ä½ç½®
     * @type {mapray.Vector3}
     * @private
     */

    this.gocs_min = GeoMath.createVector3([this.gocs_center[0] - size, this.gocs_center[1] - size, this.gocs_center[2] - size]);
    /**
     * @summary GOCSåº§æ¨ç³»ã§ã®Boxã®æå¤§ä½ç½®
     * @type {mapray.Vector3}
     * @private
     */

    this.gocs_max = GeoMath.createVector3([this.gocs_center[0] + size, this.gocs_center[1] + size, this.gocs_center[2] + size]);
    /**
     * @type {Box.Status}
     * @private
     */

    this._status = Box.Status.NOT_LOADED; // (this._status === Box.Status.LOADED) ã«ããã¦æå¹ãªå¤

    /**
     * @summary å­Boxãã»ã«ã«é¢ããæå ±
     * @type {object}
     * @private
     */

    this._metaInfo = null;
    /**
     * @summary å­Boxã
     * <code>(u, v, w)</code>ã®ã¤ã³ããã¯ã¹ã¯ <code>(u | v << 1 | w << 2)</code> ã«ãã£ã¦ç®åºãããã
     * @type {mapray.Box[]}
     * @private
     */

    this._children = [null, null, null, null, null, null, null, null];
    /**
     * @type {mapray.Vector3}
     * @private
     */

    this.average = null;
    /**
     * @type {mapray.Vector3}
     * @private
     */

    this.eigenVector = null;
    /**
     * @type {mapray.Vector3}
     * @private
     */

    this.eigenVectorLength = null;
    /**
     * @private
     */

    this._vertex_buffer = null;
    /**
     * @private
     */

    this._vertex_length = null;
    /**
     * @private
     */

    this._vertex_attribs = null;
    /**
     * @private
     */

    this.debug1 = null;

    if (this._owner) {
      this._updateDebugMesh();
    }
  }
  /**
   * @private
   */


  _createClass(Box, [{
    key: "_updateDebugMeshes",
    value: function _updateDebugMeshes() {
      this._updateDebugMesh();

      for (var i = 0; i < this._children.length; i++) {
        if (this._children[i]) {
          this._children[i]._updateDebugMeshes();
        }
      }
    }
  }, {
    key: "_updateDebugMesh",
    value: function _updateDebugMesh() {
      var vertices = [];
      var indices = [];
      var tindices = [];

      if (this._owner._debug_render_box) {
        /*
        *         4----------5
        *       .Â´:        .Â´|
        *     .Â´  :      .Â´  |
        *    0----------1    |
        *    |    6 - - |----7
        *    |  .Â´      |  .Â´ 
        *    |.Â´        |.Â´   
        *    2----------3     
        */
        for (var i = 0; i < Box.CHILDREN_INDICES.length; i++) {
          vertices.push(this.size * (2 * Box.CHILDREN_INDICES[i][2] - 1), this.size * (2 * Box.CHILDREN_INDICES[i][1] - 1), this.size * (2 * Box.CHILDREN_INDICES[i][0] - 1));
        }

        indices.push(0, 1, 1, 3, 3, 2, 2, 0, 4, 5, 5, 7, 7, 6, 6, 4, 0, 4, 1, 5, 3, 7, 2, 6); //*

        tindices.push(0, 2, 1, 1, 2, 3, 4, 5, 6, 7, 6, 5, 0, 1, 4, 1, 5, 4, 1, 3, 5, 3, 7, 5, 3, 6, 7, 3, 2, 6, 6, 2, 4, 2, 0, 4); //*/
      }

      if (this.average && !isNaN(this.eigenVector[0][0])) {
        if (this._owner._debug_render_axis) {
          // Render Normal
          var offset = vertices.length / 3;

          for (var _i = 0; _i < 3; _i++) {
            var len = Math.max(0.2, this.eigenVectorLength[_i]);
            var ev = this.eigenVector[_i];

            for (var j = 0; j < 3; j++) {
              vertices.push(this.average[j] - len * ev[j]);
            }

            for (var _j = 0; _j < 3; _j++) {
              vertices.push(this.average[_j] + len * ev[_j]);
            }

            indices.push(offset++, offset++);
          }
        }

        if (this._owner._debug_render_section) {
          if (this.level > 20 && this.getPointsLength() > 5000 && this.eigenVectorLength[0] < this.size * 0.2) {
            // = 10% = (2 * s) / 10
            this._putSectionShapePoints(vertices, indices, tindices); // Render Cross Section

          }
        }

        if (this._owner._debug_render_ellipsoid) {
          this._putVariancePoints(vertices, indices, tindices); // Render Normal Ring

        }
      }

      var meshes = [];

      if (indices.length > 0) {
        var mesh_data = {
          vtype: [{
            name: "a_position",
            size: 3
          }],
          ptype: "lines",
          vertices: vertices,
          indices: indices
        };
        meshes.push(new Mesh(this._owner._glenv, mesh_data));
      }

      if (tindices.length > 0) {
        var _mesh_data = {
          vtype: [{
            name: "a_position",
            size: 3
          }],
          ptype: "triangles",
          vertices: vertices,
          indices: tindices
        };
        meshes.push(new Mesh(this._owner._glenv, _mesh_data));
      }

      this.debugMesh = meshes;
    }
    /**
     * @private
     */

  }, {
    key: "_putVariancePoints",
    value: function _putVariancePoints(vertices, indices, tindices) {
      var _this = this;

      var offset = vertices.length / 3;

      var _this$eigenVector = _slicedToArray(this.eigenVector, 3),
          e1 = _this$eigenVector[0],
          e2 = _this$eigenVector[1],
          e3 = _this$eigenVector[2];

      var _this$eigenVectorLeng = _slicedToArray(this.eigenVectorLength, 3),
          e1l = _this$eigenVectorLeng[0],
          e2l = _this$eigenVectorLeng[1],
          e3l = _this$eigenVectorLeng[2];

      var G = 6;
      var N = 12;

      var cache = PointCloud._variance_points_cache || function () {
        var c = {
          cos_ro: [],
          sin_ro: [],
          cos_th: [],
          sin_th: []
        };

        for (var j = 0; j <= G; ++j) {
          var ro = Math.PI * j / G;
          c.cos_ro[j] = Math.cos(ro);
          c.sin_ro[j] = Math.sin(ro);
        }

        for (var i = 0; i <= N; ++i) {
          var th = 2 * Math.PI * i / N;
          c.cos_th[i] = Math.cos(th);
          c.sin_th[i] = Math.sin(th);
        }

        return PointCloud._variance_points_cache = c;
      }();

      var putPoint = function putPoint(ro, th, vs) {
        var cos_ro = cache.cos_ro[ro];
        var sin_ro = cache.sin_ro[ro];
        var cos_th = cache.cos_th[th];
        var sin_th = cache.sin_th[th];
        vs.push(_this.average[0] + sin_ro * (e2l * cos_th * e2[0] + e3l * sin_th * e3[0]) + e1l * cos_ro * e1[0], _this.average[1] + sin_ro * (e2l * cos_th * e2[1] + e3l * sin_th * e3[1]) + e1l * cos_ro * e1[1], _this.average[2] + sin_ro * (e2l * cos_th * e2[2] + e3l * sin_th * e3[2]) + e1l * cos_ro * e1[2]);
      };

      for (var j = 0; j <= G; ++j) {
        for (var i = 0; i <= N; ++i) {
          putPoint(j, i, vertices);
        }
      }

      for (var _j2 = 0; _j2 < G; ++_j2) {
        for (var _i2 = 0; _i2 < N; ++_i2) {
          var p = offset + _j2 * (N + 1) + _i2;
          indices.push(p, p + 1, p, p + N + 1);
          tindices.push(p, p + 1, p + N + 1, p + N + 1, p + 1, p + N + 2);
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "_putSectionShapePoints",
    value: function _putSectionShapePoints(vertices, indices, tindices) {
      var offset = vertices.length / 3;
      var a = this.average;
      var e = this.eigenVector[0];
      var s = this.size;
      var l = Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
      var ue = [e[0] / l, e[1] / l, e[2] / l];
      var ps = [];
      /*
        Compute Intersection(c) of Plane(a, ue) and Line(p, v)
              \             a: average point
               \   ue      ue: eigenVector (normal vector)
                a-Â¯Â¯        p: point
                 \          v: vector
        p---> . . c         c = p + alpha v
            v      \       
                    \               (a - p) ue 
        |-------->|  \     alpha = ------------
          alpha v     \                v ue    
      */

      var q = [];

      for (var i = 0; i < 2; ++i) {
        for (var j = 0; j < 2; ++j) {
          q.push({
            p: [i > 0 ? s : -s, j > 0 ? s : -s, 0],
            v: [0, 0, s]
          }, {
            p: [j > 0 ? s : -s, 0, i > 0 ? s : -s],
            v: [0, s, 0]
          }, {
            p: [0, i > 0 ? s : -s, j > 0 ? s : -s],
            v: [s, 0, 0]
          });
        }
      }

      var n, t;

      for (var _i3 = 0; _i3 < q.length; _i3++) {
        var p = q[_i3].p;
        var v = q[_i3].v;
        var alpha = ((a[0] - p[0]) * ue[0] + (a[1] - p[1]) * ue[1] + (a[2] - p[2]) * ue[2]) / (v[0] * ue[0] + v[1] * ue[1] + v[2] * ue[2]);

        if (Math.abs(alpha) <= 1.0) {
          var c = [p[0] + alpha * v[0], p[1] + alpha * v[1], p[2] + alpha * v[2]];
          var lp = [c[0] - a[0], c[1] - a[1], c[2] - a[2]];
          var angle = void 0;

          if (n) {
            angle = Math.atan2(t[0] * lp[0] + t[1] * lp[1] + t[2] * lp[2], n[0] * lp[0] + n[1] * lp[1] + n[2] * lp[2]);
          } else {
            angle = 0;
            t = [ue[1] * lp[2] - ue[2] * lp[1], ue[2] * lp[0] - ue[0] * lp[2], ue[0] * lp[1] - ue[1] * lp[0]];
            n = [t[1] * ue[2] - t[2] * ue[1], t[2] * ue[0] - t[0] * ue[2], t[0] * ue[1] - t[1] * ue[0]];
          }

          ps.push([].concat(c, [angle, lp[0], lp[1], lp[2], n[0] * lp[0] + n[1] * lp[1] + n[2] * lp[2], t[0] * lp[0] + t[1] * lp[1] + t[2] * lp[2]]));
        }
      }

      ps.sort(function (a, b) {
        return a[3] - b[3];
      });

      for (var _i4 = 0; _i4 < ps.length; ++_i4) {
        vertices.push(ps[_i4][0], ps[_i4][1], ps[_i4][2]);
        indices.push(offset + _i4);
        if (_i4 == ps.length - 1) indices.push(offset);else indices.push(offset + _i4 + 1);

        if (tindices) {
          tindices.push(offset, offset + _i4);
          if (_i4 == ps.length - 1) tindices.push(offset);else tindices.push(offset + _i4 + 1);
        }
      }
    }
    /**
     * @summary èª­ã¿è¾¼ã¿ã¹ãã¼ã¿ã¹
     * @type {mapray.PointCloud.Box.Status}
     */

  }, {
    key: "getChildInfo",

    /**
     * @summary å­Boxã®æå ±ãåå¾
     * 
     * @param {number} index çªå·
     * @return {Box}
     */
    value: function getChildInfo(index) {
      if (!this._metaInfo) return null;
      return this._metaInfo.children[index];
    }
    /**
     * @summary Boxé åã8åå²ããé åãã¨ã«ç¹ãå­å¨ããããèª¿ã¹ãã
     * 
     * @param {number} index å­Boxã¨åæ§ã®é çª
     * @return {boolean} ç¹ãå­å¨ããå ´åã« true ã¨ãªãã
     */

  }, {
    key: "cellPointsAvailable",
    value: function cellPointsAvailable(index) {
      return this._metaInfo && (index === 0 ? this._metaInfo.indices[index] > 0 : this._metaInfo.indices[index] > this._metaInfo.indices[index - 1]);
    }
    /**
     * @summary Boxã«å«ã¾ããç¹ã®æ°
     * 
     * @return {number}
     */

  }, {
    key: "getPointsLength",
    value: function getPointsLength() {
      return this._metaInfo ? this._metaInfo.indices[7] : 0;
    }
    /**
     * @summary å­Boxã®çªå·ãè¿ãã¾ãã
     * @param {Box} child å­Box
     * @return {number}
     */

  }, {
    key: "indexOf",
    value: function indexOf(child) {
      return this._children.indexOf(child);
    }
    /**
     * @summary ã«ãªã³ã°ãããï¼
     * @param  {mapray.Vector4[]} clip_planes  ã¯ãªããå¹³é¢éå
     * @return {boolean}                       è¦ããªãã¨ã true, è¦ããã¾ãã¯ä¸æã®ã¨ã false
     */

  }, {
    key: "isInvisible",
    value: function isInvisible(clip_planes) {
      if (this.level === 0) return false;
      var xmin = this.gocs_min[0];
      var xmax = this.gocs_max[0];
      var ymin = this.gocs_min[1];
      var ymax = this.gocs_max[1];
      var zmin = this.gocs_min[2];
      var zmax = this.gocs_max[2];

      for (var i = 0; i < clip_planes.length; ++i) {
        var p = clip_planes[i];
        var px = p[0];
        var py = p[1];
        var pz = p[2];
        var pw = p[3]; // ä»¥ä¸ããã¹ã¦æãç«ã¤ã¨ããã¯ã¹å¨ä½ã¯å¹³é¢ã®è£å´ã«ãã
        //   px*xmin + py*ymin + pz*zmin + pw < 0
        //   px*xmax + py*ymin + pz*zmin + pw < 0
        //   px*xmin + py*ymax + pz*zmin + pw < 0
        //   px*xmax + py*ymax + pz*zmin + pw < 0
        //   px*xmin + py*ymin + pz*zmax + pw < 0
        //   px*xmax + py*ymin + pz*zmax + pw < 0
        //   px*xmin + py*ymax + pz*zmax + pw < 0
        //   px*xmax + py*ymax + pz*zmax + pw < 0

        var c0 = px * xmin + py * ymin;
        var c1 = px * xmax + py * ymin;
        var c2 = px * xmin + py * ymax;
        var c3 = px * xmax + py * ymax;
        var c4 = -pz * zmin - pw;
        var c5 = -pz * zmax - pw;

        if (c0 < c4 && c1 < c4 && c2 < c4 && c3 < c4 && c0 < c5 && c1 < c5 && c2 < c5 && c3 < c5) {
          // ããã¯ã¹å¨ä½ãå¹³é¢ã®è£å´ã«ããã®ã§è¦ããªã
          return true;
        }
      }

      return false; // è¦ãã¦ããå¯è½æ§ããã
    }
    /**
     * @summary ç¹ç¾¤ã®èª­ã¿è¾¼ã¿å¦ç
     * 
     * @return {Promise<void>}
     */

  }, {
    key: "load",
    value: function load() {
      var _this2 = this;

      if (this._status !== Box.Status.NOT_LOADED) throw new Error("illegal status: " + this._status.id);
      if (!this._owner._provider.isReady()) return;
      this._status = Box.Status.LOADING;

      var task = this._owner._provider.load(this.level, this.x, this.y, this.z, true);

      this._loadId = task.id;
      return task.done.then(function (event) {
        _this2._metaInfo = {
          children: [],
          indices: event.header.indices
        };
        {
          var childFlags = event.header.childFlags;

          for (var i = 7; i >= 0; --i) {
            _this2._metaInfo.children[i] = childFlags & 1 ? {} : null;
            childFlags = childFlags >> 1;
          }
        }
        _this2.average = event.header.average;
        _this2.eigenVector = event.header.eigenVector;
        _this2.eigenVectorLength = event.header.eigenVectorLength;
        _this2.debug1 = event.header.debug1;
        var values = event.body;
        console.assert(values.length > 0);
        console.assert(values.length / 6 === _this2._metaInfo.indices[7]);

         {
          var number_of_points = values.length / 6;

          for (var _i5 = 0; _i5 < 8; ++_i5) {
            if (_this2._metaInfo.indices[_i5] > number_of_points) {
              console.log("warning fix indices");
              _this2._metaInfo.indices[_i5] = number_of_points;
            }
          }
        }

        var gl = _this2._owner._glenv.context;
        _this2._vertex_buffer = gl.createBuffer();
        _this2._vertex_length = values.length / 6;
        gl.bindBuffer(gl.ARRAY_BUFFER, _this2._vertex_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, values, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        /*
         * +------------+------------+----
         * | a_position | a_color    | ...
         * +------------+------------+----
         * 
         * |<--12 bit-->|<--12 bit-->|
         */

        _this2._vertex_attribs = {
          "a_position": {
            buffer: _this2._vertex_buffer,
            num_components: 3,
            component_type: gl.FLOAT,
            normalized: false,
            byte_stride: 24,
            byte_offset: 0
          },
          "a_color": {
            buffer: _this2._vertex_buffer,
            num_components: 3,
            component_type: gl.FLOAT,
            normalized: false,
            byte_stride: 24,
            byte_offset: 12
          }
        };
        _this2._status = Box.Status.LOADED;

        _this2._updateDebugMesh();
      })["catch"](function (error) {
        var skip_error = error.message === "cancel" || error.message === "not loading" || error.message === "The user aborted a request." || error.is_aborted;

        if (!skip_error) {
          console.log(error);
          _this2._status = Box.Status.DESTROYED;
        }
      });
    }
    /**
     * @summary å­Boxãçæã(ãã§ã«å­å¨ããå ´åã¯æ¢å­ã®Boxãè¿ã)
     * LOADED ç¶æã§ã®ã¿å¼ã¶ãã¨ãã§ãã
     * 
     * @param {number} index çªå·
     * @param {object} [statistics] çµ±è¨æå ±
     * @return {Box}
     */

  }, {
    key: "newChild",
    value: function newChild(index, statistics) {
      var _Box$CHILDREN_INDICES = _slicedToArray(Box.CHILDREN_INDICES[index], 3),
          u = _Box$CHILDREN_INDICES[0],
          v = _Box$CHILDREN_INDICES[1],
          w = _Box$CHILDREN_INDICES[2];

      return this.newChildAt(u, v, w, statistics);
    }
    /**
     * @summary å­Boxãçæã(ãã§ã«å­å¨ããå ´åã¯æ¢å­ã®Boxãè¿ã)
     * LOADED ç¶æã§ã®ã¿å¼ã¶ãã¨ãã§ãã
     * 
     * @param {number} u xæ¹å-å´ã¯0ã+å´ã¯1
     * @param {number} v yæ¹å-å´ã¯0ã+å´ã¯1
     * @param {number} w zæ¹å-å´ã¯0ã+å´ã¯1
     * @param {object} [statistics] çµ±è¨æå ±
     * @return {Box}
     */

  }, {
    key: "newChildAt",
    value: function newChildAt(u, v, w, statistics) {
      console.assert(this._status === Box.Status.LOADED);
      var index = u | v << 1 | w << 2;
      var child = this._children[index];
      if (child) return child;
      if (!this.getChildInfo(index)) return null;
      if (statistics) statistics.created_boxes++;
      return this._children[index] = new Box(this, this.level + 1, this.x << 1 | u, this.y << 1 | v, this.z << 1 | w);
    }
    /**
     * @summary å­Boxãåå¾ã
     * å­å¨ããªãå ´åã¯ null ãè¿å´ããã
     * 
     * @param {number} index çªå·
     * @return {Box}
     */

  }, {
    key: "getChild",
    value: function getChild(index) {
      return this._children[index];
    }
    /**
     * ãããã°ã¡ãã·ã¥ãæç»
     * 
     * @param {mapray.RenderStage} render_stage ã¬ã³ããªã³ã°ã¹ãã¼ã¸
     */

  }, {
    key: "_drawDebugMesh",
    value: function _drawDebugMesh(render_stage) {
      if (!this.debugMesh) return;
      var gl = render_stage._glenv.context;
      var color = Box.STATUS_COLOR_TABLE[this._status.id];
      gl.disable(gl.CULL_FACE);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.debugMesh[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var debugMesh = _step.value;
          var debug_material = debugMesh._draw_mode === 1 ? this._owner._scene.viewer._render_cache.point_cloud_debug_wire_material : this._owner._scene.viewer._render_cache.point_cloud_debug_face_material;
          debug_material.bindProgram();
          debug_material.setDebugBoundsParameter(render_stage, this.gocs_center, color);
          debugMesh.draw(debug_material);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      gl.enable(gl.CULL_FACE);
    }
    /**
     * @summary Boxãæç»ããã
     * Boxå¨ä½ã®æç»ããã³ãBoxã®8åå²åä½ã§ã®æç»ã«å¯¾å¿ã
     * 
     * @param {mapray.RenderStage} render_stage ã¬ã³ããªã³ã°ã¹ãã¼ã¸
     * @param {number[]|null} target_cells æç»å¯¾è±¡ã®å­çªå·ã®éåããã ãnullã¯å¨ä½ãè¡¨ãã
     * @param {number[]} points_per_pixels ç¹ã®è§£ååº¦ã®éåãtarget_cellsåãé åºã§ãããnullã®å ´åã¯è¦ç´ æ°1ã¨ãªãã
     * @param {object} statistics çµ±è¨æå ±
     */

  }, {
    key: "draw",
    value: function draw(render_stage, target_cells, points_per_pixels, statistics) {
      if (this.debugMesh) {
        this._drawDebugMesh(render_stage);
      }

      if (this._status !== Box.Status.LOADED) return;
      var gl = render_stage._glenv.context;
      var point_shape = this._owner._point_shape;
      var point_size_type = this._owner._point_size_type;
      var point_size = this._owner._point_size;
      var point_size_limit = this._owner._point_size_limit;
      var debug_shader = this._owner._debug_shader;

      if (this._status === Box.Status.LOADED) {
        var material = this._owner._getMaterial(point_shape);

        material.bindProgram();
        material.setDebugBoundsParameter(render_stage, this.gocs_center);
        material.bindVertexAttribs(this._vertex_attribs);
        var overlap_scale = 3;

        if (target_cells === null) {
          // draw whole points
          var ppp = points_per_pixels[0];
          material.setPointSize(point_size_type === PointCloud.PointSizeType.PIXEL ? point_size : point_size_type === PointCloud.PointSizeType.MILLIMETERS ? -0.001 * point_size / render_stage._pixel_step : Math.min(point_size_limit, Math.max(1.0, overlap_scale / ppp)));
          material.setDebug(debug_shader ? 0.5 / ppp : -1.0);
          gl.drawArrays(gl.POINTS, 0, this._vertex_length);
        } else {
          // draw only target regions
          for (var i = 0; i < target_cells.length; i++) {
            var _ppp = points_per_pixels[i];
            material.setPointSize(point_size_type === PointCloud.PointSizeType.PIXEL ? point_size : point_size_type === PointCloud.PointSizeType.MILLIMETERS ? -0.001 * point_size / render_stage._pixel_step : Math.min(point_size_limit, Math.max(1.0, overlap_scale / _ppp)));
            material.setDebug(debug_shader ? 0.5 / _ppp : -1.0);
            var childIndex = target_cells[i];
            var offset = childIndex > 0 ? this._metaInfo.indices[childIndex - 1] : 0;
            var length = this._metaInfo.indices[childIndex] - offset;
            if (length > 0) gl.drawArrays(gl.POINTS, offset, length);
          }
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        if (statistics) {
          statistics.render_boxes++;

          if (target_cells && this._metaInfo.indices) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = target_cells[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _childIndex = _step2.value;

                var _offset = _childIndex > 0 ? this._metaInfo.indices[_childIndex - 1] : 0;

                var _length = this._metaInfo.indices[_childIndex] - _offset;

                statistics.render_point_count += _length;
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          } else {
            statistics.render_point_count += this._vertex_length;
          }
        }
      }
    }
    /**
     * @summary å­å­«Boxãå¨ã¦åé¤ããã
     * å¨ã¦ã®ç¶æã§ãã®é¢æ°ãå¼ã¶ãã¨ãã§ããè¤æ°åå¼ã¶ãã¨ãã§ããã
     * @param {object} [statistics] çµ±è¨æå ±
     */

  }, {
    key: "disposeChildren",
    value: function disposeChildren(statistics) {
      for (var i = 0; i < this._children.length; i++) {
        if (this._children[i]) {
          this._children[i].dispose(statistics);

          this._children[i] = null;
        }
      }
    }
    /**
     * @summary Boxãç ´æ£ãã¾ããå­å­«Boxãå¨ã¦åé¤ããã
     * å¨ã¦ã®ç¶æã§ãã®é¢æ°ãå¼ã¶ãã¨ãã§ããè¤æ°åå¼ã¶ãã¨ãã§ããã
     * @param {object} [statistics] çµ±è¨æå ±
     */

  }, {
    key: "dispose",
    value: function dispose(statistics) {
      if (this._status === Box.Status.LOADING) {
        if (this._abort_controller) {
          this._abort_controller.abort();
        }

        this._owner._provider.cancel(this._loadId);
      }

      this.disposeChildren(statistics);

      if (this._vertex_buffer) {
        var gl = this._owner._glenv.context;
        gl.deleteBuffer(this._vertex_buffer);
        this._vertex_buffer = null;
      }

      if (this.debugMesh) ;

      if (statistics) statistics.disposed_boxes++;
      this._status = Box.Status.DESTROYED;
    }
    /**
     * @summary Boxã®æå­åè¡¨ç¾ãè¿ãã¾ãã
     * @return {string}
     */

  }, {
    key: "toString",
    value: function toString() {
      return "Box-".concat(this.level, "-").concat(this.x, "-").concat(this.y, "-").concat(this.z);
    }
    /**
     * @summary Boxã®ããªã¼å½¢å¼ã®æå­åè¡¨ç¾ãè¿ãã¾ãã
     * @param {string} [indent] ã«ã¼ãè¦ç´ ã®ã¤ã³ãã³ãæå­åãæå®ãã¾ãã
     * @return {string}
     */

  }, {
    key: "toTreeString",
    value: function toTreeString() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      return this._children.reduce(function (text, child) {
        return text + (child ? "\n" + child.toTreeString(indent + "  ") : "");
      }, indent + this.toString());
    }
    /**
     * ã«ã¼ãBoxãçæãã¾ãã
     * @param {mapray.PointCloud} owner
     * @return {Box}
     */

  }, {
    key: "status",
    get: function get() {
      return this._status;
    }
    /**
     * @summary èª­ã¿è¾¼ã¿ãå®äºãã¦ããã
     *
     * @type {boolean}
     */

  }, {
    key: "is_loaded",
    get: function get() {
      return this._status === Box.Status.LOADED;
    }
    /**
     * @summary è¦ªãã¼ã
     *
     * @type {Box}
     */

  }, {
    key: "parent",
    get: function get() {
      return this._parent;
    }
  }], [{
    key: "createRoot",
    value: function createRoot(owner) {
      var box = new Box(null, 0, 0, 0, 0);
      box._owner = owner;
      return box;
    }
  }, {
    key: "Status",
    get: function get() {
      return Status$2;
    }
  }]);

  return Box;
}();

Box.CHILDREN_INDICES = [[0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 0], [0, 0, 1], [1, 0, 1], [0, 1, 1], [1, 1, 1]];
/**
 * @summary Boxã®ç¶æã
 * <pre>
 *                                                                      
 *              load()                            dispose()             
 * NOT_LOADED ---------> LOADING -------> LOADED -----------> DESTROYED 
 *                              \                          /            
 *                               `------>-----------------Â´             
 *                                  error or dispose()                  
 * </pre>
 * @enum {object}
 * @memberof mapray.PointCloud.Box
 * @constant
 * @see mapray.PointCloud.Box#status
 */

var Status$2 = {
  /**
   * æºåä¸­ (åæç¶æ)ã
   * load()ãå¼ã¶ã¨ LOADING ã¸é·ç§»ãèª­ã¿è¾¼ã¿å¦çãéå§ãããã
   */
  NOT_LOADED: {
    id: "NOT_LOADED"
  },

  /**
   * èª­ã¿è¾¼ã¿ä¸­ã
   * èª­ã¿è¾¼ã¿å¦çãçµäºããã¨ãLOADED ã DESTROYED ã®ããããã«é·ç§»ããã
   * æ­£å¸¸ã«å¦çãå®äºããã¨ LOADED ãä½ããã®ã¨ã©ã¼ãçºçããå ´åã¯ DESTROYED ã¨ãªãã
   * ã¾ããLOADING ä¸­ã« dispose() ãå¼ã°ããå ´åãå³åº§ã« DESTROYED ã«é·ç§»ããã
   */
  LOADING: {
    id: "LOADING"
  },

  /**
   * èª­ã¿è¾¼ã¿å®äº(æç»å¯è½)ã
   * dispose()ãå¼ã¶ã¨ DESTROYED ã«é·ç§»ããã
   */
  LOADED: {
    id: "LOADED"
  },

  /**
   * ç ´æ£ç¶æ
   * ä»ã®ç¶æã«é·ç§»ãããã¨ã¯ãªãã
   */
  DESTROYED: {
    id: "DESTROYED"
  }
};
Box.STATUS_COLOR_TABLE = {};
{
  Box.STATUS_COLOR_TABLE[Box.Status.LOADED.id] = [0.0, 0.8, 1.0, 0.5];
  Box.STATUS_COLOR_TABLE[Box.Status.DESTROYED.id] = [1.0, 0.0, 0.0];
  Box.STATUS_COLOR_TABLE[Box.Status.LOADING.id] = [1.0, 1.0, 0.0];
  Box.STATUS_COLOR_TABLE[Box.Status.NOT_LOADED.id] = [0.0, 1.0, 0.0];
}
var MIN_INT = 1 << 31;

/**
 * @summary Boxãã¬ã³ããªã³ã°ããããã®ãªãã¸ã§ã¯ã
 *
 * @memberof mapray
 * @private
 */

var PointCloudBoxRenderObject =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.PointCloud.Box} box æç»å¯¾è±¡
   * @param {number} distance è¦ç¹ããBoxã¾ã§ã®è·é¢
   * @param {number} parent_points_per_pixel è¦ªBoxã®ç¹ã®ç´°ãã
   */
  function PointCloudBoxRenderObject(box, distance, parent_points_per_pixel) {
    _classCallCheck(this, PointCloudBoxRenderObject);

    this._box = box;
    this._distance = distance;
    this._target_children = [];
    this._points_per_pixel = [];
    this._parent_points_per_pixel = parent_points_per_pixel;
  }
  /**
   * @summary æç»å¯¾è±¡
   * @type {mapray.PointCloud.Box}
   */


  _createClass(PointCloudBoxRenderObject, [{
    key: "pushRegion",

    /**
     * @summary æç»å¯¾è±¡é åãè¿½å ãã
     * @param {number} child é å
     * @param {number} points_per_pixel æç»ããç¹ã®ç´°ãã
     */
    value: function pushRegion(child, points_per_pixel) {
      if (this._target_children !== null) {
        var index = this._target_children.indexOf(child);

        if (index === -1) {
          this._target_children.push(child);

          this._points_per_pixel.push(points_per_pixel);
        } else {
          this._target_children[index] = child;
          this._points_per_pixel[index] = points_per_pixel;
        }
      }
    }
    /**
     * @summary æç»å¯¾è±¡ãå¨é åã«ãã
     * @param {number} points_per_pixel æç»ããç¹ã®ç´°ãã
     */

  }, {
    key: "setWholeRegion",
    value: function setWholeRegion(points_per_pixel) {
      this._target_children = null;
      this._points_per_pixel = [points_per_pixel];
    }
    /**
     * @summary æç»
     * @param {mapray.RenderStage} render_stage ã¬ã³ããªã³ã°ã¹ãã¼ã¸
     * @param {object} statistics çµ±è¨æå ±
     */

  }, {
    key: "draw",
    value: function draw(render_stage, statistics) {
      this._box.draw(render_stage, this._target_children, this._points_per_pixel, statistics);
    }
  }, {
    key: "box",
    get: function get() {
      return this._box;
    }
    /**
     * @summary ã«ã¡ã©ããã®è·é¢
     * @type {number}
     */

  }, {
    key: "distance",
    get: function get() {
      return this._distance;
    }
    /**
     * @summary è¦ªBoxã®ç¹ã®è§£ååº¦
     * @type {number}
     */

  }, {
    key: "parent_points_per_pixel",
    get: function get() {
      return this._parent_points_per_pixel;
    }
  }]);

  return PointCloudBoxRenderObject;
}();

/**
 * @summary Boxãåéãããã¼ã«
 * @memberof mapray
 * @private
 */

var PointCloudBoxCollector =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.RenderStage} stage   ææèã§ãã RenderStage
   * @param {number} load_limit èª­ã¿è¾¼ã¿ãå¿è¦ãªBoxãªã¹ãã«ä¿æããè¦ç´ æ°ã®ä¸é
   */
  function PointCloudBoxCollector(stage) {
    var load_limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

    _classCallCheck(this, PointCloudBoxCollector);

    this._setupViewVectors(stage);

    this._setupClipPlanes(stage);

    this._point_cloud_collection = stage._point_cloud_collection;
    /**
     * æç»ããBoxã®ãªã¹ãã
     * @private
     */

    this._render_boxes = [];
    /**
     * Box => PointCloudBoxRenderObject ã®è¾æ¸
     * @private
     */

    this._render_boxes_map = new Map();
    /**
     * èª­ã¿è¾¼ã¿ãå¿è¦ãªBoxãªã¹ããå¸¸ã«åªååº¦ã§ã½ã¼ãæ¸ã¿ã
     * @private
     */

    this._load_boxes = [];
    /**
     * èª­ã¿è¾¼ã¿ãå¿è¦ãªBoxãªã¹ãã®è¦ç´ æ°ã®ä¸é
     * @private
     */

    this._load_limit = load_limit;
  }
  /**
   * @private
   */


  _createClass(PointCloudBoxCollector, [{
    key: "_setupViewVectors",
    value: function _setupViewVectors(stage) {
      var view_to_gocs = stage._view_to_gocs;
      var pixel_step = stage._pixel_step;
      var view_pos_Q = GeoMath.createVector3();
      var view_dir_wU = GeoMath.createVector3(); // å°è¡¨è©³ç´°ã¬ãã« (LOD) è¨ç®ç¨ã® Q, w*U ãã¯ãã«ãè¨­å®

      view_pos_Q[0] = view_to_gocs[12];
      view_pos_Q[1] = view_to_gocs[13];
      view_pos_Q[2] = view_to_gocs[14];
      view_dir_wU[0] = -view_to_gocs[8] * pixel_step;
      view_dir_wU[1] = -view_to_gocs[9] * pixel_step;
      view_dir_wU[2] = -view_to_gocs[10] * pixel_step;
      /**
       *  @summary ä½ç½®ãã¯ãã« Q
       *  @member mapray.FlakeCollector#_view_pos_Q
       *  @type {mapray.Vector3}
       *  @private
       *  @see doc/ImageLevelCalculation.txt
       */

      this._view_pos_Q = view_pos_Q;
      /**
       *  @summary ãã¯ãã« w * U
       *  @member mapray.FlakeCollector#_view_dir_wU
       *  @type {mapray.Vector3}
       *  @private
       *  @see doc/ImageLevelCalculation.txt
       */

      this._view_dir_wU = view_dir_wU;
    }
    /**
     * @private
     */

  }, {
    key: "_setupClipPlanes",
    value: function _setupClipPlanes(stage) {
      var view_to_gocs = stage._view_to_gocs;
      var gocs_to_view = stage._gocs_to_view;
      this.volume_planes = stage._volume_planes; // const volume_planes = stage._volume_planes;

      var clip_planes = []; // å°è¡¨é®è½ã«ãªã³ã°å¹³é¢

      var root_flake = stage._viewer._globe.root_flake;
      var rmin = GeoMath.EARTH_RADIUS + root_flake.height_min; // æå°åå¾

      var rmax = GeoMath.EARTH_RADIUS + root_flake.height_max; // æå¤§åå¾
      // P (è¦ç¹ä½ç½®)

      var px = view_to_gocs[12];
      var py = view_to_gocs[13];
      var pz = view_to_gocs[14]; // q = â[(P.P - rmin^2)(rmax^2 - rmin^2)] - rmin^2

      var p2 = px * px + py * py + pz * pz;
      var rmin2 = rmin * rmin;
      var rmax2 = rmax * rmax;
      var q = Math.sqrt((p2 - rmin2) * (rmax2 - rmin2)) - rmin2; // L = <P, q> / âPâ

      var plane = GeoMath.createVector4();
      var recip = 1 / Math.sqrt(p2);
      plane[0] = px * recip;
      plane[1] = py * recip;
      plane[2] = pz * recip;
      plane[3] = q * recip; // clip_planes.push( plane );
      // L ãåºã¨ããé æ¹è·é¢

      var far_dist = Math.sqrt(p2 + rmax2 + 2 * q); // è¦ä½ç©å¹³é¢ãåå¾ãã¦ãå°å¿ç´äº¤åº§æ¨ç³»ã«å¤æ
      // (ç´äº¤å¤æãªã®ã§ x, y, z ã¯æ­£è¦åããã¦ãã)

      for (var i = 0; i < 6; ++i) {
        var src_plane = this.volume_planes[i];
        var dst_plane = GeoMath.createVector4();

        if (i == 1 && src_plane[3] > far_dist) {
          // é æ¹å¹³é¢ãå¿è¦ä»¥ä¸ã«é ãã¨ã far_dist ã«ç½®ãæãã
          src_plane = GeoMath.createVector4(src_plane);
          src_plane[3] = far_dist;
        }

        GeoMath.transformPlane_A(gocs_to_view, src_plane, dst_plane);
        clip_planes.push(dst_plane);
      }

      this._clip_planes = clip_planes;
    }
    /**
     * @summary ç¹ç¾¤Boxãåéãã
     * @param {mapray.PointCloud} point_cloud ç¹ç¾¤
     * @param {object} statistics çµ±è¨æå ±
     * @return {mapray.RenderFlake[]}  åéãããç¹ç¾¤Boxã®éå
     */

  }, {
    key: "traverse",
    value: function traverse(point_cloud, statistics) {
      this._points_per_pixel = point_cloud.getPointsPerPixel();
      this._dispersion = point_cloud.getDispersion();
      this._statistics = statistics;

      this._updateBox(point_cloud.root, 0);

      return {
        visible_boxes: this._render_boxes,
        load_boxes: this._load_boxes
      };
    }
    /**
     * @private
     */

  }, {
    key: "_updateBox",
    value: function _updateBox(box, parent_ppp) {
      if (this._statistics) {
        this._statistics.total_boxes++;
        if (box.status === Box.Status.LOADING) this._statistics.loading_boxes++;

        if (box.getPointsLength()) {
          this._statistics.total_point_count += box.getPointsLength();
        }
      }

      if (box.isInvisible(this._clip_planes)) {
        box.disposeChildren(this._statistics);
        return;
      }

      var box_ppp, lodStatus;

      if (box.is_loaded) {
        box_ppp = this._calcPointsPerPixel(box);
        lodStatus = box_ppp < this._points_per_pixel ? LodStatus.LOAD_NEXT_LEVEL : LodStatus.UNLOAD_NEXT_LEVEL;
      } else {
        lodStatus = LodStatus.KEEP_STATUS;
      }

      if (lodStatus === LodStatus.LOAD_NEXT_LEVEL) {
        // if more detaild data is required then load nextLevel
        // å­Boxããªãé åãæç»ãã
        //   [A]
        //    |--a1--[B]
        //    |--a2--[C]
        //    `--a3-- x
        //    - Aã¯ã8åå²ãããé åã®ãã¡ãa1, a2, a3ã®é åã«ç¹ãå«ã¾ãã¦ããã
        //    - ãã®ãã¡a1, a2ã«ã¤ãã¦ã¯å­Box(B, C)ãæã£ã¦ãããa3ã¯å­Boxãæã£ã¦ããªãã
        //    - ãã®å ´åãa3ã®é åã«ã¤ãã¯Aãæç»ãããï¼a1, a2ã®é åã«ã¤ãã¦ã¯ãB, Cã«ããæç»ãããï¼
        this._collectNextLevel(box, box_ppp);

        for (var i = 0; i < 8; i++) {
          if (box.cellPointsAvailable(i) && !box.getChild(i)) {
            this._pushBox(box, i, box_ppp, parent_ppp);
          }
        }

        return;
      }

      if (lodStatus === LodStatus.UNLOAD_NEXT_LEVEL) {
        // if more detaild data is not required then dispose children
        box.disposeChildren(this._statistics);
      }

      if (box.status !== Box.Status.DESTROYED) {
        //   [A]
        //    |--a1--[B]
        //    |--a2--[C]
        //    `--a3-- x
        //    - Bãèª­ã¿è¾¼ã¾ãã¦ããå ´åã¯Bãæç»ããã
        //    - Bã®èª­ã¿è¾¼ã¿ãå®äºããã¾ã§ã¯ãAãa1é åãæç»ãã(èª­ã¿è¾¼ã¿ä¸­ã¯æ ã®ã¿æç»ãããå ´åããããããBãæç»ãã)ã
        this._pushBox(box, null, box_ppp, parent_ppp);

        if (box.status === Box.Status.LOADING || box.status === Box.Status.NOT_LOADED) {
          if (box.level > 1) {
            this._pushBox(box.parent, box.parent.indexOf(box), parent_ppp, parent_ppp);
          }
        }
      }
    }
    /**
     * @ã¹ã¯ãªã¼ã³ï¼ç»ç´ ãããã®ç¹ã®æ°[points/pixel]ãè¨ç®ããã
     * ä¾ãã°ã2ç»ç´ ã«ã¤ã1ç¹ã®ééã§ä¸¦ãã§ããå ´åã¯0.5ãè¿ãã
     * @param {mapray.PointCloud.Box} box Box
     * @private
     */

  }, {
    key: "_calcPointsPerPixel",
    value: function _calcPointsPerPixel(box) {
      var is_plane = box.eigenVectorLength[0] < box.size * 0.8;
      var points_per_pixel;

      if (is_plane && this._dispersion && box.eigenVectorLength[0] > 0) {
        var dir = GeoMath.normalize3(this._view_dir_wU, GeoMath.createVector3f());

        var _box$eigenVector = _slicedToArray(box.eigenVector, 3),
            ev1 = _box$eigenVector[0],
            ev2 = _box$eigenVector[1],
            ev3 = _box$eigenVector[2];

        var _box$eigenVectorLengt = _slicedToArray(box.eigenVectorLength, 3),
            ev1l = _box$eigenVectorLengt[0],
            ev2l = _box$eigenVectorLengt[1],
            ev3l = _box$eigenVectorLengt[2];

        var n = [GeoMath.dot3(ev2, dir), GeoMath.dot3(ev1, dir), GeoMath.dot3(ev3, dir)];
        var s = n[0] * n[0] / (ev2l * ev2l) + n[2] * n[2] / (ev3l * ev3l);
        var nn = [s * ev3l * ev1l / ev2l * n[0], s * ev2l * ev3l / ev1l * n[1], s * ev1l * ev2l / ev3l * n[2]];
        GeoMath.normalize3(nn, nn);
        var area_calc = (nn[0] * n[0] + nn[1] * n[1] + nn[2] * n[2]) * (Math.PI * ev1l * ev2l * ev3l / Math.sqrt(nn[0] * nn[0] * ev2l * ev2l + nn[1] * nn[1] * ev1l * ev1l + nn[2] * nn[2] * ev3l * ev3l));
        var area = Math.min(Math.max(area_calc, 0.05 * box.proj_area), box.proj_area);
        points_per_pixel = Math.sqrt(box.getPointsLength() / area);
      } else {
        points_per_pixel = 64 / box.size; // (128 / (2*box.size)) = 1ã»ã«ã®å¤§ããï¼ç¹ã®ééï¼
      }

      var diff = [box.gocs_center[0] + box.average[0] - this._view_pos_Q[0], box.gocs_center[1] + box.average[1] - this._view_pos_Q[1], box.gocs_center[2] + box.average[2] - this._view_pos_Q[2]]; // Ï ã¹ã¯ãªã¼ã³ä¸ã®ï¼ç»ç´ ã®ä¸è¾ºã®é·ãããbox.averageã®ä½ç½®ã«æå½±ããé·ã

      var Ï = GeoMath.dot3(this._view_dir_wU, diff);
      return Ï * points_per_pixel;
    }
    /**
     * @summary æç»å¯¾è±¡ãè¿½å 
     * 
     * @param {mapray.PointCloud.Box} box
     * @param {number|null} targetChild cellé åãæå®ããå ´åã¯æ°å­ãå¨ä½ãæç»ããå ´åã¯nullãæå®ãã
     * @param ppp æç»æã®è§£ååº¦ (points per pixel)
     * @param parent_ppp è¦ªBoxã®æç»æã®è§£ååº¦ (points per pixel)
     * @private
     */

  }, {
    key: "_pushBox",
    value: function _pushBox(box, target_child, ppp, parent_ppp) {
      var ro = this._render_boxes_map.get(box);

      if (ro) {
        if (target_child === null) ro.setWholeRegion(ppp);else ro.pushRegion(target_child, ppp);
      } else {
        var diff = box.is_loaded ? [box.gocs_center[0] + box.average[0] - this._view_pos_Q[0], box.gocs_center[1] + box.average[1] - this._view_pos_Q[1], box.gocs_center[2] + box.average[2] - this._view_pos_Q[2]] : [box.gocs_center[0] - this._view_pos_Q[0], box.gocs_center[1] - this._view_pos_Q[1], box.gocs_center[2] - this._view_pos_Q[2]];
        var distance = Math.sqrt(diff[0] * diff[0] + diff[1] * diff[1] + diff[2] * diff[2]);
        ro = new PointCloudBoxRenderObject(box, distance, parent_ppp);
        if (target_child === null) ro.setWholeRegion(ppp);else ro.pushRegion(target_child, ppp);

        this._render_boxes.push(ro);

        this._render_boxes_map.set(box, ro);

        if (box.status === Box.Status.NOT_LOADED) {
          this._pushLoadBox(ro);
        }
      }
    }
    /**
     * @summary æç»å¯¾è±¡ãè¿½å 
     * 
     * @param {mapray.PointCloud.Box} box
     * @param {number|null} targetChild cellé åãæå®ããå ´åã¯æ°å­ãå¨ä½ãæç»ããå ´åã¯nullãæå®ãã
     * @param ppp æç»æã®è§£ååº¦ (points per pixel)
     * @param parent_ppp è¦ªBoxã®æç»æã®è§£ååº¦ (points per pixel)
     * @private
     */

  }, {
    key: "_pushLoadBox",
    value: function _pushLoadBox(ro) {
      var index = this._binarySearch(this._load_boxes, ro, function (ro1, ro2) {
        return ro1.parent_points_per_pixel < ro2.parent_points_per_pixel;
      }); // this._load_boxes.splice( index, 0, ro );


      if (index === -1) this._load_boxes.push(ro);else this._insert_with_limit(this._load_boxes, index, ro, this._load_limit);
    }
    /**
     * @private
     */

  }, {
    key: "_insert_with_limit",
    value: function _insert_with_limit(list, index, item, limit) {
      if (limit === undefined || limit - list.length > 0) {
        list.splice(index, 0, item);
      } else {
        // we couldn't increase the size
        if (index === list.length) return;

        for (var i = list.length - 1; i > index; i--) {
          list[i] = list[i - 1];
        }

        list[index] = item;
      }
    }
    /**
     * @param Array<T> sorted_list ã½ã¼ãæ¸ã¿ãªã¹ã
     * 
     * @private
     */

  }, {
    key: "_binarySearch",
    value: function _binarySearch(sorted_list, value, compareFunc) {
      if (sorted_list.length === 0) return -1;
      if (compareFunc(value, sorted_list[0])) return 0;
      if (compareFunc(sorted_list[sorted_list.length - 1], value)) return sorted_list.length;
      if (sorted_list.length === 1) return sorted_list.length;
      return this._binarySearchInner(sorted_list, value, compareFunc, 0, sorted_list.length - 1);
    }
    /**
     * @private
     */

  }, {
    key: "_binarySearchInner",
    value: function _binarySearchInner(sorted_list, value, compareFunc, min, max) {
      if (max - min === 1) return max;
      var mid = 0.5 * (min + max) | 0;
      if (compareFunc(sorted_list[mid], value)) min = mid;else max = mid;
      return this._binarySearchInner(sorted_list, value, compareFunc, min, max);
    }
    /**
     * @private
     */

  }, {
    key: "_collectNextLevel",
    value: function _collectNextLevel(box, parent_ppp) {
      var child;

      for (var i = 0; i < 8; i++) {
        if (child = box.newChild(i, this._statistics)) {
          this._updateBox(child, parent_ppp);
        }
      }
    }
  }]);

  return PointCloudBoxCollector;
}();
/**
 * @summary Boxã®è§£ååº¦ã®ç¶æãè¡¨ãåæå
 * @enum {object}
 * @memberof mapray.PointCloud.Box
 * @constant
 * @see mapray.PointCloud.Box#status
 */


var LodStatus = {
  /**
   * ç®æ¨è§£ååº¦ã«éãã¦ããããæ¬¡ã®ã¬ãã«ã®Boxãèª­ã¿è¾¼ãå¿è¦ããããã¨ãç¤ºããã
   */
  LOAD_NEXT_LEVEL: 1,

  /**
   * èª­ã¿è¾¼ã¿ä¸­ãªã©ã®çç±ã§è§£ååº¦ãè¨ç®ã§ããªããããç¾ç¶ãç¶­æãããã¨ãç¤ºãã
   */
  KEEP_STATUS: 0,

  /**
   * ç®æ¨è§£ååº¦ã«éãã¦ãããæ¬¡ã®ã¬ãã«ã®Boxãå¿è¦ãªããã¨ãç¤ºãã
   */
  UNLOAD_NEXT_LEVEL: -1
};

var slice = [].slice;
var factories = {};

var construct = function (C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func


    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  }

  return factories[argsLength](C, args);
}; // `Function.prototype.bind` method implementation
// https://tc39.github.io/ecma262/#sec-function.prototype.bind


var functionBind = Function.bind || function bind(that
/* , ...args */
) {
  var fn = aFunction$1(this);
  var partArgs = slice.call(arguments, 1);

  var boundFunction = function bound()
  /* args... */
  {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };

  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};

// https://tc39.github.io/ecma262/#sec-function.prototype.bind

_export({
  target: 'Function',
  proto: true
}, {
  bind: functionBind
});

/**
 * @summary ãã¬ã¼ã ãããã¡
 *
 * @memberof mapray
 * @private
 */
var FrameBuffer =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.GLEnv} glenv     WebGL ç°å¢
   * @param {number}       width     å¹
   * @param {number}       height    é«ã
   * @param {object}       options   ãªãã·ã§ã³
   * @param {object[]}     options.color_containers   ãã¯ã¹ãã£ãªãã·ã§ã³ã®éå
   * @param {object}       [options.depth_containers]  æ·±åº¦ãã¯ã¹ãã£ãªãã·ã§ã³
   */
  function FrameBuffer(glenv, width, height) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, FrameBuffer);

    this._glenv = glenv;
    this._width = width;
    this._height = height;
    this._options = options;

    var _this$_buildBuffers = this._buildBuffers(options),
        frame_buffer = _this$_buildBuffers.frame_buffer,
        color_containers = _this$_buildBuffers.color_containers,
        depth_container = _this$_buildBuffers.depth_container;

    this._frame_buffer = frame_buffer;
    this._color_containers = color_containers;
    this._depth_container = depth_container;
  }
  /**
   * @summary ãããã¡ã®çæ
   * @private
   */


  _createClass(FrameBuffer, [{
    key: "_buildBuffers",
    value: function _buildBuffers(options) {
      var ret = {};
      var width = this._width;
      var height = this._height;
      var gl = this._glenv.context;
      var frame_buffer = ret.frame_buffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, frame_buffer);
      ret.color_containers = options.color_containers.map(function (color_container, index) {
        var type = color_container.type || FrameBuffer.ContainerType.RENDER_BUFFER;
        var c_options = color_container.options || {};

        if (type === FrameBuffer.ContainerType.RENDER_BUFFER) {
          var buffer = gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
          gl.renderbufferStorage(gl.RENDERBUFFER, c_options.internal_format, width, height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + index, gl.RENDERBUFFER, buffer);
          return buffer;
        } else {
          // type === FrameBuffer.ContainerType.TEXTURE
          var texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, c_options.internal_format, width, height, 0, c_options.format, c_options.type, null);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + index, gl.TEXTURE_2D, texture, 0);
          return texture;
        }
      });

      if (options.depth_container) {
        var type = options.depth_container.type || FrameBuffer.ContainerType.RENDER_BUFFER;
        var d_options = options.depth_container.options || {};

        if (type === FrameBuffer.ContainerType.RENDER_BUFFER) {
          var buffer = ret.depth_container = gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
          gl.renderbufferStorage(gl.RENDERBUFFER, d_options.internal_format, width, height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, buffer);
        } else {
          // type === FrameBuffer.ContainerType.TEXTURE
          var depth_container = ret.depth_container = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, depth_container);
          gl.texImage2D(gl.TEXTURE_2D, 0, d_options.internal_format, width, height, 0, d_options.format, d_options.type, null);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, options.depth_container.attach_type, gl.TEXTURE_2D, depth_container, 0);
        }
      }

      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error("ERROR: " + gl.checkFramebufferStatus(gl.FRAMEBUFFER));
      }

      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return ret;
    }
    /**
     * @summary ãªã½ã¼ã¹ãç ´æ£ãã
     */

  }, {
    key: "dispose",
    value: function dispose() {
      var _this = this;

      var gl = this._glenv.context;
      gl.deleteFramebuffer(this._frame_buffer);
      this._frame_buffer = null;

      this._color_containers.forEach(function (container) {
        _this._delete_container(container);
      });

      this._color_containers = [];

      this._delete_container(container, this._depth_container);

      this._depth_container = null;
    }
    /**
     * @private
     */

  }, {
    key: "_delete_container",
    value: function _delete_container(container) {
      var gl = this._glenv.context;

      if (container instanceof WebGLTexture) {
        gl.deleteTexture(container);
      } else if (container instanceof WebGLRenderbuffer) {
        gl.deleteRenderbuffer(container);
      }
    }
    /**
     * @summary ãã¬ã¼ã ãããã¡
     * @type {WebGLFramebuffer}
     */

  }, {
    key: "getColorContainer",

    /**
     * @summary ã«ã©ã¼ãã¼ã¿ãåå¾
     * @param {number} index
     * @type {WebGLTexture|WebGLRenderbuffer}
     */
    value: function getColorContainer(index) {
      return this._color_containers[index];
    }
    /**
     * @summary ã«ã©ã¼ãã¼ã¿æ°
     * @type {number}
     */

  }, {
    key: "bind",

    /**
     * @summary ãã¬ã¼ã ãããã¡ããã¤ã³ãããã
     * å¼ã³åºãå´ããã¤ã³ãã»ã¢ã³ãã¤ã³ããå¯¾å¿ããããã«ä½¿ç¨ããã
     */
    value: function bind() {
      if (FrameBuffer.active_frame_buffer) {
        throw new Error("Invalid status: already bound");
      }

      var gl = this._glenv.context;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frame_buffer);
      FrameBuffer.active_frame_buffer = this;
    }
    /**
     * @summary ãã¬ã¼ã ãããã¡ãã¢ã³ãã¤ã³ãããã
     * å¼ã³åºãå´ããã¤ã³ãã»ã¢ã³ãã¤ã³ããå¯¾å¿ããããã«ä½¿ç¨ããã
     */

  }, {
    key: "unbind",
    value: function unbind() {
      if (FrameBuffer.active_frame_buffer !== this) {
        throw new Error("Invalid status");
      }

      var gl = this._glenv.context;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      FrameBuffer.active_frame_buffer = null;
    }
  }, {
    key: "frame_buffer",
    get: function get() {
      return this._frame_buffer;
    }
    /**
     * @summary ã«ã©ã¼ãã¼ã¿ãåå¾ï¼0çªç®ãåå¾ï¼
     * @type {WebGLTexture|WebGLRenderbuffer}
     */

  }, {
    key: "color_container",
    get: function get() {
      return this._color_containers[0];
    }
  }, {
    key: "color_container_length",
    get: function get() {
      return this._color_containers.length;
    }
    /**
     * @summary æ·±åº¦ãã¼ã¿
     * @type {WebGLTexture|WebGLRenderbuffer}
     */

  }, {
    key: "depth_container",
    get: function get() {
      return this._depth_container;
    }
  }]);

  return FrameBuffer;
}();

FrameBuffer.active_frame_buffer = null;
/**
 * @summary è¦ç´ åã®åæå
 * @enum {object}
 * @memberof mapray.ContainerType
 * @constant
 */

var ContainerType = {
  /**
   * Render Buffer
   */
  RENDER_BUFFER: {
    id: "RENDER_BUFFER"
  },

  /**
   * Texture
   */
  TEXTURE: {
    id: "TEXTURE"
  }
};
FrameBuffer.ContainerType = ContainerType;

var depth_vs_code = "/**\n * æ·±åº¦æç»ç¨ã·ã§ã¼ã (é ç¹ã·ã§ã¼ã)\n */\n\nattribute vec3 a_position;\n\n\nvoid\nmain( void ) {\n    gl_Position = vec4( a_position, 1.0 );\n}\n";

var depth_fs_code = "// define PASS_BASE 0 or 1 JSå´ã§æå®ããã\n\n/**\n * æ·±åº¦æç»ç¨ã·ã§ã¼ã (ãã©ã°ã¡ã³ãã·ã§ã¼ã)\n */\n\nuniform highp sampler2D u_sampler;\n\nvoid\nmain( void ) {\n    highp float fdepth = texture2D( u_sampler, vec2( 0.5, 0.5 ) ).r; // r:[0.0-1.0](24bit), g:0.0, b:0.0, a:1.0\n\n    /* çä¼¼ã³ã¼ã PASS_BASEã¯0ã4ãæ³å®\n    int n[8];  // å n[i] ã®å¤ã¯ç¯å² [0, 7], ãã ã n[0] ã¯ [0, 8]\n    for ( int i = 0; i < 8; ++i ) {\n        n[i] = 0;\n        for ( int w = (i == 0 ? 3 : 2); w >= 0; --w ) {\n            if ( fdepth >= 1.0 ) {\n                n[i] += (1 << w);\n                fdepth = fract( fdepth );\n            }\n            fdepth *= 2.0;\n        }\n    }\n\n    gl_FragColor = vec4( n[PASS_BASE + 0],\n        n[PASS_BASE + 1],\n        n[PASS_BASE + 2],\n        n[PASS_BASE + 3]\n    ) / NMAX;\n    */\n\n#if PASS_BASE == 1\n    for ( int i=0; i<12; i++ ) {\n        fdepth = fract( fdepth * 2.0 );\n    }\n#endif // PASS_BASE\n\n    highp vec4 v;\n\n    int n = 0;\n    if ( fdepth >= 1.0 ) { n += 0x8; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x4; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x2; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x1; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    v[0] = float(n) / 15.0;\n\n    n = 0;\n    if ( fdepth >= 1.0 ) { n += 0x4; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x2; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x1; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    v[1] = float(n) / 15.0;\n\n    n = 0;\n    if ( fdepth >= 1.0 ) { n += 0x4; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x2; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x1; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    v[2] = float(n) / 15.0;\n\n    n = 0;\n    if ( fdepth >= 1.0 ) { n += 0x4; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x2; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    if ( fdepth >= 1.0 ) { n += 0x1; fdepth = fract( fdepth ); } fdepth *= 2.0;\n    v[3] = float(n) / 15.0;\n\n    gl_FragColor = v;\n}\n";

/**
 * @summary ãã¦ã¹ããã¯å¦çã«é¢é£ããå¦çãè¡ã
 *
 * @memberof mapray
 * @private
 */

var PickTool =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.GLEnv} glenv     WebGL ç°å¢
   */
  function PickTool(glenv) {
    _classCallCheck(this, PickTool);

    this._glenv = glenv;
    var gl = this._glenv.context;
    this._camera = new Camera({
      width: 1,
      height: 1
    });
    this._frame_buffer = new FrameBuffer(this._glenv, 1, 1, {
      color_containers: [{
        type: FrameBuffer.ContainerType.RENDER_BUFFER,
        options: {
          internal_format: gl.RGBA4
        }
      }],
      depth_container: {
        type: FrameBuffer.ContainerType.TEXTURE,
        attach_type: gl.DEPTH_STENCIL_ATTACHMENT,
        options: {
          internal_format: gl.DEPTH_STENCIL,
          format: gl.DEPTH_STENCIL,
          type: glenv.WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL
        }
      }
    });
    this._depth_to_color_frame_buffer = new FrameBuffer(this._glenv, 1, 1, {
      color_containers: [{
        type: FrameBuffer.ContainerType.RENDER_BUFFER,
        options: {
          internal_format: gl.RGBA4
        }
      }]
    });
    this._depth_to_color_materials = [new Material(this._glenv, depth_vs_code, define_PASS_BASE_0 + "\n\n" + depth_fs_code), new Material(this._glenv, depth_vs_code, define_PASS_BASE_1 + "\n\n" + depth_fs_code)];
    {
      var vertex_buf = gl.createBuffer();
      {
        var vertices = [-1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, +1.0];
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }
      var texcoord_buf = gl.createBuffer();
      {
        var texcoord = [0, 1, 0, 0, 1, 0, 1, 1];
        gl.bindBuffer(gl.ARRAY_BUFFER, texcoord_buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoord), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }
      {
        var indices = [0, 1, 2, 0, 2, 3];
        this._indices_length = indices.length;
        this._index_buf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._index_buf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }
      this._vertex_attribs = {
        "a_position": {
          buffer: vertex_buf,
          num_components: 2,
          component_type: gl.FLOAT,
          normalized: false,
          byte_stride: 0,
          byte_offset: 0
        },
        "a_texcoord": {
          buffer: texcoord_buf,
          num_components: 2,
          component_type: gl.FLOAT,
          normalized: false,
          byte_stride: 0,
          byte_offset: 0
        }
      };
    }
    this._rid_value = new Uint8Array(4);
    this._depth_value = new Uint8Array(4);
  }
  /**
   * @summary ããã¯ç¨ã«ã¡ã©ãè¿å´ãããåãã¤ã³ã¹ã¿ã³ã¹ãè¿å´ãããã
   * @param {mapray.Camera}  viewer_camera  Viewreã®ã«ã¡ã©
   */


  _createClass(PickTool, [{
    key: "pickCamera",
    value: function pickCamera(viewer_camera) {
      var cw = viewer_camera.canvas_size.width;
      var ch = viewer_camera.canvas_size.height;

      this._camera.copyViewParameters(viewer_camera);

      var hfov_rad = viewer_camera.fov * GeoMath.DEGREE / 2;
      var hfov_rad2 = Math.atan(Math.sqrt(2) * Math.tan(hfov_rad) / Math.sqrt(cw * cw + ch * ch));
      this._camera.fov = 2 * hfov_rad2 / GeoMath.DEGREE;
      return this._camera;
    }
    /**
     * @summary Sceneæç»å¦çç´åã«å¼ã°ãã
     */

  }, {
    key: "beforeRender",
    value: function beforeRender() {
      this._frame_buffer.bind();
    }
    /**
     * @summary Sceneæç»å¦çç´å¾ã«å¼ã°ãã
     */

  }, {
    key: "afterRender",
    value: function afterRender() {
      this._frame_buffer.unbind();
    }
    /**
     * @summary Sceneæç»å¦çãã­ã£ã³ã»ã«ãããã¨ãã«å¼ã°ãã
     */

  }, {
    key: "renderCanceled",
    value: function renderCanceled() {
      this._frame_buffer.unbind();
    }
    /**
     * @summary ridããæç»æ¸ã¿ãã¯ã¹ãã£ããèª­ãï¼1ã¹ãããåã®å¤ãè¿å´ãããï¼
     * @return {number}
     */

  }, {
    key: "readRid",
    value: function readRid() {
      var gl = this._glenv.context;
      var startRid = Date.now();

      this._frame_buffer.bind();

      var startRidRead, endRidRead;
      startRidRead = Date.now();
      gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, this._rid_value);
      endRidRead = Date.now(); // 4bit x4 ã®å¤ã 8bit x4 ã«æ ¼ç´ããã¦ããã

      /*
      const rid = Math.round(
          this._rid_value[0] / 17 << 12 |
          this._rid_value[1] / 17 <<  8 |
          this._rid_value[2] / 17 <<  4 |
          this._rid_value[3] / 17
      );
      */

      var rid = Math.round(COEFFICIENTS_RID[0] * Math.round(this._rid_value[0] / 17.0) + COEFFICIENTS_RID[1] * Math.round(this._rid_value[1] / 17.0) + COEFFICIENTS_RID[2] * Math.round(this._rid_value[2] / 17.0) + COEFFICIENTS_RID[3] * Math.round(this._rid_value[3] / 17.0));

      this._frame_buffer.unbind();

      var endRid = Date.now();

      if (endRid - startRid > 7) {
        console.log("Render and Read Index: " + (endRid - startRid) + "ms gl.readPixels:" + (endRidRead - startRidRead) + "ms");
      }

      return rid;
    }
    /**
     * @summary æ·±åº¦å¤ããæç»æ¸ã¿ãã¯ã¹ãã£ããèª­ã¿ï¼1ã¹ãããåã®å¤ãè¿å´ãããï¼ãGocsåº§æ¨ç³»ã«å¤æãã
     * @return {mapray.Matrix} view_to_clip Viewåº§æ¨ç³»ããã¯ãªããåº§æ¨ç³»ã¸ã®å¤æãããªãã¯ã¹
     * @return {mapray.Matrix} view_to_gocs Viewåº§æ¨ç³»ããViewåº§æ¨ç³»ã¸ã®å¤æãããªãã¯ã¹
     * @return {mapray.Vector3}
     */

  }, {
    key: "readDepth",
    value: function readDepth(view_to_clip, view_to_gocs) {
      var gl = this._glenv.context;
      var startDepth = Date.now();
      var startDepthRead, endDepthRead;

      this._depth_to_color_frame_buffer.bind();

      var depth_clip = 0;
      gl.viewport(0, 0, 1, 1);

      for (var i = 0; i < 2; i++) {
        var material = this._depth_to_color_materials[i];
        material.bindProgram();
        material.bindVertexAttribs(this._vertex_attribs);
        material.setInteger("u_sampler", 0);
        material.bindTexture2D(0, this._frame_buffer.depth_container);
        gl.depthFunc(gl.ALWAYS);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._index_buf);
        gl.drawElements(gl.TRIANGLES, this._indices_length, gl.UNSIGNED_SHORT, 0);
        gl.bindTexture(gl.TEXTURE_2D, null);
        startDepthRead = Date.now();
        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, this._depth_value);
        endDepthRead = Date.now(); // 4bit x4 ã®å¤ã 8bit x4 ã«æ ¼ç´ããã¦ããã => [0.0 ã 1.0]

        /*
        depth_clip += (
            this._depth_value[ 0 ] * Math.pow(2, i==0 ? -3  : -15) / 17.0 +
            this._depth_value[ 1 ] * Math.pow(2, i==0 ? -6  : -18) / 17.0 +
            this._depth_value[ 2 ] * Math.pow(2, i==0 ? -9  : -21) / 17.0 +
            this._depth_value[ 3 ] * Math.pow(2, i==0 ? -12 : -24) / 17.0
        );
        */

        var coef = COEFFICIENTS_DEPTH[i];

        for (var j = 0; j < 4; j++) {
          depth_clip += coef[j] * this._depth_value[j];
        }
      }

      this._depth_to_color_frame_buffer.unbind();

      depth_clip = 2.0 * depth_clip - 1.0; // [0.0 ã 1.0] => [-1.0 ã 1.0]

      var vtc = view_to_clip;
      /*
      const ctv = GeoMath.inverse(vtc, GeoMath.createMatrix());
      const v = GeoMath.mul( ctv, [ 0, 0, c ] );
      */

      var v = [vtc[8] / vtc[0], vtc[9] / vtc[5], -1.0, (depth_clip + vtc[10]) / vtc[14]]; // const point = GeoMath.mul_Av( view_to_gocs, v );

      var m = view_to_gocs;
      var w = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];
      var point = GeoMath.createVector3([(m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3]) / w, (m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3]) / w, (m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3]) / w]);
      var endDepth = Date.now();

      if (endDepth - startDepth > 7) {
        console.log("Render and Read Depth: " + (endDepth - startDepth) + "ms gl.readPixels:" + (endDepthRead - startDepthRead) + "ms");
      }

      return point;
    }
  }]);

  return PickTool;
}();

var COEFFICIENTS_RID = [];

for (var i$1 = 0; i$1 < 4; i$1++) {
  COEFFICIENTS_RID[i$1] = Math.pow(16, 3 - i$1);
}

var COEFFICIENTS_DEPTH = [[], []];

for (var _i = 0; _i < 4; _i++) {
  COEFFICIENTS_DEPTH[0][_i] = Math.pow(2, -3 * (_i + 1)) / 17.0;
  COEFFICIENTS_DEPTH[1][_i] = Math.pow(2, -3 * (_i + 5)) / 17.0;
}

var define_PASS_BASE_0 = "#define PASS_BASE 0";
var define_PASS_BASE_1 = "#define PASS_BASE 1";

/**
 * @summary æç»å¯¾è±¡
 * @enum {object}
 * @memberof mapray.AbstractRenderStage
 * @constant
 * @private
 */

var RenderTarget = {
  /**
   * éå¸¸ã®ã·ã¼ã³æç»
   */
  SCENE: {
    id: "SCENE"
  },

  /**
   * ãã¦ã¹ããã¯ãªã©ãRIDåå¾ãç®çã¨ããæç»
   */
  RID: {
    id: "RID"
  }
};
/**
 * @summary 1ãã¬ã¼ã åã®ã¬ã³ããªã³ã°ãå®è¡
 * @desc
 * {@link mapray.Viewer} ã¤ã³ã¹ã¿ã³ã¹ã¯ãã¬ã¼ã æ¯ã«ãã®ã¯ã©ã¹ã®ã¤ã³ã¹ã¿ã³ã¹ãçæãã¦ã¬ã³ããªã³ã°ãå®è¡ããã
 *
 * @memberof mapray
 * @private
 */

var AbstractRenderStage =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Viewer} viewer        ææèã§ãã Viewer
   * @param {mapray.Camera} camera        ã«ã¡ã©
   * @param {object} [renderInfo]         ã¬ã³ããªã³ã°é å
   * @param {number} [renderInfo.sx]      ã¬ã³ããªã³ã°é åã®xä½ç½®(ãã¥ã¼ãã¼ãä¸­å¤®ã0, å³æ¹åãæ­£ã¨ãã)
   * @param {number} [renderInfo.sy]      ã¬ã³ããªã³ã°é åã®yä½ç½®(ãã¥ã¼ãã¼ãä¸­å¤®ã0, ä¸æ¹åãæ­£ã¨ãã)
   * @param {number} [renderInfo.swidth]  ã¬ã³ããªã³ã°é åã®å¹
   * @param {number} [renderInfo.sheight] ã¬ã³ããªã³ã°é åã®é«ã
   */
  function AbstractRenderStage(viewer, camera, renderInfo) {
    _classCallCheck(this, AbstractRenderStage);

    this._viewer = viewer;
    this._glenv = viewer.glenv;
    this._width = camera.canvas_size.width;
    this._height = camera.canvas_size.height;

    if (this._width === 0 || this._height === 0) {
      // ç»ç´ ããªãã®ã§ã¬ã³ããªã³ã°ãçç¥
      this._rendering_cancel = true;
      return;
    } // _view_to_gocs, _gocs_to_view, _view_to_clip, _gocs_to_clip


    this._setupBasicMatrices(renderInfo, camera); // ã«ã¡ã©æå ±


    this._volume_planes = renderInfo.volume_planes; // è¦ä½ç©ã®å¹³é¢ãã¯ãã«éå (è¦ç¹ç©ºé)

    this._pixel_step = renderInfo.pixel_step; // ç»ç´ ã®å¤åé (è¦ç¹ç©ºé)
    // ã¢ãã«ã·ã¼ã³

    this._scene = viewer.scene; // ãªã½ã¼ã¹ã­ã£ãã·ã¥

    this._globe = viewer.globe;
    this._tile_texture_cache = viewer.tile_texture_cache;
    this._point_cloud_collection = viewer.point_cloud_collection; // å°å½¢

    this._flake_material = null;
    this._flake_list = null; // åéæåã¢ã¼ã

    this._translucent_mode = false; // ãã¬ã¼ã éã®ãªãã¸ã§ã¯ãã­ã£ãã·ã¥

    var render_cache = viewer._render_cache || (viewer._render_cache = {});

    if (!render_cache.surface_material) {
      render_cache.surface_material = new SurfaceMaterial(viewer);
      render_cache.wireframe_material = new WireframeMaterial(viewer);
    }

    if (!render_cache.surface_pick_material) {
      render_cache.surface_pick_material = new SurfaceMaterial(viewer, {
        ridMaterial: true
      });
    } // ãããã°çµ±è¨


    this._debug_stats = viewer.debug_stats;
  }
  /**
   * åéæåã¢ã¼ããåå¾ãã¨ã³ãã£ãã£ã¢ãã«ãåéæåãã¦æç»ããã
   * Sceneãã¨ã³ãã£ãã£ã¸"åéæåã¢ã¼ã"ãä¼éããã®ã«ç¨ããã
   * @see mapray.Entity#anchor_mode
   * @return {boolean}
   * @private
   */


  _createClass(AbstractRenderStage, [{
    key: "getTranslucentMode",
    value: function getTranslucentMode() {
      return this._translucent_mode;
    }
    /**
     * @summary åéæåã¢ã¼ããè¨­å®ã
     * @see getTranslucentMode()
     * @parm {boolean} transparent_mode
     * @private
     */

  }, {
    key: "setTranslucentMode",
    value: function setTranslucentMode(translucent_mode) {
      this._translucent_mode = translucent_mode;
    }
    /**
     * @private
     */

  }, {
    key: "_setupBasicMatrices",
    value: function _setupBasicMatrices(renderInfo, camera) {
      this._view_to_gocs = camera.view_to_gocs;
      this._gocs_to_view = GeoMath.createMatrix();
      GeoMath.inverse_A(this._view_to_gocs, this._gocs_to_view);
      this._view_to_clip = renderInfo.view_to_clip;
      this._gocs_to_clip = GeoMath.createMatrix();
      GeoMath.mul_PzA(this._view_to_clip, this._gocs_to_view, this._gocs_to_clip);
    }
    /**
     * @type {RenderTarget}
     * @abstract
     */

  }, {
    key: "getRenderTarget",
    value: function getRenderTarget() {
      throw new Error("not implemented");
    }
    /**
     * @summary Sceneãã¬ã³ããªã³ã°ãç¢ºå®ãããã¨ãéç¥
     * pick_objectã¯ãprimitiveãpickãããã¨ãã«è¿å´ãã¹ããªãã¸ã§ã¯ããæå®ããã
     * @param {Primitive} primitive
     * @param {mapray.Entity} [pick_object]
     * @abstract
     */

  }, {
    key: "onPushPrimitive",
    value: function onPushPrimitive(primitive, pick_object) {}
    /**
     * @summary 1ãã¬ã¼ã ã®ã¬ã³ããªã³ã°ãå®è¡
     * @abstract
     */

  }, {
    key: "render",
    value: function render() {
      throw new Error("not implemented");
    }
    /**
     * @summary 1ãã¬ã¼ã ã®ã¬ã³ããªã³ã°ãå®è¡
     * @abstract
     * @private
     */

  }, {
    key: "_render",
    value: function _render() {
      var gl = this._glenv.context; // æç»é åå¨ä½ã«ãã¥ã¼ãã¼ããè¨­å®

      gl.viewport(0, 0, this._width, this._height);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.depthMask(true);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      if (this._rendering_cancel) return; // å°è¡¨æ­çãã¼ã¿ã®åé

      if (this._globe.status !== Globe.Status.READY) {
        // ã¾ã åºåºã¿ã¤ã«ãã¼ã¿ãèª­ã¿è¾¼ã¾ãã¦ããªãã®ã§å°è¡¨ãã¬ã³ããªã³ã°ã§ããªã
        this._rendering_cancel = true;
        return;
      }

      gl.enable(gl.CULL_FACE);
      gl.enable(gl.DEPTH_TEST);
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE); // FB ã®Î±å¤ã¯å¤ããªã

      gl.depthFunc(gl.LEQUAL);
      var collector = new FlakeCollector(this);
      this._flake_list = collector.traverse();

      var vis_ground = this._viewer.getVisibility(Viewer.Category.GROUND);

      var vis_entity = this._viewer.getVisibility(Viewer.Category.ENTITY); // ãã¹ã¦ã®å°è¡¨æ­çãæç»


      this._prepare_draw_flake();

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._flake_list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var rflake = _step.value;
          var fro = rflake.getRenderObject();

          if (vis_ground) {
            this._draw_flake_base(rflake, fro.getBaseMesh());
          }

          if (vis_entity) {
            this._draw_entities_on_flake(fro);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._draw_point_cloud(); // ã¢ãã«ã·ã¼ã³æç»


      if (vis_entity) {
        this._scene.draw(this);
      }
    }
    /**
     * @summary å°è¡¨æ­çãæç»ããåã®æºå
     *
     * @private
     */

  }, {
    key: "_prepare_draw_flake",
    value: function _prepare_draw_flake() {
      // RenderFlake#getRenderObject() ã®åã«å¿è¦ãªå¦ç
      var producers = this._scene.getFlakePrimitiveProducers();

      this._globe.putNextEntityProducers(producers);
    }
    /**
     * @summary å°è¡¨ã¨ã¬ã¤ã¤ã¼ãæç»
     *
     * @param {mapray.RenderFlake} rflake  å°è¡¨æ­çãã¼ã¿
     * @param {mapray.FlakeMesh}   mesh    å°è¡¨æ­çã¡ãã·ã¥
     *
     * @private
     */

  }, {
    key: "_draw_flake_base",
    value: function _draw_flake_base(rflake, mesh) {
      var gl = this._glenv.context;
      var material = this._flake_material;
      material.bindProgram();
      var num_drawings = material.numDrawings(); // ä¸çªä¸ã®ä¸éæå°è¡¨

      if (material.setFlakeParameter(this, rflake, mesh, 0)) {
        gl.disable(gl.BLEND);
        gl.depthMask(true);
        mesh.draw(material);
      } // ã¬ã¤ã¤ã¼ã®å°è¡¨ (åéæã®å¯è½æ§ãã)


      for (var i = 1; i < num_drawings; ++i) {
        var mat = this._viewer.layers.getDrawingLayer(i - 1).getMateral();

        if (material !== mat) {
          material = mat;
          material.bindProgram();
        }

        if (material.setFlakeParameter(this, rflake, mesh, i)) {
          if (this.getRenderTarget() === RenderTarget.SCENE) {
            gl.enable(gl.BLEND);
          }

          gl.depthMask(false);
          mesh.draw(material);
        }
      } // æç»å°è¡¨æ­é ç¹æ°ãè¨é²


      var stats = this._debug_stats;

      if (stats !== null) {
        stats.num_drawing_flake_vertices += mesh.num_vertices;
      }
    }
    /**
     * @summary å°è¡¨æ­çä¸ã®ã¨ã³ãã£ãã£ãæç»
     *
     * @param {mapray.FlakeRenderObject} fro  FlakeRenderObject ã¤ã³ã¹ã¿ã³ã¹
     *
     * @private
     */

  }, {
    key: "_draw_entities_on_flake",
    value: function _draw_entities_on_flake(fro) {
      var num_entities = fro.num_entities;

      if (num_entities == 0) {
        // ã¨ã³ãã£ãã£ãªã
        return;
      }

      var gl = this._glenv.context;
      gl.enable(gl.POLYGON_OFFSET_FILL);
      gl.depthMask(false); // å°è¡¨ã«å¼µãä»ãã¦ãããã¨ãåæãªã®ã§æ·±åº¦ã¯å¤æ´ããªã
      // todo: ä»®ã®ããªã´ã³ãªãã»ãã
      // å®é¨ã§å¾ãé©åãªå¤ (Windows, GeForce GT750)
      //   Chrome+ANGLE: -8, -8
      //   Chrome+EGL: -40, -40

      gl.polygonOffset(-8, -8); // éæè²ã®ãããªã¢ã«ã§ãã£ã¦ããRIDæç»æã¯ gl.BLEND ãç¡å¹ã«ããã

      var setBlend;

      if (this.getRenderTarget() === RenderTarget.SCENE) {
        setBlend = function setBlend(enable) {
          if (enable) gl.enable(gl.BLEND);else gl.disable(gl.BLEND);
        };
      } else {
        gl.disable(gl.BLEND);

        setBlend = function setBlend() {};
      }

      for (var i = 0; i < num_entities; ++i) {
        var _fro$getEntityPrimiti = fro.getEntityPrimitive(i, this),
            primitive = _fro$getEntityPrimiti.primitive,
            entity = _fro$getEntityPrimiti.entity;

        setBlend(primitive.isTranslucent(this));
        this.onPushPrimitive(primitive, entity);
        primitive.draw(this);
      }

      gl.depthMask(true);
      gl.disable(gl.POLYGON_OFFSET_FILL);
    }
  }, {
    key: "_draw_point_cloud",
    value: function _draw_point_cloud() {}
  }]);

  return AbstractRenderStage;
}();
/**
 * @summary 1ãã¬ã¼ã åã®ã¬ã³ããªã³ã°ãå®è¡
 * @desc
 * {@link mapray.Viewer} ã¤ã³ã¹ã¿ã³ã¹ã¯ãã¬ã¼ã æ¯ã«ãã®ã¯ã©ã¹ã®ã¤ã³ã¹ã¿ã³ã¹ãçæãã¦ã¬ã³ããªã³ã°ãå®è¡ããã
 *
 * @memberof mapray
 * @private
 */


var RenderStage =
/*#__PURE__*/
function (_AbstractRenderStage) {
  _inherits(RenderStage, _AbstractRenderStage);

  /**
   * @param viewer {mapray.Viewer}  ææèã§ãã Viewer
   */
  function RenderStage(viewer) {
    var _this;

    _classCallCheck(this, RenderStage);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RenderStage).call(this, viewer, viewer.camera, viewer.camera.createRenderInfo())); // å°è¡¨ãããªã¢ã«ã®é¸æ

    _this._flake_material = viewer.render_mode === Viewer.RenderMode.WIREFRAME ? viewer._render_cache.wireframe_material : viewer._render_cache.surface_material;
    return _this;
  }
  /**
   * @type {RenderTarget}
   * @override
   */


  _createClass(RenderStage, [{
    key: "getRenderTarget",
    value: function getRenderTarget() {
      return RenderTarget.SCENE;
    }
    /**
     * @summary 1ãã¬ã¼ã ã®ã¬ã³ããªã³ã°ãå®è¡
     * @override
     */

  }, {
    key: "render",
    value: function render() {
      this._render();

      if (this._rendering_cancel) return; // æç»å°è¡¨æ­çæ°ãè¨é²

      var stats = this._debug_stats;

      if (stats !== null) {
        stats.num_drawing_flakes = this._flake_list.length;
      } // ãã¬ã¼ã çµäºå¦ç


      this._globe.endFrame();

      this._tile_texture_cache.endFrame();

      this._viewer.layers.endFrame();
    }
    /**
     * @summary ç¹ç¾¤ãæç»
     *
     * @private
     */

  }, {
    key: "_draw_point_cloud",
    value: function _draw_point_cloud() {
      // const debug_handlers = PointCloud.getDebugHandlers() || {};
      var traverseDataRequestQueue = PointCloud.getTraverseDataRequestQueue();
      var traverseData = traverseDataRequestQueue.length === 0 ? null : [];
      var s = PointCloud.getStatistics() || {}; // const statistics = ;

      if (s.statistics_obj) s.statistics_obj.clear();

      for (var i = 0; i < this._point_cloud_collection.length; ++i) {
        if (s.statistics_obj) s.statistics_obj.start();

        var point_cloud = this._point_cloud_collection.get(i);

        var load_limit = Math.max(0, 10 - point_cloud.provider.getNumberOfRequests());
        var pcb_collector = new PointCloudBoxCollector(this, load_limit);
        var traverse_result = pcb_collector.traverse(point_cloud, s.statistics_obj);
        if (s.statistics_obj) s.statistics_obj.doneTraverse();

        if (point_cloud.provider.isReady()) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = traverse_result.load_boxes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var ro = _step2.value;
              ro.box.load();
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = traverse_result.visible_boxes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _ro = _step3.value;

            _ro.draw(this, s.statistics_obj);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        point_cloud.provider.flushQueue();

        if (traverseData) {
          traverseData.push({
            point_cloud: point_cloud,
            pcb_collection: traverse_result.visible_boxes
          });
        }

        if (s.statistics_obj) s.statistics_obj.done();
      }

      if (traverseData) {
        for (var _i = 0; _i < traverseDataRequestQueue.length; _i++) {
          traverseDataRequestQueue[_i](traverseData);
        }
      }

      if (s.statistics_handler) {
        s.statistics_handler(s.statistics_obj);
      }
    }
  }]);

  return RenderStage;
}(AbstractRenderStage);
/**
 * @summary ãã¦ã¹ããã¯ç¨ã«1ãã¬ã¼ã åã®ã¬ã³ããªã³ã°ãå®è¡
 * @desc
 * {@link mapray.Viewer} ã®pické¢æ°åã§ã¤ã³ã¹ã¿ã³ã¹ãçæããã¬ã³ããªã³ã°ãå®è¡ãããã
 *
 * @memberof mapray
 * @private
 */


var PickStage =
/*#__PURE__*/
function (_AbstractRenderStage2) {
  _inherits(PickStage, _AbstractRenderStage2);

  /**
   * @param {mapray.Viewer} viewer  ææèã§ãã Viewer
   * @param {number} size ãªãã¹ã¯ãªã¼ã³å¹ = ãªãã¹ã¯ãªã¼ã³é«ã
   * @param {mapray.Vector2} screen_pos ã¹ã¯ãªã¼ã³ä¸ã®ãã¯ã»ã«ä½ç½®
   */
  function PickStage(viewer, screen_pos) {
    var _this2;

    _classCallCheck(this, PickStage);

    var pick_tool = viewer.pick_tool_cache || (viewer.pick_tool_cache = new PickTool(viewer.glenv));
    var camera = pick_tool.pickCamera(viewer.camera, screen_pos);
    var renderInfo = camera.createRenderInfo(+screen_pos[0] - viewer.camera.canvas_size.width / 2, -screen_pos[1] + viewer.camera.canvas_size.height / 2);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(PickStage).call(this, viewer, camera, renderInfo)); // å°è¡¨ãããªã¢ã«ã®é¸æ

    _this2._flake_material = viewer._render_cache.surface_pick_material;
    _this2._pick_tool = pick_tool;
    _this2._rid_map = [null]; // rid == 0 ã¯è¦ç´ ãªããæå³ãã

    _this2._pick_result = {};
    return _this2;
  }
  /**
   * @override
   */


  _createClass(PickStage, [{
    key: "onPushPrimitive",
    value: function onPushPrimitive(primitive, pick_object) {
      primitive.rid = this._rid_map.length;

      this._rid_map.push(pick_object);
    }
    /**
     * @type {RenderTarget}
     * @override
     */

  }, {
    key: "getRenderTarget",
    value: function getRenderTarget() {
      return RenderTarget.RID;
    }
    /**
     * ã¹ã¯ãªã¼ã³ã®ä»»æã®ç¹ã«ãããä¸æ¬¡åä½ç½®ãæç»å¯¾è±¡ã«é¢ããæå ±ãåå¾ãã¾ãã
     * @return ä½ç½®æå ±ãæç»å¯¾è±¡ã«é¢ããæå ±
     * @override
     */

  }, {
    key: "render",
    value: function render() {
      var pick_tool = this._pick_tool;
      pick_tool.beforeRender();
      var gl = this._glenv.context;
      gl.disable(gl.DITHER);

      this._render();

      gl.enable(gl.DITHER);

      if (this._rendering_cancel) {
        pick_tool.renderCanceled();
        return;
      }

      pick_tool.afterRender();
      var rid = pick_tool.readRid();

      if (rid > 0) {
        var pick_object = this._rid_map[rid];

        if (pick_object instanceof Entity) {
          this._pick_result.entity = pick_object;
        }
      }

      this._pick_result.point = pick_tool.readDepth(this._view_to_clip, this._view_to_gocs);
    }
    /**
     * @type {mapray.Viewer.PickResult}
     */

  }, {
    key: "pick_result",
    get: function get() {
      return this._pick_result;
    }
  }]);

  return PickStage;
}(AbstractRenderStage);

/**
 * @summary ã¯ã¬ãã³ã·ã£ã«ã¢ã¼ã
 * @desc
 * <p>HTTP ãªã¯ã¨ã¹ãã®ã¯ã¬ãã³ã·ã£ã«ã¢ã¼ããè¡¨ç¾ããåã§ããã<p>
 * @enum {object}
 * @memberof mapray
 * @constant
 * @see https://developer.mozilla.org/docs/Web/API/Request/credentials
 * @see mapray.StandardDemProvider
 */
var CredentialMode = {
  /**
   * æ±ºãã¦ã¯ãã­ã¼ãéä¿¡ããªã
   */
  OMIT: {
    id: "OMIT",
    credentials: "omit"
  },

  /**
   * URL ãå¼ã³åºãåã®ã¹ã¯ãªããã¨åä¸ãªãªã¸ã³ã ã£ãå ´åã®ã¿ãã¯ãã­ã¼ãéä¿¡
   */
  SAME_ORIGIN: {
    id: "SAME_ORIGIN",
    credentials: "same-origin"
  },

  /**
   * ã¯ã­ã¹ãªãªã¸ã³ã®å¼ã³åºãã§ãã£ã¦ããå¸¸ã«ã¯ãã­ã¼ãéä¿¡
   */
  INCLUDE: {
    id: "INCLUDE",
    credentials: "include"
  }
};

/**
 * @summary æ¨æºå°å³ç»åãã­ãã¤ã
 * @classdesc
 * <p>æ±ç¨çãªå°å³ç»åãã­ãã¤ãã®å®è£ã§ããã</p>
 * <p>æ§ç¯å­ã®å¼æ°ã« prefix, suffix, size, zmin, zmax ãä¸ããå ´åãåã¡ã½ããã®åä½ã¯ä»¥ä¸ã®ããã«ãªãã
 * ããã§ c1, c2, c3 ã¯ opts.coord_order ã®æå®ã«å¾ã£ãç¬¬1ãç¬¬2ãç¬¬3ã®åº§æ¨ã§ããã</p>
 * <pre>
 *   requestTile( z, x, y ) -> URL ã prefix + c1 + '/' + c2 + '/' + c3 + suffix ã®ç»åãè¦æ±
 *   getImageSize()         -> size ãè¿ã
 *   getZoomLevelRange()    -> new ImageProvider.Range( zmin, zmax ) ãè¿ã
 * </pre>
 * @memberof mapray
 * @extends mapray.ImageProvider
 */

var StandardImageProvider =
/*#__PURE__*/
function (_ImageProvider) {
  _inherits(StandardImageProvider, _ImageProvider);

  /**
   * @param {string} prefix  URL ã®åé ­æå­å
   * @param {string} suffix  URL ã®æ«å°¾æå­å
   * @param {number} size    å°å³ã¿ã¤ã«ç»åã®å¯¸æ³
   * @param {number} zmin    æå°ãºã¼ã ã¬ãã«
   * @param {number} zmax    æå¤§ãºã¼ã ã¬ãã«
   * @param {object} [opts]  ãªãã·ã§ã³éå
   * @param {mapray.StandardImageProvider.CoordOrder}  [opts.coord_order=ZXY]          URL ã®åº§æ¨é åº
   * @param {mapray.StandardImageProvider.CoordSystem} [opts.coord_system=UPPER_LEFT]  ã¿ã¤ã« XY åº§æ¨ç³»
   * @param {mapray.CredentialMode}                    [opts.credentials=SAME_ORIGIN]  ã¯ã¬ãã³ã·ã£ã«ã¢ã¼ã
   */
  function StandardImageProvider(prefix, suffix, size, zmin, zmax, opts) {
    var _this;

    _classCallCheck(this, StandardImageProvider);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(StandardImageProvider).call(this));
    _this._prefix = prefix;
    _this._suffix = suffix;
    _this._size = size;
    _this._min_level = zmin;
    _this._max_level = zmax; // ã¿ã¤ã«åº§æ¨ãä¸¦ã³æ¿ããé¢æ°

    var orderCoords;

    if (opts && opts.coord_order) {
      if (opts.coord_order === CoordOrder.ZYX) {
        orderCoords = function orderCoords(z, x, y) {
          return z + "/" + y + "/" + x;
        };
      } else if (opts.coord_order === CoordOrder.XYZ) {
        orderCoords = function orderCoords(z, x, y) {
          return x + "/" + y + "/" + z;
        };
      }
    }

    if (!orderCoords) {
      // ãã®ä»ã®å ´åã¯æ¢å®å¤ COORD_ORDER_ZXY ãä½¿ã
      orderCoords = function orderCoords(z, x, y) {
        return z + "/" + x + "/" + y;
      };
    } // XY åº§æ¨ãå¤æããé¢æ°


    var convCoords;

    if (opts && opts.coord_system) {
      if (opts.coord_system === CoordSystem.LOWER_LEFT) {
        convCoords = function convCoords(z, x, y) {
          var size = Math.round(Math.pow(2, z));
          return orderCoords(z, x, size - y - 1);
        };
      }
    }

    if (!convCoords) {
      // ãã®ä»ã®å ´åã¯æ¢å®å¤ UPPER_LEFT (ç¡å¤æ) ãä½¿ã
      convCoords = orderCoords;
    } // åº§æ¨é¨åã® URL ãåå¾ããé¢æ°


    _this._coords_part = convCoords; // crossorigin å±æ§ã®å¤

    _this._crossOrigin = "anonymous";

    if (opts && opts.credentials) {
      if (opts.credentials === CredentialMode.OMIT) {
        _this._crossOrigin = null;
      } else if (opts.credentials === CredentialMode.INCLUDE) {
        _this._crossOrigin = "use-credentials";
      }
    }

    return _this;
  }
  /**
   * @override
   */


  _createClass(StandardImageProvider, [{
    key: "requestTile",
    value: function requestTile(z, x, y, callback) {
      var image = new Image();

      image.onload = function () {
        callback(image);
      };

      image.onerror = function () {
        callback(null);
      };

      if (this._crossOrigin !== null) {
        image.crossOrigin = this._crossOrigin;
      }

      image.src = this._makeURL(z, x, y);
      return image; // è¦æ± ID (å®æã¯ Image)
    }
    /**
     * @override
     */

  }, {
    key: "cancelRequest",
    value: function cancelRequest(id) {} // TODO: Image èª­ã¿è¾¼ã¿ã®åãæ¶ãæ¹æ³ã¯ä¸æ

    /**
     * @override
     */

  }, {
    key: "getImageSize",
    value: function getImageSize() {
      return this._size;
    }
    /**
     * @override
     */

  }, {
    key: "getZoomLevelRange",
    value: function getZoomLevelRange() {
      return new ImageProvider.Range(this._min_level, this._max_level);
    }
    /**
     * URL ãä½æ
     * @private
     */

  }, {
    key: "_makeURL",
    value: function _makeURL(z, x, y) {
      return this._prefix + this._coords_part(z, x, y) + this._suffix;
    }
  }]);

  return StandardImageProvider;
}(ImageProvider);
/**
 * @summary URL åº§æ¨é åºã®åæå
 * @desc
 * {@link mapray.StandardImageProvider} ã®æ§ç¯å­ã§ opts.coord_order ãã©ã¡ã¼ã¿ã«æå®ããå¤ã®åã§ããã
 * @enum {object}
 * @memberof mapray.StandardImageProvider
 * @constant
 */


var CoordOrder = {
  /**
   * åº§æ¨é åº Z/X/Y (æ¢å®å¤)
   */
  ZXY: {
    id: "ZXY"
  },

  /**
   * åº§æ¨é åº Z/Y/X
   */
  ZYX: {
    id: "ZYX"
  },

  /**
   * åº§æ¨é åº Z/X/Y
   */
  XYZ: {
    id: "XYZ"
  }
};
/**
 * @summary ã¿ã¤ã« XY åº§æ¨ç³»ã®åæå
 * @desc
 * {@link mapray.StandardImageProvider} ã®æ§ç¯å­ã§ opts.coord_system ãã©ã¡ã¼ã¿ã«æå®ããå¤ã®åã§ããã
 * @enum {object}
 * @memberof mapray.StandardImageProvider
 * @constant
 */

var CoordSystem = {
  /**
   * åç¹:å·¦ä¸, Xè»¸:å³æ¹å, Yè»¸:ä¸æ¹å (æ¢å®å¤)
   */
  UPPER_LEFT: {
    id: "UPPER_LEFT"
  },

  /**
   * åç¹:å·¦ä¸, Xè»¸:å³æ¹å, Yè»¸:ä¸æ¹å
   */
  LOWER_LEFT: {
    id: "LOWER_LEFT"
  }
}; // ã¯ã©ã¹å®æ°ã®å®ç¾©

{
  StandardImageProvider.CoordOrder = CoordOrder;
  StandardImageProvider.CoordSystem = CoordSystem;
}

var nativeAssign = Object.assign;
var defineProperty$9 = Object.defineProperty; // `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign

var objectAssign = !nativeAssign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (descriptors && nativeAssign({
    b: 1
  }, nativeAssign(defineProperty$9({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty$9(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), {
    b: 2
  })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)

  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) {
    B[chr] = chr;
  });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  var propertyIsEnumerable = objectPropertyIsEnumerable.f;

  while (argumentsLength > index) {
    var S = indexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  }

  return T;
} : nativeAssign;

// https://tc39.github.io/ecma262/#sec-object.assign

_export({
  target: 'Object',
  stat: true,
  forced: Object.assign !== objectAssign
}, {
  assign: objectAssign
});

/**
 * @summary DEM ãã¼ã¿ãã­ãã¤ã
 * @classdesc
 * <p>ã¬ã³ãã©ã¼ã« DEM ãã¼ã¿ãä¸ããããã®æ½è±¡ã¯ã©ã¹ã§ããã</p>
 * <p>ä»¥ä¸ã®æ½è±¡ã¡ã½ããã¯æ¢å®ã®åä½ããªãã®ã§ãå©ç¨èã¯ãããã®ã¡ã½ããããªã¼ãã©ã¤ãããå·è±¡ã¯ã©ã¹ãä½¿ç¨ããªããã°ãªããªãã</p>
 * <ul>
 *   <li>[requestTile()]{@link mapray.DemProvider#requestTile}</li>
 *   <li>[cancelRequest()]{@link mapray.DemProvider#cancelRequest}</li>
 * </ul>
 * <p>[getResolutionPower()]{@link mapray.DemProvider#getResolutionPower} ã®æ¢å®ã®å®è£ã¯ 8 ãè¿ããDEM ã¿ã¤ã«ã®è§£ååº¦ã 256 ä»¥å¤ã®ã¨ãã¯ãã®ã¡ã½ããããªã¼ãã¼ã­ã¼ãããå¿è¦ãããã</p>
 * @memberof mapray
 * @abstract
 * @protected
 * @see mapray.StandardDemProvider
 * @see mapray.Viewer
 */
var DemProvider =
/*#__PURE__*/
function () {
  function DemProvider() {
    _classCallCheck(this, DemProvider);
  }

  _createClass(DemProvider, [{
    key: "requestTile",

    /**
     * @summary DEM ã¿ã¤ã«ãã¼ã¿ãè¦æ±
     * @desc
     * <p>åº§æ¨ã (z, x, y) ã® DEM ã¿ã¤ã«ãã¼ã¿ãè¦æ±ããã</p>
     * <p>æå®ããã¿ã¤ã«ãã¼ã¿ã®åå¾ãæåã¾ãã¯å¤±æããã¨ãã« callback ãéåæã«å¼ã³åºãããªããã°ãªããªãã</p>
     * <p>ã ãã [cancelRequest()]{@link mapray.DemProvider#cancelRequest} ã«ããè¦æ±ãåãæ¶ãããã¨ããcallback ã¯å¼ã³åºãã¦ãå¼ã³åºããªãã¦ããããã¾ãéåæå¼ã³åºãã§ããå¿è¦ããªãã</p>
     * @param  {number}   z  ãºã¼ã ã¬ãã«
     * @param  {number}   x  X ã¿ã¤ã«åº§æ¨
     * @param  {number}   y  Y ã¿ã¤ã«åº§æ¨
     * @param  {mapray.DemProvider.RequestCallback} callback  è¦æ±ã³ã¼ã«ããã¯é¢æ°
     * @return {object}   è¦æ± ID ([cancelRequest()]{@link mapray.DemProvider#cancelRequest} ã«ä¸ãããªãã¸ã§ã¯ã)
     * @abstract
     */
    value: function requestTile(z, x, y, callback) {
      throw new Error("mapray.DemProvider#requestTile() method has not been overridden.");
    }
    /**
     * @summary DEM ã¿ã¤ã«ãã¼ã¿ã®è¦æ±ãåãæ¶ã
     * <p>[requestTile()]{@link mapray.DemProvider#requestTile} ã«ããè¦æ±ãå¯è½ã§ããã°åãæ¶ãã</p>
     * @param {object} id  è¦æ± ID ([requestTile()]{@link mapray.DemProvider#requestTile} ããå¾ããªãã¸ã§ã¯ã)
     * @abstract
     */

  }, {
    key: "cancelRequest",
    value: function cancelRequest(id) {
      throw new Error("mapray.DemProvider#cancelRequest() method has not been overridden.");
    }
    /** 
     * @summary è§£ååº¦ã®ææ°ãåå¾
     * @desc
     * <p>DEM ã¿ã¤ã«ãã¼ã¿è§£ååº¦ã®ã2 ãåºã¨ããå¯¾æ°ãåå¾ãããDEM ã¿ã¤ã«ãã¼ã¿ã®è§£ååº¦ã¯å¿ã 2 ã®ã¹ãä¹ã§ããã</p>
     * <p>å¶é: this ãåããªãå¸¸ã«åãå¤ãè¿ããªããã°ãªããªãã</p>
     * @return {number}  è§£ååº¦ææ°
     * @abstract
     */

  }, {
    key: "getResolutionPower",
    value: function getResolutionPower() {
      return 8;
    }
  }]);

  return DemProvider;
}();

/**
 * @summary æ¨æº DEM ãã­ãã¤ã
 * @classdesc
 * <p>æ±ç¨çãª DEM ãã­ãã¤ãã®å®è£ã§ããã</p>
 * <p>æ§ç¯å­ã®å¼æ°ã« prefix ãä¸ããå ´åãåã¡ã½ããã®åä½ã¯ä»¥ä¸ã®ããã«ãªãã
 * <pre>
 *   requestTile( z, x, y ) -> URL ã prefix + z + '/' + x + '/' + y + suffix ã®ãã¼ã¿ãè¦æ±
 * </pre>
 * @memberof mapray
 * @extends mapray.DemProvider
 */

var StandardDemProvider =
/*#__PURE__*/
function (_DemProvider) {
  _inherits(StandardDemProvider, _DemProvider);

  /**
   * @param {string} prefix     URL ã®åé ­æå­å
   * @param {string} suffix     URL ã®æ«å°¾æå­å
   * @param {object} [options]  ãªãã·ã§ã³éå
   * @param {mapray.CredentialMode} [options.credentials=OMIT]  ã¯ã¬ãã³ã·ã£ã«ã¢ã¼ã
   * @param {object} [options.headers={}]  ãªã¯ã¨ã¹ãã«è¿½å ãããããã¼ã®è¾æ¸
   */
  function StandardDemProvider(prefix, suffix, options) {
    var _this;

    _classCallCheck(this, StandardDemProvider);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(StandardDemProvider).call(this));
    var opts = options || {};
    _this._prefix = prefix;
    _this._suffix = suffix;
    _this._credentials = (opts.credentials || CredentialMode.OMIT).credentials;
    _this._headers = Object.assign({}, opts.headers);
    return _this;
  }
  /**
   * @override
   */


  _createClass(StandardDemProvider, [{
    key: "requestTile",
    value: function requestTile(z, x, y, callback) {
      var actrl = new AbortController();
      fetch(this._makeURL(z, x, y), {
        credentials: this._credentials,
        headers: this._headers,
        signal: actrl.signal
      }).then(function (response) {
        return response.ok ? response.arrayBuffer() : Promise.reject(Error(response.statusText));
      }).then(function (buffer) {
        // ãã¼ã¿åå¾ã«æå
        callback(buffer);
      })["catch"](function () {
        // ãã¼ã¿åå¾ã«å¤±æã¾ãã¯åãæ¶ã
        callback(null);
      });
      return actrl;
    }
    /**
     * @override
     */

  }, {
    key: "cancelRequest",
    value: function cancelRequest(id) {
      var actrl = id; // è¦æ± ID ã AbortController ã«å¤æ

      actrl.abort(); // åãæ¶ããã®ã§è¦æ±ãä¸­æ­¢
    }
    /**
     * URL ãä½æ
     * @private
     */

  }, {
    key: "_makeURL",
    value: function _makeURL(z, x, y) {
      return this._prefix + z + '/' + x + '/' + y + this._suffix;
    }
  }]);

  return StandardDemProvider;
}(DemProvider);

/**
 * @summary å°å³ã¬ã¤ã¤ã¼ç®¡ç
 * @classdesc
 * <p>å°å³ã¬ã¤ã¤ã¼ãç®¡çãããªãã¸ã§ã¯ãã§ããã</p>
 * <p>ã¤ã³ã¹ã¿ã³ã¹ã¯ {@link mapray.Viewer#layers} ããå¾ããã¨ãã§ããã</p>
 *
 * @hideconstructor
 * @memberof mapray
 * @see mapray.Layer
 */

var LayerCollection =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Viewer} viewer  Viewer
   * @param {array}         layers  åæåãã­ããã£éå
   */
  function LayerCollection(viewer, layers) {
    _classCallCheck(this, LayerCollection);

    this._viewer = viewer;
    this._glenv = viewer._glenv;
    this._layers = [];
    this._draw_layers = null; // åæã¬ã¤ã¤ã¼ãè¿½å 

    for (var i = 0; i < layers.length; ++i) {
      this.add(layers[i]);
    }
  }
  /**
   * @summary Viewerãåå¾
   * @type {mapray.Viewer}
   * @readonly
   * @package
   */


  _createClass(LayerCollection, [{
    key: "getLayer",

    /**
     * @summary ã¬ã¤ã¤ã¼ãåå¾
     *
     * @param  {number} index  ã¬ã¤ã¤ã¼ã®å ´æ
     * @return {mapray.Layer}    ã¬ã¤ã¤ã¼
     */
    value: function getLayer(index) {
      return this._layers[index];
    }
    /**
     * @summary ãã¹ã¦ã®ã¬ã¤ã¤ã¼ãåé¤
     */

  }, {
    key: "clear",
    value: function clear() {
      while (this.num_layers() > 0) {
        this.remove(0);
      }
    }
    /**
     * @summary ã¬ã¤ã¤ã¼ãæ«å°¾ã«è¿½å 
     *
     * @param {object|mapray.ImageProvider} layer          ã¬ã¤ã¤ã¼ã®ãã­ããã£
     * @param {mapray.ImageProvider} layer.image_provider  ç»åãã­ãã¤ã
     * @param {boolean}              [layer.visibility]    å¯è¦æ§ãã©ã°
     * @param {number}               [layer.opacity]       ä¸éæåº¦
     */

  }, {
    key: "add",
    value: function add(layer) {
      this.insert(this.num_layers, layer);
    }
    /**
     * @summary ã¬ã¤ã¤ã¼ãæ«å°¾ã«è¿½å 
     *
     * @param {number}                      index          æ¿å¥å ´æ
     * @param {object|mapray.ImageProvider} layer          ã¬ã¤ã¤ã¼ã®ãã­ããã£
     * @param {mapray.ImageProvider} layer.image_provider  ç»åãã­ãã¤ã
     * @param {boolean}              [layer.visibility]    å¯è¦æ§ãã©ã°
     * @param {number}               [layer.opacity]       ä¸éæåº¦
     */

  }, {
    key: "insert",
    value: function insert(index, layer) {
      this._layers.splice(index, 0, new Layer(this, layer));

      this.dirtyDrawingLayers();
    }
    /**
     * @summary ç¹å®ã®ã¬ã¤ã¤ã¼ãåé¤
     *
     * @param {number} index  åé¤å ´æ
     */

  }, {
    key: "remove",
    value: function remove(index) {
      this._layers.splice(index, 1);

      this.dirtyDrawingLayers();
    }
    /**
     * @summary æç»ã¬ã¤ã¤ã¼æ°ãåå¾
     *
     * @return {number}  æç»ã¬ã¤ã¤ã¼æ°
     * @package
     */

  }, {
    key: "numDrawingLayers",
    value: function numDrawingLayers() {
      if (this._draw_layers === null) {
        this._updataDrawingLayers();
      }

      return this._draw_layers.length;
    }
    /**
     * @summary æç»ã¬ã¤ã¤ã¼ãåå¾
     *
     * @param  {number} index  ã¬ã¤ã¤ã¼ã®å ´æ
     * @return {mapray.Layer}  ã¬ã¤ã¤ã¼
     * @package
     */

  }, {
    key: "getDrawingLayer",
    value: function getDrawingLayer(index) {
      if (this._draw_layers === null) {
        this._updataDrawingLayers();
      }

      return this._draw_layers[index];
    }
    /**
     * @summary ãã¬ã¼ã ã®æå¾ã®å¦ç
     * @package
     */

  }, {
    key: "endFrame",
    value: function endFrame() {
      var layers = this._layers;

      for (var i = 0; i < layers.length; ++i) {
        layers[i].tile_cache.endFrame();
      }
    }
    /**
     * @summary åãæ¶ãå¦ç
     * @package
     */

  }, {
    key: "cancel",
    value: function cancel() {
      var layers = this._layers;

      for (var i = 0; i < layers.length; ++i) {
        layers[i].tile_cache.cancel();
      }
    }
    /**
     * @summary æç»ã¬ã¤ã¤ã¼éåãç¡å¹å
     * @package
     */

  }, {
    key: "dirtyDrawingLayers",
    value: function dirtyDrawingLayers() {
      this._draw_layers = null;
    }
    /**
     * @summary æç»ã¬ã¤ã¤ã¼éåãæ´æ°
     * @private
     */

  }, {
    key: "_updataDrawingLayers",
    value: function _updataDrawingLayers() {
      var num_layers = this.num_layers;
      var draw_layers = [];

      for (var i = 0; i < num_layers; ++i) {
        var layer = this._layers[i];

        if (layer.image_provider.status() === ImageProvider.Status.READY && layer.visibility === true) {
          draw_layers.push(layer);
        }
      }

      this._draw_layers = draw_layers;
    }
  }, {
    key: "viewer",
    get: function get() {
      return this._viewer;
    }
    /**
     * @summary WebGL ç°å¢ãåå¾
     * @type {mapray.GLEnv}
     * @readonly
     * @package
     */

  }, {
    key: "glenv",
    get: function get() {
      return this._glenv;
    }
    /**
     * @summary ã¬ã¤ã¤ã¼æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "num_layers",
    get: function get() {
      return this._layers.length;
    }
  }]);

  return LayerCollection;
}();

/**
 * @summary PointCloudãç®¡çããã¯ã©ã¹
 * @see mapray.Viewer#point_cloud_collection
 * 
 * @memberof mapray
 */

var PointCloudCollection =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Scene} scene    æå±ããã·ã¼ã³
   */
  function PointCloudCollection(scene) {
    _classCallCheck(this, PointCloudCollection);

    this._scene = scene;
    this._items = [];
  }
  /**
   * @summary ç¹ç¾¤ãªãã¸ã§ã¯ãæ°
   * @type {number}
   * @readonly
   */


  _createClass(PointCloudCollection, [{
    key: "get",

    /**
     * @summary ç¹ç¾¤ãªãã¸ã§ã¯ããåå¾
     *
     * @param  {number} index  çªå·
     * @return {mapray.PointCloud}  ç¹ç¾¤
     */
    value: function get(index) {
      return this._items[index];
    }
    /**
     * @summary ç¹ç¾¤ãªãã¸ã§ã¯ããè¿½å 
     *
     * @param  {PointCloudProvider} item ç¹ç¾¤ãã­ãã¤ã
     * @return {mapray.PointCloud}  ç¹ç¾¤
     */

  }, {
    key: "add",
    value: function add(item) {
      return this.insert(this.length, item);
    }
    /**
     * @summary ç¹ç¾¤ãªãã¸ã§ã¯ããæå®ããä½ç½®ã«è¿½å 
     *
     * @param  {number} index  çªå·
     * @param  {PointCloudProvider} item ç¹ç¾¤ãã­ãã¤ã
     * @return {mapray.PointCloud}  ç¹ç¾¤
     */

  }, {
    key: "insert",
    value: function insert(index, item) {
      var point_cloud = new PointCloud(this._scene, item);

      this._items.splice(index, 0, point_cloud);

      point_cloud.init();
      return point_cloud;
    }
    /**
     * @summary æå®ããä½ç½®ã®ç¹ç¾¤ãªãã¸ã§ã¯ããåé¤
     *
     * @param  {number} index  çªå·
     * @return {mapray.PointCloud}  åé¤ãããç¹ç¾¤
     */

  }, {
    key: "removeByIndex",
    value: function removeByIndex(index) {
      var removedItem = this._items.splice(index, 1)[0];

      removedItem.destroy();
      return removedItem;
    }
    /**
     * @summary æå®ããç¹ç¾¤ãªãã¸ã§ã¯ããåé¤
     *
     * @param {mapray.PointCloud} item åé¤ããç¹ç¾¤
     */

  }, {
    key: "remove",
    value: function remove(item) {
      var index = this._items.indexOf(item);

      if (index === -1) {
        throw new Error("Couldn't find item: " + item);
      }

      this.removeByIndex(index);
    }
  }, {
    key: "length",
    get: function get() {
      return this._items.length;
    }
  }]);

  return PointCloudCollection;
}();

/**
 * @summary ã¬ã³ããªã³ã°ã³ã¼ã«ããã¯
 * @classdesc
 * <p>ã¬ã³ããªã³ã°ã«ã¼ãã§ã®åç®æã§å¼ã³åºãããã³ã¼ã«ããã¯é¢æ°ãå®è£ããããã®æ½è±¡ã¯ã©ã¹ã§ããã</p>
 * <p>ãµãã¯ã©ã¹ã§ã¯ä»¥ä¸ã®ã¡ã½ããããªã¼ãã¼ã©ã¤ããããã¨ãã§ããããªã¼ãã¼ã©ã¤ãããªãã¡ã½ããã¯ä½ãããªãã</p>
 * <ul>
 *   <li>[onStart()]{@link mapray.RenderCallback#onStart}</li>
 *   <li>[onUpdateFrame()]{@link mapray.RenderCallback#onUpdateFrame}</li>
 *   <li>[onStop()]{@link mapray.RenderCallback#onStop}</li>
 * </ul>
 * @memberof mapray
 * @protected
 * @abstract
 * @see mapray.Viewer
 */
var RenderCallback =
/*#__PURE__*/
function () {
  function RenderCallback() {
    _classCallCheck(this, RenderCallback);

    this._viewer = null;
    this._is_started_ = false;
  }
  /**
   * View ã«åãä»ãã
   * @package
   */


  _createClass(RenderCallback, [{
    key: "attach",
    value: function attach(viewer) {
      if (this._viewer) {
        throw new Error("RenderCallback instance is already attached");
      }

      this._viewer = viewer;
      this._is_started_ = false;
    }
    /**
     * View ããåãé¢ã
     * ãã§ã« onStart() ãå¼ã³åºãã¦ãå ´åãonStop() ãå¼ã³åºãã
     * @package
     */

  }, {
    key: "detach",
    value: function detach() {
      if (this._is_started_) {
        this.onStop();
        this._is_started_ = false;
      }

      this._viewer = null;
    }
    /**
     * ãã¬ã¼ã  onUpdateFrame() ã®å¼ã³åºã
     * åãä»ãã¦ããæåã®ãã¬ã¼ã ã®ã¨ãã¯ onStart() ãå¼ã³åºãã
     * @package
     */

  }, {
    key: "onUpdateFrameInner",
    value: function onUpdateFrameInner(delta_time) {
      if (!this._is_started_) {
        this.onStart();
        this._is_started_ = true;
      }

      this.onUpdateFrame(delta_time);
    }
    /**
     * @summary ä¿æè Viewer
     * @desc
     * <p>ãã® RenderCallback ã¤ã³ã¹ã¿ã³ã¹ãè¨­å®ããã¦ãã Viewer ã¤ã³ã¹ã¿ã³ã¹ãç¤ºãã</p>
     * <p>ãã ã RenderCallback ã¤ã³ã¹ã¿ã³ã¹ãã©ã® Viewer ã¤ã³ã¹ã¿ã³ã¹ã«ãè¨­å®ããã¦ããªãç¶æã§ã¯ null ã¨ãªãã</p>
     * @type {?mapray.Viewer}
     * @readonly
     */

  }, {
    key: "onStart",

    /**
     * @summary ã¬ã³ããªã³ã°ã«ã¼ãéå§ã®å¦ç
     * @abstract
     */
    value: function onStart() {}
    /**
     * @summary ãã¬ã¼ã ã¬ã³ããªã³ã°åã®å¦ç
     * @param {number} delta_time  åãã¬ã¼ã ããã®çµéæé (ç§)
     * @abstract
     */

  }, {
    key: "onUpdateFrame",
    value: function onUpdateFrame(delta_time) {}
    /**
     * @summary ã¬ã³ããªã³ã°ã«ã¼ãçµäºã®å¦ç
     * @abstract
     */

  }, {
    key: "onStop",
    value: function onStop() {}
  }, {
    key: "viewer",
    get: function get() {
      return this._viewer;
    }
  }]);

  return RenderCallback;
}();

/**
 * @summary ç¡æ©è½ RenderCallback
 * @desc
 * <p>Viewer ã« RenderCallback ãè¨­å®ããã¦ããªãã¨ãã«ä½¿ç¨ããåé¨ã¯ã©ã¹ã§ããã</p>
 * @memberof mapray
 * @extends mapray.RenderCallback
 * @private
 */

var NullRenderCallback =
/*#__PURE__*/
function (_RenderCallback) {
  _inherits(NullRenderCallback, _RenderCallback);

  function NullRenderCallback() {
    _classCallCheck(this, NullRenderCallback);

    return _possibleConstructorReturn(this, _getPrototypeOf(NullRenderCallback).call(this));
  }

  return NullRenderCallback;
}(RenderCallback);

/**
 * @summary ã¢ãã«ã·ã¼ã³
 *
 * @classdesc
 * <p>è¡¨ç¤ºããã¨ã³ãã£ãã£ãç®¡çããã¯ã©ã¹ã§ããã</p>
 * <p>ã¤ã³ã¹ã¿ã³ã¹ã¯ {@link mapray.Viewer#scene} ããå¾ããã¨ãã§ããã</p>
 *
 * @hideconstructor
 * @memberof mapray
 * @see mapray.SceneLoader
 */

var Scene =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Viewer}  viewer  Viewer ã¤ã³ã¹ã¿ã³ã¹ (æªæ§ç¯)
   * @param {mapray.GLEnv}   glenv   GLEnv ã¤ã³ã¹ã¿ã³ã¹
   */
  function Scene(viewer, glenv) {
    var _this = this;

    _classCallCheck(this, Scene);

    this._viewer = viewer;
    this._glenv = glenv;
    this._enode_list = []; // ENode ã®ãªã¹ã

    this._loaders = []; // ç¾å¨èª­ã¿è¾¼ã¿ä¸­ã® SceneLoader (åãæ¶ãç¨)
    // animation.BindingBlock

    this._animation = new EasyBindingBlock();

    this._animation.addDescendantUnbinder(function () {
      _this._unbindDescendantAnimations();
    });
  }
  /**
   * WebGL ã¬ã³ããªã³ã°ã³ã³ãã­ã¹ãæå ±
   * @type {mapray.GLEnv}
   * @readonly
   * @package
   */


  _createClass(Scene, [{
    key: "clearEntities",

    /**
     * @summary ãã¹ã¦ã®ã¨ã³ãã£ãã£ãåé¤
     */
    value: function clearEntities() {
      this._enode_list = [];
    }
    /**
     * @summary ã¨ã³ãã£ãã£ãæ«å°¾ã«è¿½å 
     * @param {mapray.Entity} entity  ã¨ã³ãã£ãã£
     */

  }, {
    key: "addEntity",
    value: function addEntity(entity) {
      if (entity.scene !== this) {
        throw new Error("invalid entity");
      }

      this._enode_list.push(new ENode(entity));
    }
    /**
     * @summary ã¨ã³ãã£ãã£ãåé¤
     * @param {mapray.Entity} entity  ã¨ã³ãã£ãã£
     */

  }, {
    key: "removeEntity",
    value: function removeEntity(entity) {
      var array = this._enode_list;

      for (var i = 0; i < array.length; ++i) {
        if (array[i].entity === entity) {
          array.splice(i, 1);
          break;
        }
      }
    }
    /**
     * @summary ã¨ã³ãã£ãã£ãåå¾
     * @param  {number} index    ã¤ã³ããã¯ã¹
     * @return {mapray.Entity}   ã¨ã³ãã£ãã£
     */

  }, {
    key: "getEntity",
    value: function getEntity(index) {
      return this._enode_list[index].entity;
    }
    /**
     * @summary ã·ã¼ã³ãæç»
     * @param {mapray.RenderStage} stage  ã¬ã³ããªã³ã°ã¹ãã¼ã¸
     * @package
     */

  }, {
    key: "draw",
    value: function draw(stage) {
      this._prepare_entities(); // ããªããã£ãã®éåãçæ


      var op_prims = []; // ä¸éæããªããã£ã

      var tp_prims = []; // åéæããªããã£ã

      var ac_prims = []; // ã¢ã³ã«ã¼ããªããã£ã

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._enode_list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var entity = _step.value.entity;
          if (!entity.visibility) continue;

          this._add_primitives(stage, entity, op_prims, tp_prims, ac_prims);
        } // ããªããã£ãéåãæ´åãã¦ããæç»

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._draw_opaque_primitives(stage, op_prims);

      this._draw_translucent_primitives(stage, tp_prims);

      this._draw_anchor_primitives(stage, ac_prims);
    }
    /**
     * @summary æç»åã®ã¨ã³ãã£ãã£ã®æºå
     * @private
     */

  }, {
    key: "_prepare_entities",
    value: function _prepare_entities() {
      var dem_area_updated = this._viewer.globe.dem_area_updated;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._enode_list[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var enode = _step2.value;
          var producer = enode.entity.getPrimitiveProducer();

          if (producer === null || !producer.needsElevation()) {
            // producer ãå­å¨ããªãã¨ããã¾ãã¯
            // producer ãæ¨é«ãå¿è¦ã¨ããªãã¨ãã¯ä½ãããªã
            continue;
          }

          if (producer.checkToCreateRegions() || enode.regions === null) {
            // é åæå ±ãåãããªããã¾ãã¯é åæå ±ãå¤åããå¯è½æ§ãããã¨ã
            enode.regions = producer.createRegions();

            if (enode.regions.length > 0) {
              enode.regions.forEach(function (region) {
                region.compile();
              });
              producer.onChangeElevation(enode.regions);
            }
          } else {
            if (dem_area_updated.isEmpty()) {
              // æ´æ°ããã DEM é åã¯å­å¨ããªã
              // æ¨é«ã®å¤åã¯ãªãã®ã§ä»¥ä¸ã®å¦çãçã
              continue;
            }

            var regions = []; // æ¨é«ã«å¤åããã£ãé å

            enode.regions.forEach(function (region) {
              if (region.intersectsWith(dem_area_updated)) {
                // é åã®æ¨é«ã«å¤åããã£ã
                regions.push(region);
              }
            });

            if (regions.length > 0) {
              // æ¨é«ãå¤åããå¯è½æ§ãããé åãéç¥
              producer.onChangeElevation(regions);
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    /**
     * è¦ä½ç©ã«å«ã¾ããããªããã£ããè¿½å 
     * @private
     */

  }, {
    key: "_add_primitives",
    value: function _add_primitives(stage, entity, op_prims, tp_prims, ac_prims) {
      var producer = entity.getPrimitiveProducer();
      if (producer === null) return;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = producer.getPrimitives(stage)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var primitive = _step3.value;

          if (primitive.isVisible(stage)) {
            var dst_prims = entity.anchor_mode ? ac_prims : primitive.isTranslucent(stage) ? tp_prims : op_prims;
            stage.onPushPrimitive(primitive, entity);
            dst_prims.push(primitive);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
    /**
     * ä¸éæããªããã£ããæ´åãã¦ããæç»
     * @private
     */

  }, {
    key: "_draw_opaque_primitives",
    value: function _draw_opaque_primitives(stage, primitives) {
      // ä¸éæããªããã£ãã®æ´å: è¿æ¥ -> é æ¹ (Z éé )
      primitives.sort(function (a, b) {
        return b.sort_z - a.sort_z;
      });
      var gl = this._glenv.context;
      gl.disable(gl.BLEND);
      gl.depthMask(true);

      for (var i = 0; i < primitives.length; ++i) {
        primitives[i].draw(stage);
      }
    }
    /**
     * åéæããªããã£ããæ´åãã¦ããæç»
     * @private
     */

  }, {
    key: "_draw_translucent_primitives",
    value: function _draw_translucent_primitives(stage, primitives) {
      // åéæããªããã£ãã®æ´å: é æ¹ -> è¿æ¥ (Z æé )
      primitives.sort(function (a, b) {
        return a.sort_z - b.sort_z;
      });
      var gl = this._glenv.context;

      if (stage.getRenderTarget() === RenderTarget.SCENE) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }

      gl.depthMask(false);

      for (var i = 0; i < primitives.length; ++i) {
        primitives[i].draw(stage);
      }

      gl.disable(gl.BLEND);
      gl.depthMask(true);
    }
    /**
     * @summary ã¢ã³ã«ã¼ããªããã£ããæ´åãã¦ããæç»ã
     * <p>{@link mapray.AbstractRenderStage#getRenderTarget} ã {@link mapray.AbstractRenderStage.RenderTarget.SCENE} ã®å ´åã¯ã
     *   é é¢å¦çã§é ãã¦ããã¾ãé¨åã¯åéæã§æç»ããããä»¥å¤ã®é¨åã¯éå¸¸ã®æç»ãè¡ããçµæçã«ã¢ã³ã«ã¼ãªãã¸ã§ã¯ããé é¢ã«ããã¦éãªã£ãå ´åã¯è²ãæ··ãã£ãè¡¨ç¤ºã¨ãªã</p>
     * <p>{@link mapray.AbstractRenderStage#getRenderTarget} ã {@link mapray.AbstractRenderStage.RenderTarget.RID} ã®å ´åã¯ã
     *   é é¢å¦çã§é ãã¦ããã¾ãé¨åã¯å¼·å¶çã«æç»ããããä»¥å¤ã®é¨åã¯éå¸¸ã®æç»ãè¡ããçµæçã«ã¢ã³ã«ã¼ãªãã¸ã§ã¯ããé é¢ã«ããã¦éãªã£ãå ´åã¯zã½ã¼ãããé çªã§RIDãä¸æ¸ãããã</p>
     * @see {@link mapray.Entity#anchor_mode}
     * @private
     */

  }, {
    key: "_draw_anchor_primitives",
    value: function _draw_anchor_primitives(stage, primitives) {
      // ä¸éæããªããã£ãã®æ´å: è¿æ¥ -> é æ¹ (Z éé )
      primitives.sort(function (a, b) {
        return b.sort_z - a.sort_z;
      });
      var gl = this._glenv.context;
      gl.disable(gl.DEPTH_TEST);
      gl.depthMask(false);

      if (stage.getRenderTarget() === RenderTarget.SCENE) {
        stage.setTranslucentMode(true);
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      } // é æ¹ -> è¿æ¥ (Z æé )


      for (var i = primitives.length - 1; i >= 0; --i) {
        primitives[i].draw(stage);
      }

      gl.depthMask(true);
      gl.enable(gl.DEPTH_TEST);
      stage.setTranslucentMode(false); // è¿æ¥ -> é æ¹ (Z éé )

      for (var i = 0; i < primitives.length; ++i) {
        primitives[i].draw(stage);
      }

      gl.disable(gl.BLEND);
    }
    /**
     * ãã¹ã¦ã® SceneLoader ã®èª­ã¿è¾¼ã¿ãåãæ¶ã
     * @package
     */

  }, {
    key: "cancelLoaders",
    value: function cancelLoaders() {
      var loaders = this._loaders.concat(); // è¤è£½


      for (var i = 0; i < loaders.length; ++i) {
        loaders[i].cancel();
      }
    }
    /**
     * èª­ã¿è¾¼ã¿ä¸­ã® SceneLoader ãç»é²
     * @param {mapray.SceneLoader} loader  ç»é²ããã­ã¼ãã¼
     * @package
     */

  }, {
    key: "addLoader",
    value: function addLoader(loader) {
      this._loaders.push(loader);
    }
    /**
     * èª­ã¿è¾¼ã¿ä¸­ã® SceneLoader ãåé¤
     * @param {mapray.SceneLoader} loader  åé¤ããã­ã¼ãã¼
     * @package
     */

  }, {
    key: "removeLoader",
    value: function removeLoader(loader) {
      var index = this._loaders.indexOf(loader);

      if (index >= 0) {
        this._loaders.splice(index, 1);
      }
    }
    /**
     * @summary FlakePrimitiveProducer ã®åå¾©å¯è½ãªãã¸ã§ã¯ããåå¾
     *
     * @return {iterable.<mapray.Entity.FlakePrimitiveProducer>}
     *
     * @package
     */

  }, {
    key: "getFlakePrimitiveProducers",
    value: function getFlakePrimitiveProducers() {
      var producers = [];
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._enode_list[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var entity = _step4.value.entity;
          if (!entity.visibility) continue;
          var prod = entity.getFlakePrimitiveProducer();

          if (prod !== null) {
            producers.push(prod);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return producers;
    }
    /**
     * EasyBindingBlock.DescendantUnbinder å¦ç
     *
     * @private
     */

  }, {
    key: "_unbindDescendantAnimations",
    value: function _unbindDescendantAnimations() {
      // ãã¹ã¦ã®ã¨ã³ãã£ãã£ãè§£é¤
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this._enode_list[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var entity = _step5.value.entity;
          entity.animation.unbindAllRecursively();
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
  }, {
    key: "glenv",
    get: function get() {
      return this._glenv;
    }
    /**
     * this ãä¿æããè¦ªãªãã¸ã§ã¯ã
     * @type {mapray.Viewer}
     * @readonly
     */

  }, {
    key: "viewer",
    get: function get() {
      return this._viewer;
    }
    /**
     * @summary ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿è¨­å®
     *
     * @type {mapray.animation.BindingBlock}
     * @readonly
     */

  }, {
    key: "animation",
    get: function get() {
      return this._animation;
    }
    /**
     * ã¨ã³ãã£ãã£æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "num_entities",
    get: function get() {
      return this._enode_list.length;
    }
  }]);

  return Scene;
}();
/**
 * ã¨ã³ãã£ãã£ç®¡çç¨ãã¼ã
 *
 * @memberof mapray.Scene
 * @private
 */


var ENode =
/**
 * @param {mapray.Entity} entity  ç®¡çå¯¾è±¡ã®ã¨ã³ãã£ãã£
 */
function ENode(entity) {
  _classCallCheck(this, ENode);

  /**
   * @summary ç®¡çå¯¾è±¡ã®ã¨ã³ãã£ãã£
   * @member mapray.Scene.ENode#entity
   * @type {mapray.Entity}
   * @readonly
   */
  this.entity = entity;
  this.regions = null;
};

var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)
// https://tc39.github.io/ecma262/#sec-createhtml

var createHtml = function (string, tag, attribute, value) {
  var S = String(requireObjectCoercible(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

// of a tag and escaping quotes in arguments

var stringHtmlForced = function (METHOD_NAME) {
  return fails(function () {
    var test = ''[METHOD_NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  });
};

// https://tc39.github.io/ecma262/#sec-string.prototype.link


_export({
  target: 'String',
  proto: true,
  forced: stringHtmlForced('link')
}, {
  link: function link(url) {
    return createHtml(this, 'a', 'href', url);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof

_export({
  target: 'Array',
  proto: true,
  forced: arrayLastIndexOf !== [].lastIndexOf
}, {
  lastIndexOf: arrayLastIndexOf
});

var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;
var nativeStartsWith = ''.startsWith;
var min$5 = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('startsWith'); // https://github.com/zloirock/core-js/pull/702

var MDN_POLYFILL_BUG =  !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor$4(String.prototype, 'startsWith');
  return descriptor && !descriptor.writable;
}(); // `String.prototype.startsWith` method
// https://tc39.github.io/ecma262/#sec-string.prototype.startswith

_export({
  target: 'String',
  proto: true,
  forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
}, {
  startsWith: function startsWith(searchString
  /* , position = 0 */
  ) {
    var that = String(requireObjectCoercible(this));
    notARegexp(searchString);
    var index = toLength(min$5(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return nativeStartsWith ? nativeStartsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/**
 * @private
 */
var HTTP =
/*#__PURE__*/
function () {
  function HTTP() {
    _classCallCheck(this, HTTP);
  }

  _createClass(HTTP, null, [{
    key: "get",
    value: function () {
      var _get = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(url, query) {
        var option,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                option = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
                _context.next = 3;
                return this.fetch(HTTP.METHOD.GET, url, query, null, option);

              case 3:
                return _context.abrupt("return", _context.sent);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function get(_x5, _x6) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
  }, {
    key: "post",
    value: function () {
      var _post = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(url, query, body) {
        var option,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                option = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};
                _context2.next = 3;
                return this.fetch(HTTP.METHOD.POST, url, query, body, option);

              case 3:
                return _context2.abrupt("return", _context2.sent);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function post(_x7, _x8, _x9) {
        return _post.apply(this, arguments);
      }

      return post;
    }()
  }, {
    key: "patch",
    value: function () {
      var _patch = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(url, query, body) {
        var option,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                option = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {};
                _context3.next = 3;
                return this.fetch(HTTP.METHOD.PATCH, url, query, body, option);

              case 3:
                return _context3.abrupt("return", _context3.sent);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function patch(_x10, _x11, _x12) {
        return _patch.apply(this, arguments);
      }

      return patch;
    }()
  }, {
    key: "put",
    value: function () {
      var _put = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(url, query, body) {
        var option,
            _args4 = arguments;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                option = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : {};
                _context4.next = 3;
                return this.fetch(HTTP.METHOD.PUT, url, query, body, option);

              case 3:
                return _context4.abrupt("return", _context4.sent);

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function put(_x13, _x14, _x15) {
        return _put.apply(this, arguments);
      }

      return put;
    }()
  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(url, query) {
        var option,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                option = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};
                _context5.next = 3;
                return this.fetch(HTTP.METHOD.DELETE, url, query, null, option);

              case 3:
                return _context5.abrupt("return", _context5.sent);

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _delete(_x16, _x17) {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }()
    /**
     * @summary call fetch
     *
     * <pre>
     * query = {
     *     key1: value1,
     *     key2: value2,
     * };
     * URL: url?key1=value1&key2=value2
     * </pre>
     * window.fetch();
     *
     * @private
     * @param {string} method
     * @param {string} url
     * @param {object} query
     * @param {object|string} body
     * @param {object} [option] second argument of window.fetch(url, [init]).
     */

  }, {
    key: "fetch",
    value: function (_fetch) {
      function fetch(_x, _x2, _x3, _x4) {
        return _fetch.apply(this, arguments);
      }

      fetch.toString = function () {
        return _fetch.toString();
      };

      return fetch;
    }(
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(method, url, query, body) {
        var option,
            queryText,
            response,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                option = _args6.length > 4 && _args6[4] !== undefined ? _args6[4] : {};
                queryText = !query ? "" : "?" + Object.keys(query).map(function (k) {
                  return k + "=" + query[k];
                }).join("&");
                option.method = method;
                if (body) option.body = _typeof(body) === "object" ? JSON.stringify(body) : body;
                _context6.prev = 4;
                _context6.next = 7;
                return fetch(url + queryText, option);

              case 7:
                response = _context6.sent;
                _context6.next = 13;
                break;

              case 10:
                _context6.prev = 10;
                _context6.t0 = _context6["catch"](4);
                throw new FetchError("Failed to fetch", url, null, _context6.t0);

              case 13:
                if (response.ok) {
                  _context6.next = 15;
                  break;
                }

                throw new FetchError("Failed to fetch: " + response.statusText, url, response);

              case 15:
                return _context6.abrupt("return", response);

              case 16:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, null, [[4, 10]]);
      }));

      return function (_x18, _x19, _x20, _x21) {
        return _ref.apply(this, arguments);
      };
    }())
  }, {
    key: "isJson",
    value: function isJson(mimeType) {
      return mimeType.startsWith("application/json") || mimeType === "model/gltf+json";
    }
  }]);

  return HTTP;
}();

HTTP.METHOD = {
  GET: "GET",
  POST: "POST",
  PATCH: "PATCH",
  PUT: "PUT",
  DELETE: "DELETE"
};
HTTP.CONTENT_TYPE = "Content-Type";
HTTP.RESPONSE_STATUS = {
  NO_CONTENT: 204
};
/**
 * @private
 */

var FetchError =
/*#__PURE__*/
function (_Error) {
  _inherits(FetchError, _Error);

  function FetchError(message, url, response, cause) {
    var _this;

    _classCallCheck(this, FetchError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(FetchError).call(this, message + " " + url));

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), FetchError);
    }

    _this.name = "FetchError";
    _this.url = url;
    _this.response = response;
    _this.cause = cause;
    var is_aborted = false;

    if (cause) {
      is_aborted = cause.message === "The user aborted a request.";
      _this.stack += "\nCaused-By: " + (cause.stack || cause);
    }

    _this.is_aborted = is_aborted;
    return _this;
  }

  return FetchError;
}(_wrapNativeSuper(Error));

var defineProperty$a = objectDefineProperty.f;
var getOwnPropertyNames$2 = objectGetOwnPropertyNames.f;
var setInternalState$6 = internalState.set;
var MATCH$2 = wellKnownSymbol('match');
var NativeRegExp = global_1.RegExp;
var RegExpPrototype$1 = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g; // "new" should create a new object, old webkit bug

var CORRECT_NEW = new NativeRegExp(re1) !== re1;
var UNSUPPORTED_Y$2 = regexpStickyHelpers.UNSUPPORTED_Y;
var FORCED$7 = descriptors && isForced_1('RegExp', !CORRECT_NEW || UNSUPPORTED_Y$2 || fails(function () {
  re2[MATCH$2] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
})); // `RegExp` constructor
// https://tc39.github.io/ecma262/#sec-regexp-constructor

if (FORCED$7) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegexp(pattern);
    var flagsAreUndefined = flags === undefined;
    var sticky;

    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
      return pattern;
    }

    if (CORRECT_NEW) {
      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
    } else if (pattern instanceof RegExpWrapper) {
      if (flagsAreUndefined) flags = regexpFlags.call(pattern);
      pattern = pattern.source;
    }

    if (UNSUPPORTED_Y$2) {
      sticky = !!flags && flags.indexOf('y') > -1;
      if (sticky) flags = flags.replace(/y/g, '');
    }

    var result = inheritIfRequired(CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype$1, RegExpWrapper);
    if (UNSUPPORTED_Y$2 && sticky) setInternalState$6(result, {
      sticky: sticky
    });
    return result;
  };

  var proxy = function (key) {
    key in RegExpWrapper || defineProperty$a(RegExpWrapper, key, {
      configurable: true,
      get: function () {
        return NativeRegExp[key];
      },
      set: function (it) {
        NativeRegExp[key] = it;
      }
    });
  };

  var keys$3 = getOwnPropertyNames$2(NativeRegExp);
  var index = 0;

  while (keys$3.length > index) proxy(keys$3[index++]);

  RegExpPrototype$1.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype$1;
  redefine(global_1, 'RegExp', RegExpWrapper);
} // https://tc39.github.io/ecma262/#sec-get-regexp-@@species


setSpecies('RegExp');

var ITERATOR$7 = wellKnownSymbol('iterator');
var nativeUrl = !fails(function () {
  var url = new URL('b?a=1&b=2&c=3', 'http://a');
  var searchParams = url.searchParams;
  var result = '';
  url.pathname = 'c%20d';
  searchParams.forEach(function (value, key) {
    searchParams['delete']('b');
    result += key + value;
  });
  return isPure && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR$7] // throws in Edge
  || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b' // not punycoded in Edge
  || new URL('http://ÑÐµÑÑ').host !== 'xn--e1aybc' // not escaped in Chrome 62-
  || new URL('http://a#Ð±').hash !== '#%D0%B1' // fails in Chrome 66-
  || result !== 'a1c3' // throws in Safari
  || new URL('http://x', undefined).host !== 'x';
});

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80

var delimiter = '-'; // '\x2D'

var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars

var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;
var floor$3 = Math.floor;
var stringFromCharCode = String.fromCharCode;
/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */

var ucs2decode = function (string) {
  var output = [];
  var counter = 0;
  var length = string.length;

  while (counter < length) {
    var value = string.charCodeAt(counter++);

    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      var extra = string.charCodeAt(counter++);

      if ((extra & 0xFC00) == 0xDC00) {
        // Low surrogate.
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }

  return output;
};
/**
 * Converts a digit/integer into a basic code point.
 */


var digitToBasic = function (digit) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26);
};
/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */


var adapt = function (delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor$3(delta / damp) : delta >> 1;
  delta += floor$3(delta / numPoints);

  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor$3(delta / baseMinusTMin);
  }

  return floor$3(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */
// eslint-disable-next-line  max-statements


var encode = function (input) {
  var output = []; // Convert the input in UCS-2 to an array of Unicode code points.

  input = ucs2decode(input); // Cache the length.

  var inputLength = input.length; // Initialize the state.

  var n = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue; // Handle the basic code points.

  for (i = 0; i < input.length; i++) {
    currentValue = input[i];

    if (currentValue < 0x80) {
      output.push(stringFromCharCode(currentValue));
    }
  }

  var basicLength = output.length; // number of basic code points.

  var handledCPCount = basicLength; // number of code points that have been handled;
  // Finish the basic string with a delimiter unless it's empty.

  if (basicLength) {
    output.push(delimiter);
  } // Main encoding loop:


  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next larger one:
    var m = maxInt;

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];

      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.


    var handledCPCountPlusOne = handledCPCount + 1;

    if (m - n > floor$3((maxInt - delta) / handledCPCountPlusOne)) {
      throw RangeError(OVERFLOW_ERROR);
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];

      if (currentValue < n && ++delta > maxInt) {
        throw RangeError(OVERFLOW_ERROR);
      }

      if (currentValue == n) {
        // Represent delta as a generalized variable-length integer.
        var q = delta;

        for (var k = base;;
        /* no condition */
        k += base) {
          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) break;
          var qMinusT = q - t;
          var baseMinusT = base - t;
          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
          q = floor$3(qMinusT / baseMinusT);
        }

        output.push(stringFromCharCode(digitToBasic(q)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }

    ++delta;
    ++n;
  }

  return output.join('');
};

var stringPunycodeToAscii = function (input) {
  var encoded = [];
  var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
  var i, label;

  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
  }

  return encoded.join('.');
};

var getIterator = function (it) {
  var iteratorMethod = getIteratorMethod(it);

  if (typeof iteratorMethod != 'function') {
    throw TypeError(String(it) + ' is not iterable');
  }

  return anObject(iteratorMethod.call(it));
};

var $fetch$1 = getBuiltIn('fetch');
var Headers = getBuiltIn('Headers');
var ITERATOR$8 = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState$7 = internalState.set;
var getInternalParamsState = internalState.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = internalState.getterFor(URL_SEARCH_PARAMS_ITERATOR);
var plus = /\+/g;
var sequences = Array(4);

var percentSequence = function (bytes) {
  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};

var percentDecode = function (sequence) {
  try {
    return decodeURIComponent(sequence);
  } catch (error) {
    return sequence;
  }
};

var deserialize = function (it) {
  var result = it.replace(plus, ' ');
  var bytes = 4;

  try {
    return decodeURIComponent(result);
  } catch (error) {
    while (bytes) {
      result = result.replace(percentSequence(bytes--), percentDecode);
    }

    return result;
  }
};

var find = /[!'()~]|%20/g;
var replace = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};

var replacer = function (match) {
  return replace[match];
};

var serialize = function (it) {
  return encodeURIComponent(it).replace(find, replacer);
};

var parseSearchParams = function (result, query) {
  if (query) {
    var attributes = query.split('&');
    var index = 0;
    var attribute, entry;

    while (index < attributes.length) {
      attribute = attributes[index++];

      if (attribute.length) {
        entry = attribute.split('=');
        result.push({
          key: deserialize(entry.shift()),
          value: deserialize(entry.join('='))
        });
      }
    }
  }
};

var updateSearchParams = function (query) {
  this.entries.length = 0;
  parseSearchParams(this.entries, query);
};

var validateArgumentsLength = function (passed, required) {
  if (passed < required) throw TypeError('Not enough arguments');
};

var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState$7(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    iterator: getIterator(getInternalParamsState(params).entries),
    kind: kind
  });
}, 'Iterator', function next() {
  var state = getInternalIteratorState(this);
  var kind = state.kind;
  var step = state.iterator.next();
  var entry = step.value;

  if (!step.done) {
    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
  }

  return step;
}); // `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams

var URLSearchParamsConstructor = function URLSearchParams()
/* init */
{
  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  var that = this;
  var entries = [];
  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;
  setInternalState$7(that, {
    type: URL_SEARCH_PARAMS,
    entries: entries,
    updateURL: function () {
      /* empty */
    },
    updateSearchParams: updateSearchParams
  });

  if (init !== undefined) {
    if (isObject(init)) {
      iteratorMethod = getIteratorMethod(init);

      if (typeof iteratorMethod === 'function') {
        iterator = iteratorMethod.call(init);
        next = iterator.next;

        while (!(step = next.call(iterator)).done) {
          entryIterator = getIterator(anObject(step.value));
          entryNext = entryIterator.next;
          if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done) throw TypeError('Expected sequence with length 2');
          entries.push({
            key: first.value + '',
            value: second.value + ''
          });
        }
      } else for (key in init) if (has(init, key)) entries.push({
        key: key,
        value: init[key] + ''
      });
    } else {
      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
    }
  }
};

var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
redefineAll(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.appent` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    validateArgumentsLength(arguments.length, 2);
    var state = getInternalParamsState(this);
    state.entries.push({
      key: name + '',
      value: value + ''
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function (name) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var key = name + '';
    var index = 0;

    while (index < entries.length) {
      if (entries[index].key === key) entries.splice(index, 1);else index++;
    }

    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var index = 0;

    for (; index < entries.length; index++) {
      if (entries[index].key === key) return entries[index].value;
    }

    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var result = [];
    var index = 0;

    for (; index < entries.length; index++) {
      if (entries[index].key === key) result.push(entries[index].value);
    }

    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var index = 0;

    while (index < entries.length) {
      if (entries[index++].key === key) return true;
    }

    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var found = false;
    var key = name + '';
    var val = value + '';
    var index = 0;
    var entry;

    for (; index < entries.length; index++) {
      entry = entries[index];

      if (entry.key === key) {
        if (found) entries.splice(index--, 1);else {
          found = true;
          entry.value = val;
        }
      }
    }

    if (!found) entries.push({
      key: key,
      value: val
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    var entries = state.entries; // Array#sort is not stable in some engines

    var slice = entries.slice();
    var entry, entriesIndex, sliceIndex;
    entries.length = 0;

    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
      entry = slice[sliceIndex];

      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
        if (entries[entriesIndex].key > entry.key) {
          entries.splice(entriesIndex, 0, entry);
          break;
        }
      }

      if (entriesIndex === sliceIndex) entries.push(entry);
    }

    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback
  /* , thisArg */
  ) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = functionBindContext(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
    var index = 0;
    var entry;

    while (index < entries.length) {
      entry = entries[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, {
  enumerable: true
}); // `URLSearchParams.prototype[@@iterator]` method

redefine(URLSearchParamsPrototype, ITERATOR$8, URLSearchParamsPrototype.entries); // `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior

redefine(URLSearchParamsPrototype, 'toString', function toString() {
  var entries = getInternalParamsState(this).entries;
  var result = [];
  var index = 0;
  var entry;

  while (index < entries.length) {
    entry = entries[index++];
    result.push(serialize(entry.key) + '=' + serialize(entry.value));
  }

  return result.join('&');
}, {
  enumerable: true
});
setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
_export({
  global: true,
  forced: !nativeUrl
}, {
  URLSearchParams: URLSearchParamsConstructor
}); // Wrap `fetch` for correct work with polyfilled `URLSearchParams`
// https://github.com/zloirock/core-js/issues/674

if (!nativeUrl && typeof $fetch$1 == 'function' && typeof Headers == 'function') {
  _export({
    global: true,
    enumerable: true,
    forced: true
  }, {
    fetch: function fetch(input
    /* , init */
    ) {
      var args = [input];
      var init, body, headers;

      if (arguments.length > 1) {
        init = arguments[1];

        if (isObject(init)) {
          body = init.body;

          if (classof(body) === URL_SEARCH_PARAMS) {
            headers = init.headers ? new Headers(init.headers) : new Headers();

            if (!headers.has('content-type')) {
              headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
            }

            init = objectCreate(init, {
              body: createPropertyDescriptor(0, String(body)),
              headers: createPropertyDescriptor(0, headers)
            });
          }
        }

        args.push(init);
      }

      return $fetch$1.apply(this, args);
    }
  });
}

var web_urlSearchParams = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};

var codeAt = stringMultibyte.codeAt;
var NativeURL = global_1.URL;
var URLSearchParams$1 = web_urlSearchParams.URLSearchParams;
var getInternalSearchParamsState = web_urlSearchParams.getState;
var setInternalState$8 = internalState.set;
var getInternalURLState = internalState.getterFor('URL');
var floor$4 = Math.floor;
var pow$1 = Math.pow;
var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';
var ALPHA = /[A-Za-z]/;
var ALPHANUMERIC = /[\d+\-.A-Za-z]/;
var DIGIT = /\d/;
var HEX_START = /^(0x|0X)/;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\dA-Fa-f]+$/; // eslint-disable-next-line no-control-regex

var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/; // eslint-disable-next-line no-control-regex

var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/; // eslint-disable-next-line no-control-regex

var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g; // eslint-disable-next-line no-control-regex

var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g;
var EOF;

var parseHost = function (url, input) {
  var result, codePoints, index;

  if (input.charAt(0) == '[') {
    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
    result = parseIPv6(input.slice(1, -1));
    if (!result) return INVALID_HOST;
    url.host = result; // opaque host
  } else if (!isSpecial(url)) {
    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
    result = '';
    codePoints = arrayFrom(input);

    for (index = 0; index < codePoints.length; index++) {
      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
    }

    url.host = result;
  } else {
    input = stringPunycodeToAscii(input);
    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
    result = parseIPv4(input);
    if (result === null) return INVALID_HOST;
    url.host = result;
  }
};

var parseIPv4 = function (input) {
  var parts = input.split('.');
  var partsLength, numbers, index, part, radix, number, ipv4;

  if (parts.length && parts[parts.length - 1] == '') {
    parts.pop();
  }

  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];

  for (index = 0; index < partsLength; index++) {
    part = parts[index];
    if (part == '') return input;
    radix = 10;

    if (part.length > 1 && part.charAt(0) == '0') {
      radix = HEX_START.test(part) ? 16 : 8;
      part = part.slice(radix == 8 ? 1 : 2);
    }

    if (part === '') {
      number = 0;
    } else {
      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
      number = parseInt(part, radix);
    }

    numbers.push(number);
  }

  for (index = 0; index < partsLength; index++) {
    number = numbers[index];

    if (index == partsLength - 1) {
      if (number >= pow$1(256, 5 - partsLength)) return null;
    } else if (number > 255) return null;
  }

  ipv4 = numbers.pop();

  for (index = 0; index < numbers.length; index++) {
    ipv4 += numbers[index] * pow$1(256, 3 - index);
  }

  return ipv4;
}; // eslint-disable-next-line max-statements


var parseIPv6 = function (input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

  var char = function () {
    return input.charAt(pointer);
  };

  if (char() == ':') {
    if (input.charAt(1) != ':') return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }

  while (char()) {
    if (pieceIndex == 8) return;

    if (char() == ':') {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }

    value = length = 0;

    while (length < 4 && HEX.test(char())) {
      value = value * 16 + parseInt(char(), 16);
      pointer++;
      length++;
    }

    if (char() == '.') {
      if (length == 0) return;
      pointer -= length;
      if (pieceIndex > 6) return;
      numbersSeen = 0;

      while (char()) {
        ipv4Piece = null;

        if (numbersSeen > 0) {
          if (char() == '.' && numbersSeen < 4) pointer++;else return;
        }

        if (!DIGIT.test(char())) return;

        while (DIGIT.test(char())) {
          number = parseInt(char(), 10);
          if (ipv4Piece === null) ipv4Piece = number;else if (ipv4Piece == 0) return;else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }

        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
      }

      if (numbersSeen != 4) return;
      break;
    } else if (char() == ':') {
      pointer++;
      if (!char()) return;
    } else if (char()) return;

    address[pieceIndex++] = value;
  }

  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;

    while (pieceIndex != 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex != 8) return;

  return address;
};

var findLongestZeroSequence = function (ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;

  for (; index < 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }

      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = index;
      ++currLength;
    }
  }

  if (currLength > maxLength) {
    maxIndex = currStart;
    maxLength = currLength;
  }

  return maxIndex;
};

var serializeHost = function (host) {
  var result, index, compress, ignore0; // ipv4

  if (typeof host == 'number') {
    result = [];

    for (index = 0; index < 4; index++) {
      result.unshift(host % 256);
      host = floor$4(host / 256);
    }

    return result.join('.'); // ipv6
  } else if (typeof host == 'object') {
    result = '';
    compress = findLongestZeroSequence(host);

    for (index = 0; index < 8; index++) {
      if (ignore0 && host[index] === 0) continue;
      if (ignore0) ignore0 = false;

      if (compress === index) {
        result += index ? ':' : '::';
        ignore0 = true;
      } else {
        result += host[index].toString(16);
        if (index < 7) result += ':';
      }
    }

    return '[' + result + ']';
  }

  return host;
};

var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = objectAssign({}, C0ControlPercentEncodeSet, {
  ' ': 1,
  '"': 1,
  '<': 1,
  '>': 1,
  '`': 1
});
var pathPercentEncodeSet = objectAssign({}, fragmentPercentEncodeSet, {
  '#': 1,
  '?': 1,
  '{': 1,
  '}': 1
});
var userinfoPercentEncodeSet = objectAssign({}, pathPercentEncodeSet, {
  '/': 1,
  ':': 1,
  ';': 1,
  '=': 1,
  '@': 1,
  '[': 1,
  '\\': 1,
  ']': 1,
  '^': 1,
  '|': 1
});

var percentEncode = function (char, set) {
  var code = codeAt(char, 0);
  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
};

var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

var isSpecial = function (url) {
  return has(specialSchemes, url.scheme);
};

var includesCredentials = function (url) {
  return url.username != '' || url.password != '';
};

var cannotHaveUsernamePasswordPort = function (url) {
  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
};

var isWindowsDriveLetter = function (string, normalized) {
  var second;
  return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ':' || !normalized && second == '|');
};

var startsWithWindowsDriveLetter = function (string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || (third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#');
};

var shortenURLsPath = function (url) {
  var path = url.path;
  var pathSize = path.length;

  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
    path.pop();
  }
};

var isSingleDot = function (segment) {
  return segment === '.' || segment.toLowerCase() === '%2e';
};

var isDoubleDot = function (segment) {
  segment = segment.toLowerCase();
  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
}; // States:


var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {}; // eslint-disable-next-line max-statements

var parseURL = function (url, input, stateOverride, base) {
  var state = stateOverride || SCHEME_START;
  var pointer = 0;
  var buffer = '';
  var seenAt = false;
  var seenBracket = false;
  var seenPasswordToken = false;
  var codePoints, char, bufferCodePoints, failure;

  if (!stateOverride) {
    url.scheme = '';
    url.username = '';
    url.password = '';
    url.host = null;
    url.port = null;
    url.path = [];
    url.query = null;
    url.fragment = null;
    url.cannotBeABaseURL = false;
    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
  }

  input = input.replace(TAB_AND_NEW_LINE, '');
  codePoints = arrayFrom(input);

  while (pointer <= codePoints.length) {
    char = codePoints[pointer];

    switch (state) {
      case SCHEME_START:
        if (char && ALPHA.test(char)) {
          buffer += char.toLowerCase();
          state = SCHEME;
        } else if (!stateOverride) {
          state = NO_SCHEME;
          continue;
        } else return INVALID_SCHEME;

        break;

      case SCHEME:
        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
          buffer += char.toLowerCase();
        } else if (char == ':') {
          if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == 'file' && (includesCredentials(url) || url.port !== null) || url.scheme == 'file' && !url.host)) return;
          url.scheme = buffer;

          if (stateOverride) {
            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
            return;
          }

          buffer = '';

          if (url.scheme == 'file') {
            state = FILE;
          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
            state = SPECIAL_RELATIVE_OR_AUTHORITY;
          } else if (isSpecial(url)) {
            state = SPECIAL_AUTHORITY_SLASHES;
          } else if (codePoints[pointer + 1] == '/') {
            state = PATH_OR_AUTHORITY;
            pointer++;
          } else {
            url.cannotBeABaseURL = true;
            url.path.push('');
            state = CANNOT_BE_A_BASE_URL_PATH;
          }
        } else if (!stateOverride) {
          buffer = '';
          state = NO_SCHEME;
          pointer = 0;
          continue;
        } else return INVALID_SCHEME;

        break;

      case NO_SCHEME:
        if (!base || base.cannotBeABaseURL && char != '#') return INVALID_SCHEME;

        if (base.cannotBeABaseURL && char == '#') {
          url.scheme = base.scheme;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          url.cannotBeABaseURL = true;
          state = FRAGMENT;
          break;
        }

        state = base.scheme == 'file' ? FILE : RELATIVE;
        continue;

      case SPECIAL_RELATIVE_OR_AUTHORITY:
        if (char == '/' && codePoints[pointer + 1] == '/') {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          pointer++;
        } else {
          state = RELATIVE;
          continue;
        }

        break;

      case PATH_OR_AUTHORITY:
        if (char == '/') {
          state = AUTHORITY;
          break;
        } else {
          state = PATH;
          continue;
        }

      case RELATIVE:
        url.scheme = base.scheme;

        if (char == EOF) {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
        } else if (char == '/' || char == '\\' && isSpecial(url)) {
          state = RELATIVE_SLASH;
        } else if (char == '?') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          state = FRAGMENT;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.path.pop();
          state = PATH;
          continue;
        }

        break;

      case RELATIVE_SLASH:
        if (isSpecial(url) && (char == '/' || char == '\\')) {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        } else if (char == '/') {
          state = AUTHORITY;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          state = PATH;
          continue;
        }

        break;

      case SPECIAL_AUTHORITY_SLASHES:
        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
        pointer++;
        break;

      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
        if (char != '/' && char != '\\') {
          state = AUTHORITY;
          continue;
        }

        break;

      case AUTHORITY:
        if (char == '@') {
          if (seenAt) buffer = '%40' + buffer;
          seenAt = true;
          bufferCodePoints = arrayFrom(buffer);

          for (var i = 0; i < bufferCodePoints.length; i++) {
            var codePoint = bufferCodePoints[i];

            if (codePoint == ':' && !seenPasswordToken) {
              seenPasswordToken = true;
              continue;
            }

            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
            if (seenPasswordToken) url.password += encodedCodePoints;else url.username += encodedCodePoints;
          }

          buffer = '';
        } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) {
          if (seenAt && buffer == '') return INVALID_AUTHORITY;
          pointer -= arrayFrom(buffer).length + 1;
          buffer = '';
          state = HOST;
        } else buffer += char;

        break;

      case HOST:
      case HOSTNAME:
        if (stateOverride && url.scheme == 'file') {
          state = FILE_HOST;
          continue;
        } else if (char == ':' && !seenBracket) {
          if (buffer == '') return INVALID_HOST;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PORT;
          if (stateOverride == HOSTNAME) return;
        } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) {
          if (isSpecial(url) && buffer == '') return INVALID_HOST;
          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PATH_START;
          if (stateOverride) return;
          continue;
        } else {
          if (char == '[') seenBracket = true;else if (char == ']') seenBracket = false;
          buffer += char;
        }

        break;

      case PORT:
        if (DIGIT.test(char)) {
          buffer += char;
        } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url) || stateOverride) {
          if (buffer != '') {
            var port = parseInt(buffer, 10);
            if (port > 0xFFFF) return INVALID_PORT;
            url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;
            buffer = '';
          }

          if (stateOverride) return;
          state = PATH_START;
          continue;
        } else return INVALID_PORT;

        break;

      case FILE:
        url.scheme = 'file';
        if (char == '/' || char == '\\') state = FILE_SLASH;else if (base && base.scheme == 'file') {
          if (char == EOF) {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
          } else if (char == '?') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
            url.fragment = '';
            state = FRAGMENT;
          } else {
            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
              url.host = base.host;
              url.path = base.path.slice();
              shortenURLsPath(url);
            }

            state = PATH;
            continue;
          }
        } else {
          state = PATH;
          continue;
        }
        break;

      case FILE_SLASH:
        if (char == '/' || char == '\\') {
          state = FILE_HOST;
          break;
        }

        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);else url.host = base.host;
        }

        state = PATH;
        continue;

      case FILE_HOST:
        if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
          if (!stateOverride && isWindowsDriveLetter(buffer)) {
            state = PATH;
          } else if (buffer == '') {
            url.host = '';
            if (stateOverride) return;
            state = PATH_START;
          } else {
            failure = parseHost(url, buffer);
            if (failure) return failure;
            if (url.host == 'localhost') url.host = '';
            if (stateOverride) return;
            buffer = '';
            state = PATH_START;
          }

          continue;
        } else buffer += char;

        break;

      case PATH_START:
        if (isSpecial(url)) {
          state = PATH;
          if (char != '/' && char != '\\') continue;
        } else if (!stateOverride && char == '?') {
          url.query = '';
          state = QUERY;
        } else if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          state = PATH;
          if (char != '/') continue;
        }

        break;

      case PATH:
        if (char == EOF || char == '/' || char == '\\' && isSpecial(url) || !stateOverride && (char == '?' || char == '#')) {
          if (isDoubleDot(buffer)) {
            shortenURLsPath(url);

            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else if (isSingleDot(buffer)) {
            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else {
            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
              if (url.host) url.host = '';
              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
            }

            url.path.push(buffer);
          }

          buffer = '';

          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
            while (url.path.length > 1 && url.path[0] === '') {
              url.path.shift();
            }
          }

          if (char == '?') {
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.fragment = '';
            state = FRAGMENT;
          }
        } else {
          buffer += percentEncode(char, pathPercentEncodeSet);
        }

        break;

      case CANNOT_BE_A_BASE_URL_PATH:
        if (char == '?') {
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
        }

        break;

      case QUERY:
        if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          if (char == "'" && isSpecial(url)) url.query += '%27';else if (char == '#') url.query += '%23';else url.query += percentEncode(char, C0ControlPercentEncodeSet);
        }

        break;

      case FRAGMENT:
        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
        break;
    }

    pointer++;
  }
}; // `URL` constructor
// https://url.spec.whatwg.org/#url-class


var URLConstructor = function URL(url
/* , base */
) {
  var that = anInstance(this, URLConstructor, 'URL');
  var base = arguments.length > 1 ? arguments[1] : undefined;
  var urlString = String(url);
  var state = setInternalState$8(that, {
    type: 'URL'
  });
  var baseState, failure;

  if (base !== undefined) {
    if (base instanceof URLConstructor) baseState = getInternalURLState(base);else {
      failure = parseURL(baseState = {}, String(base));
      if (failure) throw TypeError(failure);
    }
  }

  failure = parseURL(state, urlString, null, baseState);
  if (failure) throw TypeError(failure);
  var searchParams = state.searchParams = new URLSearchParams$1();
  var searchParamsState = getInternalSearchParamsState(searchParams);
  searchParamsState.updateSearchParams(state.query);

  searchParamsState.updateURL = function () {
    state.query = String(searchParams) || null;
  };

  if (!descriptors) {
    that.href = serializeURL.call(that);
    that.origin = getOrigin.call(that);
    that.protocol = getProtocol.call(that);
    that.username = getUsername.call(that);
    that.password = getPassword.call(that);
    that.host = getHost.call(that);
    that.hostname = getHostname.call(that);
    that.port = getPort.call(that);
    that.pathname = getPathname.call(that);
    that.search = getSearch.call(that);
    that.searchParams = getSearchParams.call(that);
    that.hash = getHash.call(that);
  }
};

var URLPrototype = URLConstructor.prototype;

var serializeURL = function () {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var username = url.username;
  var password = url.password;
  var host = url.host;
  var port = url.port;
  var path = url.path;
  var query = url.query;
  var fragment = url.fragment;
  var output = scheme + ':';

  if (host !== null) {
    output += '//';

    if (includesCredentials(url)) {
      output += username + (password ? ':' + password : '') + '@';
    }

    output += serializeHost(host);
    if (port !== null) output += ':' + port;
  } else if (scheme == 'file') output += '//';

  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
  if (query !== null) output += '?' + query;
  if (fragment !== null) output += '#' + fragment;
  return output;
};

var getOrigin = function () {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var port = url.port;
  if (scheme == 'blob') try {
    return new URL(scheme.path[0]).origin;
  } catch (error) {
    return 'null';
  }
  if (scheme == 'file' || !isSpecial(url)) return 'null';
  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
};

var getProtocol = function () {
  return getInternalURLState(this).scheme + ':';
};

var getUsername = function () {
  return getInternalURLState(this).username;
};

var getPassword = function () {
  return getInternalURLState(this).password;
};

var getHost = function () {
  var url = getInternalURLState(this);
  var host = url.host;
  var port = url.port;
  return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;
};

var getHostname = function () {
  var host = getInternalURLState(this).host;
  return host === null ? '' : serializeHost(host);
};

var getPort = function () {
  var port = getInternalURLState(this).port;
  return port === null ? '' : String(port);
};

var getPathname = function () {
  var url = getInternalURLState(this);
  var path = url.path;
  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
};

var getSearch = function () {
  var query = getInternalURLState(this).query;
  return query ? '?' + query : '';
};

var getSearchParams = function () {
  return getInternalURLState(this).searchParams;
};

var getHash = function () {
  var fragment = getInternalURLState(this).fragment;
  return fragment ? '#' + fragment : '';
};

var accessorDescriptor = function (getter, setter) {
  return {
    get: getter,
    set: setter,
    configurable: true,
    enumerable: true
  };
};

if (descriptors) {
  objectDefineProperties(URLPrototype, {
    // `URL.prototype.href` accessors pair
    // https://url.spec.whatwg.org/#dom-url-href
    href: accessorDescriptor(serializeURL, function (href) {
      var url = getInternalURLState(this);
      var urlString = String(href);
      var failure = parseURL(url, urlString);
      if (failure) throw TypeError(failure);
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.origin` getter
    // https://url.spec.whatwg.org/#dom-url-origin
    origin: accessorDescriptor(getOrigin),
    // `URL.prototype.protocol` accessors pair
    // https://url.spec.whatwg.org/#dom-url-protocol
    protocol: accessorDescriptor(getProtocol, function (protocol) {
      var url = getInternalURLState(this);
      parseURL(url, String(protocol) + ':', SCHEME_START);
    }),
    // `URL.prototype.username` accessors pair
    // https://url.spec.whatwg.org/#dom-url-username
    username: accessorDescriptor(getUsername, function (username) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(username));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.username = '';

      for (var i = 0; i < codePoints.length; i++) {
        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.password` accessors pair
    // https://url.spec.whatwg.org/#dom-url-password
    password: accessorDescriptor(getPassword, function (password) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(password));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.password = '';

      for (var i = 0; i < codePoints.length; i++) {
        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.host` accessors pair
    // https://url.spec.whatwg.org/#dom-url-host
    host: accessorDescriptor(getHost, function (host) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(host), HOST);
    }),
    // `URL.prototype.hostname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hostname
    hostname: accessorDescriptor(getHostname, function (hostname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(hostname), HOSTNAME);
    }),
    // `URL.prototype.port` accessors pair
    // https://url.spec.whatwg.org/#dom-url-port
    port: accessorDescriptor(getPort, function (port) {
      var url = getInternalURLState(this);
      if (cannotHaveUsernamePasswordPort(url)) return;
      port = String(port);
      if (port == '') url.port = null;else parseURL(url, port, PORT);
    }),
    // `URL.prototype.pathname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-pathname
    pathname: accessorDescriptor(getPathname, function (pathname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      url.path = [];
      parseURL(url, pathname + '', PATH_START);
    }),
    // `URL.prototype.search` accessors pair
    // https://url.spec.whatwg.org/#dom-url-search
    search: accessorDescriptor(getSearch, function (search) {
      var url = getInternalURLState(this);
      search = String(search);

      if (search == '') {
        url.query = null;
      } else {
        if ('?' == search.charAt(0)) search = search.slice(1);
        url.query = '';
        parseURL(url, search, QUERY);
      }

      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.searchParams` getter
    // https://url.spec.whatwg.org/#dom-url-searchparams
    searchParams: accessorDescriptor(getSearchParams),
    // `URL.prototype.hash` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hash
    hash: accessorDescriptor(getHash, function (hash) {
      var url = getInternalURLState(this);
      hash = String(hash);

      if (hash == '') {
        url.fragment = null;
        return;
      }

      if ('#' == hash.charAt(0)) hash = hash.slice(1);
      url.fragment = '';
      parseURL(url, hash, FRAGMENT);
    })
  });
} // `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson


redefine(URLPrototype, 'toJSON', function toJSON() {
  return serializeURL.call(this);
}, {
  enumerable: true
}); // `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior

redefine(URLPrototype, 'toString', function toString() {
  return serializeURL.call(this);
}, {
  enumerable: true
});

if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL; // `URL.createObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
  // eslint-disable-next-line no-unused-vars

  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
    return nativeCreateObjectURL.apply(NativeURL, arguments);
  }); // `URL.revokeObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
  // eslint-disable-next-line no-unused-vars

  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
    return nativeRevokeObjectURL.apply(NativeURL, arguments);
  });
}

setToStringTag(URLConstructor, 'URL');
_export({
  global: true,
  forced: !nativeUrl,
  sham: !descriptors
}, {
  URL: URLConstructor
});

var DATA_URL_PATTERN = new RegExp("^data:");
var ABSOLUTE_URL_PATTERN = new RegExp("^https?://");
/**
 * @summary Utility Class for DOM
 * @private
 * @memberof mapray
 */

var Dom =
/*#__PURE__*/
function () {
  function Dom() {
    _classCallCheck(this, Dom);
  }

  _createClass(Dom, null, [{
    key: "createCanvasContext",

    /**
     * @param  {number}  width
     * @param  {number}  height
     * @return {CanvasRenderingContext2D}
     */
    value: function createCanvasContext(width, height) {
      var canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      return canvas.getContext("2d");
    }
    /**
     * @summary ç»åãèª­ã¿è¾¼ã¿ã¾ãã
     * @param  {string|Blob}  src
     * @Param  {object}  options
     * @param  {mapray.CredentialMode}  [options.credentials=mapray.CredentialMode.SAME_ORIGIN]
     */

  }, {
    key: "loadImage",
    value: function () {
      var _loadImage = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(src) {
        var options,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return new Promise(function (resolve, reject) {
                  var image = new Image();

                  image.onload = function (event) {
                    return resolve(event.target);
                  };

                  image.onerror = function (event) {
                    return reject(new Error("Failed to load image"));
                  };

                  if (options.credentials !== CredentialMode.OMIT) {
                    image.crossOrigin = options.credentials === CredentialMode.INCLUDE ? "use-credentials" : "anonymous";
                  }

                  image.src = src instanceof Blob ? URL.createObjectURL(src) : src;
                });

              case 3:
                return _context.abrupt("return", _context.sent);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function loadImage(_x) {
        return _loadImage.apply(this, arguments);
      }

      return loadImage;
    }()
    /**
     * @summary ç»åãèª­ã¿è¾¼ã¾ããã¾ã§å¾ã¡ã¾ãã
     * @param  {HTMLImageElement}  image
     */

  }, {
    key: "waitForLoad",
    value: function () {
      var _waitForLoad = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(image) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (image.src) {
                  _context2.next = 2;
                  break;
                }

                throw new Error("src was not set");

              case 2:
                if (!image.complete) {
                  _context2.next = 4;
                  break;
                }

                return _context2.abrupt("return", image);

              case 4:
                _context2.next = 6;
                return new Promise(function (resolve, reject) {
                  var prevOnLoad = image.onload;
                  var prevOnError = image.onerror;

                  image.onload = function (event) {
                    if (prevOnLoad) prevOnLoad(event);
                    resolve(event.target);
                  };

                  image.onerror = function (event) {
                    if (prevOnError) prevOnError(event);
                    reject(new Error("Failed to load image"));
                  };
                });

              case 6:
                return _context2.abrupt("return", _context2.sent);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function waitForLoad(_x2) {
        return _waitForLoad.apply(this, arguments);
      }

      return waitForLoad;
    }()
  }, {
    key: "resolveUrl",
    value: function resolveUrl(baseUrl, url) {
      if (DATA_URL_PATTERN.test(url) || ABSOLUTE_URL_PATTERN.test(url)) {
        // url ããã¼ã¿ url ã¾ãã¯çµ¶å¯¾ url ã®ã¨ãã¯
        // ãã®ã¾ã¾ url ããªã¯ã¨ã¹ã
        return url;
      } else {
        // ããä»¥å¤ã®ã¨ãã¯ url ãç¸å¯¾ url ã¨è§£éã
        // åºåº url ã¨çµåãã url ããªã¯ã¨ã¹ã
        return baseUrl + url;
      }
    }
  }]);

  return Dom;
}();

Dom.SYSTEM_FONT_FAMILY = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'";

/**
 * @classdesc ãªã½ã¼ã¹ã¯ã©ã¹
 * URLãDBãã¯ã©ã¦ããµã¼ãã¹ç­ãåç¨®ãªã½ã¼ã¹ã¸ã®ã¢ã¯ã»ã¹ãåä¸ã¤ã³ã¿ã¼ãã§ã¼ã¹ã§æä¾ãããã¨ãç®çã¨ããæ½è±¡ã¯ã©ã¹ã§ãã
 * åºæ¬æ©è½ï¼
 * ã»ã³ã³ã¹ãã©ã¯ã¿ç­ã«ãããããããURLããã¼ã¿ã®ä½ç½®ãç¤ºããã­ããã£ãè¨­å®
 * ã»load()ã«ãããªã½ã¼ã¹ãèª­ã¿è¾¼ã
 * ã»loadSubResource()ã«ãããµããªã½ã¼ã¹ãèª­ã¿è¾¼ã
 *
 * @memberof mapray
 */

var Resource =
/*#__PURE__*/
function () {
  function Resource() {
    _classCallCheck(this, Resource);
  }

  _createClass(Resource, [{
    key: "load",

    /**
     * ãªã½ã¼ã¹ãèª­ã¿è¾¼ã¿ã¾ãã
     */
    value: function () {
      var _load = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                throw new Error("Not Implemented");

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function load() {
        return _load.apply(this, arguments);
      }

      return load;
    }()
    /**
     * @summary ãªã½ã¼ã¹ã®èª­ã¿è¾¼ã¿ãã­ã£ã³ã»ã«ã§ããå ´åã¯ã­ã£ã³ã»ã«ãã¾ãã
     */

  }, {
    key: "cancel",
    value: function cancel() {}
    /**
     * @summary ãµããªã½ã¼ã¹ããµãã¼ãããããè¿ãã¾ãã
     * @return {boolean}
     */

  }, {
    key: "loadSubResourceSupported",
    value: function loadSubResourceSupported() {
      return false;
    }
    /**
     * @summary ãµããªã½ã¼ã¹ãèª­ã¿è¾¼ã¿ã¾ãã
     * @param {string}  url       URL
     * @param {object} options
     * @param {mapray.Resource.ResourceType} [options.type] è¿å´ããã¿ã¤ããæå®ãã¾ãã
     * @return {object} options.type ã«å¿ããåã§è¿å´ããã¾ãã
     */

  }, {
    key: "loadSubResource",
    value: function () {
      var _loadSubResource = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(url) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                throw new Error("Not Supported");

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function loadSubResource(_x) {
        return _loadSubResource.apply(this, arguments);
      }

      return loadSubResource;
    }()
    /**
     * @summary é¢é£ãªã½ã¼ã¹ããµãã¼ãããããè¿ãã¾ãã
     * @return {boolean}
     */

  }, {
    key: "resolveResourceSupported",
    value: function resolveResourceSupported() {
      return false;
    }
    /**
     * @summary é¢é£ãªã½ã¼ã¹ãèª­ã¿è¾¼ã¿ã¾ãã
     * @return {boolean}
     */

  }, {
    key: "resolveResource",
    value: function () {
      var _resolveResource = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(url) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                throw new Error("Not Supported");

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function resolveResource(_x2) {
        return _resolveResource.apply(this, arguments);
      }

      return resolveResource;
    }()
    /**
     * @summary ãªã½ã¼ã¹å
     */

  }], [{
    key: "ResourceType",
    get: function get() {
      return ResourceType;
    }
  }]);

  return Resource;
}();
/**
 * @summary ãªã½ã¼ã¹ã®ç¨®é¡
 * @enum {object}
 * @memberof mapray.ResourceType
 * @constant
 */


var ResourceType = {
  /**
   * JSON
   */
  JSON: {
    id: "JSON"
  },

  /**
   * ãã¤ããª(ArrayBuffer)
   */
  BINARY: {
    id: "BINARY"
  },

  /**
   * ç»åï¼Imageï¼
   */
  IMAGE: {
    id: "IMAGE"
  }
};
/**
 * @classdesc URLãªã½ã¼ã¹ã§ãã
 */

var URLResource =
/*#__PURE__*/
function (_Resource) {
  _inherits(URLResource, _Resource);

  /**
   * @param {string} url
   * @param {object} [options]
   * @param {mapray.Resource.ResourceType} [options.type]
   * @param {mapray.Transform} [options.transform]
   */
  function URLResource(url) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, URLResource);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(URLResource).call(this));
    _this._url = url;
    var index = url.lastIndexOf('/');
    if (index === -1) throw new Error("invalid url");
    _this._base_url = _this._url.substr(0, index + 1);
    _this._type = options.type || "json";
    _this._transform = options.transform || defaultTransformCallback;
    _this._abort_ctrl = new AbortController();
    return _this;
  }
  /**
   * @summary ãªã½ã¼ã¹ã®url
   * @type {string}
   */


  _createClass(URLResource, [{
    key: "load",

    /**
     * @summary ãã®ãªã½ã¼ã¹ãèª­ã¿è¾¼ã¿ã¾ãã
     * @param {object} [options]
     */
    value: function () {
      var _load2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        var options,
            _args4 = arguments;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
                _context4.next = 3;
                return this._loadURLResource(this._url, options.type || this._type, options);

              case 3:
                return _context4.abrupt("return", _context4.sent);

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function load() {
        return _load2.apply(this, arguments);
      }

      return load;
    }()
    /**
     * @summary ãªã½ã¼ã¹ã®èª­ã¿è¾¼ã¿ãã­ã£ã³ã»ã«ãã¾ãã
     */

  }, {
    key: "cancel",
    value: function cancel() {
      this._abort_ctrl.abort();
    }
    /**
     * @summary ãã®ã¯ã©ã¹ã§ã®ããã©ã«ãå®è£ã§ã¯ãtrueãè¿å´ãã¾ãã
     * @return {boolean}
     */

  }, {
    key: "loadSubResourceSupported",
    value: function loadSubResourceSupported() {
      return true;
    }
    /**
     * @summary ãµããªã½ã¼ã¹ãèª­ã¿è¾¼ã¿ã¾ãã
     * @param {string} subUrl URL
     * @param {object} options
     * @param {mapray.Resource.ResourceType} [options.type] è¿å´ããã¿ã¤ããæå®ãã¾ãã
     * @return {object} options.type ã«å¿ããåã§è¿å´ããã¾ãã
     */

  }, {
    key: "loadSubResource",
    value: function () {
      var _loadSubResource2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(subUrl) {
        var options,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};
                _context5.next = 3;
                return this._loadURLResource(Dom.resolveUrl(this._base_url, subUrl), options.type, options);

              case 3:
                return _context5.abrupt("return", _context5.sent);

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function loadSubResource(_x3) {
        return _loadSubResource2.apply(this, arguments);
      }

      return loadSubResource;
    }()
    /**
     * @summary é¢é£ãªã½ã¼ã¹ããµãã¼ãããããè¿ãã¾ãã
     * @return {boolean}
     */

  }, {
    key: "resolveResourceSupported",
    value: function resolveResourceSupported() {
      return true;
    }
    /**
     * @summary é¢é£ãªã½ã¼ã¹ãèª­ã¿è¾¼ã¿ã¾ãã
     * @param {string} urlã
     * @return {Resource}
     */

  }, {
    key: "resolveResource",
    value: function resolveResource(sub_url) {
      var url = Dom.resolveUrl(this._base_url, sub_url);
      return new URLResource(url, {
        transform: this._transform
      });
    }
    /**
     * @param {string} url
     * @param {mapray.Resource.ResourceType} [type]
     * @private
     */

  }, {
    key: "_loadURLResource",
    value: function () {
      var _loadURLResource2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(url, type) {
        var options,
            tr,
            http_option,
            response,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                options = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : {};
                tr = this._transform(url, type);

                if (!(type === ResourceType.IMAGE)) {
                  _context6.next = 6;
                  break;
                }

                _context6.next = 5;
                return Dom.loadImage(tr.url, tr);

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
                http_option = this._make_fetch_params(tr) || {};
                if (options.signal) http_option.signal = options.signal;
                _context6.next = 10;
                return HTTP.get(tr.url, null, http_option);

              case 10:
                response = _context6.sent;

                if (response.ok) {
                  _context6.next = 13;
                  break;
                }

                throw new Error(response.statusText);

              case 13:
                if (!(type === ResourceType.JSON)) {
                  _context6.next = 19;
                  break;
                }

                _context6.next = 16;
                return response.json();

              case 16:
                _context6.t0 = _context6.sent;
                _context6.next = 27;
                break;

              case 19:
                if (!(type === ResourceType.BINARY)) {
                  _context6.next = 25;
                  break;
                }

                _context6.next = 22;
                return response.arrayBuffer();

              case 22:
                _context6.t1 = _context6.sent;
                _context6.next = 26;
                break;

              case 25:
                _context6.t1 = response;

              case 26:
                _context6.t0 = _context6.t1;

              case 27:
                return _context6.abrupt("return", _context6.t0);

              case 28:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _loadURLResource(_x4, _x5) {
        return _loadURLResource2.apply(this, arguments);
      }

      return _loadURLResource;
    }()
    /**
     * fetch() ã® init å¼æ°ã«ä¸ãããªãã¸ã§ã¯ããçæ
     * @private
     */

  }, {
    key: "_make_fetch_params",
    value: function _make_fetch_params(tr) {
      var init = {
        signal: this._abort_ctrl.signal,
        credentials: (tr.credentials || CredentialMode.OMIT).credentials
      };

      if (tr.headers) {
        init.headers = tr.headers;
      }

      return init;
    }
  }, {
    key: "url",
    get: function get() {
      return this._url;
    }
  }]);

  return URLResource;
}(Resource);

function defaultTransformCallback(url, type) {
  return {
    url: url
  };
}

/**
 * @summary ã­ã¼ãã¼ã¯ã©ã¹
 * @memberof mapray
 */

var Loader =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Scene} scene èª­ã¿è¾¼ã¿åã®ã·ã¼ã³
   * @param {mapray.Resource} resource 
   * @param {object} [options={}]
   * @param {object} [options.onLoad] å¨ã¦ã®èª­ã¿è¾¼ã¿å®äºæã«å¼ã°ãã
   * @param {mapray.Loader.EntityCallback} [options.onEntity] ã¨ã³ãã£ãã£ãèª­ã¿è¾¼ã¾ãããã³ã«å¼ã°ãã
   */
  function Loader(scene, resource) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Loader);

    this._scene = scene;

    if (!(resource instanceof Resource)) {
      throw new Error("Unsupported Resource Type: " + resource);
    }

    this._resource = resource;
    this._status = Loader.Status.NOT_LOADED;
    this._onLoad = options.onLoad || defaultOnLoadCallback;
    this._onEntity = options.onEntity || defaultOnEntityCallback;
  }
  /**
   * @summary èª­ã¿è¾¼ã¿åã®ã·ã¼ã³
   * @type {mapray.Scene}
   * @readonly
   */


  _createClass(Loader, [{
    key: "_setStatus",

    /**
     * @private
     */
    value: function _setStatus(status) {
      this._status = status;
    }
    /**
     * @summary èª­ã¿è¾¼ã¿ãå®è¡ãã¾ãã
     * @returns {Promise}
     */

  }, {
    key: "load",
    value: function load() {
      var _this = this;

      if (this.status !== Loader.Status.NOT_LOADED) {
        return Promise.reject(new Error("Illegal Status: " + this.status));
      }

      return Promise.resolve().then(function () {
        _this._setStatus(Loader.Status.LOADING);

        _this.scene.addLoader(_this);

        return _this._load();
      })["catch"](function (error) {
        // JSON ãã¼ã¿ã®åå¾ã«å¤±æ (ã­ã£ã³ã»ã«ã«ããå¤±æã®å¯è½æ§ãã)
        console.log(error);

        _this._scene.removeLoader(_this);

        _this._onLoad(_this, false);

        if (_this._status !== Loader.Status.CANCELED) {
          _this._setStatus(Loader.Status.ABORTED);
        }

        throw error;
      }).then(function (value) {
        _this._scene.removeLoader(_this);

        if (_this._status === Loader.Status.CANCELED) {
          _this._onLoad(_this, false);

          throw new Error("canceled");
        } else {
          _this._setStatus(Loader.Status.LOADED);

          _this._onLoad(_this, true);

          return value;
        }
      });
    }
    /**
     * @summary èª­ã¿è¾¼ã¿å¦çã®å®æãç¶æ¿ã¯ã©ã¹ã«ãã£ã¦å®è£ãããã
     * @private
     */

  }, {
    key: "_load",
    value: function _load() {
      throw new Error("_load() is not implemented in " + this.constructor.name);
    }
    /**
     * @summary èª­ã¿è¾¼ã¿ã®åãæ¶ã
     * @desc
     * <p>çµäºã³ã¼ã«ããã¯é¢æ°ã¯ isSuccess == false ã§å¼ã³åºãããã</p>
     */

  }, {
    key: "cancel",
    value: function cancel() {
      if (this._status === Loader.Status.LOADING || this._status === Loader.Status.LOADED) {
        this._setStatus(Loader.Status.CANCELED);

        this._resource.cancel();

        this._cancel(); // this._scene.removeLoader( this );
        // this._onLoad( this, false );

      }
    }
    /**
     * @summary ã­ã£ã³ã»ã«æã«è¡ãå¦çãç¶æ¿ã¯ã©ã¹ã«ãã£ã¦å®è£ãããã
     * @private
     */

  }, {
    key: "_cancel",
    value: function _cancel() {}
    /**
     * åãæ¶ãç¶æã®ã¨ãä¾å¤ãæãã
     * @private
     */

  }, {
    key: "_check_cancel",
    value: function _check_cancel() {
      if (this.status === Loader.Status.CANCELED) {
        throw new Error("canceled");
      }
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
    /**
     * @summary ã·ã¼ã³ãªã½ã¼ã¹
     * @type {string}
     * @readonly
     */

  }, {
    key: "resource",
    get: function get() {
      return this._resource;
    }
    /**
     * ã­ã¼ãã¼èª­ã¿è¾¼ã¿ã®ç¶æ
     * @readonly
     */

  }, {
    key: "status",
    get: function get() {
      return this._status;
    }
  }]);

  return Loader;
}();
/**
 * @summary Entityèª­ã¿è¾¼ã¿ã³ã¼ã«ããã¯
 * @callback EntityCallback
 * @desc
 * <p>èª­ã¿è¾¼ã¿å¦çã®ä¸­ã§Entityãçæãããéã«å¼ã°ããã
 * ä¸åº¦ã®èª­ã¿è¾¼ã¿(load()å¼ã³åºã)ã«ããã¦è¤æ°ã®ã¨ã³ãã£ãã£ãçæãããå ´åã¯ãã¨ã³ãã£ãã£ãçæããããã³ã«å¼ã°ããã
 * ãã®é¢æ°ãLoaderã«æå®ããå ´åã¯ãcallbackå¦çã®ä¸­ã§Entityãsceneã¸è¿½å ããå¿è¦ãããã
 * geojsonã®ããã«ãè¦ç´ ãã¨ã«ãã­ããã£ãå«ãããããããªå ´åã¯ãpropã«ããå¤ã«ã¢ã¯ã»ã¹ããã
 * </p>
 *
 * @param  {mapray.Loader} loader Loader
 * @param  {mapray.Entity} entity èª­ã¿è¾¼ã¾ããEntity
 * @param  {object} prop ã¨ã³ãã£ãã£çæã®åã¨ãªããªãã¸ã§ã¯ã
 *
 * @example
 * const loader = new mapray.SceneLoader( viewer.scene, resource, {
 *         onEntity: ( loader, entity, prop ) => {
 *             entity.setScale( [ 2, 2, 2 ] );
 *             loader.scene.addEntity( entity );
 *         }
 * } );
 * loader.load();
 * 
 * @memberof mapray.Loader
 */


Loader.Status = {
  NOT_LOADED: "Not Loaded",
  LOADING: "Loading",
  LOADED: "Loaded",
  CANCELED: "Canceled",
  ERROR: "ERROR"
};

function defaultOnLoadCallback(loader, isSuccess) {}

function defaultOnEntityCallback(loader, entity) {
  loader.scene.addEntity(entity);
}

// ãã®ããã«ããçç±ã¯ GeoMath.js ã®æå¾ãåç§

/**
 * @summary glTF ãªãã¸ã§ã¯ãã®å±éãã¼ã¿
 *
 * @classdesc
 * <p>å¤ãã® glTF ãªãã¸ã§ã¯ãã«å±éã«å­å¨ãããæ¬¡ã®ãã­ããã£ã®å¤ãåå¾ããã<p>
 * <pre>
 *   - name
 *   - extensions
 *   - extras
 * </pre>
 *
 * @memberof mapray.gltf
 * @private
 */
var CommonData =
/*#__PURE__*/
function () {
  /**
   * @param {object}             json  JSON ãªãã¸ã§ã¯ã
   * @param {mapray.gltf.Context} ctx  èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   */
  function CommonData(json, ctx) {
    _classCallCheck(this, CommonData);

    // specification/2.0/schema/glTFChildOfRootProperty.schema.json
    this._name = json.name || null;
    this._extensions = ctx.extractUsedExtensions(json.extensions || {});
    this._extras = json.extras || {};
  }
  /**
   * @summary ãªãã¸ã§ã¯ãåãåå¾
   *
   * @return {?string}  ãªãã¸ã§ã¯ãå
   */


  _createClass(CommonData, [{
    key: "getName",
    value: function getName() {
      return this._name;
    }
    /**
     * @summary æ¡å¼µæ©è½åºæãªãã¸ã§ã¯ããåå¾
     *
     * @param {string} id  æ¡å¼µæ©è½ã®è­å¥å­
     *
     * @return {?object}  æ¡å¼µæ©è½åºæãªãã¸ã§ã¯ã
     */

  }, {
    key: "getExtensions",
    value: function getExtensions(id) {
      var extension = this._extensions[id];
      return extension !== undefined ? extension : null;
    }
    /**
     * @summary ã¢ããªã±ã¼ã·ã§ã³åºæãã¼ã¿ãåå¾
     *
     * @param {string} id  ã¢ããªã±ã¼ã·ã§ã³åºæãã¼ã¿ã®è­å¥å­
     *
     * @return {?object}  ã¢ããªã±ã¼ã·ã§ã³åºæãã¼ã¿
     */

  }, {
    key: "getExtras",
    value: function getExtras(id) {
      var extra = this._extras[id];
      return extra !== undefined ? extra : null;
    }
  }]);

  return CommonData;
}();

/**
 * èª­ã¿è¾¼ãã  glTF ãã¼ã¿ã®åå®¹
 *
 * @memberof mapray.gltf
 * @private
 */

var Content =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.gltf.Context}    ctx  èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   * @param {mapray.gltf.Scene[]} scenes  ã·ã¼ã³ã®éå
   * @param {number} default_scene_index  æ¢å®ã·ã¼ã³ã®ç´¢å¼ (æ¢å®ã·ã¼ã³ããªãã¨ãã¯ -1)
   */
  function Content(ctx, scenes, default_scene_index) {
    _classCallCheck(this, Content);

    this._commonData = new CommonData(ctx.gjson, ctx);
    this._scenes = scenes;
    this._default_scene_index = default_scene_index;
  }
  /**
   * glTF ãªãã¸ã§ã¯ãã®å±éãã¼ã¿
   *
   * @type {mapray.gltf.CommonData}
   * @readonly
   */


  _createClass(Content, [{
    key: "commonData",
    get: function get() {
      return this._commonData;
    }
    /**
     * @summary ã·ã¼ã³ã®éå
     *
     * @type {mapray.gltf.Scene[]}
     * @readonly
     */

  }, {
    key: "scenes",
    get: function get() {
      return this._scenes;
    }
    /**
     * @summary æ¢å®ã·ã¼ã³ã®ç´¢å¼
     *
     * <p>æ¢å®ã·ã¼ã³ã®ç´¢å¼ãè¿ãããã ãæ¢å®ã·ã¼ã³ããªãã¨ãã¯ -1 ãè¿ãã</p>
     *
     * @type {number}
     * @readonly
     */

  }, {
    key: "default_scene_index",
    get: function get() {
      return this._default_scene_index;
    }
  }]);

  return Content;
}();

/**
 * @summary ã¢ãã«ãã¯ã¹ãã£
 * @memberof mapray
 * @package
 */
var Texture =
/*#__PURE__*/
function () {
  /**
   * <p>ãªãã·ã§ã³ mag_filter, min_filter, wrap_s, wrap_t ã¯ WebGL ã®å®æ°ã¨åãå¤ãæå®ããã
   *    ãããã®ãã¡ãæå®ããªãã£ããªãã·ã§ã³ã¯ usage ãªãã·ã§ã³ã«ããæ±ºå®ãããã</p>
   *
   * @param {mapray.GLEnv}                          glenv   WebGL ç°å¢
   * @param {?(HTMLImageElement|HTMLCanvasElement)} image   åç»å (usage=COLOR ã®ã¨ãã¯ null)
   * @param {object}                             [options]  ãªãã·ã§ã³éå
   * @param {mapray.Texture.Usage} [options.usage=GENERAL]    ãã¯ã¹ãã£ç¨é
   * @param {number}               [options.mag_filter]       æ¡å¤§ãã£ã«ã¿ (NEAREST | LINEAR)
   * @param {number}               [options.min_filter]       ç¸®å°ãã£ã«ã¿ (NEAREST | LINEAR | NEAREST_MIPMAP_NEAREST |
   *                                                          LINEAR_MIPMAP_NEAREST | NEAREST_MIPMAP_LINEAR | LINEAR_MIPMAP_LINEAR)
   * @param {number}               [options.wrap_s]           S Wrap (CLAMP_TO_EDGE | MIRRORED_REPEAT | REPEAT)
   * @param {number}               [options.wrap_t]           T Wrap (CLAMP_TO_EDGE | MIRRORED_REPEAT | REPEAT)
   * @param {boolean}              [options.flip_y=true]      ç»åèª­ã¿è¾¼ã¿æã«ä¸ä¸ãåè»¢ãããï¼
   * @param {mapray.Vector4}       [options.color=[1,1,1,1]]  usage=COLOR ã®ã¨ãã®è²æå®
   */
  function Texture(glenv, image, options) {
    _classCallCheck(this, Texture);

    var opts = options || {};
    this._glenv = glenv;
    this._handle = this._createTexture(image, opts);
  }
  /**
   * @summary ãã¯ã¹ãã£ã®ãã³ãã«
   * @type {WebGLTexture}
   * @readonly
   */


  _createClass(Texture, [{
    key: "dispose",

    /**
     * @summary ãªã½ã¼ã¹ãç ´æ£
     */
    value: function dispose() {
      var gl = this._glenv.context;
      gl.deleteTexture(this._handle);
      this._handle = null;
    }
    /**
     * WebGL ãã¯ã¹ãã£ãªãã¸ã§ã¯ããçæ
     *
     * @param  {?(HTMLImageElement|HTMLCanvasElement)} image  åç»å
     * @param  {object}                                opts   ãªãã·ã§ã³éå
     * @return {WebGLTexture}  WebGL ãã¯ã¹ãã£ãªãã¸ã§ã¯ã
     * @private
     */

  }, {
    key: "_createTexture",
    value: function _createTexture(image, opts) {
      var gl = this._glenv.context;
      var target = gl.TEXTURE_2D;
      var texture = gl.createTexture();

      var params = Texture._getParameters(gl, opts);

      gl.bindTexture(target, texture);
      var flip_y = opts.flip_y !== undefined ? opts.flip_y : true;
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flip_y);

      if (opts.usage === Texture.Usage.COLOR) {
        // åä¸è²ãã¯ã¹ãã£ã¼
        gl.texImage2D(target, 0, params.format, 1, 1, 0, params.format, params.type, Texture._getColorArray(opts));
      } else {
        // ç»åãã¯ã¹ãã£ã¼
        gl.texImage2D(target, 0, params.format, params.format, params.type, image);
      }

      if (flip_y) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      }

      if (Texture._generateMipmapQ(gl, params)) {
        gl.generateMipmap(target);
      }

      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, params.mag_filter);
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, params.min_filter);
      gl.texParameteri(target, gl.TEXTURE_WRAP_S, params.wrap_s);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, params.wrap_t);
      gl.bindTexture(target, null);
      return texture;
    }
    /**
     * ãã¯ã¹ãã£ã®çæãã©ã¡ã¼ã¿ãåå¾
     *
     * @param  {WebGLRenderingContext} gl    WebGL ã³ã³ãã­ã¹ã
     * @param  {object}                opts  ãªãã·ã§ã³éå
     * @return {object}  çæãã©ã¡ã¼ã¿
     * @private
     */

  }, {
    key: "handle",
    get: function get() {
      return this._handle;
    }
  }], [{
    key: "_getParameters",
    value: function _getParameters(gl, opts) {
      var params = {
        format: gl.RGBA,
        type: gl.UNSIGNED_BYTE,
        mag_filter: gl.LINEAR,
        min_filter: gl.LINEAR_MIPMAP_LINEAR,
        wrap_s: gl.REPEAT,
        wrap_t: gl.REPEAT
      };

      if (opts.usage === Texture.Usage.SIMPLETEXT) {
        params.format = gl.ALPHA;
        params.min_filter = gl.LINEAR;
        params.wrap_s = gl.CLAMP_TO_EDGE;
        params.wrap_t = gl.CLAMP_TO_EDGE;
      } else if (opts.usage === Texture.Usage.TEXT) {
        params.min_filter = gl.LINEAR;
        params.wrap_s = gl.CLAMP_TO_EDGE;
        params.wrap_t = gl.CLAMP_TO_EDGE;
      } else if (opts.usage === Texture.Usage.COLOR) {
        params.mag_filter = gl.NEAREST;
        params.min_filter = gl.NEAREST;
      } else if (opts.usage === Texture.Usage.ICON) {
        params.min_filter = gl.LINEAR;
        params.wrap_s = gl.CLAMP_TO_EDGE;
        params.wrap_t = gl.CLAMP_TO_EDGE;
      } // ãªãã·ã§ã³æå®ã«ããä¸æ¸ã


      if (opts.mag_filter !== undefined) {
        params.mag_filter = opts.mag_filter;
      }

      if (opts.min_filter !== undefined) {
        params.min_filter = opts.min_filter;
      }

      if (opts.wrap_s !== undefined) {
        params.wrap_s = opts.wrap_s;
      }

      if (opts.wrap_t !== undefined) {
        params.wrap_t = opts.wrap_t;
      }

      return params;
    }
    /**
     * ãã¯ã¹ãã£ã®çæãã©ã¡ã¼ã¿ãåå¾
     *
     * @param  {object} opts  ãªãã·ã§ã³éå
     * @return {Uint8Array}   åä¸è²ç¨ã®ç»åãã¼ã¿
     * @private
     */

  }, {
    key: "_getColorArray",
    value: function _getColorArray(opts) {
      var color = opts.color || [1, 1, 1, 1];
      var pixels = color.map(function (value) {
        return Math.round(255 * value);
      });
      return new Uint8Array(pixels);
    }
    /**
     * ãããããããçæãããï¼
     *
     * @param  {WebGLRenderingContext} gl      WebGL ã³ã³ãã­ã¹ã
     * @param  {object}                params  çæãã©ã¡ã¼ã¿
     * @return {boolean}  ãããããããçæããã¨ã true, ããä»¥å¤ã®ã¨ã false
     * @private
     */

  }, {
    key: "_generateMipmapQ",
    value: function _generateMipmapQ(gl, params) {
      var filter = params.min_filter;
      return filter == gl.NEAREST_MIPMAP_NEAREST || filter == gl.LINEAR_MIPMAP_NEAREST || filter == gl.NEAREST_MIPMAP_LINEAR || filter == gl.LINEAR_MIPMAP_LINEAR;
    }
  }]);

  return Texture;
}();
/**
 * @summary ãã¯ã¹ãã£ã®ç¨é
 * @desc
 * {@link mapray.Texture} ã®æ§ç¯å­ã§ opts.usage ãã©ã¡ã¼ã¿ã«æå®ããå¤ã®åã§ããã
 * @enum {object}
 * @memberof mapray.Texture
 * @constant
 */


var Usage = {
  /**
   * ä¸è¬ç¨é (æ¢å®å¤)
   */
  GENERAL: {
    id: "GENERAL"
  },

  /**
   * åä¸è²
   */
  COLOR: {
    id: "COLOR"
  },

  /**
   * ãã­ã¹ãè¡¨ç¤º
   */
  TEXT: {
    id: "TEXT"
  },

  /**
   * ã·ã³ãã«ãã­ã¹ãè¡¨ç¤º
   */
  SIMPLETEXT: {
    id: "SIMPLETEXT"
  },

  /**
   * ã¢ã¤ã³ã³
   */
  ICON: {
    id: "ICON"
  }
}; // ã¯ã©ã¹å®æ°ã®å®ç¾©

{
  Texture.Usage = Usage;
}

/**
 * @summary ã¨ã³ãã£ãã£ã»ãããªã¢ã«
 * @classdesc
 *   ãã®ã¯ã©ã¹ã¯ãmapray.RenderStage.getRenderTarget()ã®å¤ã«ããç°ãªãåä½ãããã
 *   <ul>
 *   <li>
 *   mapray.RenderStage.RenderTarget.SCENEã®å ´åã¯ãéå¸¸éãæç»ãè¡ãã
 *   setParametersã¯ãæç»ã«å¿è¦ãªå¨ã¦ã®ãã©ã¡ã¼ã¿ãè¨­å®ãã¾ãã
 *   <li>mapray.RenderStage.RenderTarget.RIDã®å ´åã¯ã
 *   setParametersã¯ãRIDæç»ã«å¿è¦ãªãã©ã¡ã¼ã¿ã®ã¿è¨­å®ãã¾ãï¼ä¸è¬ã«ãã¯ã¹ãã£ãè²æå ±ã¯é¤å¤ãããï¼ã
 *   ãã®ã¯ã©ã¹ã§ã®å®è£ã¯ãsetParameters()ã«ãããu_ridãè¨­å®ãããããã«ãªã£ã¦ãã¾ãã
 *   </ul>
 * @memberof mapray
 * @extends mapray.Material
 * @private
 */

var EntityMaterial =
/*#__PURE__*/
function (_Material) {
  _inherits(EntityMaterial, _Material);

  /**
   * @param {mapray.GLEnv} glenv    WebGL ç°å¢
   * @param {string}     vs_code  é ç¹ã·ã§ã¼ãã®ã½ã¼ã¹ã³ã¼ã
   * @param {string}     fs_code  ãã©ã°ã¡ã³ãã·ã§ã¼ãã®ã½ã¼ã¹ã³ã¼ã
   */
  function EntityMaterial(glenv, vs_code, fs_code) {
    _classCallCheck(this, EntityMaterial);

    return _possibleConstructorReturn(this, _getPrototypeOf(EntityMaterial).call(this, glenv, vs_code, fs_code));
  }
  /**
   * @summary èæ¯ã¨ã®æ··åãå¿è¦ãï¼
   * @param  {mapray.RenderStage} stage      ã¬ã³ããªã³ã°ã¹ãã¼ã¸
   * @param  {mapray.Primitive}   primitive  ããªããã£ã
   * @return {boolean}                     èæ¯ã¨ã®æ··åãå¿è¦ãªã¨ã true, ããä»¥å¤ã®ã¨ã false
   * @default false
   * @abstract
   */


  _createClass(EntityMaterial, [{
    key: "isTranslucent",
    value: function isTranslucent(stage, primitive) {
      return false;
    }
    /**
     * @summary ãããªã¢ã«ãã©ã¡ã¼ã¿ãè¨­å®
     * @desc
     * <p>äºåã« material.bindProgram() ãããã¨ã</p>
     * @param {mapray.RenderStage} stage      ã¬ã³ããªã³ã°ã¹ãã¼ã¸
     * @param {mapray.Primitive}   primitive  ããªããã£ã
     * @abstract
     */

  }, {
    key: "setParameters",
    value: function setParameters(stage, primitive) {
      if (stage.getRenderTarget() === RenderTarget.RID) {
        this._setRenderId(primitive.rid);
      }
    }
    /**
     * @summary u_obj_to_clip å¤æ°ãè¨­å®
     * @param {mapray.RenderStage} stage      ã¬ã³ããªã³ã°ã¹ãã¼ã¸
     * @param {mapray.Primitive}   primitive  ããªããã£ã
     * @protected
     */

  }, {
    key: "setObjToClip",
    value: function setObjToClip(stage, primitive) {
      var obj_to_gocs = primitive.transform;
      var obj_to_clip = EntityMaterial._obj_to_clip; // obj_to_clip = gocs_to_clip * obj_to_gocs

      GeoMath.mul_GA(stage._gocs_to_clip, obj_to_gocs, obj_to_clip);
      this.setMatrix("u_obj_to_clip", obj_to_clip);
    }
    /**
     * @summary u_obj_to_view å¤æ°ãè¨­å®
     * @param {mapray.RenderStage} stage      ã¬ã³ããªã³ã°ã¹ãã¼ã¸
     * @param {mapray.Primitive}   primitive  ããªããã£ã
     * @protected
     */

  }, {
    key: "setObjToView",
    value: function setObjToView(stage, primitive) {
      var obj_to_gocs = primitive.transform;
      var obj_to_view = EntityMaterial._obj_to_view; // obj_to_view = gocs_to_view * obj_to_gocs

      GeoMath.mul_AA(stage._gocs_to_view, obj_to_gocs, obj_to_view);
      this.setMatrix("u_obj_to_view", obj_to_view);
    }
    /**
     * @private
     */

  }, {
    key: "_setRenderId",
    value: function _setRenderId(id) {
      this.setVector4("u_rid", [(id >> 12 & 0xF) / 0xF, (id >> 8 & 0xF) / 0xF, (id >> 4 & 0xF) / 0xF, (id & 0xF) / 0xF]);
    }
  }]);

  return EntityMaterial;
}(Material); // ã¯ã©ã¹å®æ°ã®å®ç¾©


{
  EntityMaterial._obj_to_clip = GeoMath.createMatrixf(); // è¨ç®ç¨ä¸æé å

  EntityMaterial._obj_to_view = GeoMath.createMatrixf(); // è¨ç®ç¨ä¸æé å
}

var model_vs_code = "attribute vec4 a_position;    // ä½ç½® (ã¢ãã«åº§æ¨ç³»)\nattribute vec3 a_normal;      // æ³ç· (ã¢ãã«åº§æ¨ç³»)\nattribute vec2 a_texcoord;    // ãã¯ã¹ãã£åº§æ¨\n\nuniform mat4  u_obj_to_clip;  // ã¢ãã«åº§æ¨ç³»ããã¯ãªããåº§æ¨ç³»ã¸ã®å¤æ\nuniform mat4  u_obj_to_view;  // ã¢ãã«åº§æ¨ç³»ããè¦ç¹åº§æ¨ç³»ã¸ã®å¤æ\n\nvarying vec3  v_normal;       // æ³ç· (è¦ç¹åº§æ¨ç³»)\nvarying vec2  v_texcoord;     // ãã¯ã¹ãã£åº§æ¨\n\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n\n#ifndef UNLIT\n    v_normal = normalize( vec3( u_obj_to_view * vec4( a_normal, 0.0 ) ) );  // æ³ç· (è¦ç¹åº§æ¨ç³»)\n#endif\n\n    v_texcoord = a_texcoord;\n}\n";

var model_fs_code = "precision highp float;\n\nvarying vec3  v_normal;    // æ³ç· (è¦ç¹åº§æ¨ç³»)\nvarying vec2  v_texcoord;  // ãã¯ã¹ãã£åº§æ¨\n\nuniform vec3      u_light_dir;   // ã©ã¤ãéæ¹å (è¦ç¹åº§æ¨ç³») ã¨å¼·ã\nuniform vec4      u_base_color;  // åºæ¬è²ä¿æ°\nuniform sampler2D u_base_image;  // åºæ¬è²ç»å\n\n\nvoid\nmain()\n{\n#ifndef UNLIT\n    vec3 normal = normalize( v_normal );  // æ³ç· (è¦ç¹åº§æ¨ç³»)\n\n    vec3 dlit = vec3( dot( normal, u_light_dir ) );  // æ¡æ£åã®å¼·ã\n#else\n    vec3 dlit = vec3( 1.0 );\n#endif\n\n    gl_FragColor = u_base_color * texture2D( u_base_image, v_texcoord ) * vec4( dlit, 1.0 );\n}\n";

/**
 * @summary åºæ¬ãããªã¢ã«
 * @memberof mapray
 * @extends mapray.EntityMaterial
 * @private
 */

var ModelMaterial =
/*#__PURE__*/
function (_EntityMaterial) {
  _inherits(ModelMaterial, _EntityMaterial);

  /**
   * @param {mapray.GLEnv} glenv
   * @param {object}  [options]  ãªãã·ã§ã³æå®
   * @param {boolean} [options.is_unlit=false]  ç¡ç§åãï¼
   */
  function ModelMaterial(glenv) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ModelMaterial);

    var preamble = ModelMaterial._getPreamble(options);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ModelMaterial).call(this, glenv, preamble + model_vs_code, preamble + (options.ridMaterial ? rid_fs_code : model_fs_code))); // åä¸è²ãã¯ã¹ãã£

    _this._white_texture = new Texture(glenv, null, {
      usage: Texture.Usage.COLOR,
      color: [1, 1, 1, 1]
    }); // ä¸å¤ãã©ã¡ã¼ã¿ãäºåè¨­å®

    _this.bindProgram();

    _this.setInteger("u_base_image", ModelMaterial.TEXUNIT_BASE_IMAGE);

    return _this;
  }
  /**
   * @override
   */


  _createClass(ModelMaterial, [{
    key: "setParameters",
    value: function setParameters(stage, primitive) {
      _get(_getPrototypeOf(ModelMaterial.prototype), "setParameters", this).call(this, stage, primitive);

      var props = primitive.properties;
      var pbrMR = props.pbrMetallicRoughness; // u_obj_to_clip, u_obj_to_view

      this.setObjToClip(stage, primitive);
      this.setObjToView(stage, primitive);

      if (stage.getRenderTarget() === RenderTarget.SCENE) {
        // åºæ¬è²ä¿æ°
        var bcf = pbrMR["baseColorFactor"];
        var u_base_color = stage.getTranslucentMode() ? [0.5 * bcf[0], 0.5 * bcf[1], 0.5 * bcf[2], 0.5 * bcf[3]] : bcf;
        this.setVector4("u_base_color", u_base_color); // ã©ã¤ãéæ¹å (è¦ç¹åº§æ¨ç³») ã¨å¼·ã

        this.setVector3("u_light_dir", [0, 0, 1]); // ãã¯ã¹ãã£ã®ãã¤ã³ã

        var base_image_texture = this._selectTexture(pbrMR["baseColorTexture"], this._white_texture);

        this.bindTexture2D(ModelMaterial.TEXUNIT_BASE_IMAGE, base_image_texture.handle);
      }
    }
    /**
     * ãã¯ã¹ãã£ãé¸æ
     * @param  {object}         texinfo
     * @param  {mapray.Texture} alt_texure
     * @return {mapray.Texture}
     * @private
     */

  }, {
    key: "_selectTexture",
    value: function _selectTexture(texinfo, alt_texure) {
      if (texinfo !== null) {
        return texinfo.texture;
      } else {
        return alt_texure;
      }
    }
    /**
     * @summary ã·ã§ã¼ãã®åæãåå¾
     *
     * @param {object}  options  ãªãã·ã§ã³æå®
     * @param {boolean} [options.is_unlit=false]  ç¡ç§åãï¼
     *
     * @private
     */

  }], [{
    key: "_getPreamble",
    value: function _getPreamble(options) {
      var is_unlit = options.is_unlit !== undefined ? options.is_unlit : false;
      var lines = []; // UNLIT ãã¯ã­ã®å®ç¾©

      if (is_unlit) {
        lines.push("#define UNLIT");
      } // lines ãæå­åã«ãã¦è¿ã


      return lines.join("\n") + "\n\n";
    }
  }]);

  return ModelMaterial;
}(EntityMaterial); // ã¯ã©ã¹å®æ°ã®å®ç¾©


{
  ModelMaterial.TEXUNIT_BASE_IMAGE = 0; // åºæ¬è²ç»åã®ãã¯ã¹ãã£ã¦ããã
}

/**
 * glTF ã® sampler ã«å¯¾å¿
 * @memberof mapray.gltf
 * @private
 */
var Sampler =
/*#__PURE__*/
function () {
  /**
   * åæå
   * @param {mapray.gltf.Context} ctx    èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   * @param {object}              index  ãµã³ãã©ã¼ç´¢å¼ (éæ°ã®å ´åã¯æ¢å®å¤ãµã³ãã©ã¼)
   */
  function Sampler(ctx, index) {
    _classCallCheck(this, Sampler);

    // specification/2.0/schema/sampler.schema.json
    // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#samplers
    var jsampler = typeof index == 'number' ? ctx.gjson.samplers[index] : {};
    this._magFilter = jsampler.magFilter; // ãã£ã«ã¿ã®æ¢å®å¤ã¯å®è£ä¾å­

    this._minFilter = jsampler.minFilter; // âââ

    this._wrapS = jsampler.wrapS !== undefined ? jsampler.wrapS : Sampler.WRAP_DEFAULT;
    this._wrapT = jsampler.wrapT !== undefined ? jsampler.wrapT : Sampler.WRAP_DEFAULT;
  }
  /**
   * æ¡å¤§ãã£ã«ã¿
   * @type {number|undefined}
   * @readonly
   */


  _createClass(Sampler, [{
    key: "magFilter",
    get: function get() {
      return this._magFilter;
    }
    /**
     * ç¸®å°ãã£ã«ã¿
     * @type {number|undefined}
     * @readonly
     */

  }, {
    key: "minFilter",
    get: function get() {
      return this._minFilter;
    }
    /**
     * S-wrap
     * @type {number}
     * @readonly
     */

  }, {
    key: "wrapS",
    get: function get() {
      return this._wrapS;
    }
    /**
     * T-wrap
     * @type {number}
     * @readonly
     */

  }, {
    key: "wrapT",
    get: function get() {
      return this._wrapT;
    }
  }]);

  return Sampler;
}();

Sampler.WRAP_DEFAULT = 10497; // REPEAT

/**
 * glTF ã® texture ã«å¯¾å¿
 * @memberof mapray.gltf
 * @private
 */

var Texture$1 =
/*#__PURE__*/
function () {
  /**
   * åæå
   * @param {mapray.gltf.Context} ctx    èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   * @param {object}              index  ãã¯ã¹ãã£ç´¢å¼
   */
  function Texture(ctx, index) {
    _classCallCheck(this, Texture);

    // specification/2.0/schema/texture.schema.json
    var jtexture = ctx.gjson.textures[index];
    this._sampler = new Sampler(ctx, jtexture.sampler);
    this._source = ctx.findImage(jtexture.source);
  }
  /**
   * ã¤ã¡ã¼ã¸ãåå¾
   * @type {mapray.gltf.Image}
   * @readonly
   */


  _createClass(Texture, [{
    key: "source",
    get: function get() {
      return this._source;
    }
    /**
     * ãµã³ãã©ãåå¾
     * @type {mapray.gltf.Sampler}
     * @readonly
     */

  }, {
    key: "sampler",
    get: function get() {
      return this._sampler;
    }
  }]);

  return Texture;
}();

/**
 * glTF ã® textureInfo ã«å¯¾å¿
 * @memberof mapray.gltf
 * @private
 */

var TextureInfo =
/*#__PURE__*/
function () {
  /**
   * åæå
   * @param {object}              jtexinfo  ãã¯ã¹ãã£æå ±
   * @param {mapray.gltf.Context} ctx       èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   */
  function TextureInfo(jtexinfo, ctx) {
    _classCallCheck(this, TextureInfo);

    // specification/2.0/schema/textureInfo.schema.json
    this._texture = new Texture$1(ctx, jtexinfo.index);
    this._texCoord = jtexinfo.texCoord !== undefined ? jtexinfo.texCoord : 0;
  }
  /**
   * åç§ãããã¯ã¹ãã£ãåå¾
   * @type {mapray.gltf.Texture}
   */


  _createClass(TextureInfo, [{
    key: "texture",
    get: function get() {
      return this._texture;
    }
    /**
     * åç§ãããã¯ã¹ãã£ãè¨­å®
     * @type {mapray.gltf.Texture}
     */
    ,
    set: function set(value) {
      this._texture = value;
    }
    /**
     * ãã¯ã¹ãã£åº§æ¨ã®ã¤ã³ããã¯ã¹
     * @type {number}
     * @readonly
     */

  }, {
    key: "texCoord",
    get: function get() {
      return this._texCoord;
    }
  }]);

  return TextureInfo;
}();

/**
 * glTF ã® normalTextureInfo ã«å¯¾å¿
 * @memberof mapray.gltf
 * @private
 */

var NormalTextureInfo =
/*#__PURE__*/
function (_TextureInfo) {
  _inherits(NormalTextureInfo, _TextureInfo);

  /**
   * åæå
   * @param {object}              jtexinfo  ãã¯ã¹ãã£æå ±
   * @param {mapray.gltf.Context} ctx       èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   */
  function NormalTextureInfo(jtexinfo, ctx) {
    var _this;

    _classCallCheck(this, NormalTextureInfo);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(NormalTextureInfo).call(this, jtexinfo, ctx)); // specification/2.0/schema/material.normalTextureInfo.schema.json

    _this._scale = jtexinfo.scale !== undefined ? jtexinfo.scale : 1.0;
    return _this;
  }
  /**
   * æ³ç·ã¹ã±ã¼ã«
   * @type {number}
   * @readonly
   */


  _createClass(NormalTextureInfo, [{
    key: "texCoord",
    get: function get() {
      return this._scale;
    }
  }]);

  return NormalTextureInfo;
}(TextureInfo);

/**
 * glTF ã® occlusionTextureInfo ã«å¯¾å¿
 * @memberof mapray.gltf
 * @private
 */

var OcclusionTextureInfo =
/*#__PURE__*/
function (_TextureInfo) {
  _inherits(OcclusionTextureInfo, _TextureInfo);

  /**
   * åæå
   * @param {object}              jtexinfo  ãã¯ã¹ãã£æå ±
   * @param {mapray.gltf.Context} ctx       èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   */
  function OcclusionTextureInfo(jtexinfo, ctx) {
    var _this;

    _classCallCheck(this, OcclusionTextureInfo);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(OcclusionTextureInfo).call(this, jtexinfo, ctx)); // specification/2.0/schema/material.occlusionTextureInfo.schema.json

    _this._strength = jtexinfo.strength !== undefined ? jtexinfo.strength : 1.0;
    return _this;
  }
  /**
   * é®è½å¼·åº¦
   * @type {number}
   * @readonly
   */


  _createClass(OcclusionTextureInfo, [{
    key: "strength",
    get: function get() {
      return this._strength;
    }
  }]);

  return OcclusionTextureInfo;
}(TextureInfo);

/**
 * @summary ã¨ã³ãã£ãã£ç¨ã®ã¢ãã«ãã¼ã¿ãæ ¼ç´
 *
 * @classdesc
 * <p>ã¨ã³ãã£ãã£ãä½¿ç¨ããã¢ãã«ãã¼ã¿ãæ ¼ç´ããã¯ã©ã¹ã§ããã</p>
 *
 * @memberof mapray
 * @private
 * @see mapray.ModelEntity
 */

var ModelContainer =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Scene}        scene    ã¨ã³ãã£ãã£ãæå±ããã·ã¼ã³
   * @param {mapray.gltf.Content} content  å¥åã¢ãã«ãã¼ã¿
   */
  function ModelContainer(scene, content) {
    _classCallCheck(this, ModelContainer);

    this._entries = []; // è¾æ¸: æ´æ° -> Entry

    this._name_map = {}; // è¾æ¸: åå -> Entry

    this._default = null; // æ¢å®ã¢ãã«ã® Entry

    this._offset_transform = GeoMath.setIdentity(GeoMath.createMatrix());
    var share = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = content.scenes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var gltf_scene = _step.value;
        var entry = new Entry$1(scene, gltf_scene, share);

        this._entries.push(entry);

        if (gltf_scene.name !== null) {
          this._name_map[gltf_scene.name] = entry;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (content.default_scene_index >= 0) {
      if (content.default_scene_index < this._entries.length) {
        this._default = this._entries[content.default_scene_index];
      } else {
        throw new Error("default_scene_index is out of range");
      }
    } else {
      if (this._entries.length >= 1) {
        this._default = this._entries[0];
      }
    }
  }
  /**
   * @summary å¯¾å¿å¯è½ãª glTF æ¡å¼µæ©è½ã®éåãåå¾
   *
   * @desc
   * <p>ä¾ãã° {@link mapray.gltf.Tools.load} ã® supported_extensions ãªãã·ã§ã³ã®ããã«ä½¿ç¨ããã</p>
   * <p>glTF ã®ã³ã³ãã³ãããããã®æ¡å¼µæ©è½ã ãã§å¯¾å¿ã§ããªãã¨ããèª­ã¿è¾¼ã¿ã«å¤±æãããã¨ãããã</p>
   *
   * @return {string[]}
   */


  _createClass(ModelContainer, [{
    key: "setOffsetTransform",

    /**
     * @summary ãªãã»ããç¨ã®å¤æè¡åãè¨­å®
     *
     * @param {mapray.Matrix} matrix  ã¢ãã«ã®é ç¹åº§æ¨ãå¤æããå¤æè¡å
     */
    value: function setOffsetTransform(matrix) {
      GeoMath.copyMatrix(matrix, this._offset_transform);
    }
    /**
     * @summary ã¢ãã«ãã¼ã¿ãçæ
     *
     * @desc
     * <p>id ã§æå®ããã¢ãã«ã®ããªããã£ããçæããããã ã id ãçç¥ããã¨ãã¯æ¢å®ã®ã¢ãã«ãé¸æãããã</p>
     * <p>id ã§æå®ããã¢ãã«ãå­å¨ããªãã¨ããã¾ãã¯ id ãçç¥ãããã¢ãã«ãã¾ã£ããå­å¨ããªãã¨ã null ãè¿ãã</p>
     *
     * @param  {number|string} [id]   ã¢ãã« ID
     * @return {?mapray.Primitive[]}  ã¢ãã«ã®ããªããã£ãéå
     */

  }, {
    key: "createPrimitives",
    value: function createPrimitives(id, options) {
      var entry = this._getEntry(id);

      if (entry === null) return null;
      var primitives = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = entry.getPrimitives(options)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var prim = _step2.value;
          var cloned_prim = prim.fastClone();
          GeoMath.mul_AA(this._offset_transform, cloned_prim.transform, cloned_prim.transform); // ãªãã»ããå¤æè¡åãé©ç¨

          cloned_prim.properties = Builder.fastCloneProperties(cloned_prim.properties);
          primitives.push(cloned_prim);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return primitives;
    }
    /**
     * @summary ã¨ã³ããªã¼ãåå¾
     *
     * @param  {number|string} [id]            ã¢ãã« ID
     * @return {?mapray.ModelContainer.Entry}  ã¢ãã«ã¨ã³ããªã¼
     * @private
     */

  }, {
    key: "_getEntry",
    value: function _getEntry(id) {
      if (typeof id == 'number') {
        // id ãæ´æ°ã§æå®
        if (0 <= id && id < this._entries.length) {
          return this._entries[id];
        }
      } else if (typeof id == 'string') {
        // id ãååã§æå®
        if (this._name_map.hasOwnProperty(id)) {
          return this._name_map[id];
        }
      } else {
        // id æå®ãªã
        if (this._entries.length > 0) {
          return this._entries[0];
        }
      }

      return null;
    }
  }], [{
    key: "getSupportedExtensions_glTF",
    value: function getSupportedExtensions_glTF() {
      return ["KHR_materials_unlit"];
    }
  }]);

  return ModelContainer;
}();
/**
 * @summary ã¢ãã«ã¨ã³ããªã¼
 *
 * @memberof mapray.ModelContainer
 * @private
 */


var Entry$1 =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Scene}      mr_scene    Mapray ã·ã¼ã³
   * @param {mapray.gltf.Scene} gltf_scene  glTF ã·ã¼ã³
   * @param {object}            share       Builder ã¤ã³ã¹ã¿ã³ã¹éã®å±ææå ±
   */
  function Entry(mr_scene, gltf_scene, share) {
    _classCallCheck(this, Entry);

    this._builder = new Builder(mr_scene, gltf_scene, share);
  }
  /**
   * @summary mapray.Primitive ã®éåãåå¾
   * @desc
   * <p>transform ãã­ããã£ã¯ããªããã£ãåº§æ¨ç³»ããã¨ã³ãã£ãã£åº§æ¨ç³»ã¸ã®å¤æã«ãªã£ã¦ããã</p>
   * @type {mapray.Primitive[]}
   * @readonly
   */


  _createClass(Entry, [{
    key: "getPrimitives",
    value: function getPrimitives(options) {
      return this._builder.getPrimitives(options);
    }
  }]);

  return Entry;
}();
/**
 * @summary glTF ã·ã¼ã³ãã mapray.Primitive ã®éåãæ§ç¯
 *
 * @memberof mapray.ModelContainer
 * @private
 */


var Builder =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.Scene}      mr_scene    Mapray ã·ã¼ã³
   * @param {mapray.gltf.Scene} gltf_scene  glTF ã·ã¼ã³
   * @param {object}            share       Builder ã¤ã³ã¹ã¿ã³ã¹éã®å±ææå ±
   */
  function Builder(mr_scene, gltf_scene, share) {
    _classCallCheck(this, Builder);

    // share ãåæå
    if (!share.buffer_map) {
      share.buffer_map = new Map(); // gltf.Buffer  -> MeshBuffer

      share.texture_map = new Map(); // gltf.Texture -> Texture
    }

    this._mr_scene = mr_scene;
    this._glenv = mr_scene.glenv;
    this._primitives = [];
    this._pickPrimitives = [];
    this._buffer_map = share.buffer_map;
    this._texture_map = share.texture_map;
    var identity = GeoMath.setIdentity(GeoMath.createMatrix()); // ã·ã¼ã³ããã·ã¼ã³ã¸ã®å¤æ (æç­è¡å)

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = gltf_scene.root_nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var node = _step3.value;

        this._addNode(node, identity);
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }
  /**
   * @summary mapray.Primitive ã®éåãåå¾
   * @desc
   * <p>transform ãã­ããã£ã¯ããªããã£ãåº§æ¨ç³»ããã¨ã³ãã£ãã£åº§æ¨ç³»ã¸ã®å¤æã«ãªã£ã¦ããã</p>
   * @type {mapray.Primitive[]}
   * @readonly
   */


  _createClass(Builder, [{
    key: "getPrimitives",
    value: function getPrimitives() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return options.ridMaterial ? this._pickPrimitives : this._primitives;
    }
    /**
     * ãã¼ããè¿½å 
     *
     * @param {mapray.gltf.Node} node  è¿½å å¯¾è±¡ã®ãã¼ã
     * @param {mapray.Matrix}    ptos  è¦ªãã¼ãåº§æ¨ç³»ããã·ã¼ã³åº§æ¨ç³»ã¸ã®å¤æ
     * @private
     */

  }, {
    key: "_addNode",
    value: function _addNode(node, ptos) {
      var ntos = Builder._getNodeToScene(node, ptos);

      if (node.mesh !== null) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = node.mesh.primitives[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var primitive = _step4.value;

            // ããªããã£ããè¿½å 
            this._primitives.push(this._createPrimitive(primitive, ntos, {
              ridMaterial: false
            }));

            this._pickPrimitives.push(this._createPrimitive(primitive, ntos, {
              ridMaterial: true
            }));
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      } // å­å­«ã®å¦ç


      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = node.children[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var child = _step5.value;

          this._addNode(child, ntos);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
    /**
     * node åº§æ¨ç³»ããã·ã¼ã³åº§æ¨ç³»ã®å¤æè¡åãåå¾
     *
     * @param  {mapray.gltf.Node} node  è¿½å å¯¾è±¡ã®ãã¼ã
     * @param  {mapray.Matrix}    ptos  è¦ªãã¼ãåº§æ¨ç³»ããã·ã¼ã³åº§æ¨ç³»ã¸ã®å¤æè¡å
     * @return {mapray.Matrix}          node åº§æ¨ç³»ããã·ã¼ã³åº§æ¨ç³»ã®å¤æè¡å
     * @private
     */

  }, {
    key: "_createPrimitive",

    /**
     * ããªããã£ããçæ
     *
     * @param  {mapray.gltf.Primitive} iprim  å¥åããªããã£ã
     * @param {mapray.Matrix}          ntos   ãã¼ãåº§æ¨ç³»ããã·ã¼ã³åº§æ¨ç³»ã¸ã®å¤æ
     * @return {mapray.Primitive}             åºåããªããã£ã
     * @private
     */
    value: function _createPrimitive(iprim, ntos) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var mesh = this._createMesh(iprim);

      var material = this._createMaterial(iprim, {
        ridMaterial: opts.ridMaterial
      });

      var oprim = new Primitive(this._glenv, mesh, material, GeoMath.createMatrix(ntos));
      oprim.pivot = this._createMeshPivot(iprim);
      oprim.bbox = this._createBoundingBox(iprim);
      oprim.properties = this._createProperties(iprim);
      return oprim;
    }
    /**
     * ã¡ãã·ã¥ãçæ
     *
     * @param  {mapray.gltf.Primitive} iprim  å¥åããªããã£ã
     * @return {mapray.Mesh}                  ã¡ãã·ã¥
     * @private
     */

  }, {
    key: "_createMesh",
    value: function _createMesh(iprim) {
      var init = new Mesh.Initializer(Builder._convertPrimitiveMode(iprim), Builder._calcNumVertices(iprim));
      var attributes = iprim.attributes;

      for (var name in attributes) {
        this._addAttribToInit(init, name, attributes[name]);
      }

      var indices = iprim.indices;

      if (indices !== null) {
        this._addIndexToInit(init, indices);
      }

      return new Mesh(this._glenv, init);
    }
    /**
     * æç»ã¢ã¼ãã«å¤æ
     *
     * @param  {mapray.gltf.Primitive} iprim  å¥åããªããã£ã
     * @return {mapray.Mesh.DrawMode}         æç»ã¢ã¼ã
     * @private
     */

  }, {
    key: "_addAttribToInit",

    /**
     * é ç¹å±æ§ãã¤ãã·ã£ã©ã¤ã¶ã«è¿½å 
     *
     * @param {mapray.Mesh.Initializer} init      è¿½å å
     * @param {string}                  name      å±æ§å
     * @param {mapray.gltf.Accessor}    accessor  ã¢ã¯ã»ãµ
     * @private
     */
    value: function _addAttribToInit(init, name, accessor) {
      var buffer = this._findMeshBuffer(accessor.bufferView.buffer, MeshBuffer.Target.ATTRIBUTE);

      var num_components = Builder._NumComponents[accessor.type];
      var component_type = Builder._ComponentType[accessor.componentType];
      var options = {
        normalized: accessor.normalized,
        byte_stride: accessor.bufferView.byteStride,
        byte_offset: accessor.bufferView.byteOffset + accessor.byteOffset
      };
      var id = Builder._VertexAttribId[name] || name;
      init.addAttribute(id, buffer, num_components, component_type, options);
    }
    /**
     * ã¤ã³ããã¯ã¹ãã¤ãã·ã£ã©ã¤ã¶ã«è¿½å 
     *
     * @param {mapray.Mesh.Initializer} init      è¿½å å
     * @param {mapray.gltf.Accessor}    accessor  ã¢ã¯ã»ãµ
     * @private
     */

  }, {
    key: "_addIndexToInit",
    value: function _addIndexToInit(init, accessor) {
      var buffer = this._findMeshBuffer(accessor.bufferView.buffer, MeshBuffer.Target.INDEX);

      var num_indices = accessor.count;
      var type = Builder._ComponentType[accessor.componentType];
      var options = {
        byte_offset: accessor.bufferView.byteOffset + accessor.byteOffset
      };
      init.addIndex(buffer, num_indices, type, options);
    }
    /**
     * MeshBuffer ã¤ã³ã¹ã¿ã³ã¹ãæ¤ç´¢
     *
     * @param  {mapray.gltf.Buffer}       buffer  å¥åãããã¡
     * @param  {mapray.MeshBuffer.Target} target  ä½¿ç¨ç®ç
     * @return {mapray.MeshBuffer}
     * @private
     */

  }, {
    key: "_findMeshBuffer",
    value: function _findMeshBuffer(buffer, target) {
      var meshBuffer = this._buffer_map.get(buffer);

      if (meshBuffer === undefined) {
        meshBuffer = new MeshBuffer(this._glenv, buffer.binary, {
          target: target
        });

        this._buffer_map.set(buffer, meshBuffer);
      }

      return meshBuffer;
    }
    /**
     * ãããªã¢ã«ãçæ
     *
     * @param  {mapray.gltf.Primitive} iprim  å¥åããªããã£ã
     * @return {mapray.EntityMaterial}        ãããªã¢ã«
     * @private
     */

  }, {
    key: "_createMaterial",
    value: function _createMaterial(iprim) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // ã­ã£ãã·ã¥ã®å ´æã¨ãªãã·ã§ã³ãæ±ºå®
      var cache_suffix = "basic";
      var options = {};

      if (iprim.material && iprim.material.commonData.getExtensions("KHR_materials_unlit")) {
        cache_suffix = "unlit";
        options.is_unlit = true;
      }

      if (opts.ridMaterial) {
        options.ridMaterial = true;
      } // ãããªã¢ã«ã®ã¤ã³ã¹ã¿ã³ã¹ãåå¾


      var scene = this._mr_scene;
      var cache_id = "_ModelEntity_model_material_" + cache_suffix + (opts.ridMaterial ? "_pick" : "");

      if (!scene[cache_id]) {
        // scene ã«ãããªã¢ã«ãã­ã£ãã·ã¥
        scene[cache_id] = new ModelMaterial(scene.glenv, options);
      }

      return scene[cache_id];
    }
    /**
     * ã¡ãã·ã¥åºç¹ãçæ
     *
     * @param  {mapray.gltf.Primitive} iprim  å¥åããªããã£ã
     * @return {?mapray.Vector3}              ã¡ãã·ã¥åºç¹
     * @private
     */

  }, {
    key: "_createMeshPivot",
    value: function _createMeshPivot(iprim) {
      var pivot = null;

      var bbox = this._createBoundingBox(iprim);

      if (bbox !== null) {
        pivot = GeoMath.createVector3(); // å¢çç®±ã®ä¸­ç¹

        for (var i = 0; i < 3; ++i) {
          pivot[i] = (bbox[0][i] + bbox[1][i]) / 2;
        }
      }

      return pivot;
    }
    /**
     * å¢çç®±ãçæ
     *
     * @param  {mapray.gltf.Primitive} iprim  å¥åããªããã£ã
     * @return {?mapray.Vector3[]}            å¢çç®±
     * @private
     */

  }, {
    key: "_createBoundingBox",
    value: function _createBoundingBox(iprim) {
      var bbox = null;
      var attrib = iprim.attributes['POSITION'];

      if (attrib !== undefined) {
        var min = attrib.min;
        var max = attrib.max;

        if (min !== null && max !== null) {
          bbox = [GeoMath.createVector3(min), GeoMath.createVector3(max)];
        }
      }

      return bbox;
    }
    /**
     * ãã­ããã£ãçæ
     *
     * @param  {mapray.gltf.Primitive} iprim  å¥åããªããã£ã
     * @return {object}                       ãã­ããã£
     * @private
     */

  }, {
    key: "_createProperties",
    value: function _createProperties(iprim) {
      var material = iprim.material;

      if (material === null) {
        // æ¢å®ã®ãããªã¢ã«
        return {
          pbrMetallicRoughness: {
            baseColorFactor: GeoMath.createVector4f([1.0, 1.0, 1.0, 1.0]),
            baseColorTexture: null,
            metallicFactor: 1.0,
            roughnessFactor: 1.0,
            metallicRoughnessTexture: null
          },
          doubleSided: false,
          alphaMode: "OPAQUE",
          alphaCutoff: 0.5,
          emissiveFactor: GeoMath.createVector3f([0.0, 0.0, 0.0]),
          emissiveTexture: null,
          normalTexture: null,
          occlusionTexture: null
        };
      } else {
        var pbrMR = material.pbrMetallicRoughness;
        return {
          pbrMetallicRoughness: {
            baseColorFactor: GeoMath.createVector4f(pbrMR.baseColorFactor),
            baseColorTexture: this._createTextureParam(pbrMR.baseColorTexture),
            metallicFactor: pbrMR.metallicFactor,
            roughnessFactor: pbrMR.roughnessFactor,
            metallicRoughnessTexture: this._createTextureParam(pbrMR.metallicRoughnessTexture)
          },
          doubleSided: material.doubleSided,
          alphaMode: material.alphaMode,
          alphaCutoff: material.alphaCutoff,
          emissiveFactor: GeoMath.createVector3f(material.emissiveFactor),
          emissiveTexture: this._createTextureParam(material.emissiveTexture),
          normalTexture: this._createTextureParam(material.normalTexture),
          occlusionTexture: this._createTextureParam(material.occlusionTexture)
        };
      }
    }
    /**
     * ãã¯ã¹ãã£ãã©ã¡ã¼ã¿ãçæ
     *
     * @param  {mapray.gltf.TextureInfo} texinfo  TextureInfo ã¤ã³ã¹ã¿ã³ã¹
     * @return {object}  ãã¯ã¹ãã£ãã©ã¡ã¼ã¿
     * @private
     */

  }, {
    key: "_createTextureParam",
    value: function _createTextureParam(texinfo) {
      if (texinfo === null) {
        return null;
      }

      var param = {
        texture: this._findTexture(texinfo.texture),
        texCoord: texinfo.texCoord
      };

      if (texinfo instanceof NormalTextureInfo) {
        param.scale = texinfo.scale;
      } else if (texinfo instanceof OcclusionTextureInfo) {
        param.strength = texinfo.strength;
      }

      return param;
    }
    /**
     * ã¢ãã«ç¨ã®ãã­ããã£ãè¤è£½
     *
     * @param  {mapray.PropSet} props
     * @return {mapray.PropSet}
     *
     * @see _createProperties()
     */

  }, {
    key: "_findTexture",

    /**
     * ãã¯ã¹ãã£ãã©ã¡ã¼ã¿ãçæ
     *
     * @param  {mapray.gltf.Texture} itexture  glTF ãã¯ã¹ãã£
     * @return {mapray.Texture}                ãã¯ã¹ãã£
     * @private
     */
    value: function _findTexture(itexture) {
      var otexture = this._texture_map.get(itexture);

      if (otexture === undefined) {
        var sampler = itexture.sampler;
        var gl = this._glenv.context;
        var tex_opts = {
          mag_filter: sampler.magFilter !== undefined ? sampler.magFilter : gl.LINEAR,
          min_filter: sampler.minFilter !== undefined ? sampler.minFilter : gl.LINEAR_MIPMAP_LINEAR,
          wrap_s: sampler.wrapS,
          wrap_t: sampler.wrapT,
          flip_y: false // glTF ã®ãã¯ã¹ãã£åº§æ¨ã¯å·¦ä¸ãåç¹ãªã®ã§ç»åãåè»¢ããªã

        };
        otexture = new Texture(this._glenv, itexture.source.image, tex_opts);

        this._texture_map.set(itexture, otexture);
      }

      return otexture;
    }
  }], [{
    key: "_getNodeToScene",
    value: function _getNodeToScene(node, ptos) {
      var ntos = ptos; // node åº§æ¨ç³»ããã·ã¼ã³åº§æ¨ç³»ã®å¤æ

      var ntop = node.matrix; // node åº§æ¨ç³»ããè¦ªãã¼ãåº§æ¨ç³»ã®å¤æ

      if (ntop !== null) {
        ntos = GeoMath.createMatrix();
        GeoMath.mul_AA(ptos, ntop, ntos);
      }

      return ntos;
    }
  }, {
    key: "_convertPrimitiveMode",
    value: function _convertPrimitiveMode(iprim) {
      return Builder._DrawMode[iprim.mode];
    }
    /**
     * é ç¹æ°ãè¨ç®
     *
     * @param  {mapray.gltf.Primitive} iprim  å¥åããªããã£ã
     * @return {number}                       é ç¹æ°
     * @private
     */

  }, {
    key: "_calcNumVertices",
    value: function _calcNumVertices(iprim) {
      var attributes = iprim.attributes;
      var counts = [];

      for (var name in attributes) {
        var accessor = attributes[name];
        counts.push(accessor.count);
      }

      return Math.min.apply(null, counts);
    }
  }, {
    key: "fastCloneProperties",
    value: function fastCloneProperties(props) {
      var src_pbr = props.pbrMetallicRoughness;
      return {
        pbrMetallicRoughness: {
          baseColorFactor: GeoMath.createVector3f(src_pbr.baseColorFactor),
          baseColorTexture: Builder._fastCloneTextureParam(src_pbr.baseColorTexture),
          metallicFactor: src_pbr.metallicFactor,
          roughnessFactor: src_pbr.roughnessFactor,
          metallicRoughnessTexture: Builder._fastCloneTextureParam(src_pbr.metallicRoughnessTexture)
        },
        doubleSided: props.doubleSided,
        alphaMode: props.alphaMode,
        alphaCutoff: props.alphaCutoff,
        emissiveFactor: GeoMath.createVector3f(props.emissiveFactor),
        emissiveTexture: Builder._fastCloneTextureParam(props.emissiveTexture),
        normalTexture: Builder._fastCloneTextureParam(props.normalTexture),
        occlusionTexture: Builder._fastCloneTextureParam(props.occlusionTexture)
      };
    }
    /**
     * ãã¯ã¹ãã£ãã©ã¡ã¼ã¿ãè¤è£½
     *
     * @param  {object} param
     * @return {!object}
     *
     * @private
     * @see _createTextureParam()
     */

  }, {
    key: "_fastCloneTextureParam",
    value: function _fastCloneTextureParam(iparam) {
      if (iparam === null) return null;
      var oparam = {
        texture: iparam.texture,
        texCoord: iparam.texCoord
      };

      if ('scale' in iparam) {
        oparam.scale = iparam.scale;
      } else if ('strength' in iparam) {
        oparam.strength = iparam.strength;
      }

      return oparam;
    }
  }]);

  return Builder;
}(); // gltf.Primitive.mode -> mapray.Mesh.DrawMode


Builder._DrawMode = {
  0: Mesh.DrawMode.POINTS,
  1: Mesh.DrawMode.LINES,
  2: Mesh.DrawMode.LINE_LOOP,
  3: Mesh.DrawMode.LINE_STRIP,
  4: Mesh.DrawMode.TRIANGLES,
  5: Mesh.DrawMode.TRIANGLE_STRIP,
  6: Mesh.DrawMode.TRIANGLE_FAN
}; // gltf.Accessor.type -> è¦ç´ æ°

Builder._NumComponents = {
  'SCALAR': 1,
  'VEC2': 2,
  'VEC3': 3,
  'VEC4': 4
}; // gltf.Accessor.componentType -> mapray.Mesh.ComponentType

Builder._ComponentType = {
  5120: Mesh.ComponentType.BYTE,
  5121: Mesh.ComponentType.UNSIGNED_BYTE,
  5122: Mesh.ComponentType.SHORT,
  5123: Mesh.ComponentType.UNSIGNED_SHORT,
  5125: Mesh.ComponentType.UNSIGNED_INT,
  5126: Mesh.ComponentType.FLOAT
}; // gltf.Primitive.attributes ã®ã­ã¼ -> é ç¹å±æ§ ID

Builder._VertexAttribId = {
  'POSITION': "a_position",
  'NORMAL': "a_normal",
  'TANGENT': "a_tangent",
  'TEXCOORD_0': "a_texcoord",
  'TEXCOORD_1': "a_texcoord1",
  'COLOR_0': "a_color"
};

var line_vs_code = "/**\n * å¤ªãä»ãç·åã®é ç¹ã·ã§ã¼ã\n */\n\nattribute vec4 a_position;      // é ç¹ä½ç½® (ã¢ãã«åº§æ¨ç³»)\nattribute vec3 a_direction;     // ç·åæ¹å (ã¢ãã«åº§æ¨ç³») = çµç¹ä½ç½® - å§ç¹ä½ç½®\nattribute vec2 a_where;         // ç·åã®4éæå®: å§ç¹å·¦: {-1, 1}, å§ç¹å³: {-1, -1}, çµç¹å·¦: {1, 1}, çµç¹å³: {1, -1}\nattribute float a_length;\n\nuniform mat4 u_obj_to_clip;     // ã¢ãã«åº§æ¨ç³»ããã¯ãªããåº§æ¨ç³»ã¸ã®å¤æ\nuniform vec3 u_sparam;          // ç»é¢ãã©ã¡ã¼ã¿: {2/w, 2/h, h/w}\nuniform vec2 u_thickness;       // ç·ã®å¤ªãã®åå: {u, v}\n\nvarying highp float  v_length;  // å§ç¹ããã®è·é¢ (PathEntityã®ã¿å©ç¨)\n\nvec2\noffset( vec4 cpos )\n{\n    vec4 q0 = cpos;\n    q0.y *= u_sparam.z;  // q0 = A * q0\n    vec4 q1 = cpos + u_obj_to_clip * vec4( a_direction, 0 );\n    q1.y *= u_sparam.z;  // q1 = A * q1\n\n    vec2 ds = normalize( q1.xy / q1.w - q0.xy / q0.w );\n    vec2 wt = a_where * u_thickness;\n    return mat2( ds.x, ds.y, -ds.y, ds.x ) * wt;\n}\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n    gl_Position.xy += offset( gl_Position ) * u_sparam.xy * gl_Position.w;\n    v_length = a_length;\n}\n";

var line_fs_code = "/**\n * å¤ªãä»ãç·åã®ãã©ã°ã¡ã³ãã·ã§ã¼ã\n * RIDæç»ã«å¯¾å¿\n */\n\nprecision mediump float;\n\n\n\n#ifdef PATH\nuniform highp float u_lower_length; // è·é¢ã®ä¸éå¤ (PathEntityã®ã¿å©ç¨)\nuniform highp float u_upper_length; // è·é¢ã®ä¸éå¤ (PathEntityã®ã¿å©ç¨)\n\nvarying highp float  v_length;      // å§ç¹ããã®è·é¢ (PathEntityã®ã¿å©ç¨)\n#endif // PATH\n\n#ifdef RID\nuniform highp vec4 u_rid;           // rid\n#else // RID\nuniform vec4 u_color;               // ç·ã®åºæ¬è²ã¨ä¸éæåº¦\n#endif // RID\n\n\nvoid\nmain()\n{\n#ifdef PATH\n    if ( u_lower_length <= v_length && v_length <= u_upper_length ) {\n#endif // PATH\n\n#ifdef RID\n        gl_FragColor = u_rid;\n#else // RID\n        gl_FragColor = vec4( u_color.xyz * u_color.w, u_color.w );\n#endif // RID\n\n#ifdef PATH\n    }\n    else {\n        discard;  // ãã©ã°ã¡ã³ããç ´æ£\n    }\n#endif // PATH\n}\n";

/**
 * @summary å¤ªãä»ãç·åå°ç¨ãããªã¢ã«
 * @memberof mapray
 * @extends mapray.EntityMaterial
 * @private
 */

var LineMaterial =
/*#__PURE__*/
function (_EntityMaterial) {
  _inherits(LineMaterial, _EntityMaterial);

  /**
   * @param {mapray.GLEnv} glenv
   */
  function LineMaterial(glenv, line_type) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, LineMaterial);

    var preamble = LineMaterial._getPreamble(line_type, options);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LineMaterial).call(this, glenv, preamble + line_vs_code, preamble + line_fs_code));
    _this._line_type = line_type;
    return _this;
  }
  /**
   * @override
   */


  _createClass(LineMaterial, [{
    key: "isTranslucent",
    value: function isTranslucent(stage, primitive) {
      var props = primitive.properties;
      var opacity = props.opacity !== undefined ? props.opacity : LineMaterial.DEFAULT_OPACITY;
      return opacity < 1.0;
    }
    /**
     * @override
     */

  }, {
    key: "setParameters",
    value: function setParameters(stage, primitive) {
      _get(_getPrototypeOf(LineMaterial.prototype), "setParameters", this).call(this, stage, primitive);

      var props = primitive.properties; // u_obj_to_clip

      this.setObjToClip(stage, primitive); // ç»é¢ãã©ã¡ã¼ã¿: {2/w, 2/h, h/w}
      // vec3 u_sparam

      var sparam = LineMaterial._sparam;
      sparam[0] = 2 / stage._width;
      sparam[1] = 2 / stage._height;
      sparam[2] = stage._height / stage._width;
      this.setVector3("u_sparam", sparam); // ç·ã®å¤ªãã®åå: {u, v}
      // vec2 u_thickness

      var param_width = props.width || LineMaterial.DEFAULT_WIDTH;
      var thickness = LineMaterial._thickness;
      thickness[0] = param_width / 2;
      thickness[1] = param_width / 2;
      this.setVector2("u_thickness", thickness);

      if (stage.getRenderTarget() === RenderTarget.SCENE) {
        // ç·ã®åºæ¬è²
        // vec4 u_color
        var param_color = props.color !== undefined ? props.color : LineMaterial.DEFAULT_COLOR;
        var param_opacity = props.opacity !== undefined ? props.opacity : LineMaterial.DEFAULT_OPACITY;
        var color = LineMaterial._color;
        GeoMath.copyVector3(param_color, color);
        color[3] = param_opacity;
        this.setVector4("u_color", color);
      } // RID rendering also requires u_lower_length and u_upper_length.


      if (this._line_type == AbstractLineEntity.LineType.PATH) {
        var lower_length = props["lower_length"];
        this.setFloat("u_lower_length", lower_length);
        var upper_length = props["upper_length"];
        this.setFloat("u_upper_length", upper_length);
      }
    }
    /**
     * @summary ã·ã§ã¼ãã®åæãåå¾
     *
     * @param {AbstractLineEntity.LineType} line_type
     * @param {object} options
     *
     * @private
     */

  }], [{
    key: "_getPreamble",
    value: function _getPreamble(line_type, options) {
      var lines = [];

      if (line_type == AbstractLineEntity.LineType.PATH) {
        lines.push("#define PATH");
      }

      if (options.ridMaterial) {
        lines.push("#define RID");
      } // lines ãæå­åã«ãã¦è¿ã


      return lines.join("\n") + "\n\n";
    }
  }]);

  return LineMaterial;
}(EntityMaterial); // ã¯ã©ã¹å®æ°ã®å®ç¾©


{
  LineMaterial.DEFAULT_WIDTH = 1.0;
  LineMaterial.DEFAULT_COLOR = GeoMath.createVector3f([1.0, 1.0, 1.0]);
  LineMaterial.DEFAULT_OPACITY = 1.0;
  LineMaterial.DEFAULT_LOWER_LENGTH = 0.0;
  LineMaterial.DEFAULT_UPPER_LENGTH = 0.0; // è¨ç®ç¨ä¸æé å

  LineMaterial._sparam = GeoMath.createVector3f();
  LineMaterial._thickness = GeoMath.createVector2f();
  LineMaterial._color = GeoMath.createVector4f();
}

/**
 * @summary å°çç©ºéçRegion
 *
 * @memberof mapray
 */

var GeoRegion =
/*#__PURE__*/
function () {
  /**
   * åæå¤ã¯ empty ã§ããã
   * lon ã¯æ¬¡ã®æ¡ä»¶ã¨ããã
   * <p> æ¡ä»¶ this._min_lon < this._max_lon </p>
   * <p> æ¡ä»¶ this._max_lon - this._min_lon <= 360 </p>
   */
  function GeoRegion() {
    _classCallCheck(this, GeoRegion);

    this._empty = true;
    this._min_lon = 0;
    this._max_lon = 0;
    this._min_lat = 0;
    this._max_lat = 0;
    this._min_alt = 0;
    this._max_alt = 0;
  }
  /**
   * @summary ç©ºç¢ºèª
   *
   * @return {boolean}        emptyå¤
   */


  _createClass(GeoRegion, [{
    key: "empty",
    value: function empty() {
      return this._empty;
    }
    /**
     * @summary Pointãè¿½å 
     * <p> æ¡ä»¶ this._min_lon < this._max_lon </p>
     * <p> æ¡ä»¶ this._max_lon - this._min_lon <= 360 </p>
     *
     * @param {number}  lon  å°çç©ºéä½ç½® longitude
     * @param {number}  lat  å°çç©ºéä½ç½® latitude
     * @param {number}  alt  å°çç©ºéä½ç½® altitude
     * @private
     */

  }, {
    key: "_add",
    value: function _add(lon, lat, alt) {
      if (this._empty) {
        this._empty = false;
        lon = lon - 360 * Math.floor(lon / 360 + 0.5);
        this._min_lon = this._max_lon = lon;
        this._min_lat = this._max_lat = lat;
        this._min_alt = this._max_alt = alt;
      } else {
        var right_min_lon = this._calcRightPosition(this._min_lon, lon);

        if (right_min_lon <= this._max_lon) ; else {
          var right_max_lon = this._calcRightPosition(this._max_lon, lon);

          var length1 = right_max_lon - this._max_lon;
          var length2 = right_min_lon - 360 - this._min_lon;

          if (Math.abs(length1) <= Math.abs(length2)) {
            // expand east
            this._max_lon = this._max_lon + length1;
          } else {
            // expand west
            this._min_lon = this._min_lon + length2;
          }
        }

        if (lat < this._min_lat) this._min_lat = lat;else if (lat > this._max_lat) this._max_lat = lat;
        if (alt < this._min_alt) this._min_alt = alt;else if (alt > this._max_alt) this._max_alt = alt;
      }
    }
    /**
     * @summary base_lon ããå³ã¨ãªãæå°ã® longitude ãç®åº
     *
     * @param {number}  base_lon  åºæºã¨ãªãlongitude
     * @param {number}  lon       ç¢ºèªãããlongitude
     * @return {number} æå°longitude
     * @private
     */

  }, {
    key: "_calcRightPosition",
    value: function _calcRightPosition(base_lon, lon) {
      var diff = lon - base_lon;
      diff = diff - 360 * Math.floor(diff / 360);
      return base_lon + diff;
    }
    /**
     * @summary GeoPointãè¿½å 
     *
     * @param {mapary.GeoPoint}  point  å°çç©ºéä½ç½®
     */

  }, {
    key: "addPoint",
    value: function addPoint(point) {
      this._add(point.longitude, point.latitude, point.altitude);
    }
    /**
     * @summary GeoPointãè¿½å 
     *
     * @param {...mapary.GeoPoint}  points  å°çç©ºéä½ç½®
     */

  }, {
    key: "addPoints",
    value: function addPoints() {
      var _this = this;

      for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
        points[_key] = arguments[_key];
      }

      points.forEach(function (point) {
        _this._add(point.longitude, point.latitude, point.altitude);
      });
    }
    /**
     * @summary PointArrayãè¿½å 
     *
     * @param {number[]}  pointsArray  å°çç©ºéä½ç½®Array
     */

  }, {
    key: "addPointsAsArray",
    value: function addPointsAsArray(pointsArray) {
      for (var i = 0; i < pointsArray.length; i += 3) {
        this._add(pointsArray[i], pointsArray[i + 1], pointsArray[i + 2]);
      }
    }
    /**
     * @summary GeoRegionãçµå
     *
     * @param {mapray.GeoRegion}  region  å°çç©ºéRegion
     */

  }, {
    key: "merge",
    value: function merge(region) {
      if (region.empty()) {
        return;
      }

      if (this._empty) {
        this._min_lon = region._min_lon;
        this._max_lon = region._max_lon;
        this._min_lat = region._min_lat;
        this._max_lat = region._max_lat;
        this._min_alt = region._min_alt;
        this._max_alt = region._max_alt;
        this._empty = false;
      } else {
        // ååå¤å®
        var right_min_lon = this._calcRightPosition(this._min_lon, region._min_lon);

        var right_max_lon = this._calcRightPosition(this._min_lon, region._max_lon);

        if (right_min_lon > right_max_lon) {
          right_min_lon -= 360;
        }

        var min_include = false;

        if (right_min_lon >= this._min_lon && right_min_lon <= this._max_lon) {
          min_include = true;
        }

        var max_include = false;

        if (right_max_lon >= this._min_lon && right_max_lon <= this._max_lon) {
          max_include = true;
        } // 1.thisãregionãåå


        if (min_include && max_include) ; // ååç¶æ -> å¤åç¡ã
        // 2.westã®ã¿åå -> eastæ¡å¤§
        else if (min_include) {
            this._max_lon = right_max_lon;
          } // 3.eastã®ã¿åå -> westæ¡å¤§
          else if (max_include) {
              this._min_lon = right_min_lon;
            } // 4.regionãthisãåå
            else if (this._min_lon >= right_min_lon && this._max_lon <= right_max_lon) {
                this._min_lon = region._min_lon;
                this._max_lon = region._max_lon;
              } // 5.å±æç¡ã
              else {
                  // east ã¨ west æ¯è¼
                  var length1 = right_max_lon - this._max_lon;
                  var length2 = right_min_lon - 360 - this._min_lon;

                  if (Math.abs(length1) <= Math.abs(length2)) {
                    // expand east
                    this._max_lon = this._max_lon + length1;
                  } else {
                    // expand west
                    this._min_lon = this._min_lon + length2;
                  }
                } // lat ã¨ alt


        this._min_lat = Math.min(this._min_lat, region._min_lat);
        this._max_lat = Math.max(this._max_lat, region._max_lat);
        this._min_alt = Math.min(this._min_alt, region._min_alt);
        this._max_alt = Math.max(this._max_alt, region._max_alt);
      }
    }
    /**
     * @summary Regionåã®ä»»æç¹ã®åå¾
     * center     ( 0.5, 0.5 )
     * east       (   1, 0.5 )
     * west       (   0, 0.5 )
     * north      ( 0.5,   1 )
     * south      ( 0.5,   0 )
     * northEast  (   1,   1 )
     * southWest  (   0,   0 )
     *
     * @param {number}  lon_pos   longitudeä½ç½®å²å
     * @param {number}  lat_pos   latitudeä½ç½®å²å
     * @param {number}  [alt_pos] anlitudeä½ç½®å²å
     * @return {mapary.GeoPoint}   GeoPoint
     */

  }, {
    key: "getPoint",
    value: function getPoint(lon_pos, lat_pos) {
      var alt_pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      if (this._empty) {
        return null;
      }

      return new GeoPoint((1 - lon_pos) * this._min_lon + lon_pos * this._max_lon, (1 - lat_pos) * this._min_lat + lat_pos * this._max_lat, (1 - alt_pos) * this._min_alt + alt_pos * this._max_alt);
    }
    /**
     * @summary SouthWestã®Geopointãè¿å´
     *
     * @return {mapary.GeoPoint}   åè¥¿(min)ã®GeoPoint
     */

  }, {
    key: "getSouthWest",
    value: function getSouthWest() {
      if (this._empty) {
        return null;
      }

      return new GeoPoint(this._min_lon, this._min_lat, this._min_alt);
    }
    /**
     * @summary NorthEastã®Geopointãè¿å´
     *
     * @return {mapary.GeoPoint}  åæ±(max)ã®GeoPoint
     */

  }, {
    key: "getNorthEast",
    value: function getNorthEast() {
      if (this._empty) {
        return null;
      }

      return new GeoPoint(this._max_lon, this._max_lat, this._max_alt);
    }
    /**
     * @summary ä¸­å¿ä½ç½®ã®Geopointãè¿å´
     *
     * @return {mapary.GeoPoint}  ä¸­å¿(center)ã®GeoPoint
     */

  }, {
    key: "getCenter",
    value: function getCenter() {
      if (this._empty) {
        return null;
      }

      return this.getPoint(0.5, 0.5, 0.5);
    }
    /**
     * @summary Regionã®Longitudeæ¹å ã®å°è¡¨é¢è·é¢ãç®åº
     *
     * @return {number}  Longitudeæ¹åã®å°è¡¨é¢è·é¢
     */

  }, {
    key: "getLongitudeDistance",
    value: function getLongitudeDistance() {
      if (this._empty) {
        return null;
      }

      return this.getPoint(0, 0.5).getGeographicalDistance(this.getPoint(1, 0.5));
    }
    /**
     * @summary Regionã®Latitudeæ¹å ã®å°è¡¨é¢è·é¢ãç®åº
     *
     * @return {number}  Latitudeæ¹åã®å°è¡¨é¢è·é¢
     */

  }, {
    key: "getLatitudeDistance",
    value: function getLatitudeDistance() {
      if (this._empty) {
        return null;
      }

      return this.getPoint(0.5, 0).getGeographicalDistance(this.getPoint(0.5, 1));
    }
  }]);

  return GeoRegion;
}();

/**
 * @summary ã¨ã³ãã£ãã£é å
 *
 * @classdesc
 * <p>æ¨é«ã®å¤åã«ä¼´ããã¨ã³ãã£ãã£ã®æ´æ°ãè¡ãããã®ã¯ã©ã¹ã§ããã</p>
 *
 * @memberof mapray
 * @private
 * @see mapray.UpdatedTileArea
 */

var EntityRegion =
/*#__PURE__*/
function () {
  /**
   */
  function EntityRegion() {
    _classCallCheck(this, EntityRegion);

    this._is_compiled = false;
    this._point_array = new Float64Array(0);
    this._num_points = 0;
    this._node_array = new Uint32Array(0);
    this._next_node = 0;
  }
  /**
   * @summary ä½ç½®ãè¿½å 
   *
   * @desc
   * <p>point.altitude ã¯ç¡è¦ãããã</p>
   *
   * @param {mapray.GeoPoint} point  ä½ç½®
   */


  _createClass(EntityRegion, [{
    key: "addPoint",
    value: function addPoint(point) {
      this._checkNotCompiled();

      this._ensurePointArrayCapacity(2);

      var index = 2 * this._num_points;
      this._point_array[index] = point.longitude;
      this._point_array[index + 1] = point.latitude;
      this._num_points += 1;
    }
    /**
     * @summary è¤æ°ã®ä½ç½®ãè¿½å 
     *
     * @param {number[]} points      é ç¹éå (çµåº¦, ç·¯åº¦, ...)
     * @param {number}   offset      åé ­ã¤ã³ããã¯ã¹
     * @param {number}   stride      ã¹ãã©ã¤ã
     * @param {number}   num_points  é ç¹æ°
     */

  }, {
    key: "addPoints",
    value: function addPoints(points, offset, stride, num_points) {
      this._checkNotCompiled();

      this._ensurePointArrayCapacity(2 * num_points);

      var src_index = offset;
      var dst_index = 2 * this._num_points;
      var dst_array = this._point_array;

      for (var i = 0; i < num_points; ++i) {
        dst_array[dst_index] = points[src_index];
        dst_array[dst_index + 1] = points[src_index + 1];
        src_index += stride;
        dst_index += 2;
      }

      this._num_points += num_points;
    }
    /**
     * @summary æ¯è¼å¦çç¨ã«ç¿»è¨³
     *
     * @package
     */

  }, {
    key: "compile",
    value: function compile() {
      if (this._is_compiled) {
        // ãã§ã«ç¿»è¨³æ¸ã¿
        return;
      }

      this._buildCollisionQuadTree(); // this._node_array ããä½¿ã£ã¦ããªãæå¾ã®é åãåé¤


      if (this._node_array.length > this._next_node) {
        this._node_array = new Uint32Array(this._node_array.slice(0, this._next_node));
      }

      this._point_array = null; // ç¿»è¨³å¾ã¯ä½¿ããªãã®ã§æ¨ã¦ã

      this._is_compiled = true; // ç¿»è¨³æ¸ã¿ã«ãã
    }
    /**
     * @summary this ã¨ area ã¯äº¤å·®ãããï¼
     *
     * @param {mapray.UpdatedTileArea} area  å¤å®ããé å
     *
     * @return {boolean}  äº¤å·®ããã¨ã true, ããä»¥å¤ã®ã¨ã false
     *
     * @package
     */

  }, {
    key: "intersectsWith",
    value: function intersectsWith(area) {
      if (this._node_array.length == 0) {
        // this ã¯ç©ºé å
        return false;
      }

      var area_list = area.getFlatAreaList();

      for (var i = 0; i < area_list.length; ++i) {
        if (this._intersectsWith(area_list[i])) {
          // ããé åãäº¤å·®ãã
          return true;
        }
      } // ãã¹ã¦ã®é åãäº¤å·®ããªãã£ã


      return false;
    }
    /**
     * @summary this ã¨ area ã¯äº¤å·®ãããï¼ (åä¸é å)
     *
     * @param  {Uint8Array} area  å¤å®ããé å
     *
     * @return {boolean}  äº¤å·®ããã¨ã true, ããä»¥å¤ã®ã¨ã false
     *
     * @private
     */

  }, {
    key: "_intersectsWith",
    value: function _intersectsWith(area) {
      // assert this._node_array.length > 0
      var node = 0;
      var node_array = this._node_array;

      for (var i = 0; i < area.length; ++i) {
        node = node_array[node + area[i]];

        if (node == FULL_INDEX) {
          // äº¤å·®ãã (area ã¯å¨åãã¼ãã®åå´)
          return true;
        } else if (node == EMPTY_INDEX) {
          // äº¤å·®ããªã (area ã¯ç©ºãã¼ãã®åå´)
          return false;
        }
      } // äº¤å·®ãã
      //   area.length == 0 (å¨çé å) ã¾ãã¯ area ã®æå¾ã this éå±¤ã®éä¸­


      return true;
    }
    /**
     * @summary ãã§ã«ç¿»è¨³ããã¦ãã¨ãã¨ã©ã¼
     *
     * @private
     */

  }, {
    key: "_checkNotCompiled",
    value: function _checkNotCompiled() {
      if (this._is_compiled) {
        throw new Error("EitityRegion is already compiled.");
      }
    }
    /**
     * @summary this._point_array ã®å®¹éãååã«ãã
     *
     * @param {number} added_size  è¿½å ãµã¤ãº
     *
     * @private
     */

  }, {
    key: "_ensurePointArrayCapacity",
    value: function _ensurePointArrayCapacity(added_size) {
      var old_size = 2 * this._num_points;
      var needed_capacity = old_size + added_size;
      var old_capacity = this._point_array.length;

      if (needed_capacity > old_capacity) {
        // éåãæ¡å¼µãã
        var new_capacity = Math.max(needed_capacity, Math.floor(1.5 * old_capacity));
        var new_point_array = new Float64Array(new_capacity);
        new_point_array.set(this._point_array.slice(0, old_size));
        this._point_array = new_point_array;
      }
    }
    /**
     * @summary é åå¤å®ååæ¨ãæ§ç¯
     *
     * @private
     */

  }, {
    key: "_buildCollisionQuadTree",
    value: function _buildCollisionQuadTree() {
      var dPI = 2 * Math.PI;
      var point_array = this._point_array;
      var num_floats = 2 * this._num_points;

      for (var i = 0; i < num_floats;) {
        // çµç·¯åº¦ (Degrees)
        var lon = point_array[i++];
        var lat = point_array[i++]; // æ­£è¦åçµç·¯åº¦ (Degrees)

        var _lon = lon + 180 * Math.floor((90 - lat) / 360 + Math.floor((90 + lat) / 360));

        var nlon = _lon - 360 - 360 * Math.floor((_lon - 180) / 360); // æ­£è¦åçµåº¦ [-180,180)

        var nlat = 90 - Math.abs(90 - lat + 360 * Math.floor((90 + lat) / 360)); // æ­£è¦åç·¯åº¦ [-90,90]
        // åä½çã¡ã«ã«ãã«åº§æ¨

        var xm = nlon * GeoMath.DEGREE;
        var ym = GeoMath.invGudermannian(nlat * GeoMath.DEGREE); // åºåºã¿ã¤ã«åº§æ¨ (å·¦ä¸(0, 0)ãå³ä¸(1, 1))

        var xt = xm / dPI + 0.5;
        var yt = 0.5 - ym / dPI; // ãã¼ããè¿½å 

        this._addCollisionQuadTreeNode(xt, yt);
      } // å¨åãã¼ããè¨­å®


      if (this._next_node > 0) {
        this._setFullNodeRecur(0);

        this._reduceNodeRecur(0);
      }
    }
    /**
     * @summary é åå¤å®ååæ¨ã®ãã¼ããè¿½å 
     *
     * @param {number} xt  åºåºã¿ã¤ã«åº§æ¨ X
     * @param {number} yt  åºåºã¿ã¤ã«åº§æ¨ Y
     *
     * @private
     */

  }, {
    key: "_addCollisionQuadTreeNode",
    value: function _addCollisionQuadTreeNode(xt, yt) {
      if (yt < 0 || yt > 1) {
        // ç·¯åº¦ãç¯å²å¤ (æ¥µã«è¿ã)
        return;
      }

      var size = 1 << MAX_LEVEL;
      var ubits = GeoMath.clamp(Math.floor(xt * size), 0, size - 1);
      var vbits = Math.min(Math.floor(yt * size), size - 1); // >= 0

      var node = this._findRootNode();

      for (var mask = size >> 1; mask != 0; mask >>= 1) {
        var u = (ubits & mask) == 0 ? 0 : 1;
        var v = (vbits & mask) == 0 ? 0 : 2;
        node = this._findChildNode(node, u + v);
      }
    }
    /**
     * @summary æä¸ä½ãã¼ããæ¤ç´¢
     *
     * @return {number}  æä¸ä½ãã¼ã
     *
     * @private
     */

  }, {
    key: "_findRootNode",
    value: function _findRootNode() {
      if (this._next_node == 0) {
        // ã¾ã æä¸ä½ãã¼ããå­å¨ããªã
        // æä¸ä½ãã¼ããçæãã
        this._ensureNodeArrayCapacity();

        for (var i = 0; i < 4; ++i) {
          this._node_array[i] = EMPTY_INDEX;
        }

        this._next_node = 4;
      }

      return 0;
    }
    /**
     * @summary å­ãã¼ããæ¤ç´¢
     *
     * @param  {number} parent  è¦ªãã¼ã
     * @param  {number} ichild  å­ãã¼ãåºå (0-3)
     * @return {number}         å­ãã¼ã
     *
     * @private
     */

  }, {
    key: "_findChildNode",
    value: function _findChildNode(parent, ichild) {
      var child = this._node_array[parent + ichild];

      if (child == 0) {
        // ã¾ã å­ãã¼ããå­å¨ããªã
        // å­ãã¼ããçæãã
        this._ensureNodeArrayCapacity();

        child = this._next_node;

        for (var i = 0; i < 4; ++i) {
          this._node_array[child + i] = EMPTY_INDEX;
        }

        this._next_node += 4; // è¦ªãã¼ãã«çæããå­ãã¼ããåãä»ãã

        this._node_array[parent + ichild] = child;
      }

      return child;
    }
    /**
     * @summary å¨åãã¼ããåå¸°çã«è¨­å®
     *
     * @desc
     * <p>æ«ç«¯ãã¼ãã®å­ãã¼ãã FULL_INDEX ã«è¨­å®ããã</p>
     *
     * @param {number} node  ãã¼ãã®ç´¢å¼
     *
     * @private
     */

  }, {
    key: "_setFullNodeRecur",
    value: function _setFullNodeRecur(node) {
      var node_array = this._node_array;
      var is_leaf = true;

      for (var i = 0; i < 4; ++i) {
        var child = node_array[node + i];

        if (child != EMPTY_INDEX) {
          this._setFullNodeRecur(child);

          is_leaf = false;
        }
      } // æ«ç«¯ãªãå­ãã¼ãã FULL_INDEX


      if (is_leaf) {
        for (i = 0; i < 4; ++i) {
          node_array[node + i] = FULL_INDEX;
        }
      }
    }
    /**
     * @summary å¨åãã¼ããåå¸°çã«è¨­å®
     *
     * @param  {number} node  ãã¼ãã®ç´¢å¼
     * @return {boolean}      å¨åãã¼ããªã true, ãã®ä»ãªã false
     *
     * @private
     */

  }, {
    key: "_reduceNodeRecur",
    value: function _reduceNodeRecur(node) {
      var node_array = this._node_array;
      var num_fulls = 0;

      for (var i = 0; i < 4; ++i) {
        var child = node_array[node + i];

        if (child == FULL_INDEX) {
          ++num_fulls;
        } else if (child != EMPTY_INDEX) {
          if (this._reduceNodeRecur(child)) {
            node_array[node + i] = FULL_INDEX;
            ++num_fulls;
          }
        }
      }

      return num_fulls == 4;
    }
    /**
     * @summary this._node_array ã®å®¹éãååã«ãã
     *
     * @private
     */

  }, {
    key: "_ensureNodeArrayCapacity",
    value: function _ensureNodeArrayCapacity() {
      var old_size = this._next_node;
      var needed_capacity = old_size + 4;
      var old_capacity = this._node_array.length;

      if (needed_capacity > old_capacity) {
        // éåãæ¡å¼µãã
        var new_capacity = Math.max(needed_capacity, Math.floor(1.5 * old_capacity));
        var new_node_array = new Uint32Array(new_capacity);
        new_node_array.set(this._node_array.slice(0, old_size));
        this._node_array = new_node_array;
      }
    }
  }]);

  return EntityRegion;
}();

var MAX_LEVEL = 20; // æ´æ°: 0ï½30

var EMPTY_INDEX = 0; // ç©ºãã¼ãã®ç´¢å¼

var FULL_INDEX = 4294967295; // å¨åãã¼ãã®ç´¢å¼ = 2^32 - 1

/**
 * @summary 4åæ¨ãã¼ã¹ã®é åç®¡ç
 *
 * <p>Entity.FlakePrimitiveProducer ã® getAreaStatus() ã¨ createMesh()
 *    ã¡ã½ãããè£å©ããããã®ã¯ã©ã¹ã§ããã</p>
 *
 * @memberof mapray
 * @private
 * @see mapray.Entity.FlakePrimitiveProducer
 */

var QAreaManager =
/*#__PURE__*/
function () {
  /**
   */
  function QAreaManager() {
    _classCallCheck(this, QAreaManager);

    this._tree_root = null; // QAreaNode | AreaStatus.EMPTY | AreaStatus.FULL
  }
  /**
   * @summary é åç¶æãåå¾
   *
   * @desc
   * <p>area ãç¤ºãé åã®ç¶æãåå¾ããã</p>
   *
   * @param {mapray.Area} area  ç¢ºèªããé å
   *
   * @return {mapray.Entity.AreaStatus}  é åã®ç¶æ
   */


  _createClass(QAreaManager, [{
    key: "getAreaStatus",
    value: function getAreaStatus(area) {
      var node = this._get_area_node(area);

      if (node === Entity.AreaStatus.EMPTY || node === Entity.AreaStatus.FULL) {
        // Entity.AreaStatus ã®ã¨ã
        return node;
      } else {
        // QAreaNode ã®ã¨ã
        return Entity.AreaStatus.PARTIAL;
      }
    }
    /**
     * @summary åå®¹ãã¼ã¿ãåå¾
     *
     * @param {mapray.Area} area  å¯¾è±¡é å
     *
     * @return {object|mapray.Entity.AreaStatus}  area ã«å¯¾å¿ããåå®¹ãã¼ã¿ | AreaStatus.EMPTY | AreaStatus.FULL
     */

  }, {
    key: "getAreaContent",
    value: function getAreaContent(area) {
      var node = this._get_area_node(area);

      if (node === Entity.AreaStatus.EMPTY || node === Entity.AreaStatus.FULL) {
        // Entity.AreaStatus ã®ã¨ã
        return node;
      } else {
        // QAreaNode ã®ã¨ã
        return node.content;
      }
    }
    /**
     * @summary åãã®åå®¹ãã¼ã¿ãåå¾
     *
     * @desc
     * <p>æä¸ä½é åã®åå®¹ãã¼ã¿ãçæããããã®åå®¹ãã¼ã¿ãåå¾ããã</p>
     * <p>FlakePrimitiveProducer ã®å®è£èããã®ã¡ã½ãããå®è£ããã</p>
     *
     * @return {object}  åå®¹ãã¼ã¿
     *
     * @abstract
     */

  }, {
    key: "getInitialContent",
    value: function getInitialContent() {
      return null;
    }
    /**
     * @summary é åã®åå®¹ãã¼ã¿ãçæ
     *
     * @desc
     * <p>é åã¨ parent_content ããåå®¹ãã¼ã¿ãçæããã</p>
     * <p>ãã©ã¡ã¼ã¿ã®åº§æ¨ç³»ã¯æ­£è¦åã¡ã«ã«ãã«åº§æ¨ç³»ã§ããã</p>
     * <p>FlakePrimitiveProducer ã®å®è£èããã®ã¡ã½ãããå®è£ããã</p>
     *
     * @param {number} min_x           é åã®æå° x åº§æ¨
     * @param {number} min_y           é åã®æå° y åº§æ¨
     * @param {number} msize           é åã®å¯¸æ³
     * @param {object} parent_content  è¦ªé åã®åå®¹ãã¼ã¿
     *
     * @return {object|mapray.Entity.AreaStatus}  åå®¹ãã¼ã¿ | AreaStatus.EMPTY | AreaStatus.FULL
     *
     * @abstract
     */

  }, {
    key: "createAreaContent",
    value: function createAreaContent(min_x, min_y, msize, parent_content) {
      return Entity.AreaStatus.EMPTY;
    }
    /**
     * @summary åå®¹ãã¼ã¿ãæ´æ°ããããã¨éç¥
     *
     * @desc
     * <p>åå®¹ãã¼ã¿ãæ´æ°ããã¨ãã« FlakePrimitiveProducer ã®å®è£èããã®ã¡ã½ãããå¼ã³åºãã</p>
     */

  }, {
    key: "notifyForUpdateContent",
    value: function notifyForUpdateContent() {
      this._tree_root = null;
    }
    /**
     * @summary é åã®ãã¼ããçæ
     *
     * @param {number} min_x           é åã®æå° x åº§æ¨
     * @param {number} max_y           é åã®æå¤§ y åº§æ¨
     * @param {number} msize           é åã®å¯¸æ³
     * @param {object} parent_content  è¦ªé åã®åå®¹ãã¼ã¿
     *
     * @return {QAreaNode|mapray.Entity.AreaStatus}  ãã¼ã | AreaStatus.EMPTY | AreaStatus.FULL
     *
     * @private
     */

  }, {
    key: "_create_area_node",
    value: function _create_area_node(min_x, max_y, msize, parent_content) {
      var content = this.createAreaContent(min_x, max_y - msize, msize, parent_content);

      if (content === Entity.AreaStatus.EMPTY || content === Entity.AreaStatus.FULL) {
        return content;
      } else {
        return new QAreaNode(content);
      }
    }
    /**
     * @summary é åã®ãã¼ããåå¾
     *
     * @desc
     * <p>area ã«å¯¾å¿ãããã¼ããåå¾ããã</p>
     *
     * @param {mapray.Area} area  é å
     *
     * @return {QAreaNode|mapray.Entity.AreaStatus}  area ã«å¯¾å¿ãããã¼ã | AreaStatus.EMPTY | AreaStatus.FULL
     *
     * @private
     */

  }, {
    key: "_get_area_node",
    value: function _get_area_node(area) {
      var msize = 2;
      var min_x = -1;
      var max_y = 1;

      if (this._tree_root === null) {
        var content = this.getInitialContent();
        this._tree_root = this._create_area_node(min_x, max_y, msize, content);
      }

      var node = this._tree_root;
      var tsize = Math.round(Math.pow(2, area.z)); // ç¾è¡ã¬ãã«ã§ã®ç¸¦æ¨ªã¿ã¤ã«æ°

      var rx = area.x; // ç¾è¡ã¬ãã«ã§ã®ã¿ã¤ã« x åº§æ¨

      var ry = area.y; // ç¾è¡ã¬ãã«ã§ã®ã¿ã¤ã« y åº§æ¨

      while (tsize != 1 && node !== Entity.AreaStatus.EMPTY && node !== Entity.AreaStatus.FULL) {
        tsize /= 2;
        var u = rx >= tsize ? 1 : 0;
        var v = ry >= tsize ? 1 : 0;
        msize /= 2;
        min_x += u * msize;
        max_y -= v * msize;
        var index = u + 2 * v;
        var child = node.children[index];

        if (child === null) {
          // å­ãã¼ããçæãã¦ node ã«è¨­å®
          child = this._create_area_node(min_x, max_y, msize, node.content);
          node.children[index] = child;
        }

        rx -= u * tsize;
        ry -= v * tsize;
        node = child;
      }

      return node;
    }
  }]);

  return QAreaManager;
}();
/**
 * @summary QAreaManager ãç®¡çãããã¼ã
 *
 * @memberof mapray.QAreaManager
 * @private
 */


var QAreaNode =
/**
 * @param {object} content  åå®¹ãã¼ã¿
 */
function QAreaNode(content) {
  _classCallCheck(this, QAreaNode);

  this.children = [null, null, null, null]; // QAreaNode | AreaStatus.EMPTY | AreaStatus.FULL

  this.content = content;
};

/**
 * @summary ç·ã¨ã³ãã£ãã£
 *
 * @classdesc
 * <p>{@link mapray.MarkerLineEntity} ã¨ {@link mapray.PathEntity} ã®å±éæ©è½ã
 *    æä¾ããã¯ã©ã¹ã§ããã</p>
 *
 * @memberof mapray
 * @extends mapray.Entity
 * @abstract
 * @protected
 */

var AbstractLineEntity =
/*#__PURE__*/
function (_Entity) {
  _inherits(AbstractLineEntity, _Entity);

  /**
   * @param {mapray.Scene} scene        æå±å¯è½ã·ã¼ã³
   * @param {mapray.AbstractLineEntity.LineType} line_type  ã¯ã©ã¹ç¨®å¥
   * @param {object}       [opts]       ãªãã·ã§ã³éå
   * @param {object}       [opts.json]  çææå ±
   * @param {object}       [opts.refs]  åç§è¾æ¸
   */
  function AbstractLineEntity(scene, line_type, opts) {
    var _this;

    _classCallCheck(this, AbstractLineEntity);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AbstractLineEntity).call(this, scene, opts));
    _this._line_type = line_type;

    if (_this.altitude_mode === AltitudeMode.CLAMP) {
      _this._producer = new FlakePrimitiveProducer$1(_assertThisInitialized(_this));
      _this._is_flake_mode = true;
    } else {
      _this._producer = new PrimitiveProducer$1(_assertThisInitialized(_this));
      _this._is_flake_mode = false;
    }

    return _this;
  }
  /**
   * @override
   */


  _createClass(AbstractLineEntity, [{
    key: "getPrimitiveProducer",
    value: function getPrimitiveProducer() {
      return !this._is_flake_mode ? this._producer : null;
    }
    /**
     * @override
     */

  }, {
    key: "getFlakePrimitiveProducer",
    value: function getFlakePrimitiveProducer() {
      return this._is_flake_mode ? this._producer : null;
    }
    /**
     * @override
     */

  }, {
    key: "onChangeAltitudeMode",
    value: function onChangeAltitudeMode(prev_mode) {
      if (this.altitude_mode === AltitudeMode.CLAMP) {
        this._producer = new FlakePrimitiveProducer$1(this);
        this._is_flake_mode = true;
      } else {
        this._producer = new PrimitiveProducer$1(this);
        this._is_flake_mode = false;
      }
    }
    /**
     * @summary ç·ã®å¤ªããè¨­å®
     *
     * @param {number} width  ç·ã®å¤ªã (ç»ç´ åä½)
     */

  }, {
    key: "setLineWidth",
    value: function setLineWidth(width) {
      if (this._width !== width) {
        this._width = width;

        this._producer.onChangeProperty();
      }
    }
    /**
     * @summary åºæ¬è²ãè¨­å®
     *
     * @param {mapray.Vector3} color  åºæ¬è²
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      if (this._color[0] !== color[0] || this._color[1] !== color[1] || this._color[2] !== color[2]) {
        // ä½ç½®ãå¤æ´ããã
        GeoMath.copyVector3(color, this._color);

        this._producer.onChangeProperty();
      }
    }
    /**
     * @summary ä¸éæåº¦ãè¨­å®
     *
     * @param {number} opacity  ä¸éæåº¦
     */

  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      if (this._opacity !== opacity) {
        this._opacity = opacity;

        this._producer.onChangeProperty();
      }
    }
    /**
     * @summary ãã¹ã¦ã®é ç¹ã®ãã¦ã³ãã£ã³ã°ãç®åº
     *
     * @override
     * @return {mapray.GeoRegion}  ãã¦ã³ãã£ã³ã°æå ±ãæã£ãGeoRegion
     */

  }, {
    key: "getBounds",
    value: function getBounds() {
      var region = new GeoRegion();
      region.addPointsAsArray(this._point_array);
      return region;
    }
    /**
     * @summary å°ç¨ãããªã¢ã«ãåå¾
     * @private
     */

  }, {
    key: "_getLineMaterial",
    value: function _getLineMaterial(render_target) {
      var scene = this.scene;
      var cache_id = "_AbstractLineEntity_material" + (this._line_type === LineType.PATH ? "_path" : "_markerline") + (render_target === RenderTarget.RID ? "_pick" : "");

      if (!scene[cache_id]) {
        // scene ã«ãããªã¢ã«ãã­ã£ãã·ã¥
        var opt = {
          ridMaterial: render_target === RenderTarget.RID
        };
        scene[cache_id] = new LineMaterial(scene.glenv, this._line_type, opt);
      }

      return scene[cache_id];
    }
  }]);

  return AbstractLineEntity;
}(Entity);
/**
 * @summary MarkerLineEntity ã® PrimitiveProducer
 *
 * @private
 */


var PrimitiveProducer$1 =
/*#__PURE__*/
function (_Entity$PrimitiveProd) {
  _inherits(PrimitiveProducer, _Entity$PrimitiveProd);

  /**
   * @param {mapray.MarkerLineEntity} entity
   */
  function PrimitiveProducer(entity) {
    var _this2;

    _classCallCheck(this, PrimitiveProducer);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(PrimitiveProducer).call(this, entity)); // ããªããã£ãã®è¦ç´ 

    _this2._transform = GeoMath.setIdentity(GeoMath.createMatrix());
    _this2._pivot = GeoMath.createVector3();
    _this2._bbox = [GeoMath.createVector3(), GeoMath.createVector3()];
    _this2._properties = {
      width: 1.0,
      color: GeoMath.createVector3f(),
      opacity: 1.0
    };

    if (entity._line_type == LineType.PATH) {
      _this2._properties["lower_length"] = 0.0;
      _this2._properties["upper_length"] = 0.0;
    } // ããªããã£ã


    var material = entity._getLineMaterial(RenderTarget.SCENE);

    var primitive = new Primitive(entity.scene.glenv, null, material, _this2._transform);
    primitive.pivot = _this2._pivot;
    primitive.bbox = _this2._bbox;
    primitive.properties = _this2._properties;
    _this2._primitive = primitive;

    var pick_material = entity._getLineMaterial(RenderTarget.RID);

    var pickPrimitive = new Primitive(entity.scene.glenv, null, pick_material, _this2._transform);
    pickPrimitive.pivot = _this2._pivot;
    pickPrimitive.bbox = _this2._bbox;
    pickPrimitive.properties = _this2._properties;
    _this2._pickPrimitive = pickPrimitive; // ããªããã£ãéå

    _this2._primitives = [primitive];
    _this2._pickPrimitives = [pickPrimitive];
    _this2._geom_dirty = true;
    return _this2;
  }
  /**
   * @override
   */


  _createClass(PrimitiveProducer, [{
    key: "createRegions",
    value: function createRegions() {
      var region = new EntityRegion();
      region.addPoints(this.entity._point_array, 0, 3, this._numPoints());
      return [region];
    }
    /**
     * @override
     */

  }, {
    key: "onChangeElevation",
    value: function onChangeElevation(regions) {
      this._geom_dirty = true;
    }
    /**
     * @override
     */

  }, {
    key: "getPrimitives",
    value: function getPrimitives(stage) {
      if (this._num_floats < 6) {
        // 2é ç¹æªæºã¯è¡¨ç¤ºããªã
        return [];
      } else {
        this._updatePrimitive();

        return stage.getRenderTarget() === RenderTarget.SCENE ? this._primitives : this._pickPrimitives;
      }
    }
    /**
     * @summary é ç¹ãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangePoints",
    value: function onChangePoints() {
      this.needToCreateRegions();
      this._geom_dirty = true;
    }
    /**
     * @summary ãã­ããã£ãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeProperty",
    value: function onChangeProperty() {}
    /**
     * @summary ããªããã£ãã®æ´æ°
     *
     * @desc
     * <pre>
     * æ¡ä»¶: this._num_floats >= 6
     * å¥å:
     *   this._geom_dirty
     *   this.entity._point_array
     *   this.entity._num_floats
     *   this.entity._width
     *   this.entity._color
     *   this.entity._opacity
     *   this.entity._length_array
     * åºå:
     *   this._transform
     *   this._pivot
     *   this._bbox
     *   this._properties
     *   this._primitive.mesh
     *   this._geom_dirty
     * </pre>
     *
     * @private
     */

  }, {
    key: "_updatePrimitive",
    value: function _updatePrimitive() {
      this._updateProperties();

      if (!this._geom_dirty) {
        // ã¡ãã·ã¥ã¯æ´æ°ããå¿è¦ããªã
        return;
      }

      var entity = this.entity; // GeoPoint å¹³å¦åéåã GOCS å¹³å¦åéåã«å¤æ

      var num_points = this._numPoints();

      var gocs_buffer = GeoPoint.toGocsArray(this._getFlatGeoPoints_with_Absolute(), num_points, new Float64Array(entity._num_floats)); // ããªããã£ãã®æ´æ°
      //   primitive.transform
      //   primitive.pivot
      //   primitive.bbox

      this._updateTransformPivotBBox(gocs_buffer, num_points);

      var add_length = entity._line_type === LineType.PATH;
      var length_array = add_length ? entity._length_array : undefined; // ã¡ãã·ã¥çæ

      var mesh_data = {
        vtype: [{
          name: "a_position",
          size: 3
        }, {
          name: "a_direction",
          size: 3
        }, {
          name: "a_where",
          size: 2
        }],
        vertices: this._createVertices(gocs_buffer, num_points, length_array),
        indices: this._createIndices()
      };

      if (add_length) {
        mesh_data.vtype.push({
          name: "a_length",
          size: 1
        });
      }

      var mesh = new Mesh(entity.scene.glenv, mesh_data); // ã¡ãã·ã¥è¨­å®
      //   primitive.mesh

      var primitive = this._primitive;

      if (primitive.mesh) {
        primitive.mesh.dispose();
      }

      primitive.mesh = mesh;
      var pickPrimitive = this._pickPrimitive;

      if (pickPrimitive.mesh) {
        pickPrimitive.mesh.dispose();
      }

      pickPrimitive.mesh = mesh; // æ´æ°çµäº

      this._geom_dirty = false;
    }
    /**
     * @summary ãã­ããã£ãæ´æ°
     *
     * @desc
     * <pre>
     * å¥å:
     *   this.entity._width
     *   this.entity._color
     *   this.entity._opacity
     *   this.entity._lower_length
     *   this.entity._upper_length
     * åºå:
     *   this._properties
     * </pre>
     *
     * @private
     */

  }, {
    key: "_updateProperties",
    value: function _updateProperties() {
      var entity = this.entity;
      var props = this._properties;
      props.width = entity._width;
      GeoMath.copyVector3(entity._color, props.color);
      props.opacity = entity._opacity;
      props.lower_length = entity._lower_length;
      props.upper_length = entity._upper_length;
    }
    /**
     * @summary GeoPoint å¹³å¦åéåãåå¾ (çµ¶å¯¾é«åº¦)
     *
     * @return {number[]}  GeoPoint å¹³å¦åéå
     * @private
     */

  }, {
    key: "_getFlatGeoPoints_with_Absolute",
    value: function _getFlatGeoPoints_with_Absolute() {
      var entity = this.entity;
      var point_array = entity._point_array;
      var num_floats = entity._num_floats;
      var abs_buffer = null;

      switch (entity.altitude_mode) {
        case AltitudeMode.RELATIVE:
          var num_points = this._numPoints();

          abs_buffer = new Float64Array(num_floats); // abs_buffer[] ã®é«åº¦è¦ç´ ã«ç¾å¨ã®æ¨é«ãè¨­å®

          entity.scene.viewer.getExistingElevations(num_points, point_array, 0, 3, abs_buffer, 2, 3); // abs_buffer[] ã«çµåº¦è¦ç´ ã¨ç·¯åº¦è¦ç´ ãè¨­å®ããé«åº¦è¦ç´ ã«çµ¶å¯¾é«åº¦ãè¨­å®

          for (var i = 0; i < num_floats; i += 3) {
            abs_buffer[i] = point_array[i]; // çµåº¦

            abs_buffer[i + 1] = point_array[i + 1]; // ç·¯åº¦

            abs_buffer[i + 2] += point_array[i + 2]; // çµ¶å¯¾é«åº¦
          }

          break;

        default:
          // AltitudeMode.ABSOLUTE
          abs_buffer = point_array;
          break;
      }

      return abs_buffer;
    }
    /**
     * @summary ããªããã£ãã®æ´æ°
     *
     * @desc
     * <pre>
     * åºå:
     *   this._transform
     *   this._pivot
     *   this._bbox
     * </pre>
     *
     * @param {Float64Array} gocs_buffer  å¥åé ç¹éå (GOCS)
     * @param {number}       num_points   å¥åé ç¹æ°
     * @private
     */

  }, {
    key: "_updateTransformPivotBBox",
    value: function _updateTransformPivotBBox(gocs_buffer, num_points) {
      // ã¢ãã«åº§æ¨ç³»ã®åç¹ (GOCS)
      var ox = gocs_buffer[0];
      var oy = gocs_buffer[1];
      var oz = gocs_buffer[2]; // å¤æè¡åã®æ´æ°

      var transform = this._transform;
      transform[12] = ox;
      transform[13] = oy;
      transform[14] = oz; // çµ±è¨

      var xsum = 0;
      var ysum = 0;
      var zsum = 0;
      var xmin = Number.MAX_VALUE;
      var ymin = Number.MAX_VALUE;
      var zmin = Number.MAX_VALUE;
      var xmax = -Number.MAX_VALUE;
      var ymax = -Number.MAX_VALUE;
      var zmax = -Number.MAX_VALUE;

      for (var i = 0; i < num_points; ++i) {
        var b = 3 * i;
        var x = gocs_buffer[b] - ox;
        var y = gocs_buffer[b + 1] - oy;
        var z = gocs_buffer[b + 2] - oz;
        xsum += x;
        ysum += y;
        zsum += z;

        if (x < xmin) {
          xmin = x;
        }

        if (y < ymin) {
          ymin = y;
        }

        if (z < zmin) {
          zmin = z;
        }

        if (x > xmax) {
          xmax = x;
        }

        if (y > ymax) {
          ymax = y;
        }

        if (z > zmax) {
          zmax = z;
        }
      } // ä¸­å¿ç¹


      var pivot = this._pivot;
      pivot[0] = xsum / num_points;
      pivot[1] = ysum / num_points;
      pivot[2] = zsum / num_points; // å¢çç®±

      var bbox = this._bbox;
      var bmin = bbox[0];
      var bmax = bbox[1];
      bmin[0] = xmin;
      bmin[1] = ymin;
      bmin[2] = zmin;
      bmax[0] = xmax;
      bmax[1] = ymax;
      bmax[2] = zmax;
    }
    /**
     * @summary é ç¹éåã®çæ
     *
     * @param  {Float64Array} gocs_buffer  å¥åé ç¹éå (GOCS)
     * @param  {number}       num_points   å¥åé ç¹æ°
     * @return {Float32Array}              Mesh ç¨ã®é ç¹éå
     *
     * @private
     */

  }, {
    key: "_createVertices",
    value: function _createVertices(gocs_buffer, num_points) {
      var length_array = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      // é ç¹ã®è·é¢ãè¿½å ããã
      var add_length = length_array !== undefined; // ã¢ãã«åº§æ¨ç³»ã®åç¹ (GOCS)

      var ox = gocs_buffer[0];
      var oy = gocs_buffer[1];
      var oz = gocs_buffer[2];
      var num_segments = num_points - 1;
      var num_vertices = 4 * num_segments;
      var vertices = new Float32Array((add_length ? 9 : 8) * num_vertices);

      for (var i = 0; i < num_segments; ++i) {
        var b = 3 * i;
        var sx = gocs_buffer[b] - ox;
        var sy = gocs_buffer[b + 1] - oy;
        var sz = gocs_buffer[b + 2] - oz;
        var ex = gocs_buffer[b + 3] - ox;
        var ey = gocs_buffer[b + 4] - oy;
        var ez = gocs_buffer[b + 5] - oz;
        var dx = gocs_buffer[b + 3] - gocs_buffer[b];
        var dy = gocs_buffer[b + 4] - gocs_buffer[b + 1];
        var dz = gocs_buffer[b + 5] - gocs_buffer[b + 2];
        var v = (add_length ? 36 : 32) * i; // å§å·¦ãå§å³ãçµå·¦ãçµå³ã®ã«ã¼ã

        for (var j = 0; j < 4; ++j) {
          var start = j < 2;
          var id = v + j * (add_length ? 9 : 8);
          vertices[id] = start ? sx : ex; // a_position.x

          vertices[id + 1] = start ? sy : ey; // a_position.y

          vertices[id + 2] = start ? sz : ez; // a_position.z

          vertices[id + 3] = dx; // a_direction.x

          vertices[id + 4] = dy; // a_direction.y

          vertices[id + 5] = dz; // a_direction.z

          switch (j) {
            case 0:
              vertices[id + 6] = -1; // a_where.x

              vertices[id + 7] = 1; // a_where.y

              break;

            case 1:
              vertices[id + 6] = -1; // a_where.x

              vertices[id + 7] = -1; // a_where.y

              break;

            case 2:
              vertices[id + 6] = 1; // a_where.x

              vertices[id + 7] = 1; // a_where.y

              break;

            case 3:
              vertices[id + 6] = 1; // a_where.x

              vertices[id + 7] = -1; // a_where.y

              break;
          }

          if (add_length) {
            vertices[id + 8] = length_array[start ? i : i + 1];
          }
        }
      }

      return vertices;
    }
    /**
     * @summary é ç¹ã¤ã³ããã¯ã¹ã®çæ
     *
     * @desc
     * <pre>
     * æ¡ä»¶: this.entity._num_floats >= 6
     * å¥å: this.entity._num_floats
     * </pre>
     *
     * @return {Uint32Array}  ã¤ã³ããã¯ã¹éå
     *
     * @private
     */

  }, {
    key: "_createIndices",
    value: function _createIndices() {
      var num_points = this._numPoints();

      var num_segments = num_points - 1;
      var num_indices = 6 * num_segments;
      var indices = new Uint32Array(num_indices);

      for (var i = 0; i < num_segments; ++i) {
        var base_d = 6 * i;
        var base_s = 4 * i;
        indices[base_d] = base_s;
        indices[base_d + 1] = base_s + 1;
        indices[base_d + 2] = base_s + 2;
        indices[base_d + 3] = base_s + 2;
        indices[base_d + 4] = base_s + 1;
        indices[base_d + 5] = base_s + 3;
      }

      return indices;
    }
    /**
     * @summary é ç¹æ°ãåå¾
     *
     * @return {number} é ç¹æ°
     *
     * @private
     */

  }, {
    key: "_numPoints",
    value: function _numPoints() {
      return Math.floor(this.entity._num_floats / 3);
    }
  }]);

  return PrimitiveProducer;
}(Entity.PrimitiveProducer);
/**
 * @summary MarkerLineEntity ã® FlakePrimitiveProducer
 *
 * @private
 */


var FlakePrimitiveProducer$1 =
/*#__PURE__*/
function (_Entity$FlakePrimitiv) {
  _inherits(FlakePrimitiveProducer, _Entity$FlakePrimitiv);

  /**
   * @param {mapray.MarkerLineEntity} entity
   */
  function FlakePrimitiveProducer(entity) {
    var _this3;

    _classCallCheck(this, FlakePrimitiveProducer);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(FlakePrimitiveProducer).call(this, entity));
    _this3._material_map = Object.keys(RenderTarget).reduce(function (map, key) {
      var render_target = RenderTarget[key];
      map.set(render_target, entity._getLineMaterial(render_target));
      return map;
    }, new Map());
    _this3._properties = null;
    _this3._area_manager = new LineAreaManager(entity);
    return _this3;
  }
  /**
   * @override
   */


  _createClass(FlakePrimitiveProducer, [{
    key: "getAreaStatus",
    value: function getAreaStatus(area) {
      return this._area_manager.getAreaStatus(area);
    }
    /**
     * @override
     */

  }, {
    key: "createMesh",
    value: function createMesh(area, dpows, dem) {
      var segments = this._divideXY(area, dpows);

      if (segments.length == 0) {
        return null;
      }

      var add_length = this.entity._line_type === LineType.PATH; // ã¡ãã·ã¥çæ

      var mesh_data = {
        vtype: [{
          name: "a_position",
          size: 3
        }, {
          name: "a_direction",
          size: 3
        }, {
          name: "a_where",
          size: 2
        }],
        vertices: this._createVertices(area, dem, segments, add_length),
        indices: this._createIndices(segments.length)
      };

      if (add_length) {
        mesh_data.vtype.push({
          name: "a_length",
          size: 1
        });
      }

      return new Mesh(this.entity.scene.glenv, mesh_data);
    }
    /**
     * @override
     */

  }, {
    key: "getMaterialAndProperties",
    value: function getMaterialAndProperties(stage) {
      if (this._properties === null) {
        var entity = this.entity;
        this._properties = {
          width: entity._width,
          color: GeoMath.createVector3f(entity._color),
          opacity: entity._opacity
        };

        if (entity._line_type == LineType.PATH) {
          this._properties["lower_length"] = entity._lower_length;
          this._properties["upper_length"] = entity._upper_length;
        }
      }

      return {
        material: this._material_map.get(stage.getRenderTarget()),
        properties: this._properties
      };
    }
    /**
     * @summary é ç¹ãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangePoints",
    value: function onChangePoints() {
      this._area_manager.notifyForUpdateContent();

      this.notifyForUpdate();
    }
    /**
     * @summary ãã­ããã£ãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeProperty",
    value: function onChangeProperty() {
      this._properties = null;
    }
    /**
     * @summary ãã¹ã¦ã®ç·åãåç´ã°ãªããã§åå²
     *
     * @param {mapray.Area} area   å°è¡¨æ­çã®é å
     * @param {number}      msize  area å¯¸æ³ Ã· Ï (å³å¯å¤)
     * @param {number}      dpow   area ã® x åå²ææ°
     *
     * @private
     */

  }, {
    key: "_divideXOnly",
    value: function _divideXOnly(area, msize, dpow) {
      var x_min = Math.PI * (area.x * msize - 1);
      var x_max = Math.PI * ((area.x + 1) * msize - 1);
      var div_x = 1 << dpow; // æ¨ªåå²æ°: 2^dpow

      var step_x = (x_max - x_min) / div_x; // æ¨ªåå²éé

      var segments = []; // åç´ã°ãªããç·ã§åå²

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._area_manager.getAreaContent(area)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 6),
              px = _step$value[0],
              py = _step$value[1],
              pl = _step$value[2],
              qx = _step$value[3],
              qy = _step$value[4],
              ql = _step$value[5];

          var _ref = px <= qx ? [px, py, pl, qx, qy, ql] : [qx, qy, ql, px, py, pl],
              _ref2 = _slicedToArray(_ref, 6),
              x0 = _ref2[0],
              y0 = _ref2[1],
              l0 = _ref2[2],
              x1 = _ref2[3],
              y1 = _ref2[4],
              l1 = _ref2[5]; // assert: x0 <= x1


          if (x1 < x_min || x0 >= x_max) {
            // ç·åã® x åº§æ¨ã area ã®ç¯å²å¤
            continue;
          }

          if (x0 == x1) {
            // åç´ç·åãªã®ã§ãåç´ã°ãªããç·ã§åå²ããªã
            segments.push([x0, y0, l0, x1, y1, l1]);
            continue;
          } // å·¦ç«¯ã§ããªãã³ã°


          var tx0 = x0;
          var ty0 = y0;
          var tl0 = l0;

          if (x0 < x_min) {
            var mu1 = (x_min - x0) / (x1 - x0);
            var mu0 = 1 - mu1;
            tx0 = x_min;
            ty0 = mu0 * y0 + mu1 * y1; // å·¦ç«¯ç·ã¨ç·åã®äº¤ç¹ã® y åº§æ¨

            tl0 = mu0 * l0 + mu1 * l1;
          } // å³ç«¯ã§ããªãã³ã°


          var tx1 = x1;
          var ty1 = y1;
          var tl1 = l1;

          if (x1 > x_max) {
            var _mu = (x_max - x0) / (x1 - x0);

            var _mu2 = 1 - _mu;

            tx1 = x_max;
            ty1 = _mu2 * y0 + _mu * y1; // å³ç«¯ç·ã¨ç·åã®äº¤ç¹ã® y åº§æ¨

            tl1 = _mu2 * l0 + _mu * l1;
          } // ã°ãªããç·ã®ç¯å²


          var i_min = Math.max(Math.ceil((x0 - x_min) / step_x), 1);
          var i_max = Math.min(Math.floor((x1 - x_min) / step_x), div_x - 1);
          var prev_x = tx0;
          var prev_y = ty0;
          var prev_l = tl0;

          for (var i = i_min; i <= i_max; ++i) {
            var next_x = x_min + step_x * i; // åç´ã°ãªããç·ã® x åº§æ¨

            var _mu3 = (next_x - x0) / (x1 - x0);

            var _mu4 = 1 - _mu3;

            var next_y = _mu4 * y0 + _mu3 * y1; // åç´ã°ãªããç·ã¨ç·åã®äº¤ç¹ã® y åº§æ¨

            var next_l = _mu4 * l0 + _mu3 * l1;

            if (prev_x != next_x || prev_y != next_y) {
              segments.push([prev_x, prev_y, prev_l, next_x, next_y, next_l]);
            }

            prev_x = next_x;
            prev_y = next_y;
            prev_l = next_l;
          }

          if (prev_x != tx1 || prev_y != ty1) {
            segments.push([prev_x, prev_y, prev_l, tx1, ty1, tl1]);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return segments;
    }
    /**
     * @summary ãã¹ã¦ã®ç·åãã°ãªããã§åå²
     *
     * @param {mapray.Area} area   å°è¡¨æ­çã®é å
     * @param {number[]}    dpows  area ã® xy åå²ææ°
     *
     * @private
     */

  }, {
    key: "_divideXY",
    value: function _divideXY(area, dpows) {
      // area å¯¸æ³ Ã· Ï (å³å¯å¤)
      // ç·åã®å ´åãé åã®ç«¯ã«ããã¯ãªããã³ã°ãã·ãã¢ãªã®ã§å³å¯å¤ (2^æ´æ°) ãä½¿ã
      var msize = 2 / Math.round(Math.pow(2, area.z)); // area ã® y åº§æ¨ã®ç¯å²

      var y_min = Math.PI * (1 - (area.y + 1) * msize);
      var y_max = Math.PI * (1 - area.y * msize);
      var div_y = 1 << dpows[1]; // ç¸¦åå²æ°: 2^dpow

      var step_y = (y_max - y_min) / div_y; // ç¸¦åå²éé

      var segments = []; // æ°´å¹³ã°ãªããç·ã§åå²

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._divideXOnly(area, msize, dpows[0])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = _slicedToArray(_step2.value, 6),
              px = _step2$value[0],
              py = _step2$value[1],
              pl = _step2$value[2],
              qx = _step2$value[3],
              qy = _step2$value[4],
              ql = _step2$value[5];

          var _ref3 = py <= qy ? [px, py, pl, qx, qy, ql] : [qx, qy, ql, px, py, pl],
              _ref4 = _slicedToArray(_ref3, 6),
              x0 = _ref4[0],
              y0 = _ref4[1],
              l0 = _ref4[2],
              x1 = _ref4[3],
              y1 = _ref4[4],
              l1 = _ref4[5]; // assert: y0 <= y1


          if (y1 < y_min || y0 >= y_max) {
            // ç·åã® y åº§æ¨ã area ã®ç¯å²å¤
            continue;
          }

          if (y0 == y1) {
            // æ°´å¹³ç·åãªã®ã§ãæ°´å¹³ã°ãªããç·ã§åå²ããªã
            segments.push([x0, y0, l0, x1, y1, l1]);
            continue;
          } // ä¸ç«¯ã§ããªãã³ã°


          var tx0 = x0;
          var ty0 = y0;
          var tl0 = l0;

          if (y0 < y_min) {
            var mu1 = (y_min - y0) / (y1 - y0);
            var mu0 = 1 - mu1;
            tx0 = mu0 * x0 + mu1 * x1; // ä¸ç«¯ç·ã¨ç·åã®äº¤ç¹ã® x åº§æ¨

            ty0 = y_min;
            tl0 = mu0 * l0 + mu1 * l1;
          } // ä¸ç«¯ã§ããªãã³ã°


          var tx1 = x1;
          var ty1 = y1;
          var tl1 = l1;

          if (y1 > y_max) {
            var _mu5 = (y_max - y0) / (y1 - y0);

            var _mu6 = 1 - _mu5;

            tx1 = _mu6 * x0 + _mu5 * x1; // ä¸ç«¯ç·ã¨ç·åã®äº¤ç¹ã® x åº§æ¨

            ty1 = y_max;
            tl1 = _mu6 * l0 + _mu5 * l1;
          } // ã°ãªããç·ã®ç¯å²


          var i_min = Math.max(Math.ceil((y0 - y_min) / step_y), 1);
          var i_max = Math.min(Math.floor((y1 - y_min) / step_y), div_y - 1);
          var prev_x = tx0;
          var prev_y = ty0;
          var prev_l = tl0;

          for (var i = i_min; i <= i_max; ++i) {
            var next_y = y_min + step_y * i; // æ°´å¹³ã°ãªããç·ã® y åº§æ¨

            var _mu7 = (next_y - y0) / (y1 - y0);

            var _mu8 = 1 - _mu7;

            var next_x = _mu8 * x0 + _mu7 * x1; // æ°´å¹³ã°ãªããç·ã¨ç·åã®äº¤ç¹ã® x åº§æ¨

            var next_l = _mu8 * l0 + _mu7 * l1;

            if (prev_x != next_x || prev_y != next_y) {
              segments.push([prev_x, prev_y, prev_l, next_x, next_y, next_l]);
            }

            prev_x = next_x;
            prev_y = next_y;
            prev_l = next_l;
          }

          if (prev_x != tx1 || prev_y != ty1) {
            segments.push([prev_x, prev_y, prev_l, tx1, ty1, tl1]);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return segments;
    }
    /**
     * @summary é ç¹éåã®çæ
     *
     * @param {mapray.Area}      area  å°è¡¨æ­çã®é å
     * @param {mapray.DemBinary} dem   DEM ãã¤ããª
     *
     * @return {Float32Array}  Mesh ç¨ã®é ç¹éå
     *
     * @private
     */

  }, {
    key: "_createVertices",
    value: function _createVertices(area, dem, segments) {
      var add_length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var sampler = dem.newLinearSampler();

      var _AreaUtil$getCenter = AreaUtil.getCenter(area, GeoMath.createVector3()),
          _AreaUtil$getCenter2 = _slicedToArray(_AreaUtil$getCenter, 3),
          ox = _AreaUtil$getCenter2[0],
          oy = _AreaUtil$getCenter2[1],
          oz = _AreaUtil$getCenter2[2];

      var num_segments = segments.length;
      var num_vertices = 4 * num_segments;
      var vertices = new Float32Array((add_length ? 9 : 8) * num_vertices);

      for (var i = 0; i < num_segments; ++i) {
        var _segments$i = _slicedToArray(segments[i], 6),
            smx = _segments$i[0],
            smy = _segments$i[1],
            prev_length = _segments$i[2],
            emx = _segments$i[3],
            emy = _segments$i[4],
            next_length = _segments$i[5];

        var _toGocs = toGocs(smx, smy, sampler),
            _toGocs2 = _slicedToArray(_toGocs, 3),
            sgx = _toGocs2[0],
            sgy = _toGocs2[1],
            sgz = _toGocs2[2];

        var _toGocs3 = toGocs(emx, emy, sampler),
            _toGocs4 = _slicedToArray(_toGocs3, 3),
            egx = _toGocs4[0],
            egy = _toGocs4[1],
            egz = _toGocs4[2];

        var sx = sgx - ox;
        var sy = sgy - oy;
        var sz = sgz - oz;
        var ex = egx - ox;
        var ey = egy - oy;
        var ez = egz - oz;
        var dx = egx - sgx;
        var dy = egy - sgy;
        var dz = egz - sgz;
        var v = (add_length ? 36 : 32) * i; // å§å·¦ãå§å³ãçµå·¦ãçµå³ã®ã«ã¼ã

        for (var j = 0; j < 4; ++j) {
          var start = j < 2;
          var id = v + j * (add_length ? 9 : 8);
          vertices[id] = start ? sx : ex; // a_position.x

          vertices[id + 1] = start ? sy : ey; // a_position.y

          vertices[id + 2] = start ? sz : ez; // a_position.z

          vertices[id + 3] = dx; // a_direction.x

          vertices[id + 4] = dy; // a_direction.y

          vertices[id + 5] = dz; // a_direction.z

          switch (j) {
            case 0:
              vertices[id + 6] = -1; // a_where.x

              vertices[id + 7] = 1; // a_where.y

              break;

            case 1:
              vertices[id + 6] = -1; // a_where.x

              vertices[id + 7] = -1; // a_where.y

              break;

            case 2:
              vertices[id + 6] = 1; // a_where.x

              vertices[id + 7] = 1; // a_where.y

              break;

            case 3:
              vertices[id + 6] = 1; // a_where.x

              vertices[id + 7] = -1; // a_where.y

              break;
          }

          if (add_length) {
            vertices[id + 8] = start ? prev_length : next_length;
          }
        }
      }

      return vertices;
    }
    /**
     * @summary @summary é ç¹ã¤ã³ããã¯ã¹ã®çæ
     *
     * @param {number} num_segments  ç·åã®æ°
     *
     * @return {Uint32Array}  Mesh ç¨ã®é ç¹ã¤ã³ããã¯ã¹
     *
     * @private
     */

  }, {
    key: "_createIndices",
    value: function _createIndices(num_segments) {
      var num_indices = 6 * num_segments;
      var indices = new Uint32Array(num_indices);

      for (var i = 0; i < num_segments; ++i) {
        var base_d = 6 * i;
        var base_s = 4 * i;
        indices[base_d] = base_s;
        indices[base_d + 1] = base_s + 1;
        indices[base_d + 2] = base_s + 2;
        indices[base_d + 3] = base_s + 2;
        indices[base_d + 4] = base_s + 1;
        indices[base_d + 5] = base_s + 3;
      }

      return indices;
    }
  }]);

  return FlakePrimitiveProducer;
}(Entity.FlakePrimitiveProducer);
/**
 * @private
 */


function toGocs(x, y, sampler) {
  var Î» = x;
  var Ï = GeoMath.gudermannian(y);
  var r = GeoMath.EARTH_RADIUS + sampler.sample(x, y);
  var cosÏ = Math.cos(Ï);
  return [r * cosÏ * Math.cos(Î»), r * cosÏ * Math.sin(Î»), r * Math.sin(Ï)];
}
/**
 * @summary ç·åã®é åç®¡ç
 *
 * @private
 */


var LineAreaManager =
/*#__PURE__*/
function (_QAreaManager) {
  _inherits(LineAreaManager, _QAreaManager);

  /**
   * @param {mapray.MarkerLineEntity} entity  ç®¡çå¯¾è±¡ã®ã¨ã³ãã£ãã£
   */
  function LineAreaManager(entity) {
    var _this4;

    _classCallCheck(this, LineAreaManager);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(LineAreaManager).call(this));
    _this4._entity = entity;
    return _this4;
  }
  /**
   * @override
   */


  _createClass(LineAreaManager, [{
    key: "getInitialContent",
    value: function getInitialContent() {
      var Degree = GeoMath.DEGREE;
      var RAngle = Math.PI / 2; // ç´è§

      var TwoPI = 2 * Math.PI; // 2Ï

      var segments = []; // é ç¹ãã¼ã¿

      var points = this._entity._point_array;
      var end_point = this._entity._num_floats;

      if (end_point < 6) {
        // ç·åãªã
        return segments;
      }

      var is_path = this._entity._line_type === LineType.PATH;
      var length_array = is_path ? this._entity._length_array : null; // ç·åã®å§ç¹ (ã©ã¸ã¢ã³)

      var lon0 = points[0] * Degree;
      var lat0 = points[1] * Degree;
      var length0 = is_path ? length_array[0] : 0;
      var lon1;
      var lat1;
      var length1;

      for (var i = 3; i < end_point; i += 3, lon0 = lon1, lat0 = lat1, length0 = length1) {
        // ç·åã®çµç¹ (ã©ã¸ã¢ã³)
        lon1 = points[i] * Degree;
        lat1 = points[i + 1] * Degree;
        length1 = is_path ? length_array[i / 3] : 0;

        if (lat0 <= -RAngle || lat0 >= RAngle || lat1 <= -RAngle || lat1 >= RAngle) {
          // ç«¯ç¹ã®ç·¯åº¦ã®çµ¶å¯¾å¤ã RAngle ä»¥ä¸ã®ç·åã¯é¤å¤
          // â» ã¾ã æ¤è¨ãã¦ããªãã®ã§ãã¨ããããã®å¦ç½®
          continue;
        } // åä½çã¡ã«ã«ãã«åº§æ¨ç³»ã«å¤æ


        var x0 = lon0;
        var y0 = GeoMath.invGudermannian(lat0);
        var l0 = length0;
        var x1 = lon1;
        var y1 = GeoMath.invGudermannian(lat1);
        var l1 = length1; // å·¦ç«¯ç¹ã¨å³ç«¯ç¹

        var _ref5 = x0 < x1 ? [x0, y0, l0, x1, y1, l1] : [x1, y1, l1, x0, y0, l0],
            _ref6 = _slicedToArray(_ref5, 6),
            xL = _ref6[0],
            yL = _ref6[1],
            lL = _ref6[2],
            xR = _ref6[3],
            yR = _ref6[4],
            lR = _ref6[5]; // -Ï <= xL < Ï ã«ãªãããã« xL ãæ­£è¦å


        if (xL < -Math.PI || xL >= Math.PI) {
          var dx = xR - xL;
          xL -= TwoPI * (Math.floor((xL - Math.PI) / TwoPI) + 1);

          if (xL < -Math.PI || xL >= Math.PI) {
            // èª¤å·®å¯¾ç­
            xL = -Math.PI;
          }

          xR = xL + dx;
        }

        if (xL == xR && yL == yR) {
          // é·ã 0 ã®ç·åã¯é¤å¤
          continue;
        } // ç·åãè¿½å 


        segments.push([xL, yL, lL, xR, yR, lR]);

        if (xR > Math.PI) {
          // ç·åã 180 åº¦å­åç·ãã¾ããã¨ã
          // ãã¡ãã¯å¤å°å³å¯ããç¡è¦ãã
          segments.push([xL - TwoPI, yL, lL, xR - TwoPI, yR, lR]);
        }
      }

      return segments;
    }
    /**
     * @override
     */

  }, {
    key: "createAreaContent",
    value: function createAreaContent(min_x, min_y, msize, parent_content) {
      // åä½çã¡ã«ã«ãã«ã§ã®é åã«å¤æ
      var x_area_min = Math.PI * min_x;
      var x_area_max = Math.PI * (min_x + msize);
      var y_area_min = Math.PI * min_y;
      var y_area_max = Math.PI * (min_y + msize);
      var segments = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = parent_content[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var segment = _step3.value;

          var _segment = _slicedToArray(segment, 5),
              xP = _segment[0],
              yP = _segment[1],

          /*lP*/
          xQ = _segment[3],
              yQ
          /*lQ*/
          = _segment[4];

          if (this._intersect(x_area_min, x_area_max, y_area_min, y_area_max, xP, yP, xQ, yQ)) {
            segments.push(segment);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return segments.length > 0 ? segments : Entity.AreaStatus.EMPTY;
    }
    /**
     * @summary ç©å½¢ã¨ç·åã®äº¤å·®å¤å®
     *
     * @desc
     * <p>ç©å½¢é åã¨ç·åãäº¤å·®ãããã©ãããè¿ãã</p>
     * <p>ç©å½¢é åã«ã¯ x åº§æ¨ã x_area_max ã®ç¹ã¨ãy åº§æ¨ã y_area_max ã®ç¹ã¯å«ã¾ããªããã®ã¨ããã</p>
     *
     * <pre>
     * äºåæ¡ä»¶:
     *   x_area_min < x_area_max
     *   y_area_min < y_area_max
     * </pre>
     *
     * @param {number} x_area_min  ç©å½¢é åã®æå° x åº§æ¨
     * @param {number} x_area_max  ç©å½¢é åã®æå¤§ x åº§æ¨
     * @param {number} y_area_min  ç©å½¢é åã®æå° y åº§æ¨
     * @param {number} y_area_max  ç©å½¢é åã®æå¤§ y åº§æ¨
     * @param {number} xP          ç·åç«¯ç¹ P ã® x åº§æ¨
     * @param {number} yP          ç·åç«¯ç¹ P ã® y åº§æ¨
     * @param {number} xQ          ç·åç«¯ç¹ Q ã® x åº§æ¨
     * @param {number} yQ          ç·åç«¯ç¹ Q ã® y åº§æ¨
     *
     * @return {boolean}  äº¤å·®ããã¨ã true, ããä»¥å¤ã®ã¨ã false
     *
     * @private
     */

  }, {
    key: "_intersect",
    value: function _intersect(x_area_min, x_area_max, y_area_min, y_area_max, xP, yP, xQ, yQ) {
      if (Math.abs(xP - xQ) < Math.abs(yP - yQ)) {
        // ç·åãåç´ã«è¿ãã¨ã
        return this._nhorz_intersect(x_area_min, x_area_max, y_area_min, y_area_max, xP, yP, xQ, yQ);
      } else {
        // ç·åãæ°´å¹³ã«è¿ãã¨ã
        return this._nhorz_intersect(y_area_min, y_area_max, x_area_min, x_area_max, yP, xP, yQ, xQ);
      }
    }
    /**
     * @summary ç©å½¢ã¨éæ°´å¹³ç·åã®äº¤å·®å¤å®
     *
     * @desc
     * <p>ç©å½¢é åã¨ç·åãäº¤å·®ãããã©ãããè¿ãã</p>
     * <p>ç©å½¢é åã«ã¯ x åº§æ¨ã x_area_max ã®ç¹ã¨ãy åº§æ¨ã y_area_max ã®ç¹ã¯å«ã¾ããªããã®ã¨ããã</p>
     *
     * <pre>
     * äºåæ¡ä»¶:
     *   x_area_min < x_area_max
     *   y_area_min < y_area_max
     *   yP != yQ
     * </pre>
     *
     * <p>æ³¨æ: |yP - yQ| ãå°ããã¨ç²¾åº¦ãæªããªãã</p>
     *
     * @param {number} x_area_min  ç©å½¢é åã®æå° x åº§æ¨
     * @param {number} x_area_max  ç©å½¢é åã®æå¤§ x åº§æ¨
     * @param {number} y_area_min  ç©å½¢é åã®æå° y åº§æ¨
     * @param {number} y_area_max  ç©å½¢é åã®æå¤§ y åº§æ¨
     * @param {number} xP          ç·åç«¯ç¹ P ã® x åº§æ¨
     * @param {number} yP          ç·åç«¯ç¹ P ã® y åº§æ¨
     * @param {number} xQ          ç·åç«¯ç¹ Q ã® x åº§æ¨
     * @param {number} yQ          ç·åç«¯ç¹ Q ã® y åº§æ¨
     *
     * @return {boolean}  äº¤å·®ããã¨ã true, ããä»¥å¤ã®ã¨ã false
     *
     * @private
     */

  }, {
    key: "_nhorz_intersect",
    value: function _nhorz_intersect(x_area_min, x_area_max, y_area_min, y_area_max, xP, yP, xQ, yQ) {
      // ç·åã® y åº§æ¨ã®ç¯å²
      var _ref7 = yP < yQ ? [yP, yQ] : [yQ, yP],
          _ref8 = _slicedToArray(_ref7, 2),
          y_line_min = _ref8[0],
          y_line_max = _ref8[1];

      if (y_line_min >= y_area_max || y_line_max < y_area_min) {
        // ç·åã® y ç¯å²ãç©å½¢é åã® y ç¯å²ã®å¤å´ãªã®ã§äº¤å·®ããªã
        return false;
      } // ç©å½¢é åã¨ç·åã® y åº§æ¨ãéãªãç¯å² (é ä¸å)


      var y_range_0 = y_area_min >= y_line_max ? y_area_min : y_line_max;
      var y_range_1 = y_area_max <= y_line_min ? y_area_max : y_line_min; // y ã {y_range_0, y_range_1} ç¯å²ã§ã®ç·åã® x ç¯å² (é ä¸å)

      var x_range_0 = xP + (xQ - xP) * (y_range_0 - yP) / (yQ - yP);
      var x_range_1 = xP + (xQ - xP) * (y_range_1 - yP) / (yQ - yP); // y ã {y_range_0, y_range_1} ç¯å²ã§ã®ç·åã® x ç¯å²

      var _ref9 = x_range_0 < x_range_1 ? [x_range_0, x_range_1] : [x_range_1, x_range_0],
          _ref10 = _slicedToArray(_ref9, 2),
          x_range_min = _ref10[0],
          x_range_max = _ref10[1]; // [x_range_min, x_range_max] ç¯å²ã¯ç©å½¢é åã® x ã®ç¯å²ã¨éãªããï¼


      return x_range_min < x_area_max && x_range_max >= x_area_min;
    }
  }]);

  return LineAreaManager;
}(QAreaManager);
/**
* @summary ã¨ã³ãã£ãã£ã®ç¨®é¡ã®åæå
* @enum {object}
* @memberof mapray.AbstractLineEntity
* @constant
* @see mapray.AbstractLineEntity#line_type
*/


var LineType = {
  /**
   * MarkerLineEntity
   */
  MARKERLINE: {
    id: "MARKERLINE"
  },

  /**
   * PathEntity
   */
  PATH: {
    id: "PATH"
  }
};
AbstractLineEntity.LineType = LineType;

/**
 * @summary å¤ªãä»ãé£ç¶ç·ã¨ã³ãã£ãã£
 * @memberof mapray
 * @extends mapray.AbstractLineEntity
 */

var MarkerLineEntity =
/*#__PURE__*/
function (_AbstractLineEntity) {
  _inherits(MarkerLineEntity, _AbstractLineEntity);

  /**
   * @param {mapray.Scene} scene        æå±å¯è½ã·ã¼ã³
   * @param {object}       [opts]       ãªãã·ã§ã³éå
   * @param {object}       [opts.json]  çææå ±
   * @param {object}       [opts.refs]  åç§è¾æ¸
   */
  function MarkerLineEntity(scene, opts) {
    var _this;

    _classCallCheck(this, MarkerLineEntity);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MarkerLineEntity).call(this, scene, AbstractLineEntity.LineType.MARKERLINE, opts));
    _this._point_array = new Float64Array(0);
    _this._num_floats = 0;
    _this._width = 1.0;
    _this._color = GeoMath.createVector3([1.0, 1.0, 1.0]);
    _this._opacity = 1.0;

    _this._setupAnimationBindingBlock(); // çææå ±ããè¨­å®


    if (opts && opts.json) {
      _this._setupByJson(opts.json);
    }

    return _this;
  }
  /**
   * ã¢ãã¡ã¼ã·ã§ã³ã® BindingBlock ãåæå
   *
   * @private
   */


  _createClass(MarkerLineEntity, [{
    key: "_setupAnimationBindingBlock",
    value: function _setupAnimationBindingBlock() {
      var _this2 = this;

      var block = this.animation; // å®ä½ã¯ EasyBindingBlock

      var number = Type.find("number");
      var vector3 = Type.find("vector3"); // ãã©ã¡ã¼ã¿å: width
      // ãã©ã¡ã¼ã¿å: number
      //   ç·ã®å¤ªã

      block.addEntry("width", [number], null, function (value) {
        _this2.setLineWidth(value);
      }); // ãã©ã¡ã¼ã¿å: color
      // ãã©ã¡ã¼ã¿å: vector3
      //   è²

      block.addEntry("color", [vector3], null, function (value) {
        _this2.setColor(value);
      }); // ãã©ã¡ã¼ã¿å: opacity
      // ãã©ã¡ã¼ã¿å: number
      //   ä¸éæåº¦

      block.addEntry("opacity", [number], null, function (value) {
        _this2.setOpacity(value);
      });
    }
    /**
     * @summary è¤æ°ã®é ç¹ãè¿½å 
     *
     * @desc
     * <p>points ã¯ [lon_0, lat_0, alt_0, lon_1, lat_1, alt_1, ...] ã®ãããªå½¢å¼ã®éåãä¸ããã</p>
     *
     * @param {number[]} points  é ç¹ã®éå
     */

  }, {
    key: "addPoints",
    value: function addPoints(points) {
      var add_size = points.length;

      if (add_size == 0) {
        // è¿½å é ç¹ãç¡ãã®ã§å¤åãªã
        return;
      } // ãããã¡ãæ¡å¼µ


      var target_size = this._num_floats + add_size;
      var buffer_size = this._point_array.length;

      if (target_size > buffer_size) {
        var new_buffer = new Float64Array(Math.max(target_size, 2 * buffer_size));
        var old_buffer = this._point_array;
        var copy_size = this._num_floats;

        for (var i = 0; i < copy_size; ++i) {
          new_buffer[i] = old_buffer[i];
        }

        this._point_array = new_buffer;
      } // é ç¹è¿½å å¦ç


      var buffer = this._point_array;
      var base = this._num_floats;

      for (var j = 0; j < add_size; ++j) {
        buffer[base + j] = points[j];
      }

      this._num_floats = target_size; // å½¢ç¶ãå¤åããå¯è½æ§ããã

      this._producer.onChangePoints();
    }
    /**
     * @private
     */

  }, {
    key: "_setupByJson",
    value: function _setupByJson(json) {
      // json.points
      this.addPoints(json.points); // json.line_width
      //     .color
      //     .opacity

      if (json.line_width !== undefined) this.setLineWidth(json.line_width);
      if (json.color !== undefined) this.setColor(json.color);
      if (json.opacity !== undefined) this.setOpacity(json.opacity);
    }
  }]);

  return MarkerLineEntity;
}(AbstractLineEntity);

/**
 * @summary å¤ªãä»ãé£ç¶ç·ã¨ã³ãã£ãã£
 * @memberof mapray
 * @extends mapray.AbstractLineEntity
 */

var PathEntity =
/*#__PURE__*/
function (_AbstractLineEntity) {
  _inherits(PathEntity, _AbstractLineEntity);

  /**
   * @param {mapray.Scene} scene        æå±å¯è½ã·ã¼ã³
   * @param {object}       [opts]       ãªãã·ã§ã³éå
   * @param {object}       [opts.json]  çææå ±
   * @param {object}       [opts.refs]  åç§è¾æ¸
   */
  function PathEntity(scene, opts) {
    var _this;

    _classCallCheck(this, PathEntity);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PathEntity).call(this, scene, AbstractLineEntity.LineType.PATH, opts));
    _this._point_array = new Float64Array(0);
    _this._num_floats = 0;
    _this._length_array = new Float64Array(0);
    _this._width = 1.0;
    _this._color = GeoMath.createVector3([1.0, 1.0, 1.0]);
    _this._opacity = 1.0;
    _this._lower_length = 0;
    _this._upper_length = 0;

    _this._setupAnimationBindingBlock(); // çææå ±ããè¨­å®


    if (opts && opts.json) {
      _this._setupByJson(opts.json);
    }

    return _this;
  }
  /**
   * ã¢ãã¡ã¼ã·ã§ã³ã® BindingBlock ãåæå
   *
   * @private
   */


  _createClass(PathEntity, [{
    key: "_setupAnimationBindingBlock",
    value: function _setupAnimationBindingBlock() {
      var _this2 = this;

      var block = this.animation; // å®ä½ã¯ EasyBindingBlock

      var number = Type.find("number");
      var vector3 = Type.find("vector3"); // ãã©ã¡ã¼ã¿å: width
      // ãã©ã¡ã¼ã¿å: number
      //   ç·ã®å¤ªã

      block.addEntry("width", [number], null, function (value) {
        _this2.setLineWidth(value);
      }); // ãã©ã¡ã¼ã¿å: color
      // ãã©ã¡ã¼ã¿å: vector3
      //   è²

      block.addEntry("color", [vector3], null, function (value) {
        _this2.setColor(value);
      }); // ãã©ã¡ã¼ã¿å: opacity
      // ãã©ã¡ã¼ã¿å: number
      //   ä¸éæåº¦

      block.addEntry("opacity", [number], null, function (value) {
        _this2.setOpacity(value);
      }); // ãã©ã¡ã¼ã¿å: lower_length
      // ãã©ã¡ã¼ã¿å: number
      //   è·é¢ã®ä¸éå¤

      block.addEntry("lower_length", [number], null, function (value) {
        _this2.setLowerLength(value);
      }); // ãã©ã¡ã¼ã¿å: upper_length
      // ãã©ã¡ã¼ã¿å: number
      //   è·é¢ã®ä¸éå¤

      block.addEntry("upper_length", [number], null, function (value) {
        _this2.setUpperLength(value);
      });
    }
    /**
     * @summary è·é¢ã®ä¸éå¤ãè¨­å®
     *
     * @param {number} lower_length  è·é¢ã®ä¸éå¤
     */

  }, {
    key: "setLowerLength",
    value: function setLowerLength(lower_length) {
      if (this._lower_length !== lower_length) {
        this._lower_length = lower_length;

        this._producer.onChangeProperty();
      }
    }
    /**
    * @summary è·é¢ã®ä¸éå¤ãè¨­å®
    *
    * @param {number} upper_length  è·é¢ã®ä¸éå¤
    */

  }, {
    key: "setUpperLength",
    value: function setUpperLength(upper_length) {
      if (this._upper_length !== upper_length) {
        this._upper_length = upper_length;

        this._producer.onChangeProperty();
      }
    }
    /**
     * @summary è¤æ°ã®é ç¹ãè¿½å 
     *
     * @desc
     * <p>points ã¯ [lon_0, lat_0, alt_0, lon_1, lat_1, alt_1, ...] ã®ãããªå½¢å¼ã®éåãä¸ããã</p>
     *
     * @param {number[]} points  é ç¹ã®éå
     * @param {number[]} length_array  å§ç¹ããã®è·é¢ã®éå
     */

  }, {
    key: "addPoints",
    value: function addPoints(points, length_array) {
      var add_size = points.length;
      var add_length_size = length_array.length;

      if (add_size == 0 || add_length_size == 0) {
        // è¿½å é ç¹ãç¡ãã®ã§å¤åãªã
        return;
      }

      var num_length_floats = this._num_floats / 3; // ãããã¡ãæ¡å¼µ

      var target_size = this._num_floats + add_size;
      var buffer_size = this._point_array.length;

      if (target_size > buffer_size) {
        var new_buffer = new Float64Array(Math.max(target_size, 2 * buffer_size));
        var old_buffer = this._point_array;
        var copy_size = this._num_floats;

        for (var i = 0; i < copy_size; ++i) {
          new_buffer[i] = old_buffer[i];
        }

        this._point_array = new_buffer;
      } // è·é¢éåãããã¡ãæ¡å¼µ


      var target_length_size = num_length_floats + add_length_size;
      var buffer_length_size = this._length_array.length;

      if (target_length_size > buffer_length_size) {
        var _new_buffer = new Float64Array(Math.max(target_length_size, 2 * buffer_length_size));

        var _old_buffer = this._length_array;
        var _copy_size = num_length_floats;

        for (var _i = 0; _i < _copy_size; ++_i) {
          _new_buffer[_i] = _old_buffer[_i];
        }

        this._length_array = _new_buffer;
      } // é ç¹è¿½å å¦ç


      var buffer = this._point_array;
      var base = this._num_floats;

      for (var _i2 = 0; _i2 < points.length; ++_i2) {
        buffer[base + _i2] = points[_i2];
      } // è·é¢ã®éåãè¿½å 


      var buffer_length = this._length_array;
      var base_length = num_length_floats;

      for (var _i3 = 0; _i3 < length_array.length; ++_i3) {
        buffer_length[base_length + _i3] = length_array[_i3];
      }

      this._num_floats = target_size; // å½¢ç¶ãå¤åããå¯è½æ§ããã

      this._producer.onChangePoints();
    }
    /**
     * @private
     */

  }, {
    key: "_setupByJson",
    value: function _setupByJson(json) {
      // json.points
      this.addPoints(json.points.positions, json.points.lengths); // json.line_width
      //     .color
      //     .opacity
      //     .lower_length
      //     .upper_length

      if (json.line_width !== undefined) this.setLineWidth(json.line_width);
      if (json.color !== undefined) this.setColor(json.color);
      if (json.opacity !== undefined) this.setOpacity(json.opacity);
      if (json.lower_length !== undefined) this.setLowerLength(json.lower_length);
      if (json.upper_length !== undefined) this.setUpperLength(json.upper_length);
    }
  }]);

  return PathEntity;
}(AbstractLineEntity);

var text_vs_code = "/**\n * ãã­ã¹ã (é ç¹ã·ã§ã¼ã)\n */\n\nattribute vec4 a_position;    // é ç¹ä½ç½® (ã¢ãã«åº§æ¨ç³»)\nattribute vec2 a_offset;      // é ç¹å¤ä½ (ã¹ã¯ãªã¼ã³åº§æ¨ç³»)\nattribute vec2 a_texcoord;    // ãã¯ã¹ãã£åº§æ¨\n\nuniform mat4 u_obj_to_clip;   // ã¢ãã«åº§æ¨ç³»ããã¯ãªããåº§æ¨ç³»ã¸ã®å¤æ\nuniform vec2 u_sparam;        // ç»é¢ãã©ã¡ã¼ã¿: {2/w, 2/h}\n\nvarying vec2 v_texcoord;      // ãã­ã¹ãã®ãã¯ã¹ãã£åº§æ¨\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n    gl_Position.xy += a_offset * u_sparam * gl_Position.w;\n    v_texcoord = a_texcoord;\n}";

var text_fs_code = "/**\n * ãã­ã¹ã (ãã©ã°ã¡ã³ãã·ã§ã¼ã)\n */\n\nprecision mediump float;\n\nvarying vec2 v_texcoord;        // ãã¯ã¹ãã£åº§æ¨\nuniform sampler2D u_image;      // ç»å\n\nvoid\nmain()\n{\n    gl_FragColor = texture2D( u_image, v_texcoord );\n}";

/**
 * @summary ãã­ã¹ããããªã¢ã«
 * @memberof mapray
 * @extends mapray.EntityMaterial
 * @private
 * @see mapray.TextEntity
 */

var TextMaterial =
/*#__PURE__*/
function (_EntityMaterial) {
  _inherits(TextMaterial, _EntityMaterial);

  /**
   * @param {mapray.GLEnv} glenv
   */
  function TextMaterial(glenv) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, TextMaterial);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextMaterial).call(this, glenv, text_vs_code, options.ridMaterial ? rid_fs_code : text_fs_code)); // ä¸å¤ãã©ã¡ã¼ã¿ãäºåè¨­å®

    _this.bindProgram();

    _this.setInteger("u_image", TextMaterial.TEXUNIT_IMAGE);

    return _this;
  }
  /**
   * @override
   */


  _createClass(TextMaterial, [{
    key: "isTranslucent",
    value: function isTranslucent(stage, primitive) {
      var props = primitive.properties; // If drawing background color, alpha is disable.

      return !props.enable_bg;
    }
    /**
     * @override
     */

  }, {
    key: "setParameters",
    value: function setParameters(stage, primitive) {
      _get(_getPrototypeOf(TextMaterial.prototype), "setParameters", this).call(this, stage, primitive);

      var props = primitive.properties; // mat4 u_obj_to_clip

      this.setObjToClip(stage, primitive); // ç»é¢ãã©ã¡ã¼ã¿: {2/w, 2/h}
      // vec2 u_sparam

      var sparam = TextMaterial._sparam;
      sparam[0] = 2 / stage._width;
      sparam[1] = 2 / stage._height;
      this.setVector2("u_sparam", sparam);

      if (stage.getRenderTarget() === RenderTarget.SCENE) {
        // ãã¯ã¹ãã£ã®ãã¤ã³ã
        // sampler2D u_image
        var image_tex = props["image"];
        this.bindTexture2D(TextMaterial.TEXUNIT_IMAGE, image_tex.handle);
      }
    }
  }]);

  return TextMaterial;
}(EntityMaterial); // ã¯ã©ã¹å®æ°ã®å®ç¾©


{
  TextMaterial.TEXUNIT_IMAGE = 0; // ç»åã®ãã¯ã¹ãã£ã¦ããã
  // è¨ç®ç¨ä¸æé å

  TextMaterial._sparam = GeoMath.createVector2f();
}

var text_vs_code$1 = "/**\n * ãã­ã¹ã (é ç¹ã·ã§ã¼ã)\n */\n\nattribute vec4 a_position;    // é ç¹ä½ç½® (ã¢ãã«åº§æ¨ç³»)\nattribute vec2 a_offset;      // é ç¹å¤ä½ (ã¹ã¯ãªã¼ã³åº§æ¨ç³»)\nattribute vec2 a_texcoord;    // ãã¯ã¹ãã£åº§æ¨\nattribute vec4 a_color;       // ãã­ã¹ãã®è²ã¨ä¸éæåº¦\n\nuniform mat4 u_obj_to_clip;   // ã¢ãã«åº§æ¨ç³»ããã¯ãªããåº§æ¨ç³»ã¸ã®å¤æ\nuniform vec2 u_sparam;        // ç»é¢ãã©ã¡ã¼ã¿: {2/w, 2/h}\n\nvarying vec2 v_texcoord;      // ãã­ã¹ãã®ãã¯ã¹ãã£åº§æ¨\nvarying vec4 v_color;         // ãã­ã¹ãã®è²ã¨ä¸éæåº¦\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n    gl_Position.xy += a_offset * u_sparam * gl_Position.w;\n    v_texcoord = a_texcoord;\n    v_color    = a_color;\n}\n";

var text_fs_code$1 = "/**\n * ãã­ã¹ã (ãã©ã°ã¡ã³ãã·ã§ã¼ã)\n */\n\nprecision mediump float;\n\nvarying vec2 v_texcoord;     // ãã­ã¹ãã®ãã¯ã¹ãã£åº§æ¨\nvarying vec4 v_color;        // ãã­ã¹ãã®è²ã¨ä¸éæåº¦\n\nuniform sampler2D u_image;   // ãã­ã¹ãç»å\n\nvoid\nmain()\n{\n    float level = texture2D( u_image, v_texcoord ).w;  // è¼åº¦\n    float alpha = v_color.w * level;\n    gl_FragColor = vec4( v_color.xyz * alpha, alpha );\n}\n";

/**
 * @summary ãã­ã¹ããããªã¢ã«
 * @memberof mapray
 * @extends mapray.EntityMaterial
 * @private
 * @see mapray.TextEntity
 */

var SimpleTextMaterial =
/*#__PURE__*/
function (_EntityMaterial) {
  _inherits(SimpleTextMaterial, _EntityMaterial);

  /**
   * @param {mapray.GLEnv} glenv
   */
  function SimpleTextMaterial(glenv) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, SimpleTextMaterial);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SimpleTextMaterial).call(this, glenv, text_vs_code$1, options.ridMaterial ? rid_fs_code : text_fs_code$1)); // ä¸å¤ãã©ã¡ã¼ã¿ãäºåè¨­å®

    _this.bindProgram();

    _this.setInteger("u_image", SimpleTextMaterial.TEXUNIT_IMAGE);

    return _this;
  }
  /**
   * @override
   */


  _createClass(SimpleTextMaterial, [{
    key: "isTranslucent",
    value: function isTranslucent(stage, primitive) {
      // ã¢ã³ãã¨ã¤ãªã¢ã¹ç¨ã®ãã¬ã³ãã®ããå¸¸ã«åéæ
      return true;
    }
    /**
     * @override
     */

  }, {
    key: "setParameters",
    value: function setParameters(stage, primitive) {
      _get(_getPrototypeOf(SimpleTextMaterial.prototype), "setParameters", this).call(this, stage, primitive);

      var props = primitive.properties; // mat4 u_obj_to_clip

      this.setObjToClip(stage, primitive); // ç»é¢ãã©ã¡ã¼ã¿: {2/w, 2/h}
      // vec2 u_sparam

      var sparam = SimpleTextMaterial._sparam;
      sparam[0] = 2 / stage._width;
      sparam[1] = 2 / stage._height;
      this.setVector2("u_sparam", sparam);

      if (stage.getRenderTarget() === RenderTarget.SCENE) {
        // ãã¯ã¹ãã£ã®ãã¤ã³ã
        // sampler2D u_image
        var image_tex = props["image"];
        this.bindTexture2D(SimpleTextMaterial.TEXUNIT_IMAGE, image_tex.handle);
      }
    }
  }]);

  return SimpleTextMaterial;
}(EntityMaterial); // ã¯ã©ã¹å®æ°ã®å®ç¾©


{
  SimpleTextMaterial.TEXUNIT_IMAGE = 0; // ç»åã®ãã¯ã¹ãã£ã¦ããã
  // è¨ç®ç¨ä¸æé å

  SimpleTextMaterial._sparam = GeoMath.createVector2f();
}

/**
 * @summary Utility Class for Color
 * @memberof mapray
 */
var Color =
/*#__PURE__*/
function () {
  /**
   * @param r {number}    The red (0.0 ~ 1.0)
   * @param g {number}    The green (0.0 ~ 1.0)
   * @param b {number}    The blue (0.0 ~ 1.0)
   * @param a {number}    The alpha (0.0 ~ 1.0)
   */
  function Color(r, g, b, a) {
    _classCallCheck(this, Color);

    this._r = r;
    this._g = g;
    this._b = b;
    this._a = a;
  }
  /**
   * @summary ä¸éæè²ãçæ
   * @param  {mapray.Vector3}
   * @return {mapray.Color}
   */


  _createClass(Color, [{
    key: "toArray",

    /**
     * @summary è²éåã«å¤æãã
     * @desc
     * <p>0ãã255ã«æ­£è¦åã [R, G, B, A]ã®é çª</p>
     *
     * @return {mapray.Vector4}      dst
     */
    value: function toArray() {
      return this._a === 0 ? [0, 0, 0, 0] : [this.floatToByte(this._r) / this._a, this.floatToByte(this._g) / this._a, this.floatToByte(this._b) / this._a, this._a];
    }
    /**
     * @summary è²éåã«å¤æãã
     * @desc
     * <p>0ãã1ã«æ­£è¦åã [R, G, B, A]ã®é çª</p>
     *
     * @return {mapray.Vector4}      dst
     */

  }, {
    key: "toVector4",
    value: function toVector4() {
      return this._a === 0 ? [0, 0, 0, 0] : [this._r / this._a, this._g / this._a, this._b / this._a, this._a];
    }
    /**
     * @summary RGBAæå­åã«å¤æãã
     * @desc
     * <p>RGBAæå­åã«å¤æãã¦æå­åãè¿å´</p>
     *
     * @return {mapray.string}
     */

  }, {
    key: "toRGBString",
    value: function toRGBString() {
      var rgba = this.toArray();
      return "rgba(".concat(Math.round(rgba[0]), ",").concat(Math.round(rgba[1]), ",").concat(Math.round(rgba[2]), ",").concat(rgba[3], ")");
    }
    /**
     * @summary 0~1.0ã®è²å¤ã255ã¾ã§ã§æ­£è¦å
     * @desc
     * <p>0ãã1ã§æ­£è¦åãããè²å¤ã255ã¾ã§ã«æ¡å¼µãã</p>
     *
     * @return {mapray.string}
     */

  }, {
    key: "floatToByte",
    value: function floatToByte(value) {
      return value === 1.0 ? 255.0 : value * 256.0 | 0;
    }
    /**
     * @summary Red
     * @type {number}
     * @readonly
     */

  }, {
    key: "r",
    get: function get() {
      return this._r;
    }
    /**
     * @summary Green
     * @type {number}
     * @readonly
     */

  }, {
    key: "g",
    get: function get() {
      return this._g;
    }
    /**
    * @summary Blue
    * @type {number}
    * @readonly
    */

  }, {
    key: "b",
    get: function get() {
      return this._b;
    }
    /**
     * @summary Alpha
     * @type {number}
     * @readonly
     */

  }, {
    key: "a",
    get: function get() {
      return this._a;
    }
  }], [{
    key: "generateOpacityColor",
    value: function generateOpacityColor(rgb) {
      return new Color(rgb[0], rgb[1], rgb[2], 1);
    }
    /**
     * @summary è²ãä»£å¥
     * @desc
     * <p>src ã dst ã«ä»£å¥ããã</p>
     * @param  {mapray.Color} src  ä»£å¥å
     * @param  {mapray.Color} dst  ä»£å¥å
     * @return {mapray.Color}      dst
     */

  }, {
    key: "copyColor",
    value: function copyColor(src, dst) {
      dst._r = src._r;
      dst._g = src._g;
      dst._b = src._b;
      dst._a = src._a;
      return dst;
    }
    /**
     * @summary ä¸éæè²ãä»£å¥
     * @desc
     * <p>src ã dst ã«ä»£å¥ããã</p>
     * @param  {mapray.Vector3} rgb  ä»£å¥å
     * @param  {mapray.Color} dst  ä»£å¥å
     * @return {mapray.Color}      dst
     */

  }, {
    key: "setOpacityColor",
    value: function setOpacityColor(rgb, dst) {
      dst._r = rgb[0];
      dst._g = rgb[1];
      dst._b = rgb[2];
      dst._a = 1;
    }
  }]);

  return Color;
}();

/**
 * @summary ç¹ã¨ã³ãã£ãã£
 *
 * @classdesc
 * <p>{@link mapray.ImageIconEntity} ã¨ {@link mapray.PinEntity}
 *    ã¨ {@link mapray.TextEntity} ã®å±éæ©è½ãæä¾ããã¯ã©ã¹ã§ããã</p>
 *
 * @memberof mapray
 * @extends mapray.Entity
 * @abstract
 * @protected
 */

var AbstractPointEntity =
/*#__PURE__*/
function (_Entity) {
  _inherits(AbstractPointEntity, _Entity);

  /**
   * @param {mapray.Scene} scene        æå±å¯è½ã·ã¼ã³
   * @param {object}       [opts]       ãªãã·ã§ã³éå
   * @param {object}       [opts.json]  çææå ±
   * @param {object}       [opts.refs]  åç§è¾æ¸
   */
  function AbstractPointEntity(scene, opts) {
    var _this;

    _classCallCheck(this, AbstractPointEntity);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AbstractPointEntity).call(this, scene, opts)); // è¦ç´ ç®¡ç

    _this._entries = [];
    return _this;
  }
  /**
   * @summary ãã¹ã¦ã®Entryã®ãã¦ã³ãã£ã³ã°ãç®åº
   *
   * @override
   * @return {mapray.GeoRegion}  ãã¦ã³ãã£ã³ã°æå ±ãæã£ãGeoRegion
   */


  _createClass(AbstractPointEntity, [{
    key: "getBounds",
    value: function getBounds() {
      var region = new GeoRegion();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var entry = _step.value;
          region.addPoint(entry._position);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return region;
    }
  }]);

  return AbstractPointEntity;
}(Entity);

/**
 * @summary ãã­ã¹ãã¨ã³ãã£ãã£
 *
 * @memberof mapray
 * @extends mapray.Entity
 */

var TextEntity =
/*#__PURE__*/
function (_AbstractPointEntity) {
  _inherits(TextEntity, _AbstractPointEntity);

  /**
   * @param {mapray.Scene} scene        æå±å¯è½ã·ã¼ã³
   * @param {object}       [opts]       ãªãã·ã§ã³éå
   * @param {object}       [opts.json]  çææå ±
   * @param {object}       [opts.refs]  åç§è¾æ¸
   */
  function TextEntity(scene, opts) {
    var _this;

    _classCallCheck(this, TextEntity);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextEntity).call(this, scene, opts)); // ãã­ã¹ãã®è¦ªãã­ããã£

    _this._text_parent_props = {
      font_style: "normal",
      font_weight: "normal",
      font_size: TextEntity.DEFAULT_FONT_SIZE,
      font_family: TextEntity.DEFAULT_FONT_FAMILY,
      color: Color.generateOpacityColor(TextEntity.DEFAULT_COLOR),
      stroke_color: Color.generateOpacityColor(TextEntity.DEFAULT_STROKE_COLOR),
      stroke_width: TextEntity.DEFAULT_STROKE_WIDTH,
      bg_color: Color.generateOpacityColor(TextEntity.DEFAULT_BG_COLOR),
      enable_stroke: false,
      enable_bg: false
    };

    _this._animation.addDescendantUnbinder(function () {
      _this._unbindDescendantAnimations();
    });

    _this._setupAnimationBindingBlock(); // çææå ±ããè¨­å®


    if (opts && opts.json) {
      _this._setupByJson(opts.json);
    }

    return _this;
  }
  /**
   * @override
   */


  _createClass(TextEntity, [{
    key: "getPrimitiveProducer",
    value: function getPrimitiveProducer() {
      return this._primitive_producer;
    }
    /**
     * @override
     */

  }, {
    key: "onChangeAltitudeMode",
    value: function onChangeAltitudeMode(prev_mode) {
      if (this._primitive_producer) {
        this._primitive_producer.onChangeAltitudeMode();
      }
    }
    /**
     * EasyBindingBlock.DescendantUnbinder å¦ç
     *
     * @private
     */

  }, {
    key: "_unbindDescendantAnimations",
    value: function _unbindDescendantAnimations() {
      // ãã¹ã¦ã®ã¨ã³ããªã¼ãè§£é¤
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var entry = _step.value;
          entry.animation.unbindAllRecursively();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * ã¢ãã¡ã¼ã·ã§ã³ã® BindingBlock ãåæå
     *
     * @private
     */

  }, {
    key: "_setupAnimationBindingBlock",
    value: function _setupAnimationBindingBlock() {
      var _this2 = this;

      var block = this.animation; // å®ä½ã¯ EasyBindingBlock

      var number = Type.find("number");
      var string = Type.find("string");
      var vector3 = Type.find("vector3"); // ãã©ã¡ã¼ã¿å: font_style
      // ãã©ã¡ã¼ã¿å: string
      //   ãã©ã³ãã¹ã¿ã¤ã«

      block.addEntry("font_style", [string], null, function (value) {
        _this2.setFontStyle(value);
      }); // ãã©ã¡ã¼ã¿å: font_weight
      // ãã©ã¡ã¼ã¿å: string
      //   ãã©ã³ãã®å¤ªã

      block.addEntry("font_weight", [string], null, function (value) {
        _this2.setFontWeight(value);
      }); // ãã©ã¡ã¼ã¿å: font_size
      // ãã©ã¡ã¼ã¿å: number
      //   ãã©ã³ãã®å¤§ãã

      block.addEntry("font_size", [number], null, function (value) {
        _this2.setFontSize(value);
      }); // ãã©ã¡ã¼ã¿å: color
      // ãã©ã¡ã¼ã¿å: vector3
      //   ãã­ã¹ãã®è²

      block.addEntry("color", [vector3], null, function (value) {
        _this2.setColor(value);
      }); // ãã©ã¡ã¼ã¿å: stroke_color
      // ãã©ã¡ã¼ã¿å: vector3
      //   ç¸ã®è²

      block.addEntry("stroke_color", [vector3], null, function (value) {
        _this2.setStrokeColor(value);
      }); // ãã©ã¡ã¼ã¿å: stroke_width
      // ãã©ã¡ã¼ã¿å: number
      //   ç¸ã®ç·å¹

      block.addEntry("stroke_width", [number], null, function (value) {
        _this2.setStrokeLineWidth(value);
      });
    }
    /**
     * @summary ãã©ã³ãã¹ã¿ã¤ã«ãè¨­å®
     * @param {string} style  ãã©ã³ãã¹ã¿ã¤ã« ("normal" | "italic" | "oblique")
     */

  }, {
    key: "setFontStyle",
    value: function setFontStyle(style) {
      this._setValueProperty("font_style", style);
    }
    /**
     * @summary ãã©ã³ãã®å¤ªããè¨­å®
     * @param {string} weight  ãã©ã³ãã®å¤ªã ("normal" | "bold")
     */

  }, {
    key: "setFontWeight",
    value: function setFontWeight(weight) {
      this._setValueProperty("font_weight", weight);
    }
    /**
     * @summary ãã©ã³ãã®å¤§ãããè¨­å®
     * @param {number} size  ãã©ã³ãã®å¤§ãã (Pixels)
     */

  }, {
    key: "setFontSize",
    value: function setFontSize(size) {
      this._setValueProperty("font_size", size);
    }
    /**
     * @summary ãã©ã³ããã¡ããªã¼ãè¨­å®
     * @param {string} family  ãã©ã³ããã¡ããªã¼
     * @see https://developer.mozilla.org/ja/docs/Web/CSS/font-family
     */

  }, {
    key: "setFontFamily",
    value: function setFontFamily(family) {
      this._setValueProperty("font_family", family);
    }
    /**
     * @summary ãã­ã¹ãã®è²ãè¨­å®
     * @param {mapray.Vector3} color  ãã­ã¹ãã®è²
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      this._setColorProperty("color", color);
    }
    /**
     * @summary ãã­ã¹ãç¸ã®è²ãè¨­å®
     * @param {mapray.Vector3} color  ç¸ã®è²
     */

  }, {
    key: "setStrokeColor",
    value: function setStrokeColor(color) {
      this._setColorProperty("stroke_color", color);
    }
    /**
     * @summary ãã­ã¹ãç¸ã®å¤ªããè¨­å®
     * @param {mapray.number} width  ç¸ã®ç·å¹
     */

  }, {
    key: "setStrokeLineWidth",
    value: function setStrokeLineWidth(width) {
      this._setValueProperty("stroke_width", width);
    }
    /**
     * @summary ãã­ã¹ãç¸ãæå¹ã«ãããã©ãã
     * @param {boolean} enable  trueãªãæå¹
     */

  }, {
    key: "setEnableStroke",
    value: function setEnableStroke(enable) {
      this._setValueProperty("enable_stroke", enable);

      this._primitive_producer = new PrimitiveProducer$2(this);
    }
    /**
     * @summary ãã­ã¹ãèæ¯ã®è²ãè¨­å®
     * @param {mapray.Vector3} color  ãã­ã¹ãã®è²
     */

  }, {
    key: "setBackgroundColor",
    value: function setBackgroundColor(color) {
      this._setColorProperty("bg_color", color);
    }
    /**
     * @summary ãã­ã¹ãèæ¯ãæå¹ã«ãããã©ãã
     * @param {boolean} enable  trueãªãæå¹
     */

  }, {
    key: "setEnableBackground",
    value: function setEnableBackground(enable) {
      this._setValueProperty("enable_bg", enable);

      this._primitive_producer = new PrimitiveProducer$2(this);
    }
    /**
     * @summary ãã­ã¹ããè¿½å 
     * @param {string}          text      ãã­ã¹ã
     * @param {mapray.GeoPoint} position  ä½ç½®
     * @param {object}          [props]   ãã­ããã£
     * @param {string}         [props.font_style]   ãã©ã³ãã¹ã¿ã¤ã« ("normal" | "italic" | "oblique")
     * @param {string}         [props.font_weight]  ãã©ã³ãã®å¤ªã   ("normal" | "bold")
     * @param {number}         [props.font_size]    ãã©ã³ãã®å¤§ãã (Pixels)
     * @param {string}         [props.font_family]  ãã©ã³ããã¡ããªã¼
     * @param {mapray.Color}   [props.color]        ãã­ã¹ãã®è²
     * @param {mapray.Color}   [props.stroke_color] ãã­ã¹ãç¸ã®è²
     * @param {number}         [props.stroke_width] ãã­ã¹ãç¸ã®å¹
     * @param {mapray.Color}   [props.bg_color]     ãã­ã¹ãèæ¯è²
     * @param {boolean}        [props.enable_stroke] ãã­ã¹ãã®ç¸åããæå¹ã«ããã
     * @param {string}         [props.id]            Entryãè­å¥ããID
     * @return {mapray.TextEntity.Entry}             è¿½å ããEntry
     */

  }, {
    key: "addText",
    value: function addText(text, position, props) {
      var entry = new Entry$2(this, text, position, props);

      this._entries.push(entry);

      this._primitive_producer = new PrimitiveProducer$2(this);

      this._primitive_producer.onAddTextEntry();

      return entry;
    }
    /**
     * @summary å°ç¨ãããªã¢ã«ãåå¾
     * @private
     */

  }, {
    key: "_getTextMaterial",
    value: function _getTextMaterial(render_target) {
      var scene = this.scene;

      if (render_target === RenderTarget.SCENE) {
        if (!scene._TextEntity_text_material) {
          // scene ã«ãããªã¢ã«ãã­ã£ãã·ã¥
          scene._TextEntity_text_material = new TextMaterial(scene.glenv);
        }

        return scene._TextEntity_text_material;
      } else if (render_target === RenderTarget.RID) {
        if (!scene._TextEntity_text_material_pick) {
          // scene ã«ãããªã¢ã«ãã­ã£ãã·ã¥
          scene._TextEntity_text_material_pick = new TextMaterial(scene.glenv, {
            ridMaterial: true
          });
        }

        return scene._TextEntity_text_material_pick;
      }
    }
    /**
     * @summary ãã­ã¹ãã ããæç»ããå°ç¨ãããªã¢ã«ãåå¾
     * @private
     */

  }, {
    key: "_getSimpleTextMaterial",
    value: function _getSimpleTextMaterial(render_target) {
      var scene = this.scene;

      if (render_target === RenderTarget.SCENE) {
        if (!scene._SimpleTextEntity_text_material) {
          // scene ã«ãããªã¢ã«ãã­ã£ãã·ã¥
          scene._SimpleTextEntity_text_material = new SimpleTextMaterial(scene.glenv);
        }

        return scene._SimpleTextEntity_text_material;
      } else if (render_target === RenderTarget.RID) {
        if (!scene._SimpleTextEntity_text_material_pick) {
          // scene ã«ãããªã¢ã«ãã­ã£ãã·ã¥
          scene._SimpleTextEntity_text_material_pick = new SimpleTextMaterial(scene.glenv, {
            ridMaterial: true
          });
        }

        return scene._SimpleTextEntity_text_material_pick;
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setValueProperty",
    value: function _setValueProperty(name, value) {
      var props = this._text_parent_props;

      if (props[name] != value) {
        props[name] = value;

        if (this._primitive_producer) {
          this._primitive_producer.onChangeParentProperty();
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setColorProperty",
    value: function _setColorProperty(name, value) {
      var dst = this._text_parent_props[name];

      if (dst.r != value[0] || dst.g != value[1] || dst.b != value[2]) {
        Color.setOpacityColor(value, dst);

        if (this._primitive_producer) {
          this._primitive_producer.onChangeParentProperty();
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setupByJson",
    value: function _setupByJson(json) {
      var position = new GeoPoint();
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = json.entries[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var entry = _step2.value;
          position.setFromArray(entry.position);
          this.addText(entry.text, position, entry);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (json.font_style !== undefined) this.setFontStyle(json.font_style);
      if (json.font_weight !== undefined) this.setFontWeight(json.font_weight);
      if (json.font_size !== undefined) this.setFontSize(json.font_size);
      if (json.font_family !== undefined) this.setFontFamily(json.font_family);
      if (json.color !== undefined) this.setColor(json.color);
      if (json.stroke_color !== undefined) this.setStrokeColor(json.stroke_color);
      if (json.stroke_width !== undefined) this.setStrokeLineWidth(json.stroke_width);
      if (json.enable_stroke !== undefined) this.setEnableStroke(json.enable_stroke);
      if (json.bg_color !== undefined) this.setBackgroundColor(json.bg_color);
      if (json.enable_bg !== undefined) this.setEnableBackground(json.enable_bg);
    }
    /**
     * @private
     */

  }, {
    key: "_enableStroke",
    value: function _enableStroke() {
      return this._text_parent_props["enable_stroke"];
    }
    /**
     * @summary IDã§Entryãåå¾
     * @param {string}  id  ID
     * @return {mapray.TextEntity.Entry}  IDãä¸è´ããEntryï¼ç¡ããã°undefinedï¼
     */

  }, {
    key: "getEntry",
    value: function getEntry(id) {
      return this._entries.find(function (entry) {
        return entry.id === id;
      });
    }
  }]);

  return TextEntity;
}(AbstractPointEntity); // ã¯ã©ã¹å®æ°ã®å®ç¾©


{
  TextEntity.DEFAULT_FONT_SIZE = 16;
  TextEntity.DEFAULT_FONT_FAMILY = "sans-serif";
  TextEntity.DEFAULT_COLOR = [1, 1, 1];
  TextEntity.DEFAULT_STROKE_COLOR = [0.0, 0.0, 0.0];
  TextEntity.DEFAULT_STROKE_WIDTH = 0.48;
  TextEntity.DEFAULT_BG_COLOR = [0.3, 0.3, 0.3];
  TextEntity.DEFAULT_TEXT_UPPER = 1.1;
  TextEntity.DEFAULT_TEXT_LOWER = 0.38;
  TextEntity.SAFETY_PIXEL_MARGIN = 1;
  TextEntity.MAX_IMAGE_WIDTH = 4096;
}
/**
 * @summary TextEntity ã® PrimitiveProducer
 *
 * TODO: relative ã§æ¨é«ã®å¤åã®ãã³ã«ãã¯ã¹ãã£ãçæããå¿è¦ã¯ãªãã®ã§
 *       Layout ã§ã®ãã¯ã¹ãã£ã®çæã¨ã¡ãã·ã¥ã®çæãåé¢ãã
 *
 * @private
 */

var PrimitiveProducer$2 =
/*#__PURE__*/
function (_Entity$PrimitiveProd) {
  _inherits(PrimitiveProducer, _Entity$PrimitiveProd);

  /**
   * @param {mapray.TextEntity} entity
   */
  function PrimitiveProducer(entity) {
    var _this3;

    _classCallCheck(this, PrimitiveProducer);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(PrimitiveProducer).call(this, entity));
    _this3._glenv = entity.scene.glenv;
    _this3._dirty = true; // ããªããã£ãã®è¦ç´ 

    _this3._transform = GeoMath.setIdentity(GeoMath.createMatrix());
    _this3._properties = {
      enable_bg: false,
      image: null // ãã­ã¹ãç»å

    }; // ããªããã£ã

    var material = null,
        pickMaterial = null;

    if (_this3._isSimpleText()) {
      material = entity._getSimpleTextMaterial(RenderTarget.SCENE);
      pickMaterial = entity._getSimpleTextMaterial(RenderTarget.RID);
    } else {
      material = entity._getTextMaterial(RenderTarget.SCENE);
      pickMaterial = entity._getTextMaterial(RenderTarget.RID);
    }

    var primitive = new Primitive(_this3._glenv, null, material, _this3._transform);
    primitive.properties = _this3._properties;
    _this3._primitive = primitive;
    var pickPrimitive = new Primitive(_this3._glenv, null, pickMaterial, _this3._transform);
    pickPrimitive.properties = _this3._properties;
    _this3._pickPrimitive = pickPrimitive; // ããªããã£ãéå

    _this3._primitives = [];
    _this3._pickPrimitives = [];
    return _this3;
  }
  /**
   * @override
   */


  _createClass(PrimitiveProducer, [{
    key: "createRegions",
    value: function createRegions() {
      var region = new EntityRegion();
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.entity._entries[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var position = _step3.value.position;
          region.addPoint(position);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return [region];
    }
    /**
     * @override
     */

  }, {
    key: "onChangeElevation",
    value: function onChangeElevation(regions) {
      this._dirty = true;
    }
    /**
     * @override
     */

  }, {
    key: "getPrimitives",
    value: function getPrimitives(stage) {
      this._updatePrimitive();

      return stage.getRenderTarget() === RenderTarget.SCENE ? this._primitives : this._pickPrimitives;
    }
    /**
     * @summary è¦ªãã­ããã£ãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeParentProperty",
    value: function onChangeParentProperty() {
      this._dirty = true;
    }
    /**
     * @summary å­ãã­ããã£ãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeChildProperty",
    value: function onChangeChildProperty() {
      this._dirty = true;
    }
    /**
     * @summary é«åº¦ã¢ã¼ããå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeAltitudeMode",
    value: function onChangeAltitudeMode() {
      this._dirty = true;
    }
    /**
     * @summary ãã­ã¹ããè¿½å ããããã¨ãéç¥
     */

  }, {
    key: "onAddTextEntry",
    value: function onAddTextEntry() {
      // å¤åããå¯è½æ§ããã
      this.needToCreateRegions();
      this._dirty = true;
    }
    /**
     * @summary ããªããã£ãã®æ´æ°
     *
     * @desc
     * å¥å:
     *   this.entity._entries
     *   this._dirty
     * åºå:
     *   this._transform
     *   this._properties.image
     *   this._primitive.mesh
     *   this._primitives
     *   this._dirty
     *
     * @return {array.<mapray.Prmitive>}  this._primitives
     *
     * @private
     */

  }, {
    key: "_updatePrimitive",
    value: function _updatePrimitive() {
      if (!this._dirty) {
        // æ´æ°ããå¿è¦ã¯ãªã
        return;
      }

      this._updateProperties();

      if (this.entity._entries.length == 0) {
        this._primitives = [];
        this._pickPrimitives = [];
        this._dirty = false;
        return;
      } // åã¨ã³ããªã¼ã® GOCS ä½ç½®ãçæ (å¹³å¦åéå)


      var gocs_array = this._createFlatGocsArray(); // ããªããã£ãã®æ´æ°
      //   primitive.transform


      this._updateTransform(gocs_array);

      var layout = new Layout(this, gocs_array);

      if (!layout.isValid()) {
        // æ´æ°ã«å¤±æ
        this._primitives = [];
        this._dirty = false;
        return this._primitives;
      } // ãã¯ã¹ãã£è¨­å®


      var properties = this._properties;

      if (properties.image) {
        properties.image.dispose();
      }

      properties.image = layout.texture; // ã¡ãã·ã¥çæ

      var vtype = [];

      if (this._isSimpleText()) {
        vtype = [{
          name: "a_position",
          size: 3
        }, {
          name: "a_offset",
          size: 2
        }, {
          name: "a_texcoord",
          size: 2
        }, {
          name: "a_color",
          size: 4
        }];
      } else {
        vtype = [{
          name: "a_position",
          size: 3
        }, {
          name: "a_offset",
          size: 2
        }, {
          name: "a_texcoord",
          size: 2
        }];
      }

      var mesh_data = {
        vtype: vtype,
        vertices: layout.vertices,
        indices: layout.indices
      };
      var mesh = new Mesh(this._glenv, mesh_data); // ã¡ãã·ã¥è¨­å®
      //   primitive.mesh

      var primitive = this._primitive;

      if (primitive.mesh) {
        primitive.mesh.dispose();
      }

      primitive.mesh = mesh;
      var pickPrimitive = this._pickPrimitive;

      if (pickPrimitive.mesh) {
        pickPrimitive.mesh.dispose();
      }

      pickPrimitive.mesh = mesh; // æ´æ°ã«æå

      this._primitives = [primitive];
      this._pickPrimitives = [pickPrimitive];
      this._dirty = false;
    }
    /**
     * @summary ãã­ããã£ãæ´æ°
     *
     * @desc
     * <pre>
     * å¥å:
     *   this.entity
     * åºå:
     *   this._properties
     * </pre>
     *
     * @private
     */

  }, {
    key: "_updateProperties",
    value: function _updateProperties() {
      var entity = this.entity;
      var props = this._properties;
      props.enable_bg = entity._text_parent_props.enable_bg;
    }
    /**
     * @summary ããªããã£ãã®æ´æ°
     *
     * @desc
     * æ¡ä»¶:
     *   this.entity._entries.length > 0
     * å¥å:
     *   this.entity._entries.length
     * åºå:
     *   this._transform
     *
     * @param {number[]} gocs_array  GOCS å¹³å¦åéå
     *
     * @private
     */

  }, {
    key: "_updateTransform",
    value: function _updateTransform(gocs_array) {
      var num_entries = this.entity._entries.length;
      var xsum = 0;
      var ysum = 0;
      var zsum = 0;

      for (var i = 0; i < num_entries; ++i) {
        var ibase = 3 * i;
        xsum += gocs_array[ibase];
        ysum += gocs_array[ibase + 1];
        zsum += gocs_array[ibase + 2];
      } // å¤æè¡åã®æ´æ°


      var transform = this._transform;
      transform[12] = xsum / num_entries;
      transform[13] = ysum / num_entries;
      transform[14] = zsum / num_entries;
    }
    /**
     * @summary GOCS å¹³å¦åéåãåå¾
     *
     * å¥å: this.entity._entries
     *
     * @return {number[]}  GOCS å¹³å¦åéå
     * @private
     */

  }, {
    key: "_createFlatGocsArray",
    value: function _createFlatGocsArray() {
      var num_points = this.entity._entries.length;
      return GeoPoint.toGocsArray(this._getFlatGeoPoints_with_Absolute(), num_points, new Float64Array(3 * num_points));
    }
    /**
     * @summary GeoPoint å¹³å¦åéåãåå¾ (çµ¶å¯¾é«åº¦)
     *
     * å¥å: this.entity._entries
     *
     * @return {number[]}  GeoPoint å¹³å¦åéå
     * @private
     */

  }, {
    key: "_getFlatGeoPoints_with_Absolute",
    value: function _getFlatGeoPoints_with_Absolute() {
      var owner = this.entity;
      var entries = owner._entries;
      var num_points = entries.length;
      var flat_array = new Float64Array(3 * num_points); // flat_array[] ã«çµåº¦è¦ç´ ã¨ç·¯åº¦è¦ç´ ãè¨­å®

      for (var i = 0; i < num_points; ++i) {
        var pos = entries[i].position;
        flat_array[3 * i] = pos.longitude;
        flat_array[3 * i + 1] = pos.latitude;
      }

      switch (owner.altitude_mode) {
        case AltitudeMode.RELATIVE:
        case AltitudeMode.CLAMP:
          // flat_array[] ã®é«åº¦è¦ç´ ã«ç¾å¨ã®æ¨é«ãè¨­å®
          owner.scene.viewer.getExistingElevations(num_points, flat_array, 0, 3, flat_array, 2, 3);

          if (owner.altitude_mode === AltitudeMode.RELATIVE) {
            // flat_array[] ã®é«åº¦è¦ç´ ã«ç¸å¯¾é«åº¦ãå ãã
            for (var _i = 0; _i < num_points; ++_i) {
              flat_array[3 * _i + 2] += entries[_i].position.altitude;
            }
          }

          break;

        default:
          // AltitudeMode.ABSOLUTE
          // flat_array[] ã®é«åº¦è¦ç´ ã«çµ¶å¯¾é«åº¦ãè¨­å®
          for (var _i2 = 0; _i2 < num_points; ++_i2) {
            flat_array[3 * _i2 + 2] = entries[_i2].position.altitude;
          }

          break;
      }

      return flat_array;
    }
    /**
    * @summary ã·ã³ãã«ãã­ã¹ãã¢ã¼ããã©ãããç¢ºèª
    *
    *
    * @return {boolean}  ã·ã³ãã«ãã­ã¹ãã¢ã¼ããªãtrue.
    * @private
    */

  }, {
    key: "_isSimpleText",
    value: function _isSimpleText() {
      var entity = this.entity;
      var enable = true; // check enable bg color or stroke;

      if (entity._text_parent_props.enable_bg || entity._text_parent_props.enable_stroke) {
        enable = false;
      } // check enable stroke


      var i = 0;

      while (enable && entity._entries.length > i) {
        var entry = entity._entries[i];
        enable = !entry.enable_stroke;
        i++;
      }

      return enable;
    }
  }]);

  return PrimitiveProducer;
}(Entity.PrimitiveProducer);
/**
 * @summary ãã­ã¹ãè¦ç´ 
 * @hideconstructor
 * @memberof mapray.TextEntity
 * @public
 */


var Entry$2 =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.TextEntity} owner                ææè
   * @param {string}            text                 ãã­ã¹ã
   * @param {mapray.GeoPoint}   position             ä½ç½®
   * @param {object}            [props]              ãã­ããã£
   * @param {string}            [props.font_style]   ãã©ã³ãã¹ã¿ã¤ã« ("normal" | "italic" | "oblique")
   * @param {string}            [props.font_weight]  ãã©ã³ãã®å¤ªã   ("normal" | "bold")
   * @param {number}            [props.font_size]    ãã©ã³ãã®å¤§ãã (Pixels)
   * @param {string}            [props.font_family]  ãã©ã³ããã¡ããªã¼
   * @param {mapray.Color}      [props.color]        ãã­ã¹ãã®è²
   * @param {mapray.Color}      [props.stroke_color] ãã­ã¹ãç¸ã®è²
   * @param {number}            [props.stroke_width] ãã­ã¹ãç¸ã®å¹
   * @param {number}            [props.enable_stroke] ãã­ã¹ãã®ç¸åããæå¹ã«ããã
   * @param {string}            [props.id]            Entryãè­å¥ããID
   */
  function Entry(owner, text, position, props) {
    _classCallCheck(this, Entry);

    this._owner = owner;
    this._text = text;
    this._position = position.clone(); // animation.BindingBlock

    this._animation = new EasyBindingBlock();

    this._setupAnimationBindingBlock();

    this._props = Object.assign({}, props); // props ã®è¤è£½

    this._copyColorProperty("color"); // deep copy


    this._copyColorProperty("stroke_color"); // deep copy


    this._copyColorProperty("bg_color"); // deep copy

  }
  /**
   * @summary ãã­ã¹ã
   * @type {string}
   * @readonly
   * @package
   */


  _createClass(Entry, [{
    key: "_setupAnimationBindingBlock",

    /**
     * ã¢ãã¡ã¼ã·ã§ã³ã® BindingBlock ãåæå
     *
     * @private
     */
    value: function _setupAnimationBindingBlock() {
      var _this4 = this;

      var block = this.animation; // å®ä½ã¯ EasyBindingBlock

      var number = Type.find("number");
      var string = Type.find("string");
      var vector3 = Type.find("vector3"); // ãã©ã¡ã¼ã¿å: position
      // ãã©ã¡ã¼ã¿å: vector3
      //   ãã¯ãã«ã®è¦ç´ ã longitude, latitude, altitude é ã§ããã¨è§£é

      var position_temp = new GeoPoint();
      block.addEntry("position", [vector3], null, function (value) {
        position_temp.setFromArray(value); // Vector3 -> GeoPoint

        _this4.setPosition(position_temp);
      }); // ãã©ã¡ã¼ã¿å: font_style
      // ãã©ã¡ã¼ã¿å: string
      //   ãã©ã³ãã¹ã¿ã¤ã«

      block.addEntry("font_style", [string], null, function (value) {
        _this4.setFontStyle(value);
      }); // ãã©ã¡ã¼ã¿å: font_weight
      // ãã©ã¡ã¼ã¿å: string
      //   ãã©ã³ãã®å¤ªã

      block.addEntry("font_weight", [string], null, function (value) {
        _this4.setFontWeight(value);
      }); // ãã©ã¡ã¼ã¿å: font_size
      // ãã©ã¡ã¼ã¿å: number
      //   ãã©ã³ãã®å¤§ãã

      block.addEntry("font_size", [number], null, function (value) {
        _this4.setFontSize(value);
      }); // ãã©ã¡ã¼ã¿å: color
      // ãã©ã¡ã¼ã¿å: vector3
      //   ãã­ã¹ãã®è²

      block.addEntry("color", [vector3], null, function (value) {
        _this4.setColor(value);
      }); // ãã©ã¡ã¼ã¿å: stroke_color
      // ãã©ã¡ã¼ã¿å: vector3
      //   ç¸ã®è²

      block.addEntry("stroke_color", [vector3], null, function (value) {
        _this4.setStrokeColor(value);
      }); // ãã©ã¡ã¼ã¿å: stroke_width
      // ãã©ã¡ã¼ã¿å: number
      //   ç¸ã®ç·å¹

      block.addEntry("stroke_width", [number], null, function (value) {
        _this4.setStrokeLineWidth(value);
      }); // ãã©ã¡ã¼ã¿å: text
      // ãã©ã¡ã¼ã¿å: string
      //   ãã­ã¹ã

      block.addEntry("text", [string], null, function (value) {
        _this4.setText(value);
      });
    }
    /**
     * @summary ãã­ã¹ãåç¹ä½ç½®ãè¨­å®
     *
     * @param {mapray.GeoPoint} position  ãã­ã¹ãåç¹ã®ä½ç½®
     */

  }, {
    key: "setPosition",
    value: function setPosition(position) {
      if (this._position.longitude !== position.longitude || this._position.latitude !== position.latitude || this._position.altitude !== position.altitude) {
        // ä½ç½®ãå¤æ´ããã
        this._position.assign(position);

        this._owner.getPrimitiveProducer().onChangeChildProperty();
      }
    }
    /**
     * @summary ãã©ã³ãã¹ã¿ã¤ã«ãè¨­å®
     * @param {string} style  ãã©ã³ãã¹ã¿ã¤ã« ("normal" | "italic" | "oblique")
     */

  }, {
    key: "setFontStyle",
    value: function setFontStyle(style) {
      this._setValueProperty("font_style", style);
    }
    /**
     * @summary ãã©ã³ãã®å¤ªããè¨­å®
     * @param {string} weight  ãã©ã³ãã®å¤ªã ("normal" | "bold")
     */

  }, {
    key: "setFontWeight",
    value: function setFontWeight(weight) {
      this._setValueProperty("font_weight", weight);
    }
    /**
     * @summary ãã©ã³ãã®å¤§ãããè¨­å®
     * @param {number} size  ãã©ã³ãã®å¤§ãã (Pixels)
     */

  }, {
    key: "setFontSize",
    value: function setFontSize(size) {
      this._setValueProperty("font_size", size);
    }
    /**
     * @summary ãã­ã¹ãã®è²ãè¨­å®
     * @param {mapray.Vector3} color  ãã­ã¹ãã®è²
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      this._setColorProperty("color", color);
    }
    /**
     * @summary ãã­ã¹ãç¸ã®è²ãè¨­å®
     * @param {mapray.Vector3} color  ç¸ã®è²
     */

  }, {
    key: "setStrokeColor",
    value: function setStrokeColor(color) {
      this._setColorProperty("stroke_color", color);
    }
    /**
     * @summary ãã­ã¹ãç¸ã®å¤ªããè¨­å®
     * @param {mapray.number} width  ç¸ã®ç·å¹
     */

  }, {
    key: "setStrokeLineWidth",
    value: function setStrokeLineWidth(width) {
      this._setValueProperty("stroke_width", width);
    }
    /**
     * @summary ãã­ã¹ãç¸ãæå¹ã«ãããã©ãã
     * @param {boolean} enable  trueãªãæå¹
     */

  }, {
    key: "setEnableStroke",
    value: function setEnableStroke(enable) {
      this._setValueProperty("enable_stroke", enable);

      this._owner._primitive_producer = new PrimitiveProducer$2(this._owner);
    }
    /**
     * @summary ãã­ã¹ããè¨­å®
     * @param {string} text  ãã­ã¹ã
     */

  }, {
    key: "setText",
    value: function setText(text) {
      if (this._text !== text) {
        this._text = text;

        this._owner.getPrimitiveProducer().onChangeChildProperty();
      }
    }
    /**
     * @private
     */

  }, {
    key: "_copyColorProperty",
    value: function _copyColorProperty(name) {
      var props = this._props;

      if (props.hasOwnProperty(name)) {
        props[name] = Color.generateOpacityColor(props[name]);
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setValueProperty",
    value: function _setValueProperty(name, value) {
      var props = this._props;

      if (props[name] != value) {
        props[name] = value;

        this._owner.getPrimitiveProducer().onChangeChildProperty();
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setColorProperty",
    value: function _setColorProperty(name, value) {
      var dst = this._props[name];

      if (dst) {
        if (dst.r != value[0] || dst.g != value[1] || dst.b != value[2]) {
          Color.setOpacityColor(value, dst);

          this._owner.getPrimitiveProducer().onChangeChildProperty();
        }
      } else {
        this._props[name] = Color.generateOpacityColor(value);

        this._owner.getPrimitiveProducer().onChangeChildProperty();
      }
    }
  }, {
    key: "text",
    get: function get() {
      return this._text;
    }
    /**
     * @summary ä½ç½®
     * @type {mapray.GeoPoint}
     * @readonly
     * @package
     */

  }, {
    key: "position",
    get: function get() {
      return this._position;
    }
    /**
     * @summary ID
     * @type {string}
     * @readonly
     */

  }, {
    key: "id",
    get: function get() {
      return this._props.hasOwnProperty("id") ? this._props.id : "";
    }
    /**
     * @summary ãã©ã³ããµã¤ãº (Pixels)
     * @type {number}
     * @readonly
     * @package
     */

  }, {
    key: "size",
    get: function get() {
      var props = this._props;
      var parent = this._owner._text_parent_props;
      return props.font_size || parent.font_size;
    }
    /**
     * @summary ãã­ã¹ãã®è²
     * @type {mapray.Vector3}
     * @readonly
     * @package
     */

  }, {
    key: "color",
    get: function get() {
      var props = this._props;
      var parent = this._owner._text_parent_props;
      return props.color || parent.color;
    }
    /**
     * @summary ãã©ã³ã
     * @type {string}
     * @readonly
     * @package
     * @see https://developer.mozilla.org/ja/docs/Web/CSS/font
     */

  }, {
    key: "font",
    get: function get() {
      var props = this._props;
      var parent = this._owner._text_parent_props;
      var style = props.font_style || parent.font_style;
      var variant = "normal";
      var weight = props.font_weight || parent.font_weight;
      var family = props.font_family || parent.font_family;
      return style + " " + variant + " " + weight + " " + this.size + "px " + family;
    }
    /**
     * @summary ãã­ã¹ãç¸ã®è²
     * @type {mapray.Color}
     * @readonly
     * @package
     */

  }, {
    key: "stroke_color",
    get: function get() {
      var props = this._props;
      var parent = this._owner._text_parent_props;
      return props.stroke_color || parent.stroke_color;
    }
    /**
     * @summary ç¸ã®å¹ (Pixels)
     * @type {number}
     * @readonly
     * @package
     */

  }, {
    key: "stroke_width",
    get: function get() {
      var props = this._props;
      var parent = this._owner._text_parent_props;
      return props.stroke_width || parent.stroke_width;
    }
    /**
     * @summary ç¸ãæç»ããã
     * @type {boolean}
     * @readonly
     * @package
     */

  }, {
    key: "enable_stroke",
    get: function get() {
      var props = this._props;
      var parent = this._owner._text_parent_props;
      return props.enable_stroke || parent.enable_stroke;
    }
    /**
     * @summary èæ¯è²
     * @type {mapray.Color}
     * @readonly
     * @package
     */

  }, {
    key: "bg_color",
    get: function get() {
      var props = this._props;
      var parent = this._owner._text_parent_props;
      return props.bg_color || parent.bg_color;
    }
    /**
     * @summary èæ¯æç»ããã
     * @type {boolean}
     * @readonly
     * @package
     */

  }, {
    key: "enable_background",
    get: function get() {
      // Enable or Disable background can be set by parent.
      var parent = this._owner._text_parent_props;
      return parent.enable_bg;
    }
    /**
     * @summary ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿è¨­å®
     *
     * @type {mapray.animation.BindingBlock}
     * @readonly
     */

  }, {
    key: "animation",
    get: function get() {
      return this._animation;
    }
  }]);

  return Entry;
}();

TextEntity.Entry = Entry$2;
/**
 * @summary ãã­ã¹ãç»åã Canvas ä¸ã«ã¬ã¤ã¢ã¦ã
 *
 * @memberof mapray.TextEntity
 * @private
 */

var Layout =
/*#__PURE__*/
function () {
  /**
   * @desc
   * å¥å:
   *   owner._glenv
   *   owner.entity._entries
   *   owner._transform
   *
   * @param {PrimitiveProducer} owner       ææè
   * @param {number[]}          gocs_array  GOCS å¹³å¦åéå
   */
  function Layout(owner, gocs_array) {
    _classCallCheck(this, Layout);

    this._owner = owner;
    this._items = this._createItemList();
    this._is_valid = true;

    var row_layouts = this._createRowLayouts();

    if (row_layouts.length == 0) {
      // æå¹ãªãã­ã¹ãã1ã¤ãç¡ã
      this._is_valid = false;
      return;
    } // ã¢ã¤ãã ã®éç½®ã®è¨­å®ã¨ã­ã£ã³ãã¹ãµã¤ãºã®æ±ºå®


    var size = this._setupLocation(row_layouts);

    if (this._isSimpleTextWithAllItems(this._items)) {
      this._texture = this._createTextureForSimple(size.width, size.height);
      this._vertices = this._createVerticesForSimple(size.width, size.height, gocs_array);
    } else {
      this._texture = this._createTexture(size.width, size.height);
      this._vertices = this._createVertices(size.width, size.height, gocs_array);
    }

    this._indices = this._createIndices();
  }
  /**
   * @summary æå¹ãªãªãã¸ã§ã¯ããï¼
   * @desc
   * <p>ç¡å¹ã®ã¨ããä»ã®ã¡ã½ããã¯å¼ã³åºããªãã</p>
   * @return {boolean}  æå¹ã®ã¨ã true, ç¡å¹ã®ã¨ã false
   */


  _createClass(Layout, [{
    key: "isValid",
    value: function isValid() {
      return this._is_valid;
    }
    /**
     * @summary ãã¯ã¹ãã£
     * @type {mapray.Texture}
     * @readonly
     */

  }, {
    key: "_createItemList",

    /**
     * @summary ã¬ã¤ã¢ã¦ãã¢ã¤ãã ã®ãªã¹ããçæ
     * @return {array.<mapray.TextEntity.LItem>}
     * @private
     */
    value: function _createItemList() {
      var context = Dom.createCanvasContext(1, 1);
      var items = [];
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._owner.entity._entries[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var entry = _step4.value;
          items.push(new LItem(this, entry, context));
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return items;
    }
    /**
     * @summary RowLayout ã®ãªã¹ããçæ
     * @return {array.<mapray.TextEntity.RowLayout>}
     * @private
     */

  }, {
    key: "_createRowLayouts",
    value: function _createRowLayouts() {
      // ã¢ã¤ãã ãªã¹ãã®è¤è£½
      var items = [].concat(this._items); // RowLayout åã§ãã¾ãé«ãã«å·®ãåºãªãããã«ãã¢ã¤ãã ãªã¹ããé«ãã§æ´å

      items.sort(function (a, b) {
        return a.height_pixel - b.height_pixel;
      }); // ãªã¹ããçæ

      var row_layouts = [];

      while (items.length > 0) {
        var row_layout = new RowLayout(items);

        if (row_layout.isValid()) {
          row_layouts.push(row_layout);
        }
      }

      return row_layouts;
    }
    /**
     * @summary ãã¯ã¹ãã£ãçæ
     * @param  {number} width    æ¨ªå¹
     * @param  {number} height   é«ã
     * @return {mapray.Texture}  ãã­ã¹ããã¯ã¹ãã£
     * @private
     */

  }, {
    key: "_createTexture",
    value: function _createTexture(width, height) {
      var context = Dom.createCanvasContext(width, height);
      context.textAlign = "left";
      context.textBaseline = "alphabetic";
      context.fillStyle = "rgba( 255, 255, 255, 1.0 )";
      var items = this._items;

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        if (item.is_canceled) continue;

        if (item._entry.enable_background) {
          item.drawRect(context);
        }

        if (item._entry.enable_stroke) {
          item.drawStrokeText(context);
        }

        item.drawText(context);
      }

      var glenv = this._owner._glenv;
      var opts = {
        usage: Texture.Usage.TEXT
      };
      return new Texture(glenv, context.canvas, opts);
    }
    /**
     * @summary é ç¹éåãçæ
     *
     * @param  {number}   width       æ¨ªå¹
     * @param  {number}   height      é«ã
     * @param  {number[]} gocs_array  GOCS å¹³å¦åéå
     * @return {array.<number>}  é ç¹éå [å·¦ä¸0, å³ä¸0, å·¦ä¸0, å³ä¸0, ...]
     *
     * @private
     */

  }, {
    key: "_createVertices",
    value: function _createVertices(width, height, gocs_array) {
      var vertices = []; // ãã­ã¹ãéåã®åç¹ (GOCS)

      var transform = this._owner._transform;
      var xo = transform[12];
      var yo = transform[13];
      var zo = transform[14];
      var items = this._items;

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        if (item.is_canceled) continue; // ãã­ã¹ãã®ä½ç½® (ã¢ãã«åº§æ¨ç³»)

        var ibase = 3 * i;
        var xm = gocs_array[ibase] - xo;
        var ym = gocs_array[ibase + 1] - yo;
        var zm = gocs_array[ibase + 2] - zo; // ãã¼ã¹ã©ã¤ã³å·¦ç«¯ (ã­ã£ã³ãã¹åº§æ¨ç³»)

        var xc = item.pos_x;
        var yc = item.pos_y;
        var upper = item.upper;
        var lower = item.lower;
        var xsize = item.width;
        var xn = 1 / width;
        var yn = 1 / height; // å·¦ä¸

        vertices.push(xm, ym, zm); // a_position

        vertices.push(-xsize / 2, -lower); // a_offset

        vertices.push(xc * xn, 1 - (yc + lower) * yn); // a_texcoord
        // å³ä¸

        vertices.push(xm, ym, zm); // a_position

        vertices.push(xsize / 2, -lower); // a_offset

        vertices.push((xc + xsize) * xn, 1 - (yc + lower) * yn); // a_texcoord
        // å·¦ä¸

        vertices.push(xm, ym, zm); // a_position

        vertices.push(-xsize / 2, upper); // a_offset

        vertices.push(xc * xn, 1 - (yc - upper) * yn); // a_texcoord
        // å³ä¸

        vertices.push(xm, ym, zm); // a_position

        vertices.push(xsize / 2, upper); // a_offset

        vertices.push((xc + xsize) * xn, 1 - (yc - upper) * yn); // a_texcoord
      }

      return vertices;
    }
    /**
     * @summary åç´ãã­ã¹ãç¨ãã¯ã¹ãã£ãçæ
     * @param  {number} width    æ¨ªå¹
     * @param  {number} height   é«ã
     * @return {mapray.Texture}  ãã­ã¹ããã¯ã¹ãã£
     * @private
     */

  }, {
    key: "_createTextureForSimple",
    value: function _createTextureForSimple(width, height) {
      var context = Dom.createCanvasContext(width, height);
      context.textAlign = "left";
      context.textBaseline = "alphabetic";
      context.fillStyle = "rgba( 255, 255, 255, 1.0 )";
      var items = this._items;

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        if (item.is_canceled) continue;
        item.drawText(context);
      }

      var glenv = this._owner._glenv;
      var opts = {
        usage: Texture.Usage.SIMPLETEXT
      };
      return new Texture(glenv, context.canvas, opts);
    }
    /**
     * @summary åç´ãã­ã¹ãç¨é ç¹éåãçæ
     *
     * @param  {number}   width       æ¨ªå¹
     * @param  {number}   height      é«ã
     * @param  {number[]} gocs_array  GOCS å¹³å¦åéå
     * @return {array.<number>}  é ç¹éå [å·¦ä¸0, å³ä¸0, å·¦ä¸0, å³ä¸0, ...]
     *
     * @private
     */

  }, {
    key: "_createVerticesForSimple",
    value: function _createVerticesForSimple(width, height, gocs_array) {
      var vertices = []; // ãã­ã¹ãéåã®åç¹ (GOCS)

      var transform = this._owner._transform;
      var xo = transform[12];
      var yo = transform[13];
      var zo = transform[14];
      var items = this._items;

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        if (item.is_canceled) continue;
        var entry = item.entry; // ãã­ã¹ãã®è²

        var color = entry.color.toVector4(); // ãã­ã¹ãã®ä½ç½® (ã¢ãã«åº§æ¨ç³»)

        var ibase = 3 * i;
        var xm = gocs_array[ibase] - xo;
        var ym = gocs_array[ibase + 1] - yo;
        var zm = gocs_array[ibase + 2] - zo; // ãã¼ã¹ã©ã¤ã³å·¦ç«¯ (ã­ã£ã³ãã¹åº§æ¨ç³»)

        var xc = item.pos_x;
        var yc = item.pos_y;
        var upper = item.upper;
        var lower = item.lower;
        var xsize = item.width;
        var xn = 1 / width;
        var yn = 1 / height; // å·¦ä¸

        vertices.push(xm, ym, zm); // a_position

        vertices.push(-xsize / 2, -lower); // a_offset

        vertices.push(xc * xn, 1 - (yc + lower) * yn); // a_texcoord

        vertices.push(color[0], color[1], color[2], 1); // a_color
        // å³ä¸

        vertices.push(xm, ym, zm); // a_position

        vertices.push(xsize / 2, -lower); // a_offset

        vertices.push((xc + xsize) * xn, 1 - (yc + lower) * yn); // a_texcoord

        vertices.push(color[0], color[1], color[2], 1); // a_color
        // å·¦ä¸

        vertices.push(xm, ym, zm); // a_position

        vertices.push(-xsize / 2, upper); // a_offset

        vertices.push(xc * xn, 1 - (yc - upper) * yn); // a_texcoord

        vertices.push(color[0], color[1], color[2], 1); // a_color
        // å³ä¸

        vertices.push(xm, ym, zm); // a_position

        vertices.push(xsize / 2, upper); // a_offset

        vertices.push((xc + xsize) * xn, 1 - (yc - upper) * yn); // a_texcoord

        vertices.push(color[0], color[1], color[2], 1); // a_color
      }

      return vertices;
    }
    /**
     * @summary ã¤ã³ããã¯ã¹éåãçæ
     * @return {array.<number>}  ã¤ã³ããã¯ã¹éå []
     * @private
     */

  }, {
    key: "_createIndices",
    value: function _createIndices() {
      var indices = [];
      var items = this._items;

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        if (item.is_canceled) continue;
        var b = 4 * i;
        indices.push(b, b + 1, b + 2, b + 2, b + 1, b + 3);
      }

      return indices;
    }
    /**
     * @summary ã¢ã¤ãã ã®éç½®ãè¨­å®
     * @param  {array.<mapray.TextEntity.RowLayout>} row_layouts
     * @return {object}                              ã­ã£ã³ãã¹ãµã¤ãº
     * @private
     */

  }, {
    key: "_setupLocation",
    value: function _setupLocation(row_layouts) {
      var width = 0;
      var height = 0;
      height += TextEntity.SAFETY_PIXEL_MARGIN;

      for (var i = 0; i < row_layouts.length; ++i) {
        var row_layout = row_layouts[i];
        row_layout.locate(height);
        width = Math.max(row_layout.width_assumed, width);
        height += row_layout.height_pixel + TextEntity.SAFETY_PIXEL_MARGIN;
      }

      return {
        width: width,
        height: height
      };
    }
    /**
     * @summary ã·ã³ãã«ãã­ã¹ãã¢ã¼ããã©ãã
     * @param  {mapray.TextEntity.LItem} item
     * @return {boolean}                 ã·ã³ãã«ãã­ã¹ãã¢ã¼ããªãtrue
     * @private
     */

  }, {
    key: "_isSimpleText",
    value: function _isSimpleText(item) {
      if (item._entry.enable_background || item._entry.enable_stroke) {
        return false;
      }

      return true;
    }
    /**
     * @summary ã·ã³ãã«ãã­ã¹ãã¢ã¼ããã©ãã
     * @param  {array.<mapray.TextEntity.LItem>} items
     * @return {boolean}                 ã·ã³ãã«ãã­ã¹ãã¢ã¼ããªãtrue
     * @private
     */

  }, {
    key: "_isSimpleTextWithAllItems",
    value: function _isSimpleTextWithAllItems(items) {
      var enable = true;
      var i = 0;

      while (enable && items.length > i) {
        var item = items[i];
        enable = this._isSimpleText(item);
        i++;
      }

      return enable;
    }
  }, {
    key: "texture",
    get: function get() {
      return this._texture;
    }
    /**
     * @summary é ç¹éå
     * @desc
     * æ¡ä»¶:
     *   this._entries.length > 0
     * å¥å:
     *   this._entries
     *   this._transform
     * @type {Float32Array}
     * @readonly
     */

  }, {
    key: "vertices",
    get: function get() {
      return this._vertices;
    }
    /**
     * @summary ã¤ã³ããã¯ã¹éå
     * @type {Uint32Array}
     * @readonly
     */

  }, {
    key: "indices",
    get: function get() {
      return this._indices;
    }
  }]);

  return Layout;
}();
/**
 * @summary ã¬ã¤ã¢ã¦ãå¯¾è±¡
 * @memberof mapray.TextEntity
 * @private
 */


var LItem =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.TextEntity.Layout} layout   ææè
   * @param {mapray.TextEntity.Entry}  entry    TextEntity ã¨ã³ããª
   * @param {CanvasRenderingContext2D} context  æ¸¬å®ç¨ã³ã³ãã­ã¹ã
   */
  function LItem(layout, entry, context) {
    _classCallCheck(this, LItem);

    this._entry = entry; // ãã­ã¹ãã®åºç¹

    this._pos_x = 0; // å·¦ç«¯

    this._pos_y = 0; // ãã¼ã¹ã©ã¤ã³ä½ç½®
    // ãã­ã¹ãã®æ¨ªå¹

    context.font = entry.font;
    this._width = context.measureText(entry.text).width; // ãã­ã¹ãã®ä¸ä¸ç¯å²

    this._upper = entry.size * TextEntity.DEFAULT_TEXT_UPPER;
    this._lower = entry.size * TextEntity.DEFAULT_TEXT_LOWER;
    this._is_canceled = false;
  }
  /**
   * @type {mapray.TextEntity.Entry}
   * @readonly
   */


  _createClass(LItem, [{
    key: "cancel",

    /**
     * @summary åãæ¶ãç¶æã«ç§»è¡
     */
    value: function cancel() {
      this._is_canceled = true;
    }
    /**
     * @summary éç½®ãæ±ºå®
     * @param {number} x  ãã­ã¹ãç©å½¢å·¦è¾ºã® X åº§æ¨ (ã­ã£ã³ãã¹åº§æ¨ç³»)
     * @param {number} y  ãã­ã¹ãç©å½¢ä¸è¾ºã® Y åº§æ¨ (ã­ã£ã³ãã¹åº§æ¨ç³»)
     */

  }, {
    key: "locate",
    value: function locate(x, y) {
      this._pos_x = x;
      this._pos_y = y + Math.ceil(this._upper);
    }
    /**
     * @summary ãã­ã¹ãã ããæç» (stokeãfillRectã¨ã¯çµã¿åããä¸å¯)
     * @desc
     * <p>context ã¯ä»¥ä¸ã®ããã«è¨­å®ãã¦ãããã¨ã</p>
     * <pre>
     *   context.textAlign    = "left";
     *   context.textBaseline = "alphabetic";
     *   context.fillStyle    = "rgba( 255, 255, 255, 1.0 )";
     * </pre>
     * @param {CanvasRenderingContext2D} context  æç»åã³ã³ãã­ã¹ã
     */

  }, {
    key: "drawTextOnly",
    value: function drawTextOnly(context) {
      var entry = this._entry;
      context.font = entry.font;
      context.fillText(entry.text, this._pos_x, this._pos_y);
    }
    /**
     * @summary ãã­ã¹ããæç»
     * @desc
     * <p>context ã¯ä»¥ä¸ã®ããã«è¨­å®ãã¦ãããã¨ã</p>
     * <pre>
     *   context.textAlign    = "left";
     *   context.textBaseline = "alphabetic";
     *   context.fillStyle    = "rgba( 255, 255, 255, 1.0 )";
     * </pre>
     * @param {CanvasRenderingContext2D} context  æç»åã³ã³ãã­ã¹ã
     */

  }, {
    key: "drawText",
    value: function drawText(context) {
      var entry = this._entry;
      context.font = entry.font;
      context.fillStyle = entry.color.toRGBString();
      context.fillText(entry.text, this._pos_x, this._pos_y);
    }
    /**
     * @summary ãã­ã¹ãã®æ·µãæç»
     * @desc
     * <p>drawTextOnlyã¨ã¯çµã¿åããä¸å¯</p>
      * @param {CanvasRenderingContext2D} context  æç»åã³ã³ãã­ã¹ã
     */

  }, {
    key: "drawStrokeText",
    value: function drawStrokeText(context) {
      /*
       context.fillText()
           .------------.   
           |',',',',',',|   
           |',',',',',',|   
           |',',',',',',|   
           |',',',',',',|   
           |',',',',',',|   
        context.strokeText()
       .--------------------.
       |',',',',',',',',',',|
       |','.------------.,',|
       |','|',',',',',',|,',|
       |','|','.----.,',|,',|
       |','|','|    |,',|,',|
       |','|','|    |,',|,',|
       |<--|-->|
         a   b
       b will be overwrite by fillText();
      */
      var entry = this._entry;
      context.font = entry.font;
      context.strokeStyle = entry.stroke_color.toRGBString();
      context.lineWidth = entry.stroke_width * 2;
      context.lineJoin = "round";
      context.strokeText(entry.text, this._pos_x, this._pos_y);
    }
    /**
     * @summary ãã­ã¹ãã®èæ¯ãæç»
     * @desc
     * <p>drawTextOnlyã¨ã¯çµã¿åããä¸å¯</p>
      * @param {CanvasRenderingContext2D} context  æç»åã³ã³ãã­ã¹ã
     */

  }, {
    key: "drawRect",
    value: function drawRect(context) {
      var entry = this._entry;
      context.fillStyle = entry.bg_color.toRGBString();
      context.fillRect(this._pos_x - TextEntity.SAFETY_PIXEL_MARGIN, this._pos_y - this._upper - TextEntity.SAFETY_PIXEL_MARGIN, this.width_pixel + TextEntity.SAFETY_PIXEL_MARGIN, this.height_pixel + TextEntity.SAFETY_PIXEL_MARGIN);
    }
  }, {
    key: "entry",
    get: function get() {
      return this._entry;
    }
    /**
     * @type {number}
     * @readonly
     */

  }, {
    key: "pos_x",
    get: function get() {
      return this._pos_x;
    }
    /**
     * @type {number}
     * @readonly
     */

  }, {
    key: "pos_y",
    get: function get() {
      return this._pos_y;
    }
    /**
     * @type {number}
     * @readonly
     */

  }, {
    key: "width",
    get: function get() {
      return this._width;
    }
    /**
     * @type {number}
     * @readonly
     */

  }, {
    key: "upper",
    get: function get() {
      return this._upper;
    }
    /**
     * @type {number}
     * @readonly
     */

  }, {
    key: "lower",
    get: function get() {
      return this._lower;
    }
    /**
     * ã­ã£ã³ãã¹ä¸ã§ã®ãã­ã¹ãã®æ¨ªç»ç´ æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "width_pixel",
    get: function get() {
      return Math.ceil(this._width);
    }
    /**
     * ã­ã£ã³ãã¹ä¸ã§ã®ãã­ã¹ãã®ç¸¦ç»ç´ æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "height_pixel",
    get: function get() {
      return Math.ceil(this._upper) + Math.ceil(this._lower);
    }
    /**
     * åãæ¶ãç¶æãï¼
     * @type {boolean}
     * @readonly
     */

  }, {
    key: "is_canceled",
    get: function get() {
      return this._is_canceled;
    }
  }]);

  return LItem;
}();
/**
 * @summary æ°´å¹³ã¬ã¤ã¢ã¦ã
 * @memberof mapray.TextEntity
 * @private
 */


var RowLayout =
/*#__PURE__*/
function () {
  /**
   * @desc
   * <p>ã¬ã¤ã¢ã¦ãããããã¾ãã¯ã¬ã¤ã¢ã¦ãã«å¤±æããã¢ã¤ãã ã¯ src_items ããåé¤ãããã</p>
   * <p>ã¬ã¤ã¢ã¦ãã«å¤±æããã¢ã¤ãã ã¯åãæ¶ã (is_canceled) ã«ãªãã</p>
   * @param {array.<mapray.TextEntity.LItem>} src_items  ã¢ã¤ãã ãªã¹ã
   */
  function RowLayout(src_items) {
    _classCallCheck(this, RowLayout);

    var width_assumed_total = 0;
    var height_pixel_max = 0;
    var row_items = [];
    width_assumed_total += TextEntity.SAFETY_PIXEL_MARGIN; // å·¦ãã¼ã¸ã³

    while (src_items.length > 0) {
      var item = src_items.shift();
      var width_assumed = item.width_pixel + TextEntity.SAFETY_PIXEL_MARGIN; // ãã­ã¹ãå¹ + å³ãã¼ã¸ã³

      if (width_assumed_total + width_assumed <= TextEntity.MAX_IMAGE_WIDTH) {
        // è¡ã«ã¢ã¤ãã ãè¿½å 
        row_items.push(item);
        width_assumed_total += width_assumed;
        height_pixel_max = Math.max(item.height_pixel, height_pixel_max);
      } else {
        if (row_items.length == 0) {
          // ãã­ã¹ããé·ããã¦è¡¨ç¤ºã§ããªã
          item.cancel();
        } else {
          // æ¬¡ã®è¡ã«ãªãããå·®ãæ»ãã¦çµäº
          src_items.unshift(item);
          break;
        }
      }
    }

    this._items = row_items;
    this._width_assumed = width_assumed_total;
    this._height_pixel = height_pixel_max;
  }
  /**
   * @summary æå¹ãªãªãã¸ã§ã¯ããï¼
   * @desc
   * <p>ç¡å¹ã®ã¨ããä»ã®ã¡ã½ããã¯å¼ã³åºããªãã</p>
   * @return {boolean}  æå¹ã®ã¨ã true, ç¡å¹ã®ã¨ã false
   */


  _createClass(RowLayout, [{
    key: "isValid",
    value: function isValid() {
      return this._items.length > 0;
    }
    /**
     * 
     * @type {array.<mapray.TextEntity.LItem>}
     * @readonly
     */

  }, {
    key: "locate",

    /**
     * @summary ã¬ã¤ã¢ã¦ãã®éç½®ãæ±ºå®
     * @param {number} y  ãã­ã¹ãç©å½¢ä¸è¾ºã® Y åº§æ¨ (ã­ã£ã³ãã¹åº§æ¨ç³»)
     */
    value: function locate(y) {
      var items = this._items;
      var x = 0;
      x += TextEntity.SAFETY_PIXEL_MARGIN; // å·¦ãã¼ã¸ã³

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        item.locate(x, y);
        x += item.width_pixel + TextEntity.SAFETY_PIXEL_MARGIN; // ãã­ã¹ãå¹ + å³ãã¼ã¸ã³
      }
    }
  }, {
    key: "items",
    get: function get() {
      return this._items;
    }
    /**
     * ã­ã£ã³ãã¹ä¸ã§ã®è¡ã®æ¨ªå æç»ç´ æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "width_assumed",
    get: function get() {
      return this._width_assumed;
    }
    /**
     * ã­ã£ã³ãã¹ä¸ã§ã®è¡ã®ç¸¦ç»ç´ æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "height_pixel",
    get: function get() {
      return this._height_pixel;
    }
  }]);

  return RowLayout;
}();

/**
 * @summary ã¢ãã«ã¨ã³ãã£ãã£
 * @memberof mapray
 * @extends mapray.Entity
 */

var ModelEntity =
/*#__PURE__*/
function (_Entity) {
  _inherits(ModelEntity, _Entity);

  /**
   * @param {mapray.Scene} scene        æå±å¯è½ã·ã¼ã³
   * @param {object}       [opts]       ãªãã·ã§ã³éå
   * @param {object}       [opts.json]  çææå ±
   * @param {object}       [opts.refs]  åç§è¾æ¸
   *
   * @throws Error  ModelContainer ããã¢ãã«ãè¦ã¤ãããªãã£ã
   */
  function ModelEntity(scene, opts) {
    var _this;

    _classCallCheck(this, ModelEntity);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ModelEntity).call(this, scene, opts));
    _this._position = new GeoPoint(0, 0, 0);
    _this._matrix = GeoMath.setIdentity(GeoMath.createMatrix());
    _this._scale = GeoMath.createVector3([1, 1, 1]);
    _this._primitive_producer = new PrimitiveProducer$3(_assertThisInitialized(_this));

    _this._setupAnimationBindingBlock(); // ã¢ã³ã«ã¼ã¢ã¼ã


    _this._anchor_mode = false;
    _this._transform_mode = TransformMode.POSITION_MLOCS_SCALE_ORIENTATION;

    if (opts && opts.json) {
      var json = opts.json;
      var refs = opts.refs || {};

      _this._setupTransform(json);

      _this._setupModelObject(json, refs);
    }

    return _this;
  }
  /**
   * @override
   * @private
   */


  _createClass(ModelEntity, [{
    key: "setAnchorMode",

    /**
     * @summary ã¢ã³ã«ã¼ã¢ã¼ããè¨­å®ã
     * @see {@link mapray.Entity#anchor_mode}
     * @param {boolean} anchor_mode
     * @private
     */
    value: function setAnchorMode(anchor_mode) {
      this._anchor_mode = anchor_mode;
    }
    /**
     * @private
     */

  }, {
    key: "setTransformMode",

    /**
     * @private
     */
    value: function setTransformMode(transform_mode) {
      if (this._transform_mode !== transform_mode) {
        if (this._transform_mode === TransformMode.POSITION_MLOCS_SCALE_ORIENTATION) {
          if (transform_mode === TransformMode.GOCS_MATRIX) {
            // POSITION_MLOCS_SCALE_ORIENTATION => GOCS_MATRIX
            this._primitive_producer.getMatrix(this._matrix);
          }
        } else {
          if (transform_mode === TransformMode.POSITION_MLOCS_SCALE_ORIENTATION) {
            // GOCS_MATRIX => POSITION_MLOCS_SCALE_ORIENTATION
            var gPos = GeoMath.createVector3([this._matrix[12], this._matrix[13], this._matrix[14]]);

            this._position.setFromGocs(gPos);

            var mat = this._position.getMlocsToGocsMatrix(GeoMath.createMatrix());

            GeoMath.inverse_A(mat, mat);
            GeoMath.mul_AA(mat, this._matrix, mat); // restore scale from mat

            for (var j = 0; j < 3; ++j) {
              var tmp = 0;

              for (var i = 0; i < 3; ++i) {
                var v = mat[j * 4 + i];
                tmp += v * v;
              }

              if (tmp < 1.0 || 1.0 < tmp) {
                tmp = Math.sqrt(tmp);

                for (var _i = 0; _i < 3; ++_i) {
                  mat[j * 4 + _i] /= tmp;
                }

                this._scale[j] = tmp;
              }
            }

            GeoMath.copyMatrix(mat, this._matrix);
          }
        }

        this._transform_mode = transform_mode;

        this._primitive_producer.onChangePosition();
      }
    }
    /**
     * @override
     */

  }, {
    key: "getPrimitiveProducer",
    value: function getPrimitiveProducer() {
      return this._primitive_producer;
    }
    /**
     * @override
     */

  }, {
    key: "onChangeAltitudeMode",
    value: function onChangeAltitudeMode(prev_mode) {
      this._primitive_producer.onChangeAltitudeMode();
    }
    /**
     * @summary bboxãå©ç¨ãã¦ç°¡æçã«ãã¦ã³ãã£ã³ã°ãç®åº
     *
     * @override
     * @return {mapray.GeoRegion}  ãã¦ã³ãã£ã³ã°æå ±ãæã£ãGeoRegion
     */

  }, {
    key: "getBounds",
    value: function getBounds() {
      var bounds = this._primitive_producer.getBounds();

      var region = new GeoRegion();
      region.addPointsAsArray(bounds);
      return region;
    }
    /**
     * ã¢ãã¡ã¼ã·ã§ã³ã® BindingBlock ãåæå
     *
     * @private
     */

  }, {
    key: "_setupAnimationBindingBlock",
    value: function _setupAnimationBindingBlock() {
      var _this2 = this;

      var block = this.animation; // å®ä½ã¯ EasyBindingBlock

      var number = Type.find("number");
      var vector3 = Type.find("vector3");
      var matrix = Type.find("matrix"); // ãã©ã¡ã¼ã¿å: position
      // ãã©ã¡ã¼ã¿å: vector3
      //   ãã¯ãã«ã®è¦ç´ ã longitude, latitude, altitude é ã§ããã¨è§£é

      var position_temp = new GeoPoint();
      block.addEntry("position", [vector3], null, function (value) {
        position_temp.setFromArray(value); // Vector3 -> GeoPoint

        _this2.setPosition(position_temp);
      }); // ãã©ã¡ã¼ã¿å: orientation
      // ãã©ã¡ã¼ã¿å: matrix | vector3
      //   åã matrix ã®ã¨ã MLOCS ã§ã®åè»¢è¡å
      //   åã vector3 ã®ã¨ããè¦ç´ ã heading, tilt, roll é ã§ããã¨è§£é

      var orientation_temp = new Orientation();
      var orientation_type;

      var orientation_tsolver = function orientation_tsolver(curve) {
        orientation_type = AnimUtil.findFirstTypeSupported(curve, [matrix, vector3]);
        return orientation_type;
      };

      block.addEntry("orientation", [matrix, vector3], orientation_tsolver, function (value) {
        if (orientation_type === matrix) {
          _this2._setRotation(value);
        } else {
          // orientation_type === vector3
          orientation_temp.heading = value[0];
          orientation_temp.tilt = value[1];
          orientation_temp.roll = value[2];

          _this2.setOrientation(orientation_temp);
        }
      }); // ãã©ã¡ã¼ã¿å: scale
      // ãã©ã¡ã¼ã¿å: vector3 | number
      //   åã vector3 ã®ã¨ãã¯ XYZ å¥ã®åç
      //   åã number ã®ã¨ãã¯åç­åç

      var scale_temp = GeoMath.createVector3();
      var scale_type;

      var scale_tsolver = function scale_tsolver(curve) {
        scale_type = AnimUtil.findFirstTypeSupported(curve, [vector3, number]);
        return scale_type;
      };

      block.addEntry("scale", [vector3, number], scale_tsolver, function (value) {
        if (scale_type === vector3) {
          _this2.setScale(value);
        } else {
          // scale_type === number
          scale_temp[0] = value;
          scale_temp[1] = value;
          scale_temp[2] = value;

          _this2.setScale(scale_temp);
        }
      });
    }
    /**
     * @summary position, orientation, scale ãè¨­å®
     *
     * @param {object} json  çææå ±
     *
     * @private
     */

  }, {
    key: "_setupTransform",
    value: function _setupTransform(json) {
      var tr = json.transform; // <TRANSFORM>
      // transform mode

      if (this.transform_mode !== TransformMode.POSITION_MLOCS_SCALE_ORIENTATION) {
        this.setTransformMode(TransformMode.POSITION_MLOCS_SCALE_ORIENTATION);
      } // position


      this.setPosition(new GeoPoint().setFromArray(tr.position)); // heading, tilt, roll

      this.setOrientation(new Orientation(tr.heading, tr.tilt, tr.roll)); // scale

      var scale = tr.scale !== undefined ? tr.scale : [1, 1, 1]; // <PARAM-SCALE3>

      if (typeof scale == 'number') {
        // ã¹ã±ã¼ã«ããã¯ãã«ã«æ­£è¦å
        scale = [scale, scale, scale];
      }

      this.setScale(scale);
    }
    /**
     * @summary ã¢ãã«ãè¨­å®
     *
     * @param {object} json  çææå ±
     * @param {object} refs  åç§è¾æ¸
     *
     * @throws Error
     *
     * @private
     */

  }, {
    key: "_setupModelObject",
    value: function _setupModelObject(json, refs) {
      var container = refs[json.ref_model];

      this._primitive_producer.setModelObject(container, json.index);
    }
    /**
     * @summary ã¢ãã«åç¹ä½ç½®ãè¨­å®
     *
     * @param {mapray.GeoPoint} value  ã¢ãã«åç¹ã®ä½ç½®
     */

  }, {
    key: "setPosition",
    value: function setPosition(value) {
      if (this.transform_mode === TransformMode.GOCS_MATRIX) {
        console.log("Warning: invalid transform mode: " + this.transform_mode.id);
        return;
      }

      var op = this._position; // å¤æ´åã®ä½ç½®

      if (value.longitude != op.longitude || value.latitude != op.latitude || value.altitude != op.altitude) {
        // ä½ç½®ãå¤æ´ããã
        this._position.assign(value);

        this._primitive_producer.onChangePosition();
      }
    }
    /**
     * @summary ã¢ãã«ã®åããè¨­å®
     *
     * @param {mapray.Orientation} value  ã¢ãã«ã®åã
     */

  }, {
    key: "setOrientation",
    value: function setOrientation(value) {
      if (this.transform_mode === TransformMode.GOCS_MATRIX) {
        console.log("Warning: invalid transform mode: " + this.transform_mode.id);
        return;
      }

      value.getTransformMatrix(sameScaleVector3, this._matrix);
    }
    /**
     * @summary ã¢ãã«ã®ã¹ã±ã¼ã«ãè¨­å®
     *
     * @param {mapray.Vector3} value  ã¢ãã«ã®ã¹ã±ã¼ã«
     */

  }, {
    key: "setScale",
    value: function setScale(value) {
      if (this.transform_mode === TransformMode.GOCS_MATRIX) {
        console.log("Warning: invalid transform mode: " + this.transform_mode.id);
        return;
      }

      GeoMath.copyVector3(value, this._scale);
    }
    /**
     * @summary ã¢ãã«ã®åè»¢ãè¨­å®
     *
     * @desc
     * <p>ä»ã®ã¨ããã¢ãã¡ã¼ã·ã§ã³å°ç¨</p>
     *
     * @param {mapray.Matrix} value  åè»¢è¡å
     *
     * @private
     */

  }, {
    key: "_setRotation",
    value: function _setRotation(value) {
      if (this.transform_mode === TransformMode.GOCS_MATRIX) {
        console.log("Warning: invalid transform mode: " + this.transform_mode.id);
        return;
      }

      GeoMath.copyMatrix(value, this._matrix);
    }
    /**
     * @summary ã¢ãã«ã®è¡åãç´æ¥è¨­å®
     * @private
     */

  }, {
    key: "setMatrix",
    value: function setMatrix(value) {
      if (this.transform_mode === TransformMode.POSITION_MLOCS_SCALE_ORIENTATION) {
        console.log("Warning: invalid transform mode: " + this.transform_mode.id);
        return;
      }

      GeoMath.copyMatrix(value, this._matrix);
    }
    /**
     * @summary ã¢ãã«ä½ç½®ã®æ¨é«ãåå¾
     *
     * @return {number} æ¨é«å¤
     *
     * @private
     */

  }, {
    key: "_getElevation",
    value: function _getElevation() {
      return this.scene.viewer.getExistingElevation(this._position);
    }
  }, {
    key: "anchor_mode",
    get: function get() {
      return this._anchor_mode;
    }
  }, {
    key: "transform_mode",
    get: function get() {
      return this._transform_mode;
    }
  }]);

  return ModelEntity;
}(Entity);
/**
 * @summary ModelEntity ã® PrimitiveProducer
 *
 * @private
 */


var PrimitiveProducer$3 =
/*#__PURE__*/
function (_Entity$PrimitiveProd) {
  _inherits(PrimitiveProducer, _Entity$PrimitiveProd);

  /**
   * @param {mapray.ModelEntity} entity
   */
  function PrimitiveProducer(entity) {
    var _this3;

    _classCallCheck(this, PrimitiveProducer);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(PrimitiveProducer).call(this, entity));
    _this3._primitives = []; // ããªããã£ãéå

    _this3._pickPrimitives = []; // ããªããã£ãéå

    _this3._ptoe_array = []; // åããªããã£ãåº§æ¨ç³»ããã¨ã³ãã£ãã£åº§æ¨ç³»ã¸ã®å¤æè¡å

    _this3._abs_position = null; // çµ¶å¯¾é«åº¦ã«å¤æããä½ç½®ã®ã­ã£ãã·ã¥ (null ãªãç¡å¹)

    return _this3;
  }
  /**
   * @summary ã¢ãã«ãè¨­å®
   *
   * @param {mapray.ModelContainer} container  ã¢ãã«ã³ã³ãã
   * @param {number|string}         [id]       ã¢ãã« ID
   *
   * @throws Error
   */


  _createClass(PrimitiveProducer, [{
    key: "setModelObject",
    value: function setModelObject(container, index) {
      var primitives = container.createPrimitives(index, {
        ridMaterial: false
      });
      var pickPrimitives = container.createPrimitives(index, {
        ridMaterial: true
      });

      if (primitives) {
        this._primitives = primitives;
        this._pickPrimitives = pickPrimitives;
        this._ptoe_array = primitives.map(function (prim) {
          return GeoMath.createMatrix(prim.transform);
        });
      } else {
        // ModelContainer ããã¢ãã«ãè¦ã¤ãããªãã£ã
        throw new Error("model is not found in ModelContainer");
      }
    }
    /**
     * @override
     */

  }, {
    key: "createRegions",
    value: function createRegions() {
      var region = new EntityRegion();
      region.addPoint(this.entity._position);
      return [region];
    }
    /**
     * @override
     */

  }, {
    key: "onChangeElevation",
    value: function onChangeElevation(regions) {
      this._abs_position = null; // ã­ã£ãã·ã¥ãç¡å¹å
    }
    /**
     * @override
     */

  }, {
    key: "getPrimitives",
    value: function getPrimitives(stage) {
      var entity_to_gocs = this.getMatrix(GeoMath.createMatrix()); // Primitive#transform ãè¨­å®

      var primitives = stage.getRenderTarget() === RenderTarget.SCENE ? this._primitives : this._pickPrimitives;
      var ptoe_array = this._ptoe_array;

      for (var i = 0; i < primitives.length; ++i) {
        var prim = primitives[i];
        var ptoe = ptoe_array[i]; // prim.transform = entity_to_gocs * ptoe

        GeoMath.mul_AA(entity_to_gocs, ptoe, prim.transform);
      }

      return primitives;
    }
    /**
     * @summary bboxãå©ç¨ãã¦ç°¡æçã«ãã¦ã³ãã£ã³ã°ãç®åº
     *
     * @return {Float64Array}  min_lon,min_lat,min_alt,max_lon,max_lat,max_alt
     */

  }, {
    key: "getBounds",
    value: function getBounds() {
      var entity_to_gocs = this.getMatrix(GeoMath.createMatrix()); // Primitive#transform ãè¨­å®

      var primitives = this._primitives;
      var ptoe_array = this._ptoe_array;
      var min_lon = Number.MAX_VALUE;
      var max_lon = -Number.MAX_VALUE;
      var min_lat = Number.MAX_VALUE;
      var max_lat = -Number.MAX_VALUE;
      var min_alt = Number.MAX_VALUE;
      var max_alt = -Number.MAX_VALUE;
      var transform = new Float64Array(4 * 4);

      for (var i = 0; i < primitives.length; ++i) {
        var prim = primitives[i];
        var ptoe = ptoe_array[i]; // prim.transform = entity_to_gocs * ptoe

        GeoMath.mul_AA(entity_to_gocs, ptoe, transform);
        var bbox = prim.bbox;
        var bbox0_x = bbox[0][0] * transform[0] + bbox[0][1] * transform[4] + bbox[0][2] * transform[8] + transform[12];
        var bbox0_y = bbox[0][0] * transform[1] + bbox[0][1] * transform[5] + bbox[0][2] * transform[9] + transform[13];
        var bbox0_z = bbox[0][0] * transform[2] + bbox[0][1] * transform[6] + bbox[0][2] * transform[10] + transform[14];
        var bbox1_x = bbox[1][0] * transform[0] + bbox[1][1] * transform[4] + bbox[1][2] * transform[8] + transform[12];
        var bbox1_y = bbox[1][0] * transform[1] + bbox[1][1] * transform[5] + bbox[1][2] * transform[9] + transform[13];
        var bbox1_z = bbox[1][0] * transform[2] + bbox[1][1] * transform[6] + bbox[1][2] * transform[10] + transform[14];
        var points0 = new GeoPoint();
        points0.setFromGocs([bbox0_x, bbox0_y, bbox0_z]);
        var points1 = new GeoPoint();
        points1.setFromGocs([bbox1_x, bbox1_y, bbox1_z]); // bbox0

        var lon = points0.longitude;
        var lat = points0.latitude;
        var alt = points0.altitude;
        if (lon < min_lon) min_lon = lon;
        if (lon > max_lon) max_lon = lon;
        if (lat < min_lat) min_lat = lat;
        if (lat > max_lat) max_lat = lat;
        if (alt < min_alt) min_alt = alt;
        if (alt > max_alt) max_alt = alt; // bbox1

        lon = points1.longitude;
        lat = points1.latitude;
        alt = points1.altitude;
        if (lon < min_lon) min_lon = lon;
        if (lon > max_lon) max_lon = lon;
        if (lat < min_lat) min_lat = lat;
        if (lat > max_lat) max_lat = lat;
        if (alt < min_alt) min_alt = alt;
        if (alt > max_alt) max_alt = alt;
      }

      var bounds_array = new Float64Array(3 * 2);
      bounds_array[0] = min_lon;
      bounds_array[1] = min_lat;
      bounds_array[2] = min_alt;
      bounds_array[3] = max_lon;
      bounds_array[4] = max_lat;
      bounds_array[5] = max_alt;
      return bounds_array;
    }
    /**
     * @summary é«åº¦ã¢ã¼ããå¤æ´ãããã¨ãã«å¼ã³åºããã
     */

  }, {
    key: "onChangeAltitudeMode",
    value: function onChangeAltitudeMode() {
      this._abs_position = null; // ã­ã£ãã·ã¥ãç¡å¹å
    }
    /**
     * @summary ä½ç½®ãå¤æ´ãããã¨ãã«å¼ã³åºããã
     */

  }, {
    key: "onChangePosition",
    value: function onChangePosition() {
      this.needToCreateRegions();
      this._abs_position = null;
    }
    /**
     * @private
     */

  }, {
    key: "getMatrix",
    value: function getMatrix(dst) {
      var entity = this.entity;

      switch (entity.transform_mode) {
        case TransformMode.GOCS_MATRIX:
          {
            return GeoMath.copyMatrix(entity._matrix, dst);
          }

        case TransformMode.POSITION_MLOCS_SCALE_ORIENTATION:
          {
            this._updateAbsPosition();

            var mlocs_to_gocs = this._abs_position.getMlocsToGocsMatrix(GeoMath.createMatrix());

            var entity_to_mlocs = mul_RS(entity._matrix, entity._scale, GeoMath.createMatrix());
            return GeoMath.mul_AA(mlocs_to_gocs, entity_to_mlocs, dst);
          }

        default:
          throw new Error("Unsupported transform mode: " + entity._transform_mode);
      }
    }
    /**
     * @summary çµ¶å¯¾é«åº¦ä½ç½®ãæ´æ°
     *
     * åºå: this._abs_position
     *
     * @private
     */

  }, {
    key: "_updateAbsPosition",
    value: function _updateAbsPosition() {
      if (this._abs_position !== null) {
        // ã­ã£ãã·ã¥ããã¦ãã
        return;
      }

      var entity = this.entity;
      this._abs_position = entity._position.clone();

      switch (entity.altitude_mode) {
        case AltitudeMode.RELATIVE:
          this._abs_position.altitude += entity._getElevation();
          break;

        case AltitudeMode.CLAMP:
          this._abs_position.altitude = entity._getElevation();
          break;
      }
    }
  }]);

  return PrimitiveProducer;
}(Entity.PrimitiveProducer);
/**
 * @summary åº§æ¨å¤æã¢ã¼ãã®åæå
 *
 * <h5>ã¢ã¼ãã«ãã£ã¦ãã©ã¡ã¼ã¿ãé¢æ°ãç¡å¹ã«ãªãã</h5>
 * <ul>
 * <li>(a) POSITION_MLOCS_SCALE_ORIENTATION
 * <li>(b) GOCS_MATRIX
 * </ul>
 * <table class="props">
 * <thead>
 * <tr><th><th>(a)<th>(b)</tr>
 * </thead>
 * <tbody>
 * <tr><th>_position, setPosition()<td>æå¹<td>ç¡å¹</tr>
 * <tr><th>_scale, setScale()<td>æå¹<td>ç¡å¹</tr>
 * <tr><th>setOrientation()<td>æå¹<td>ç¡å¹</tr>
 * <tr><th>setMatrix()<td>ç¡å¹<td>æå¹</tr>
 * <tr><th>_matrix<td>æå¹ï¼åè»¢é¨åã®ã¿ï¼<td>æå¹</tr>
 * <tr><th>altitude_mode<td>ç¡å¹<td>æå¹</tr>
 * </tbody>
 * </table>
 * 
 * <h5>ã¢ã¼ãå¤æ´æã®ä½ç½®ã»å§¿å¢ã®å¤å</h5>
 * <table class="props">
 * <thead>
 * <tr><th>é·ç§»<th>ä½ç½®ã»å§¿å¢ã®å¤å</tr>
 * </thead>
 * <tbody>
 * <tr><th>(a) &rarr; (b)<td>å§¿å¢ãç¶­æãããè¦ããä¸ä½ç½®ã»å§¿å¢ã«å¤åããªã</tr>
 * <tr><th>(b) &rarr; (a)<td>ã§ããã ãå§¿å¢ãç¶­æãã</tr>
 * </tbody>
 * </table>
 * 
 * @enum {object}
 * @memberof mapray.ModelEntity
 * @constant
 * @private
 */


var TransformMode = {
  /**
   * Positionä½ç½®ãåç¹ã¨ããMLocsã«ããã¦ ScaleãOrientation ãé©ç¨ãããããã©ã«ãã®åº§æ¨å¤æã¢ã¼ãã
   */
  POSITION_MLOCS_SCALE_ORIENTATION: {
    id: "POSITION_MLOCS_SCALE_ORIENTATION"
  },

  /**
   * Gocs åº§æ¨ç³»ã«ããã¦ãç´æ¥å¤æè¡åãé©ç¨ããã
   * Position, Scale, Orientationã«ãã£ã¦æå®ãããå¤ã¯ç¡è¦ããã¾ãã
   */
  GOCS_MATRIX: {
    id: "GOCS_MATRIX"
  }
}; // ç­åãè¡¨ããã¯ãã«

var sameScaleVector3 = GeoMath.createVector3([1, 1, 1]);
/**
 * @summary åè»¢è¡å * åç
 *
 * @param {mapray.Matrix}  rmat  åè»¢è¡å
 * @param {mapray.Vector3} svec  åçãã¯ãã«
 * @param {mapray.Matrix}  dst   çµæ
 *
 * @return {mapray.Matrix}  dst
 *
 * @private
 */

function mul_RS(rmat, svec, dst) {
  var sx = svec[0];
  var sy = svec[1];
  var sz = svec[2];
  dst[0] = rmat[0] * sx;
  dst[1] = rmat[1] * sx;
  dst[2] = rmat[2] * sx;
  dst[3] = 0;
  dst[4] = rmat[4] * sy;
  dst[5] = rmat[5] * sy;
  dst[6] = rmat[6] * sy;
  dst[7] = 0;
  dst[8] = rmat[8] * sz;
  dst[9] = rmat[9] * sz;
  dst[10] = rmat[10] * sz;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}

ModelEntity.TransformMode = TransformMode;

var exportTypedArrayStaticMethod$1 = arrayBufferViewCore.exportTypedArrayStaticMethod; // `%TypedArray%.from` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.from

exportTypedArrayStaticMethod$1('from', typedArrayFrom, typedArrayConstructorsRequireWrappers);

var polygon_vs_code = "/**\n * å¤è§å½¢ã®é ç¹ã·ã§ã¼ã\n */\n\nattribute vec4 a_position;   // ä½ç½® (ã¢ãã«åº§æ¨ç³»)\nattribute vec3 a_normal;     // æ³ç· (ã¢ãã«åº§æ¨ç³»)\n\nuniform mat4 u_obj_to_clip;  // ã¢ãã«åº§æ¨ç³»ããã¯ãªããåº§æ¨ç³»ã¸ã®å¤æ\nuniform mat4 u_obj_to_view;  // ã¢ãã«åº§æ¨ç³»ããè¦ç¹åº§æ¨ç³»ã¸ã®å¤æ\nuniform bool u_lighting;     // ç§åã®æç¡\nuniform vec3 u_light_dir;    // ã©ã¤ãéæ¹å (è¦ç¹åº§æ¨ç³») ã¨å¼·ã\n\nvarying vec3 v_lit_diffuse;  // æ¡æ£åã©ã¤ã\n\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n\n    if ( u_lighting ) {\n        // æ³ç· (è¦ç¹åº§æ¨ç³»)\n        vec3 normal = normalize( vec3( u_obj_to_view * vec4( a_normal, 0.0 ) ) );\n\n        // æ¡æ£åã®å¼·ã\n        v_lit_diffuse = vec3( dot( normal, u_light_dir ) );\n    }\n    else {\n        // ç§åãªãã®ã¨ãã¯ 1 ã«åºå®\n        v_lit_diffuse = vec3( 1 );\n    }\n}\n";

var polygon_fs_code = "/**\n * å¤è§å½¢ã®ãã©ã°ã¡ã³ãã·ã§ã¼ã\n */\n\nprecision mediump float;\n\nvarying vec3 v_lit_diffuse;  // æ¡æ£åã©ã¤ã\n\nuniform vec4 u_color;        // åºæ¬è²ã¨ä¸éæåº¦\n\n\nvoid\nmain()\n{\n    vec3  color   = u_color.xyz * v_lit_diffuse;\n    float opacity = u_color.w;\n\n    gl_FragColor = vec4( color * opacity, opacity );\n}\n";

/**
 * @summary å¤è§å½¢åå°ç¨ãããªã¢ã«
 * @memberof mapray
 * @extends mapray.EntityMaterial
 * @private
 */

var PolygonMaterial =
/*#__PURE__*/
function (_EntityMaterial) {
  _inherits(PolygonMaterial, _EntityMaterial);

  /**
   * @param {mapray.GLEnv} glenv
   */
  function PolygonMaterial(glenv) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, PolygonMaterial);

    return _possibleConstructorReturn(this, _getPrototypeOf(PolygonMaterial).call(this, glenv, polygon_vs_code, options.ridMaterial ? rid_fs_code : polygon_fs_code));
  }
  /**
   * @override
   */


  _createClass(PolygonMaterial, [{
    key: "isTranslucent",
    value: function isTranslucent(stage, primitive) {
      var props = primitive.properties;
      var opacity = props.opacity !== undefined ? props.opacity : PolygonMaterial.DEFAULT_OPACITY;
      return opacity < 1.0;
    }
    /**
     * @override
     */

  }, {
    key: "setParameters",
    value: function setParameters(stage, primitive) {
      _get(_getPrototypeOf(PolygonMaterial.prototype), "setParameters", this).call(this, stage, primitive);

      var props = primitive.properties; // å¤æè¡å
      // u_obj_to_clip, u_obj_to_view

      this.setObjToClip(stage, primitive);
      this.setObjToView(stage, primitive);

      if (stage.getRenderTarget() === RenderTarget.SCENE) {
        // åºæ¬è²
        // vec4 u_color
        var param_color = props.color !== undefined ? props.color : PolygonMaterial.DEFAULT_COLOR;
        var param_opacity = props.opacity !== undefined ? props.opacity : PolygonMaterial.DEFAULT_OPACITY;
        var color = PolygonMaterial._color;
        GeoMath.copyVector3(param_color, color);
        color[3] = param_opacity;
        this.setVector4("u_color", color); // ç§åã®æç¡
        // bool u_lighting

        this.setBoolean("u_lighting", props.lighting); // ã©ã¤ãéæ¹å (è¦ç¹åº§æ¨ç³») ã¨å¼·ã
        // vec3 u_light_dir

        this.setVector3("u_light_dir", [0, 0, 1]);
      }
    }
  }]);

  return PolygonMaterial;
}(EntityMaterial); // ã¯ã©ã¹å®æ°ã®å®ç¾©


{
  PolygonMaterial.DEFAULT_COLOR = GeoMath.createVector3f([1.0, 1.0, 1.0]);
  PolygonMaterial.DEFAULT_OPACITY = 1.0; // è¨ç®ç¨ä¸æé å

  PolygonMaterial._color = GeoMath.createVector4f();
}

/**
 * @summary å¤è§å½¢ãä¸è§å½¢ã«åå²
 *
 * @classdesc
 * <p>å¥åããå¤è§å½¢ãä¸è§å½¢ã«åå²ãã¦çµæãè¿ãã</p>
 * <p>æ§ç¯å­ã¨ addBoundary() ã§ã§å¤è§å½¢ãå¥åãã¦ãrun() ã¡ã½ããã§ãããä¸è§å½¢ã«åå²ãã¦è¿ãã</p>
 *
 * <p>å®è£ã®ã¢ã«ã´ãªãºã ã¨ç¨èªã¯åºæ¬çã«ã³ã³ãã¥ã¼ã¿ã»ã¸ãªã¡ããª (è¿ä»£ç§å­¦ç¤¾) ã®ç¬¬ï¼ç« ãå¤è§å½¢ã®ä¸è§å½¢åå²ããåèã«ãã¦ããã</p>
 *
 * @memberof mapray
 * @private
 */
var Triangulator =
/*#__PURE__*/
function () {
  /**
   * @desc
   * <p>points ã¯å¤è§å½¢ã®é ç¹ã® xy åº§æ¨ã®éåã§ããã</p>
   * <p>åº§æ¨ç³»ã¯ x è»¸ãå³æ¹åãy è»¸ãä¸æ¹åãæ³å®ãã¦ããã</p>
   *
   * @param {number[]} points  é ç¹éå
   * @param {number}   offset  æåã®é ç¹ã®ã¤ã³ããã¯ã¹ (>= 0)
   * @param {number}   stride  é ç¹ã®éé (>= 2)
   * @param {number}   count   é ç¹æ°
   */
  function Triangulator(points, offset, stride, count) {
    _classCallCheck(this, Triangulator);

    this._points = new Float64Array(2 * count);
    this._polygons = new Set(); // é ç¹åº§æ¨ãè¤è£½

    var src = offset;
    var dst = 0;

    for (var i = 0; i < count; ++i) {
      this._points[dst] = points[src];
      this._points[dst + 1] = points[src + 1];
      src += stride;
      dst += 2;
    }
  }
  /**
   * @summary å¤è§å½¢ã®å¢çãè¿½å 
   *
   * @desc
   * <p>ã¤ã³ããã¯ã¹ã®é åºã¯å¤å´å¢çã®ã¨ãã¯åæè¨åããåå´å¢çã®ã¨ãã¯æè¨åãã§ãªããã°ãªããªãã</p>
   * <p>åå´å¢çãè¿½å ããã¨ãã¯ããã®å¤å´ã®å¢çãè¿½å ããªããã°ãªããªããè¿½å ã®é åºã¯ã©ã¡ããåã§ãè¯ãã</p>
   * <p>å¢çåã¾ãã¯è¤æ°ã®å¢çéã§ã¨ãã¸ãäº¤å·®ãã¦ã¯ãªããªããåãããã«é ç¹ãä»ã®é ç¹ã¾ãã¯ã¨ãã¸ã®ä¸ã«ä¹ã£ã¦ã¯ãªããªãã</p>
   *
   * @param {number[]} indices  å¤è§å½¢ã®å¢çãè¡¨ã 3 åä»¥ä¸ã®é ç¹ã¤ã³ããã¯ã¹
   */


  _createClass(Triangulator, [{
    key: "addBoundary",
    value: function addBoundary(indices) {
      this._polygons.add(Polygon.create(this._points, indices));
    }
    /**
     * @summary å¤è§å½¢ãä¸è§å½¢ã«åå²ãã¦çµæãåå¾
     *
     * @desc
     * <p>åãã®ä¸è§å½¢ã¯ 3 ã¤ã®æ´æ°ã¤ã³ããã¯ã¹ãåæè¨åãã«ä¸¦ã¹ã¦è¡¨ç¾ãããã
     * ãã¹ã¦ã®ä¸è§å½¢ã«å¯¾ãã¦ããã®è¡¨ç¾ãé£çµããéåãåºåããã</p>
     * <p>ã¤ã³ããã¯ã¹ã¯å¥åé ç¹ã®æåã®é ç¹ã 0 ã¨ããã</p>
     *
     * @throws Error  æ³å®å¤ã®å¤è§å½¢
     *
     * @return {Uint32Array}  ä¸è§å½¢ã®é ç¹ã¤ã³ããã¯ã¹ã®éå
     */

  }, {
    key: "run",
    value: function run() {
      // å¤è§å½¢ã y åèª¿å¤è§å½¢ã«åå²
      this._makeYMonotonePolygons();

      var triangles = new Uint32Array(3 * this._numTriangles());
      var offset = 0; // å y åèª¿å¤è§å½¢ãä¸è§å½¢ã«åå²

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._polygons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var polygon = _step.value;

          var temp = this._makeTriangleArray(polygon);

          triangles.set(temp, offset);
          offset += temp.length;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return triangles;
    }
    /**
     * @summary ä¸è§å½¢ã®æ°ãåå¾
     *
     * @return {number} ä¸è§å½¢ã®æ°
     *
     * @private
     */

  }, {
    key: "_numTriangles",
    value: function _numTriangles() {
      var count = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._polygons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var polygon = _step2.value;
          count += polygon.numVertices() - 2;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      return count;
    }
    /**
     * @summary å¤è§å½¢ã y åèª¿å¤è§å½¢ã«åå²
     *
     * @desc
     * <p>this._polygons ã y è»¸åèª¿ãªé¨åå¤è§å½¢ã«åå²ããã</p>
     *
     * @private
     */

  }, {
    key: "_makeYMonotonePolygons",
    value: function _makeYMonotonePolygons() {
      var vertices = this._getYOrderedVertices();

      var edge_mgr = new EdgeManager();
      var diag_mgr = new DiagonalManager(this._polygons);

      for (var i = 0; i < vertices.length; ++i) {
        var vertex = vertices[i];

        switch (vertex.getVertexType()) {
          case "start":
            {
              var ledge = vertex.getFrontEdge();
              edge_mgr.addEdge(ledge, vertex);
            }
            break;

          case "end":
            {
              var _ledge = vertex.getBackEdge();

              var lhelp = edge_mgr.getHelper(_ledge);

              if (lhelp.getVertexType() == "merge") {
                diag_mgr.addDiagonal(vertex, lhelp);
              }

              edge_mgr.removeEdge(_ledge);
            }
            break;

          case "split":
            {
              var nedge = edge_mgr.findNearestLeftEdge(vertex);
              diag_mgr.addDiagonal(vertex, edge_mgr.getHelper(nedge));
              edge_mgr.setHelper(nedge, vertex);
              var redge = vertex.getFrontEdge();
              edge_mgr.addEdge(redge, vertex);
            }
            break;

          case "merge":
            {
              var _redge = vertex.getBackEdge();

              var rhelp = edge_mgr.getHelper(_redge);

              if (rhelp.getVertexType() == "merge") {
                diag_mgr.addDiagonal(vertex, rhelp);
              }

              edge_mgr.removeEdge(_redge);

              var _nedge = edge_mgr.findNearestLeftEdge(vertex);

              var nhelp = edge_mgr.getHelper(_nedge);

              if (nhelp.getVertexType() == "merge") {
                diag_mgr.addDiagonal(vertex, nhelp);
              }

              edge_mgr.setHelper(_nedge, vertex);
            }
            break;

          default:
            {
              // "regular"
              if (vertex.isRightInner()) {
                // vertex ã®å±æå³ã¯å¤è§å½¢ã®åå´
                var uedge = vertex.getBackEdge();
                var uhelp = edge_mgr.getHelper(uedge);

                if (uhelp.getVertexType() == "merge") {
                  diag_mgr.addDiagonal(vertex, uhelp);
                }

                edge_mgr.removeEdge(uedge);
                var dedge = vertex.getFrontEdge();
                edge_mgr.addEdge(dedge, vertex);
              } else {
                // vertex ã®å±æå³ã¯å¤è§å½¢ã®å¤å´
                var _nedge2 = edge_mgr.findNearestLeftEdge(vertex);

                var _nhelp = edge_mgr.getHelper(_nedge2);

                if (_nhelp.getVertexType() == "merge") {
                  diag_mgr.addDiagonal(vertex, _nhelp);
                }

                edge_mgr.setHelper(_nedge2, vertex);
              }
            }
            break;
        }
      } // this._polygons ãå¯¾è§ç·ã«ããåå²


      diag_mgr.splitPolygons();
    }
    /**
     * @summary ä¸ããé ã®é ç¹éåãåå¾
     *
     * @return {Vertex[]}  Y ä½ç½®éé ã®é ç¹éå
     *
     * @private
     */

  }, {
    key: "_getYOrderedVertices",
    value: function _getYOrderedVertices() {
      var vertices = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this._polygons[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var polygon = _step3.value;
          Array.prototype.push.apply(vertices, polygon.getVertices());
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
      return vertices.sort(function (a, b) {
        return Vertex.comparePositionY(b, a);
      });
    }
    /**
     * @summary å¤è§å½¢ãä¸è§å½¢ã«åå²
     *
     * @desc
     * <p>y åèª¿å¤è§å½¢ polygon ã 1 ã¤ä»¥ä¸ã®ä¸è§å½¢ã«åå²ãã¦è¿ãã</p>
     * <p>1 ã¤ã®ä¸è§å½¢ã¯ 3 ã¤ã®æ´æ°ã¤ã³ããã¯ã¹ã§è¡¨ç¾ãããä¸è§å½¢æ°ã®3åã®é·ãã®æ´æ°éåãè¿ãã
     * ãã®ã¤ã³ããã¯ã¹ã¯å¥åé ç¹éåã«å¯¾ãããã®ã§ã3 é ç¹ã¯åæè¨åãã§æ ¼ç´ãããã</p>
     *
     * @param {Polygon} polygon  y åèª¿å¤è§å½¢
     *
     * @return {Uint32Array}  ä¸è§å½¢ã®éå
     *
     * @private
     */

  }, {
    key: "_makeTriangleArray",
    value: function _makeTriangleArray(polygon) {
      var ti = 0;
      var triangles = new Uint32Array(3 * (polygon.numVertices() - 2));
      var stack = new Stack();
      var vi = 0;
      var vertices = polygon.getVertices().sort(function (a, b) {
        return Vertex.comparePositionY(b, a);
      });
      var is_right = vertices[0].prev === vertices[1]; // ã¹ã¿ãã¯ã®ãã§ã¤ã³ãå³å´ãï¼

      stack.push(vertices[vi++]);
      stack.push(vertices[vi++]);

      while (vi < vertices.length - 1) {
        var _vertex = vertices[vi];
        var is_same_chain = is_right ? _vertex === stack.top.prev : _vertex === stack.top.next;

        if (is_same_chain) {
          var _v = stack.pop();

          while (stack.size > 0) {
            var v3 = stack.top;

            var _ref = is_right ? [_v, v3] : [v3, _v],
                _ref2 = _slicedToArray(_ref, 2),
                a = _ref2[0],
                b = _ref2[1];

            if (Vertex.isCCW(_vertex, a, b)) {
              // å¯¾è§ç·ãå¤è§å½¢ã®åé¨ -> ä¸è§å½¢ãåãåºã
              triangles[ti++] = _vertex.id;
              triangles[ti++] = a.id;
              triangles[ti++] = b.id;
              _v = stack.pop();
            } else {
              break;
            }
          }

          stack.push(_v); // æå¾ã«ãããããé ç¹ãã¹ã¿ãã¯ã«æ»ã

          stack.push(_vertex);
        } else {
          // ãã¹ã¦ã®é ç¹ãã¹ã¿ãã¯ããããã
          var _v2 = stack.pop();

          while (stack.size > 0) {
            // ä¸è§å½¢ãåãåºã
            var _v3 = stack.pop();

            var _ref3 = is_right ? [_v2, _v3] : [_v3, _v2],
                _ref4 = _slicedToArray(_ref3, 2),
                _a = _ref4[0],
                _b = _ref4[1];

            triangles[ti++] = _vertex.id;
            triangles[ti++] = _a.id;
            triangles[ti++] = _b.id;
            _v2 = _v3;
          }

          stack.push(vertices[vi - 1]);
          stack.push(_vertex); // ã¹ã¿ãã¯ã®ãã§ã¤ã³ãå·¦å³åè»¢

          is_right = !is_right;
        }

        ++vi;
      } // ã¹ã¿ãã¯ã®æåã¨æå¾ã®é ç¹ãé¤ãã¦ãæä¸ç¹ãã
      // ã¹ã¿ãã¯ä¸ã®ãã¹ã¦ã®é ç¹ã¸ã®å¯¾è§ç·ãå ãã


      var vertex = vertices[vi];
      var v2 = stack.pop();

      while (stack.size > 0) {
        // ä¸è§å½¢ãåãåºã
        var _v4 = stack.pop();

        var _ref5 = is_right ? [v2, _v4] : [_v4, v2],
            _ref6 = _slicedToArray(_ref5, 2),
            _a2 = _ref6[0],
            _b2 = _ref6[1];

        triangles[ti++] = vertex.id;
        triangles[ti++] = _a2.id;
        triangles[ti++] = _b2.id;
        v2 = _v4;
      }

      return triangles;
    }
  }]);

  return Triangulator;
}();
/**
 * @summary å¤è§å½¢ã®é ç¹
 *
 * @private
 */


var Vertex =
/*#__PURE__*/
function () {
  /**
   * @param {number} id  é ç¹ ID
   * @param {number} x   x åº§æ¨
   * @param {number} y   y åº§æ¨
   */
  function Vertex(id, x, y) {
    _classCallCheck(this, Vertex);

    this.id = id;
    this.x = x;
    this.y = y;
    this.polygon = null;
    this.next = null;
    this.prev = null;
  }
  /**
   * @summary è¤è£½
   *
   * @desc
   * <p>ãã ã this.polygon, this.next, this.prev ã«ã¯ null ãè¨­å®ãããã</p>
   *
   * @return {Vertex}  this ã®è¤è£½
   */


  _createClass(Vertex, [{
    key: "clone",
    value: function clone() {
      return new Vertex(this.id, this.x, this.y);
    }
    /**
     * @summary é ç¹ã¿ã¤ããåå¾
     *
     * @desc
     * ä»¥ä¸ã®ã¿ã¤ãã®ä½ãããè¿ãã
     * <pre>
     *   "start"    åºçºç¹ (â¡)
     *   "end"      æçµç¹ (â )
     *   "split"    åé¢ç¹ (â²)
     *   "merge"    çµ±åç¹ (â¼)
     *   "regular"  æ®éç¹ (â)
     * </pre>
     *
     * @return {string}  é ç¹ã¿ã¤ã
     */

  }, {
    key: "getVertexType",
    value: function getVertexType() {
      var prev = this.prev;
      var next = this.next;
      var cprev = Vertex.comparePositionY(prev, this);
      var cnext = Vertex.comparePositionY(next, this);

      if (cprev > 0 && cnext > 0 || cprev < 0 && cnext < 0) {
        // ä¸¡å´ã®ç¹ãä¸ãã¾ãã¯ä¸¡å´ã®ç¹ãä¸ã«ãã
        // r: (prev -> this) ãã¯ãã«ã«å¯¾ãã¦å·¦ (åæè¨åã) ã«ç´è§ãªãã¯ãã«
        var rx = prev.y - this.y;
        var ry = this.x - prev.x; // v: (this -> next) ãã¯ãã«

        var vx = next.x - this.x;
        var vy = next.y - this.y; // dot( r, v ): è² æ°ãªãåè§ã 180 åº¦ããå¤§ãã

        var dot = rx * vx + ry * vy;

        if (cprev > 0 && cnext > 0) {
          // ä¸¡å´ã®ç¹ãä¸ã«ãã
          return dot < 0 ? "merge" : "end";
        } else {
          // ä¸¡å´ã®ç¹ãä¸ã«ãã
          return dot < 0 ? "split" : "start";
        }
      } else {
        // çæ¹ã®ç¹ãä¸ã§çæ¹ã®ç¹ãä¸
        return "regular";
      }
    }
    /**
     * @summary åæ¹ã¨ãã¸
     *
     * @return {Vertex}  åæ¹ã¨ãã¸ã®å§ç¹
     */

  }, {
    key: "getFrontEdge",
    value: function getFrontEdge() {
      return this;
    }
    /**
     * @summary å¾æ¹ã¨ãã¸
     *
     * @return {Vertex}  å¾æ¹ã¨ãã¸ã®å§ç¹
     */

  }, {
    key: "getBackEdge",
    value: function getBackEdge() {
      return this.prev;
    }
    /**
     * @summary é ç¹ã®å±æå³ã¯å¤è§å½¢ã®åå´ãï¼
     *
     * @desc
     * <p>é ç¹ã®å±æçãªå³å´ã¯å¤è§å½¢ã®åå´ãã©ãããè¿ãã</p>
     * <p>this ã¯ regular ã¿ã¤ãã®é ç¹ã§ãªããã°ãªããªãã</p>
     *
     * @return {boolean}  åå´ã®ã¨ã true, ããã§ãªããã° false
     */

  }, {
    key: "isRightInner",
    value: function isRightInner() {
      // æ¬¡ã®ç¹ã®ã»ããä¸ã®ã¨ããvertex ã®å³ãåå´
      return Vertex.comparePositionY(this.next, this) < 0;
    }
    /**
     * @summary ç¹ã®é«ããæ¯è¼
     *
     * @desc
     * <p>v1 ã®ç¹ã v2 ã®ç¹ããä½ãã¨ã -1, v1 ã®ç¹ã v2 ã®ç¹ããé«ãã¨ã +1, é«ããåãã¨ã 0 ãè¿ãã</p>
     *
     * @param {Vertex} v1  é ç¹ 1
     * @param {Vertex} v2  é ç¹ 2
     *
     * @return {number} æ¯è¼çµæ
     */

  }], [{
    key: "comparePositionY",
    value: function comparePositionY(v1, v2) {
      if (v1.y < v2.y || v1.y == v2.y && v1.x > v2.x) {
        // v1 (<) v2
        return -1;
      } else if (v1.y > v2.y || v1.y == v2.y && v1.x < v2.x) {
        // v1 (>) v2
        return 1;
      } else {
        // v1 (=) v2
        return 0;
      }
    }
    /**
     * @summary 3 ç¹ã¯åæè¨åããï¼
     *
     * @param {Vertex} v1  é ç¹ 1
     * @param {Vertex} v2  é ç¹ 2
     * @param {Vertex} v3  é ç¹ 3
     *
     * @return {boolean}  åæè¨åãã®ã¨ã true, ããã§ãªããã° false
     */

  }, {
    key: "isCCW",
    value: function isCCW(v1, v2, v3) {
      // a = v2 - v1
      var ax = v2.x - v1.x;
      var ay = v2.y - v1.y; // b = v3 - v1

      var bx = v3.x - v1.x;
      var by = v3.y - v1.y; // det( |a b| ) > 0

      return ax * by - ay * bx > 0;
    }
  }]);

  return Vertex;
}();
/**
 * @summary å¤è§å½¢
 *
 * @private
 */


var Polygon =
/*#__PURE__*/
function () {
  function Polygon() {
    _classCallCheck(this, Polygon);

    this._first = null;
  }
  /**
   * @summary å¤è§å½¢ãçæ
   *
   * @desc
   * <p>coords ã¯å¤è§å½¢ã®é ç¹ã® xy åº§æ¨ã®éåã§ããã</p>
   * <p>åº§æ¨ç³»ã¯ x è»¸ãå³æ¹åãy è»¸ãä¸æ¹åãæ³å®ãã¦ããã</p>
   * <p>indices ã§ã®é ç¹ã®é åºã¯åæè¨åãã§ããã<p>
   *
   * @param {number[]} coords   åº§æ¨éå
   * @param {number[]} indices  å¤è§å½¢ã®é ç¹ã¤ã³ããã¯ã¹éå (indices.length >= 3)
   *
   * @return {Polygon}  Polygon ã¤ã³ã¹ã¿ã³ã¹
   */


  _createClass(Polygon, [{
    key: "numVertices",

    /**
     * @summary é ç¹æ°ãåå¾
     *
     * @return {number}  é ç¹æ°
     */
    value: function numVertices() {
      var count = 0;
      var vertex = this._first;
      ++count;
      var end = this._first;

      for (vertex = vertex.next; vertex !== end; vertex = vertex.next) {
        ++count;
      }

      return count;
    }
    /**
     * @summary ãã¹ã¦ã®é ç¹ã®éåãåå¾
     *
     * @return {Vertex[]}  ãã¹ã¦ã®é ç¹ã®éå
     */

  }, {
    key: "getVertices",
    value: function getVertices() {
      var array = [];
      var vertex = this._first;
      array.push(vertex);
      var end = this._first;

      for (vertex = vertex.next; vertex !== end; vertex = vertex.next) {
        array.push(vertex);
      }

      return array;
    }
    /**
     * @summary é ç¹ãæ´æ°
     *
     * @private
     */

  }, {
    key: "_updateVertices",
    value: function _updateVertices() {
      var vertex = this._first;
      vertex.polygon = this;
      var end = this._first;

      for (vertex = vertex.next; vertex !== end; vertex = vertex.next) {
        vertex.polygon = this;
      }
    }
  }], [{
    key: "create",
    value: function create(coords, indices) {
      var poly = new Polygon();
      var id = indices[0];
      var base = 2 * id;
      var vertex = new Vertex(id, coords[base], coords[base + 1]);
      poly._first = vertex;

      for (var i = 1; i < indices.length; ++i) {
        var before = vertex;
        id = indices[i];
        base = 2 * id;
        vertex = new Vertex(id, coords[base], coords[base + 1]);
        before.next = vertex;
        vertex.prev = before;
      } // ããã§ vertex ã¯æå¾ã®é ç¹


      poly._first.prev = vertex;
      vertex.next = poly._first;

      poly._updateVertices();

      return poly;
    }
    /**
     * @summary å¤è§å½¢ãçæ
     *
     * @param {Vertex} first  æåã®é ç¹
     *
     * @return {Polygon}  Polygon ã¤ã³ã¹ã¿ã³ã¹
     */

  }, {
    key: "createByVertex",
    value: function createByVertex(first) {
      var poly = new Polygon();
      poly._first = first;

      poly._updateVertices();

      return poly;
    }
  }]);

  return Polygon;
}();
/**
 * @summary åèª¿å¤è§å½¢ã«åå²ããããã®ã¨ãã¸ç®¡ç
 *
 * @classdesc
 * <p>è¿½å ãããã¨ãã¸ã®å±æå³ã¯å¸¸ã«å¤è§å½¢ã®åå´ã«ãªãã</p>
 *
 * @private
 */


var EdgeManager =
/*#__PURE__*/
function () {
  /**
   */
  function EdgeManager() {
    _classCallCheck(this, EdgeManager);

    this._edges = new Map();
  }
  /**
   * @summary ã¨ãã¸ãè¿½å 
   *
   * @param {Vertex} edge    è¿½å ããã¨ãã¸
   * @param {Vertex} helper  åæãã«ãã¼é ç¹
   */


  _createClass(EdgeManager, [{
    key: "addEdge",
    value: function addEdge(edge, helper) {
      this._edges.set(edge, {
        helper: helper
      });
    }
    /**
     * @summary ã¨ãã¸ãåé¤
     *
     * @param {Vertex} edge  åé¤ããã¨ãã¸
     */

  }, {
    key: "removeEdge",
    value: function removeEdge(edge) {
      this._edges["delete"](edge);
    }
    /**
     * @summary ã¨ãã¸ã«ãã«ãã¼ãè¨­å®
     *
     * @param {Vertex} edge    å¯¾è±¡ã¨ãã¸
     * @param {Vertex} helper  ãã«ãã¼é ç¹
     */

  }, {
    key: "setHelper",
    value: function setHelper(edge, helper) {
      this._edges.get(edge).helper = helper;
    }
    /**
     * @summary ã¨ãã¸ã®ãã«ãã¼ãåå¾
     *
     * @param {Vertex} edge  å¯¾è±¡ã¨ãã¸
     *
     * @return {Vertex}  ãã«ãã¼é ç¹
     */

  }, {
    key: "getHelper",
    value: function getHelper(edge) {
      return this._edges.get(edge).helper;
    }
    /**
     * @summary é ç¹ã®å·¦å´ã§æãè¿ãã¨ãã¸ãæ¤ç´¢
     *
     * @desc
     * <p>vertex ãå·¦ã« (å¤è§å½¢ã®åå´ã) ç§»åããªããæåã«çªãå½ããã¨ãã¸ãåå¾ããã
     *    ãã®ãããªã¨ãã¸ãå¸¸ã«å­å¨ãããã¨ãåæã«ãªã£ã¦ããã</p>
     *
     * <p>vertex ã®å±æå·¦ã¯å¸¸ã«å¤è§å½¢ã®åå´ã«ãªãã</p>
     *
     * @param {Vertex} vertex  å¯¾è±¡é ç¹
     *
     * @return {Vertex}  ã¨ãã¸
     */

  }, {
    key: "findNearestLeftEdge",
    value: function findNearestLeftEdge(vertex) {
      // ãã®ã¡ã½ãããå¼ã³åºãããæç¹ã§ã®åæç¶æ:
      //   - ã©ã¡ããã®ç«¯ç¹ã vertex ã®ã¨ãã¸ã¯å­å¨ããªã
      //   - ä¸¡ç«¯ã® y åº§æ¨ãåãã¨ãã¸ã¯å­å¨ããªã
      //   - ãã¹ã¦ã®ã¨ãã¸ã¯ vertex ãéãæ°´å¹³ç·ã¨äº¤å·®ãã
      // TODO:
      //   ãã®ã¡ã½ããã¯å¤è§å½¢ã®é ç¹æ° n ã«å¯¾ãã¦è¨ç®éã¯ææª O(n), å¹³åã¯ä¸æ
      //   ææªã®å ´åãããªã´ã³åå²å¨ä½ã®è¨ç®éã O(n^2) ã«ãªã£ã¦ãã¾ã
      //   ãã®ããããã®ãã¡ã½ããåä½ã§ææª O(log n) ã¾ãã¯å¹³å O(log n) ä»¥ä¸ã«ããã
      var nearest_edge;
      var min_distance = Number.MAX_VALUE;
      var vx = vertex.x;
      var vy = vertex.y;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._edges[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _step4$value = _slicedToArray(_step4.value, 1),
              edge = _step4$value[0];

          // ã¨ãã¸å§ç¹ p
          var px = edge.x;
          var py = edge.y; // ã¨ãã¸çµç¹ q

          var qx = edge.next.x;
          var qy = edge.next.y; // ã¨ãã¸ã® x åº§æ¨å¾é

          var gx = (qx - px) / (qy - py); // æ°´å¹³ç·ã¨ã¨ãã¸ã®äº¤ç¹ã® x åº§æ¨

          var rx = px + (vy - py) * gx; // vertex ã¨äº¤ç¹ r ã¨ã®ç¬¦å·ä»ãè·é¢ (æ­£ã®ã¨ã r ã¯ vertex ã®å·¦å´)

          var distance = vx - rx;

          if (distance > 0) {
            if (distance < min_distance) {
              // è¿ãã¨ãã¸ãæ´æ°
              min_distance = distance;
              nearest_edge = edge;
            }
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      if (nearest_edge === undefined) {
        // æ³å®ã«åãã¦å·¦ã®ã¨ãã¸ãè¦ã¤ãããªãã£ã
        throw new Error("Probably a degenerate polygon");
      }

      return nearest_edge;
    }
  }]);

  return EdgeManager;
}();
/**
 * @summary å¯¾è§ç·
 *
 * @private
 */


var Diagonal =
/**
 * @param {Vertex} v1  å¯¾è§ç·ã®ç«¯ç¹1
 * @param {Vertex} v2  å¯¾è§ç·ã®ç«¯ç¹2
 */
function Diagonal(v1, v2) {
  _classCallCheck(this, Diagonal);

  this.v1 = v1;
  this.v2 = v2;
};
/**
 * @summary å¯¾è§ç·ç®¡ç
 *
 * @private
 */


var DiagonalManager =
/*#__PURE__*/
function () {
  /**
   * @param {Set.<Polygon>} polygons  å¤è§å½¢éå
   */
  function DiagonalManager(polygons) {
    _classCallCheck(this, DiagonalManager);

    this._polygons = polygons;
    this._diagonals = [];
    this._dmap = new DiagonalMap();
  }
  /**
   * @brief å¯¾è§ç·ãè¿½å 
   *
   * @param {Vertex} v1  å¯¾è§ç·ã®ç«¯ç¹1
   * @param {Vertex} v2  å¯¾è§ç·ã®ç«¯ç¹2
   */


  _createClass(DiagonalManager, [{
    key: "addDiagonal",
    value: function addDiagonal(v1, v2) {
      var diagonal = new Diagonal(v1, v2);

      this._diagonals.push(diagonal);

      this._dmap.addDiagonal(diagonal);
    }
    /**
     * @brief ãã¹ã¦ã®å¤è§å½¢ãå¯¾è§ç·ã§åå²
     */

  }, {
    key: "splitPolygons",
    value: function splitPolygons() {
      // å¯¾è§ç·ã®é åºãã©ã³ãã ã«ãã¦ãåå²æ¹åãåããªãããã«ãã
      // ããã«ããé ç¹æ° n ã«å¯¾ãã¦è¨ç®é O(n log n) ãæå¾ã§ãã
      this._shuffleArray(this._diagonals); // åãã®å¯¾è§ç·ã§å¤è§å½¢ãåå²


      while (this._diagonals.length > 0) {
        var diagonal = this._diagonals.pop();

        this._dmap.removeDiagonal(diagonal);

        var v1 = diagonal.v1;
        var v2 = diagonal.v2;

        var _this$_splitPolygonHa = this._splitPolygonHalf(v1, v2),
            _this$_splitPolygonHa2 = _slicedToArray(_this$_splitPolygonHa, 2),
            v1a = _this$_splitPolygonHa2[0],
            v2a = _this$_splitPolygonHa2[1];

        var _this$_splitPolygonHa3 = this._splitPolygonHalf(v2, v1),
            _this$_splitPolygonHa4 = _slicedToArray(_this$_splitPolygonHa3, 2),
            v2b = _this$_splitPolygonHa4[0],
            v1b = _this$_splitPolygonHa4[1];

        var p1 = v1.polygon;
        var p2 = v2.polygon;

        if (p1 === p2) {
          // diagonal ã¯å¤è§å½¢ p1 åã®å¯¾è§ç·
          this._polygons["delete"](p1);

          this._polygons.add(Polygon.createByVertex(v1a));

          this._polygons.add(Polygon.createByVertex(v1b));
        } else {
          // diagonal ã¯å¤è§å½¢ p1, p2 éã®å¯¾è§ç·
          this._polygons["delete"](p1);

          this._polygons["delete"](p2);

          this._polygons.add(Polygon.createByVertex(v1a));
        } // å¯¾è§ç·ã®ç«¯ç¹ãæ°ããçæãããç«¯ç¹ã«ç½®ãæãã


        this._replaceVertexInDiagonals(v1, v1a, v1b);

        this._replaceVertexInDiagonals(v2, v2a, v2b);
      }
    }
    /**
     * @summary å¤è§å½¢åå²ã®ååã®å¦ç
     *
     * @param {Vertex} sv  éå§ç¹
     * @param {Vertex} ev  çµäºç¹
     *
     * @return {Vertex[]}  [æ° sv, æ° ev]
     *
     * @private
     */

  }, {
    key: "_splitPolygonHalf",
    value: function _splitPolygonHalf(sv, ev) {
      var sc = sv.clone();
      var ec = ev.clone();
      sc.prev = sv.prev;
      sc.next = ec;
      sv.prev.next = sc;
      ec.prev = sc;
      ec.next = ev.next;
      ev.next.prev = ec;
      return [sc, ec];
    }
    /**
     * @summary å¯¾è§ç·ã®ç«¯ç¹ã®ç½®ãæã
     *
     * @desc
     * <p>ç«¯ç¹ã®1ã¤ã vo ã®å¯¾è§ç·ã®ãã®ç«¯ç¹ã va ã¾ãã¯ vb ã«ç½®ãæããã</p>
     * <p>åè£ç«¯ç¹ va, vb ã®ãã¡ãç½®ãæããã¨å¯¾è§ç·ãå¤è§å½¢ã®åå´ã«ãªãæ¹ãé¸ã¶ã</p>
     * <p>ä¸æ¹ãåå´ã§ãä¸æ¹ãå¤å´ã«ãªãã¯ãã</p>
     *
     * @param {Vertex} vo  åã®ç«¯ç¹
     * @param {Vertex} va  åè£ç«¯ç¹ a
     * @param {Vertex} vb  åè£ç«¯ç¹ b
     *
     * @private
     */

  }, {
    key: "_replaceVertexInDiagonals",
    value: function _replaceVertexInDiagonals(vo, va, vb) {
      // ä¸æ¦ this._dmap ããå¯¾è§ç·ãæãåã£ã¦ãç«¯ç¹ãæ¸ãæãã¦ããæ»ã
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this._dmap.removeDiagonals(vo)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var diagonal = _step5.value;
          // vo ã®åå¯¾å´ã®ç«¯ç¹
          var vo_oppo = diagonal.v1 === vo ? diagonal.v2 : diagonal.v1; // å¯¾è§ç·ã®ç«¯ç¹ã®æ¸ãæã

          diagonal.v1 = this._testDiagonal(va, vo_oppo) ? va : vb;
          diagonal.v2 = vo_oppo; // å¯¾è§ç·ãæ»ã

          this._dmap.addDiagonal(diagonal);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
    /**
     * @summary å¯¾è§ç·ãã¹ã
     *
     * <p>ç«¯ç¹ã v1, v2 ã®ç·åã¯å¤è§å½¢ã® (v1 ã®) åå´ã«å¥ããï¼</p>
     *
     * @param {Vertex} v1  ç«¯ç¹1
     * @param {Vertex} v2  ç«¯ç¹2
     *
     * @return {boolean}  åå´ã«å¥ãã¨ã true, ããä»¥å¤ã®ã¨ã false
     *
     * @private
     */

  }, {
    key: "_testDiagonal",
    value: function _testDiagonal(v1, v2) {
      // a: v1 ããé æ¹åã®ãã¯ãã«
      var ax = v1.next.x - v1.x;
      var ay = v1.next.y - v1.y; // b: v1 ããéæ¹åã®ãã¯ãã«

      var bx = v1.prev.x - v1.x;
      var by = v1.prev.y - v1.y; // c: v1 ãã v2 ã®ãã¯ãã«

      var cx = v2.x - v1.x;
      var cy = v2.y - v1.y; // cross(a) . c > 0

      var aflag = ax * cy - cx * ay > 0; // cross(b) . c < 0

      var bflag = bx * cy - cx * by < 0; // |ax bx|
      // |ay by|

      var det = ax * by - bx * ay;
      return det >= 0 ? aflag && bflag : aflag || bflag;
    }
    /**
     * @summary éåã®ä¸¦ã³ãã©ã³ãã å
     *
     * @param {array} array  å¦çå¯¾è±¡ã®éå
     *
     * @private
     */

  }, {
    key: "_shuffleArray",
    value: function _shuffleArray(array) {
      // Fisher-Yates ã®ã·ã£ããã«
      // TODO: ç¨éä¸ãåç¾æ§ã®ããä¹±æ°ãä½¿ã£ã¦ããããããã®ã»ããä½ããã£ãæã«åå ãã¤ãã¿ããã
      for (var i = array.length - 1; i > 0; --i) {
        var j = Math.floor(Math.random() * (i + 1)); // 0 <= j <= i
        // array[i] ã¨ array[j] ãäº¤æ

        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }
    }
  }]);

  return DiagonalManager;
}();
/**
 * @summary è¾æ¸: å¯¾è§ç·é ç¹ â å¯¾è§ç·ãªã¹ã
 *
 * @classdesc
 * <p>å¯¾è§ç·ã®é ç¹ããããã®é ç¹ãç«¯ç¹ã¨ããå¯¾è§ç·ã®éåãåå¾ããã</p>
 * <p>1 ã¤ã®é ç¹ã«å¯¾ãã¦å¯¾è§ç·ã¯æå¤§ 3 æ¬ãªã®ã§ãè¿½å ãåé¤ãæ¤ç´¢ã®è¨ç®éã¯å¤è§å½¢ã®é ç¹æ° n ã«å¯¾ãã¦ O(1) ã§ããã</p>
 *
 * @memberof DiagonalManager
 * @private
 */


var DiagonalMap =
/*#__PURE__*/
function () {
  function DiagonalMap() {
    _classCallCheck(this, DiagonalMap);

    // è¾æ¸ãçæ
    // key:   Vertex
    // value: Diagonal[]
    this._map = new Map();
  }
  /**
   * @summary å¯¾è§ç·ãç»é²
   *
   * @param {Diagonal} diagonal  è¿½å ããå¯¾è§ç·
   */


  _createClass(DiagonalMap, [{
    key: "addDiagonal",
    value: function addDiagonal(diagonal) {
      this._addDiagonalByVertex(diagonal.v1, diagonal);

      this._addDiagonalByVertex(diagonal.v2, diagonal);
    }
    /**
     * @summary å¯¾è§ç·ã®ç»é²ãè§£é¤
     *
     * @param {Diagonal} diagonal  åé¤ããå¯¾è§ç·
     */

  }, {
    key: "removeDiagonal",
    value: function removeDiagonal(diagonal) {
      this._removeDiagonalByVertex(diagonal.v1, diagonal);

      this._removeDiagonalByVertex(diagonal.v2, diagonal);
    }
    /**
     * @summary vertex ãç«¯ç¹ã¨ããããã¹ã®å¯¾è§ç·ã®ç»é²ãè§£é¤
     *
     * @param {Vertex} vertex  å¯¾è§ç·ã®ç«¯ç¹
     *
     * @return {Diagonal[]}  ç»é²ãè§£é¤ãããå¯¾è§ç·ã®éå
     */

  }, {
    key: "removeDiagonals",
    value: function removeDiagonals(vertex) {
      var diagonals = this._map.get(vertex);

      if (diagonals !== undefined) {
        // è¾æ¸ããå¯¾è§ç·ãåé¤
        var cloned = diagonals.slice();
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = cloned[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var diag = _step6.value;
            this.removeDiagonal(diag);
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }

        return cloned;
      } else {
        // å­å¨ããªãã£ã
        return [];
      }
    }
    /**
     * @summary å¯¾è§ç·ãç»é²
     *
     * @param {Vertex}   vertex    ã©ã¡ããã®ç«¯ç¹
     * @param {Diagonal} diagonal  è¿½å ããå¯¾è§ç·
     *
     * @private
     */

  }, {
    key: "_addDiagonalByVertex",
    value: function _addDiagonalByVertex(vertex, diagonal) {
      var array = this._map.get(vertex);

      if (array === undefined) {
        // vertex ã«å¯¾ããæåã®å¯¾è§ç·
        this._map.set(vertex, [diagonal]);
      } else {
        // vertex ã«å¯¾ãã2ã¤ç®ä»¥éã®å¯¾è§ç·
        if (array.indexOf(diagonal) != -1) {
          // å¯¾è§ç·ã¯äºéç»é²ãããªãã¯ãã...
          throw new Error("Unexpected");
        }

        if (array.length < 1 || array.length > 2) {
          // åä¸é ç¹ã®å¯¾è§ç·ã¯æå¤§3æ¬ã®ã¯ãã...
          throw new Error("Unexpected");
        }

        array.push(diagonal);
      }
    }
    /**
     * @summary å¯¾è§ç·ãåé¤
     *
     * @param {Vertex}   vertex    ã©ã¡ããã®ç«¯ç¹
     * @param {Diagonal} diagonal  åé¤ããå¯¾è§ç·
     *
     * @private
     */

  }, {
    key: "_removeDiagonalByVertex",
    value: function _removeDiagonalByVertex(vertex, diagonal) {
      var array = this._map.get(vertex);

      if (array === undefined) {
        // å­å¨ããã¯ãã...
        throw new Error("Unexpected");
      }

      var index = array.indexOf(diagonal);

      if (index == -1) {
        // å­å¨ããã¯ãã...
        throw new Error("Unexpected");
      } // éåãã diagonal ãåé¤


      array.splice(index, 1); // éåãç©ºã«ãªã£ããéåãåé¤

      if (array.length == 0) {
        this._map["delete"](vertex);
      }
    }
  }]);

  return DiagonalMap;
}();
/**
 * @summary ã¹ã¿ãã¯
 *
 * @private
 */


var Stack =
/*#__PURE__*/
function () {
  function Stack() {
    _classCallCheck(this, Stack);

    this._array = new Array();
  }

  _createClass(Stack, [{
    key: "push",
    value: function push(item) {
      this._array.push(item);
    }
  }, {
    key: "pop",
    value: function pop() {
      return this._array.pop();
    }
  }, {
    key: "size",
    get: function get() {
      return this._array.length;
    }
  }, {
    key: "top",
    get: function get() {
      var a = this._array;
      return a.length > 0 ? a[a.length - 1] : null;
    }
  }]);

  return Stack;
}();

var globalIsFinite = global_1.isFinite; // `Number.isFinite` method
// https://tc39.github.io/ecma262/#sec-number.isfinite

var numberIsFinite = Number.isFinite || function isFinite(it) {
  return typeof it == 'number' && globalIsFinite(it);
};

// https://tc39.github.io/ecma262/#sec-number.isfinite

_export({
  target: 'Number',
  stat: true
}, {
  isFinite: numberIsFinite
});

/**
 * @summary å¸å¤è§å½¢
 *
 * @memberof mapray
 *
 * @private
 */
var ConvexPolygon =
/*#__PURE__*/
function () {
  /**
   * <p>3 ç¹ã¾ãã¯ããä»¥ä¸ã®é ç¹åº§æ¨ãåæè¨åãã§æå®ããã</p>
   *
   * @param {iterable.<number>} coords  é ç¹åº§æ¨ã®ä¸¦ã³ x0, y0, x1, y1, ...
   */
  function ConvexPolygon(coords) {
    _classCallCheck(this, ConvexPolygon);

    this._vertices = Float64Array.from(coords);
    this._num_vertices = this._vertices.length / 2;
  }
  /**
   * @summary å¸å¤è§å½¢ã®é ç¹æ°
   *
   * @type {number}
   *
   * @readonly
   */


  _createClass(ConvexPolygon, [{
    key: "isValid",

    /**
     * @summary å¦¥å½æ§ãæ¤æ»
     *
     * @desc
     * <p>this ãå¦¥å½ãªå¸å¤è§å½¢ãã©ãããç¢ºãããã</p>
     *
     * @return {boolean}  this ãå¦¥å½ãªã¨ã true, ããä»¥å¤ã®ã¨ã false
     */
    value: function isValid() {
      if (this._num_vertices < 3) {
        // 3 é ç¹æªæºã®å¤è§å½¢ã¯éå¯¾å¿
        return false;
      } // åº§æ¨ãæå¹ãªæ°å¤ã§ãããã¨ããã§ãã¯


      for (var i = 0; i < this._num_vertices; ++i) {
        var x = this._vertices[2 * i];
        var y = this._vertices[2 * i + 1];

        if (!Number.isFinite(x) || !Number.isFinite(y)) {
          // æå¹ãªæ°å¤ã§ã¯ãªãåº§æ¨ãå«ã¾ãã
          return false;
        }
      } // é·ã 0 ã®ç¨ç·ãç¡ããã¨ããã§ãã¯


      for (var ei = 0; ei < this._num_vertices; ++ei) {
        var si = ei != 0 ? ei - 1 : this._num_vertices - 1;
        var sx = this._vertices[2 * si];
        var sy = this._vertices[2 * si + 1];
        var ex = this._vertices[2 * ei];
        var ey = this._vertices[2 * ei + 1];

        if (sx == ex && sy == ey) {
          // åä¸ä½ç½®ã®é£æ¥é ç¹ãå«ã¾ãã
          return false;
        }
      } // åè§ã 0 ã§ãªããã¾ãã¯ 180 åº¦ããå¤§ãããªããã¨ããã§ãã¯


      for (var oi = 0; oi < this._num_vertices; ++oi) {
        var ox = this._vertices[2 * oi];
        var oy = this._vertices[2 * oi + 1]; // åæ¹ã¸ã®æ¹åãã¯ãã«

        var fi = oi == this._num_vertices - 1 ? 0 : oi + 1;
        var fx = this._vertices[2 * fi] - ox;
        var fy = this._vertices[2 * fi + 1] - oy; // å¾æ¹ã¸ã®æ¹åãã¯ãã«

        var bi = oi == 0 ? this._num_vertices - 1 : oi - 1;
        var bx = this._vertices[2 * bi] - ox;
        var by = this._vertices[2 * bi + 1] - oy; // é¢ç©ã¨åç©

        var det = fx * by - bx * fy;
        var dot = fx * bx + fy * by;

        if (det < 0 || det == 0 && dot > 0) {
          // åè§ Î¸ ã¯ 0 < Î¸ <= 180 ã§ã¯ãªã
          return false;
        }
      }

      return true;
    }
    /**
     * @summary äº¤å·®å¸å¤è§å½¢ãåå¾
     *
     * @desc
     * <p>å¸å¤è§å½¢ this ã¨å¸å¤è§å½¢ polygon ãäº¤å·®ããã°ãäº¤å·®é¨åã®å¸å¤è§å½¢ãè¿ãã</p>
     * <p>this ã¨ polygon ãäº¤å·®ããªãã¨ãã¯ null ãè¿ãã</p>
     * <p>this ã polygon ãåå«ããã¨ãã¯ polygon ãè¿ãå¯è½æ§ãããã</p>
     *
     * @param {ConvexPolygon} polygon  å¸å¤è§å½¢
     *
     * @return {?ConvexPolygon}  äº¤å·®å¸å¤è§å½¢ããã ãäº¤å·®ããªãã¨ãã¯ null
     *
     * @throws Error  å¸å¤è§å½¢ã®åãåãã«å¤±æ
     */

  }, {
    key: "getIntersection",
    value: function getIntersection(polygon) {
      try {
        return this._clip_by_polygon(polygon);
      } catch (e) {
        throw new Error("ConvexPolygon#getIntersection failed");
      }
    }
    /**
     * @summary å¸å¤è§å½¢åå£«ã«äº¤å·®ããããã©ããï¼
     *
     * @desc
     * <p>å¸å¤è§å½¢ this ã¨å¸å¤è§å½¢ polygon ãäº¤å·®ãããã©ãããè¿ãã</p>
     *
     * @param {ConvexPolygon} polygon  å¸å¤è§å½¢
     *
     * @return {boolean}  äº¤å·®ããã¨ã true, äº¤å·®ããªãã¨ã false
     *
     * @throws Error  äº¤å·®ã®ç¢ºèªã«å¤±æ
     */

  }, {
    key: "hasIntersection",
    value: function hasIntersection(polygon) {
      try {
        return this._clip_by_polygon(polygon) !== null;
      } catch (e) {
        throw new Error("ConvexPolygon#hasIntersection failed");
      }
    }
    /**
     * @summary å¸å¤è§å½¢ãåå«ãããï¼
     *
     * @desc
     * <p>å¸å¤è§å½¢ this ã¯å¸å¤è§å½¢ polygon ãåå«ãããã©ãããè¿ãã</p>
     *
     * @param {ConvexPolygon} polygon  å¸å¤è§å½¢
     *
     * @return {boolean}  this ã polygon ãåå«ããã¨ã true, ããä»¥å¤ã¯ false
     */

  }, {
    key: "includes",
    value: function includes(polygon) {
      for (var ei = 0; ei < this._num_vertices; ++ei) {
        var si = ei != 0 ? ei - 1 : this._num_vertices - 1; // ç´ç·ä¸ã® 1 ç¹

        var px = this._vertices[2 * si];
        var py = this._vertices[2 * si + 1]; // ç´ç·ã®åå´æ¹å

        var nx = py - this._vertices[2 * ei + 1];
        var ny = this._vertices[2 * ei] - px; // å¤å®æ°å¤

        var dval = px * nx + py * ny; // this ã® si-ei ç¨ç·ã®

        for (var i = 0; i < polygon._num_vertices; ++i) {
          // polygon ã® 1 ç¹
          var qx = polygon._vertices[2 * i];
          var qy = polygon._vertices[2 * i + 1];

          if (qx * nx + qy * ny < dval) {
            // polygon ã® 1 ç¹ã this ã®å¤å´
            // polygon ã¯ this ã®å®å¨ã«åå´ã§ã¯ãªã
            return false;
          }
        }
      } // polygon ã¯ this ã®å®å¨ã«åå´ã§ãã


      return true;
    }
    /**
     * @summary å¸å¤è§å½¢ã«ããå¸å¤è§å½¢ãåãåã
     *
     * @desc
     * <p>å¸å¤è§å½¢ this ã«ããå¸å¤è§å½¢ polygon ãåãåã£ãå¸å¤è§å½¢ãè¿ãã</p>
     * <p>this ã polygon ãåå«ããã¨ãã¯ polygon ãè¿ãã</p>
     * <p>this ã¨ polygon ãäº¤å·®ããªãã¨ãã¯ null ãè¿ãã</p>
     *
     * @param {ConvexPolygon} polygon  å¸å¤è§å½¢
     *
     * @return {?ConvexPolygon}  å¸å¤è§å½¢ã¾ãã¯ null
     *
     * @throws Error  å¸å¤è§å½¢ã®åãåãã«å¤±æ
     *
     * @private
     */

  }, {
    key: "_clip_by_polygon",
    value: function _clip_by_polygon(polygon) {
      var current = polygon;

      for (var ei = 0; ei < this._num_vertices; ++ei) {
        var si = ei != 0 ? ei - 1 : this._num_vertices - 1; // ç´ç·ä¸ã® 1 ç¹

        var px = this._vertices[2 * si];
        var py = this._vertices[2 * si + 1]; // ç´ç·ã®åå´æ¹å

        var nx = py - this._vertices[2 * ei + 1];
        var ny = this._vertices[2 * ei] - px; // å¤å®æ°å¤

        var dval = px * nx + py * ny; // åç©ºéã«ããåãåã

        current = current._clip_by_halfspace(nx, ny, dval);

        if (current === null) {
          // this ã¨ polygon ã¯äº¤å·®ããªã
          break;
        }
      }

      return current;
    }
    /**
     * @summary åç©ºéã«ããå¸å¤è§å½¢ãåãåã
     *
     * @desc
     * <p>åç©ºéã«ããå¸å¤è§å½¢ this ãåãåã£ããããã®å¸å¤è§å½¢ãè¿ãã</p>
     * <p>åç©ºéã this ãååããã¨ãã¯ this ãè¿ãã</p>
     * <p>åç©ºéã¨ this ãäº¤å·®ããªãã¨ãã¯ null ãè¿ãã</p>
     *
     * @param {number} nx    åç©ºéã®åå´æ¹åã® x åº§æ¨
     * @param {number} ny    åç©ºéã®åå´æ¹åã® y åº§æ¨
     * @param {number} dval  å¤å®ç¨æ°å¤
     *
     * @return {?ConvexPolygon}  å¸å¤è§å½¢ã¾ãã¯ null
     *
     * @throws Error  åç©ºéã«ããåãåãã«å¤±æ
     *
     * @private
     */

  }, {
    key: "_clip_by_halfspace",
    value: function _clip_by_halfspace(nx, ny, dval) {
      // åç©ºéã®å¢çç·ããã®è·é¢ç¯å²
      var dist_min = Number.MAX_VALUE;
      var dist_max = -Number.MAX_VALUE;

      for (var i = 0; i < this._num_vertices; ++i) {
        // é ç¹åº§æ¨
        var px = this._vertices[2 * i];
        var py = this._vertices[2 * i + 1]; // dist == 0 åç©ºéã®å¢çç·ä¸
        // dist > 0  åç©ºéã®åå´
        // dist < 0  åç©ºéã®å¤å´

        var dist = px * nx + py * ny - dval; // æå¤§æå°ãæ´æ°

        dist_min = Math.min(dist_min, dist);
        dist_max = Math.max(dist_max, dist);
      }

      if (dist_min >= 0) {
        // åç©ºéã¯ this ãååãã
        return this;
      }

      if (dist_max <= 0) {
        // åç©ºé ã¨ this ã¯äº¤å·®ããªã
        return null;
      } // ããã§ dist_min < 0 < dist_max ãªã®ã§ãåç©ºéã®å¢çç·ã¯å¸å¤è§å½¢
      // this ã®åé¨ãééãã¦ãã (æ¥ãã¦ããªã)


      return this._clip_by_crossed_halfspace(nx, ny, dval);
    }
    /**
     * @summary åç©ºéã«ããå¸å¤è§å½¢ãåãåã (ä¸é¨äº¤å·®åæ)
     *
     * @desc
     * <p>åç©ºéã«ããå¸å¤è§å½¢ this ãåãåã£ããããã®å¸å¤è§å½¢ãè¿ãã</p>
     * <p>ãã®ã¡ã½ããã¯å¸å¤è§å½¢ this ã®å¢çç·ã¨åç©ºéã®å¢çç·ãç°ãªã
     *    2 ç¹ã§äº¤å·®ãã¦ãããã¨ãåæã«ãªã£ã¦ããã</p>
     *
     * @param {number} nx    åç©ºéã®åå´æ¹åã® x åº§æ¨
     * @param {number} ny    åç©ºéã®åå´æ¹åã® y åº§æ¨
     * @param {number} dval  å¤å®ç¨æ°å¤
     *
     * @return {ConvexPolygon}  å¸å¤è§å½¢
     *
     * @throws Error  åç©ºéã«ããåãåãã«å¤±æ
     *
     * @private
     */

  }, {
    key: "_clip_by_crossed_halfspace",
    value: function _clip_by_crossed_halfspace(nx, ny, dval) {
      var _this$_get_cross_edge = this._get_cross_edges_by_crossed_halfspace_boundary(nx, ny, dval),
          _this$_get_cross_edge2 = _slicedToArray(_this$_get_cross_edge, 2),
          ce0 = _this$_get_cross_edge2[0],
          ce1 = _this$_get_cross_edge2[1];

      var polygon = []; // æåã®é ç¹

      polygon.push(ce0.qx);
      polygon.push(ce0.qy); // ä¸­éé ç¹ã®ã¤ã³ããã¯ã¹

      var first_i = ce0.ei; // æåã®ä¸­éé ç¹

      var last_i = ce1.ei; // æå¾ã®ä¸­éé ç¹ã®æ¬¡
      // ä¸­éã®é ç¹

      for (var i = first_i; i != last_i; i = (i + 1) % this._num_vertices) {
        polygon.push(this._vertices[2 * i]);
        polygon.push(this._vertices[2 * i + 1]);
      } // æå¾ã®é ç¹


      polygon.push(ce1.qx);
      polygon.push(ce1.qy);
      return new ConvexPolygon(polygon);
    }
    /**
     * @summary åç©ºéå¢çç·ã¨äº¤å·®ãã2ç¨ç·ã®ãã¼ã¿ãåå¾ (2ç¹äº¤å·®åæ)
     *
     * @desc
     * <p>2è¦ç´ ã®éåãè¿ãã</p>
     * <p>æåã®è¦ç´ ã¯åãåãã«ããåæ¹ãæ®ãããç¨ç·ã®ãã¼ã¿ã§ããã</p>
     * <p>æ¬¡ã®è¦ç´ ã¯åãåãã«ããå¾æ¹ãæ®ãããç¨ç·ã®ãã¼ã¿ã§ããã</p>
     *
     * <p>éåã®åè¦ç´ ã®ãªãã¸ã§ã¯ããã­ããã£ã¯æ¬¡ã®ããã«ãªãã</p>
     * <pre>
     *   ei: å¢çç·ã¨äº¤å·®ããç¨ç·ã®çµç¹ã¤ã³ããã¯ã¹
     *   qx: å¢çç·ã¨ç¨ç·ãäº¤å·®ããä½ç½®ã® x åº§æ¨
     *   qy: å¢çç·ã¨ç¨ç·ãäº¤å·®ããä½ç½®ã® y åº§æ¨
     * </pre>
     *
     * @param {number} nx    åç©ºéã®åå´æ¹åã® x åº§æ¨
     * @param {number} ny    åç©ºéã®åå´æ¹åã® y åº§æ¨
     * @param {number} dval  å¤å®ç¨æ°å¤
     *
     * @return {object[]}  2ç¨ç·ã®äº¤å·®ãã¼ã¿
     *
     * @throws Error  2ç¹ã®äº¤å·®ãè¦ã¤ãããªãã£ã
     *
     * @private
     */

  }, {
    key: "_get_cross_edges_by_crossed_halfspace_boundary",
    value: function _get_cross_edges_by_crossed_halfspace_boundary(nx, ny, dval) {
      var cross_edges = new Array(2);

      for (var si = 0, ce_count = 0; ce_count < 2; ++si) {
        if (si == this._num_vertices) {
          // å¦¥å½ã§ãªãå¸å¤è§å½¢ãæ°å¤è¨ç®èª¤å·®ãéæ°å¤ã®æ··å¥ãªã©ã§
          // 2ç¹ã®äº¤å·®ãè¦ã¤ããããç¡éã«ã¼ãã«ãªãå¯è½æ§ããã
          // ãããé¿ããããããã¹ã¦ã®ç¨ç·ãèª¿ã¹çµãã£ããä¾å¤ã§
          // å¼·å¶çã«çµäºãã
          throw new Error("cross edges could not be found");
        }

        var ei = (si + 1) % this._num_vertices; // ç¨ç·ã®å§ç¹ä½ç½®

        var sx = this._vertices[2 * si];
        var sy = this._vertices[2 * si + 1]; // ç¨ç·ã®çµç¹ä½ç½®

        var ex = this._vertices[2 * ei];
        var ey = this._vertices[2 * ei + 1]; // å¢çç·ããã®è·é¢

        var sd = sx * nx + sy * ny - dval;
        var ed = ex * nx + ey * ny - dval; // åç©ºéå¢çç·ã¨ si-ei ç¨ç·ã®äº¤å·®ãããã°ãã¼ã¿ãè¿½å 

        if (sd <= 0 && 0 < ed || ed <= 0 && 0 < sd) {
          var t = sd / (sd - ed);
          var qx = sx + (ex - sx) * t;
          var qy = sy + (ey - sy) * t;
          cross_edges[sd < ed ? 0 : 1] = {
            ei: ei,
            qx: qx,
            qy: qy
          };
          ++ce_count;
        }
      }

      return cross_edges;
    }
  }, {
    key: "num_vertices",
    get: function get() {
      return this._num_vertices;
    }
    /**
     * @summary å¸å¤è§å½¢ã®é ç¹åº§æ¨éå
     *
     * @desc
     * <p>åæè¨åãã§æ ¼ç´ãããé ç¹åº§æ¨ã®éå [x0, y0, x1, y1, ...] ãè¿ãã<p>
     * <p>è¿ãããéåã®åå®¹ã¯ this ã«å¯¾ãã¦å¤æ´æä½ãè¡ãããã¾ã§æå¹ã§ããã<p>
     *
     * @type {number[]}
     *
     * @readonly
     */

  }, {
    key: "vertices",
    get: function get() {
      return this._vertices;
    }
    /**
     * @summary ç©å½¢ããå¸å¤è§å½¢ãçæ
     *
     * @param {number} x_min  x åº§æ¨ã®æå°å¤
     * @param {number} y_min  y åº§æ¨ã®æå°å¤
     * @param {number} x_max  x åº§æ¨ã®æå¤§å¤
     * @param {number} y_max  y åº§æ¨ã®æå¤§å¤
     *
     * @return {mapray.ConvexPolygon}  å¸å¤è§å½¢
     */

  }], [{
    key: "createByRectangle",
    value: function createByRectangle(x_min, y_min, x_max, y_max) {
      // å¥ååº§æ¨éå
      var coords = [x_min, y_min, x_max, y_min, x_max, y_max, x_min, y_max]; // å¸å¤è§å½¢ãçæ

      return new ConvexPolygon(coords);
    }
  }]);

  return ConvexPolygon;
}();

/**
 * @summary å¤è§å½¢ã¨ã³ãã£ãã£
 * @memberof mapray
 * @extends mapray.Entity
 */

var PolygonEntity =
/*#__PURE__*/
function (_Entity) {
  _inherits(PolygonEntity, _Entity);

  /**
   * @param {mapray.Scene} scene        æå±å¯è½ã·ã¼ã³
   * @param {object}       [opts]       ãªãã·ã§ã³éå
   * @param {object}       [opts.json]  çææå ±
   * @param {object}       [opts.refs]  åç§è¾æ¸
   */
  function PolygonEntity(scene, opts) {
    var _this;

    _classCallCheck(this, PolygonEntity);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolygonEntity).call(this, scene, opts));
    _this._extruded_height = 0.0;
    _this._color = GeoMath.createVector3([1, 1, 1]);
    _this._opacity = 1.0; // é ç¹ç®¡ç

    _this._boundaries = []; // Boundary ã®ãªã¹ã

    _this._position = null; // ä¸­å¤®ä»è¿ã® GeoPoint
    // this._producer
    // this._is_flake_mode

    if (_this.altitude_mode === AltitudeMode.CLAMP) {
      _this._producer = new FlakePrimitiveProducer$2(_assertThisInitialized(_this));
      _this._is_flake_mode = true;
    } else {
      _this._producer = new PrimitiveProducer$4(_assertThisInitialized(_this));
      _this._is_flake_mode = false;
    }

    _this._setupAnimationBindingBlock(); // çææå ±ããè¨­å®


    if (opts && opts.json) {
      _this._setupByJson(opts.json);
    }

    return _this;
  }
  /**
   * @summary æ¼ãåºãéï¼0ããå¤§ããå¤ï¼
   * @type {number}
   */


  _createClass(PolygonEntity, [{
    key: "getPrimitiveProducer",

    /**
     * @override
     */
    value: function getPrimitiveProducer() {
      return !this._is_flake_mode ? this._producer : null;
    }
    /**
     * @override
     */

  }, {
    key: "getFlakePrimitiveProducer",
    value: function getFlakePrimitiveProducer() {
      return this._is_flake_mode ? this._producer : null;
    }
    /**
     * @override
     */

  }, {
    key: "onChangeAltitudeMode",
    value: function onChangeAltitudeMode(prev_mode) {
      if (this.altitude_mode === AltitudeMode.CLAMP) {
        this._producer = new FlakePrimitiveProducer$2(this);
        this._is_flake_mode = true;
      } else {
        this._producer = new PrimitiveProducer$4(this);
        this._is_flake_mode = false;
      }
    }
    /**
     * ã¢ãã¡ã¼ã·ã§ã³ã® BindingBlock ãåæå
     *
     * @private
     */

  }, {
    key: "_setupAnimationBindingBlock",
    value: function _setupAnimationBindingBlock() {
      var _this2 = this;

      var block = this.animation; // å®ä½ã¯ EasyBindingBlock

      var number = Type.find("number");
      var vector3 = Type.find("vector3"); // ãã©ã¡ã¼ã¿å: color
      // ãã©ã¡ã¼ã¿å: vector3
      //   è²

      block.addEntry("color", [vector3], null, function (value) {
        _this2.setColor(value);
      }); // ãã©ã¡ã¼ã¿å: opacity
      // ãã©ã¡ã¼ã¿å: number
      //   ä¸éæåº¦

      block.addEntry("opacity", [number], null, function (value) {
        _this2.setOpacity(value);
      }); // ãã©ã¡ã¼ã¿å: height
      // ãã©ã¡ã¼ã¿å: number
      //   ç·ã®å¤ªã

      block.addEntry("height", [number], null, function (value) {
        _this2.setExtrudedHeight(value);
      });
    }
    /**
     * @summary åºæ¬è²ãè¨­å®
     * @param {mapray.Vector3} color  åºæ¬è²
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      if (this._color[0] !== color[0] || this._color[1] !== color[1] || this._color[2] !== color[2]) {
        GeoMath.copyVector3(color, this._color);

        this._producer.onChangeProperty();
      }
    }
    /**
     * @summary ä¸éæåº¦ãè¨­å®
     * @param {number} opacity  ä¸éæåº¦
     */

  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      if (this._opacity !== opacity) {
        this._opacity = opacity;

        this._producer.onChangeProperty();
      }
    }
    /**
     * @summary æ¼ãåºãéãè¨­å®
     * @param {number} opacity  æ¼ãåºãé
     */

  }, {
    key: "setExtrudedHeight",
    value: function setExtrudedHeight(height) {
      this.extruded_height = height;
    }
    /**
     * @summary å¤å´å¢çãè¿½å 
     *
     * @desc
     * <p>points ã¯ [lon_0, lat_0, alt_0, lon_1, lat_1, alt_1, ...] ã®ãããªå½¢å¼ã§éåãä¸ããã</p>
     *
     * @param {number[]} points  é ç¹ã®éå
     */

  }, {
    key: "addOuterBoundary",
    value: function addOuterBoundary(points) {
      this._addBoundary(points, false);
    }
    /**
     * @summary åå´å¢çãè¿½å 
     *
     * @desc
     * <p>points ã¯ [lon_0, lat_0, alt_0, lon_1, lat_1, alt_1, ...] ã®ãããªå½¢å¼ã§éåãä¸ããã</p>
     *
     * @param {number[]} points  é ç¹ã®éå
     */

  }, {
    key: "addInnerBoundary",
    value: function addInnerBoundary(points) {
      this._addBoundary(points, true);
    }
    /**
     * @summary ãã¹ã¦ã®é ç¹ã®ãã¦ã³ãã£ã³ã°ãç®åº
     *
     * @override
     * @return {mapray.GeoRegion}  ãã¦ã³ãã£ã³ã°æå ±ãæã£ãGeoRegion
     */

  }, {
    key: "getBounds",
    value: function getBounds() {
      var region = new GeoRegion();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._boundaries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var bo = _step.value;
          region.addPointsAsArray(bo.points);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return region;
    }
    /**
     * @summary å¢çãè¿½å 
     *
     * @desc
     * <p>addOuterBoundary(), addInnerBoundary() ã®å®è£ã§ããã</p>
     *
     * @param {number[]} points  é ç¹ã®éå
     *
     * @private
     */

  }, {
    key: "_addBoundary",
    value: function _addBoundary(points, is_inner) {
      this._boundaries.push(new Boundary(points, is_inner));

      this._position = null; // å¢çã®å¤æ´ãéç¥

      this._producer.onChangeBoundary();
    }
    /**
     * @summary å°ç¨ãããªã¢ã«ãåå¾
     * @private
     */

  }, {
    key: "_getMaterial",
    value: function _getMaterial(render_target) {
      var scene = this.scene;

      if (render_target === RenderTarget.SCENE) {
        if (!scene._PolygonEntity_material) {
          // scene ã«ãããªã¢ã«ãã­ã£ãã·ã¥
          scene._PolygonEntity_material = new PolygonMaterial(scene.glenv);
        }

        return scene._PolygonEntity_material;
      } else if (render_target === RenderTarget.RID) {
        if (!scene._PolygonEntity_material_pick) {
          // scene ã«ãããªã¢ã«ãã­ã£ãã·ã¥
          scene._PolygonEntity_material_pick = new PolygonMaterial(scene.glenv, {
            ridMaterial: true
          });
        }

        return scene._PolygonEntity_material_pick;
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setupByJson",
    value: function _setupByJson(json) {
      // json.boundaries
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = json.boundaries[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var boundary = _step2.value;

          if (boundary.type == "inner") {
            this.addInnerBoundary(boundary.points);
          } else {
            this.addOuterBoundary(boundary.points);
          }
        } // json.extruded_height

      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (json.extruded_height !== undefined) {
        this.extruded_height = json.extruded_height;
      } // json.color
      //     .opacity


      if (json.color !== undefined) GeoMath.copyVector3(json.color, this._color);
      if (json.opacity !== undefined) this._opacity = json.opacity;
    }
    /**
     * @summary ä¸­å¤®ä½ç½®ãåå¾
     *
     * @desc
     * <p>ä¸­å¤®ä½ç½®ãè¨ç®ãã¦è¿ããå¤è§å½¢ãå­å¨ããªãã¨ãã¯ null ãè¿ãã</p>
     *
     * <p>ä¸­å¤®ä½ç½®ãå¤åããå¯è½æ§ãããã¨ãã¯ this._position ã«ã null ãè¨­å®ãããã¨ã</p>
     *
     * <pre>
     * å¥å: this._boundaries
     * </pre>
     *
     * @return {mapray.GeoPoint}  ä¸­å¤®ä½ç½® (é«åº¦ã¯ 0) ã¾ãã¯ null
     *
     * @private
     */

  }, {
    key: "_getPosition",
    value: function _getPosition() {
      if (this._position !== null) {
        // ã­ã£ãã·ã¥ãã¦ããå¤ãè¿ã
        return this._position;
      }

      if (this._boundaries.length == 0) {
        // å¤è§å½¢ãå­å¨ããªã
        return null;
      }

      var min_lon = Number.MAX_VALUE;
      var max_lon = -Number.MAX_VALUE;
      var min_lat = Number.MAX_VALUE;
      var max_lat = -Number.MAX_VALUE;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this._boundaries[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var bo = _step3.value;
          var count = bo.num_points;
          var points = bo.points;

          for (var i = 0; i < count; ++i) {
            var lon = points[3 * i];
            var lat = points[3 * i + 1];
            if (lon < min_lon) min_lon = lon;
            if (lon > max_lon) max_lon = lon;
            if (lat < min_lat) min_lat = lat;
            if (lat > max_lat) max_lat = lat;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this._position = new GeoPoint((min_lon + max_lon) / 2, (min_lat + max_lat) / 2);
      return this._position;
    }
    /**
     * @summary ãã¹ã¦ã®å¢çã®é ç¹æ°ã®åè¨ãåå¾
     *
     * @private
     */

  }, {
    key: "_countNumPointsOnBoundaries",
    value: function _countNumPointsOnBoundaries() {
      var num_points = 0;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._boundaries[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var bo = _step4.value;
          num_points += bo.num_points;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return num_points;
    }
    /**
     * @summary çµåãããå¢çç¹åãåå¾
     *
     * @return {Float64Array}  çµåãããå¢çç¹å
     */

  }, {
    key: "_getCombinedBoundaryPoints",
    value: function _getCombinedBoundaryPoints() {
      var points = new Float64Array(3 * this._countNumPointsOnBoundaries());
      var offset = 0;
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this._boundaries[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var bo = _step5.value;
          points.set(bo.points, offset);
          offset += 3 * bo.num_points;
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return points;
    }
    /**
     * @summary çµåããã 2D å¢çç¹åãåå¾ (é«åº¦ãªã)
     *
     * @return {Float64Array}  çµåããã 2D å¢çç¹å
     */

  }, {
    key: "_getCombinedBoundary2DPoints",
    value: function _getCombinedBoundary2DPoints() {
      var dst_points = new Float64Array(2 * this._countNumPointsOnBoundaries());
      var di = 0;
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this._boundaries[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var bo = _step6.value;
          var src_size = 3 * bo.num_points;
          var src_points = bo.points;

          for (var si = 0; si < src_size; si += 3) {
            dst_points[di++] = src_points[si];
            dst_points[di++] = src_points[si + 1];
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return dst_points;
    }
    /**
     * @summary ä¸è§å½¢ãªã¹ããçæ
     *
     * @desc
     * <p>this.entity._boundaries ãä¸è§å½¢ã«å¤æãã¦ãªã¹ããè¿ãããã ãå¤æã«å¤±æããã¨ãã¯ null ãè¿ãã</p>
     *
     * @return {Uint32Array}  ä¸è§å½¢ãªã¹ãã¾ãã¯ null
     *
     * @private
     */

  }, {
    key: "_createTriangles",
    value: function _createTriangles() {
      var src_points = this._getCombinedBoundary2DPoints();

      var num_src_points = this._countNumPointsOnBoundaries(); // å¢çãç»é²


      var triangulator = new Triangulator(src_points, 0, 2, num_src_points);
      var index = 0;
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this._boundaries[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var bo = _step7.value;
          var num_indices = bo.num_points;
          var indices = new Uint32Array(num_indices);

          for (var i = 0; i < num_indices; ++i) {
            indices[i] = index++;
          }

          triangulator.addBoundary(indices);
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      try {
        // å¤æãå®è¡
        return triangulator.run();
      } catch (e) {
        // å¤æã«å¤±æ
        console.error(e.message);
        return null;
      }
    }
  }, {
    key: "extruded_height",
    set: function set(value) {
      var prev = this._extruded_height;

      if (prev !== value) {
        this._extruded_height = value;

        this._producer.onChangeExtruded();
      }
    }
    /**
     * @summary æ¼ãåºãé
     * @type {number}
     */
    ,
    get: function get() {
      return this._extruded_height;
    }
  }]);

  return PolygonEntity;
}(Entity);
/**
 * @summary PolygonEntity ã® PrimitiveProducer
 *
 * @private
 */


var PrimitiveProducer$4 =
/*#__PURE__*/
function (_Entity$PrimitiveProd) {
  _inherits(PrimitiveProducer, _Entity$PrimitiveProd);

  /**
   * @param {mapray.PolygonEntity} entity
   */
  function PrimitiveProducer(entity) {
    var _this3;

    _classCallCheck(this, PrimitiveProducer);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(PrimitiveProducer).call(this, entity));
    _this3._status = Status$3.INVALID;
    _this3._triangles = null; // ä¸è§å½¢ãªã¹ã (Uint32Array)
    // ããªããã£ãã®è¦ç´ 

    _this3._transform = GeoMath.setIdentity(GeoMath.createMatrix());
    _this3._pivot = GeoMath.createVector3();
    _this3._bbox = [GeoMath.createVector3(), GeoMath.createVector3()];
    _this3._properties = {
      color: GeoMath.createVector3f(),
      opacity: 1.0,
      lighting: false
    }; // ããªããã£ã

    var primitive = new Primitive(entity.glenv, null, entity._getMaterial(RenderTarget.SCENE), _this3._transform);
    primitive.pivot = _this3._pivot;
    primitive.bbox = _this3._bbox;
    primitive.properties = _this3._properties;
    _this3._primitive = primitive;
    var pickPrimitive = new Primitive(entity.glenv, null, entity._getMaterial(RenderTarget.RID), _this3._transform);
    pickPrimitive.pivot = _this3._pivot;
    pickPrimitive.bbox = _this3._bbox;
    pickPrimitive.properties = _this3._properties;
    _this3._pickPrimitive = pickPrimitive;
    return _this3;
  }
  /**
   * @override
   */


  _createClass(PrimitiveProducer, [{
    key: "needsElevation",
    value: function needsElevation() {
      var owner = this.entity;
      return owner.altitude_mode !== AltitudeMode.ABSOLUTE;
    }
    /**
     * @override
     */

  }, {
    key: "createRegions",
    value: function createRegions() {
      var owner = this.entity;

      if (this._status === Status$3.INVALID) {
        // å¤è§å½¢ãªããã¾ãã¯ä¸è§å½¢ã«å¤æã§ããªãã£ãã¨ã
        return [];
      } // æ­£å¸¸ãªå¤è§å½¢ã®ã¨ã


      var region = new EntityRegion();
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = owner._boundaries[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var bo = _step8.value;
          region.addPoints(bo.points, 0, 3, bo.num_points);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      region.addPoint(owner._getPosition());
      return [region];
    }
    /**
     * @override
     */

  }, {
    key: "onChangeElevation",
    value: function onChangeElevation(regions) {
      if (this._status === Status$3.NORMAL) {
        this._status = Status$3.MESH_DIRTY;
      }
    }
    /**
     * @override
     */

  }, {
    key: "getPrimitives",
    value: function getPrimitives(stage) {
      if (this._status === Status$3.INVALID) {
        // å¤è§å½¢ãªããã¾ãã¯ä¸è§å½¢ã«å¤æã§ããªãã£ãã¨ã
        return [];
      } else if (this._status === Status$3.TRIANGLE_DIRTY) {
        this._triangles = this.entity._createTriangles();

        if (this._triangles === null) {
          // å¤è§å½¢ã®ä¸è§å½¢åã«å¤±æ
          this._primitive.mesh = null;
          this._pickPrimitive.mesh = null;
          this._status = Status$3.INVALID;
          return [];
        }

        this._updatePrimitiveMesh();
      } else if (this._status === Status$3.MESH_DIRTY) {
        this._updatePrimitiveMesh();
      }

      this._updatePrimitiveProperties();

      this._status = Status$3.NORMAL;
      return stage.getRenderTarget() === RenderTarget.SCENE ? [this._primitive] : [this._pickPrimitive];
    }
    /**
     * @summary æ¼ãåºãã¢ã¼ããå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeExtruded",
    value: function onChangeExtruded() {
      if (this._status === Status$3.NORMAL) {
        this._status = Status$3.MESH_DIRTY;
      }
    }
    /**
     * @summary ãã­ããã£ãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeProperty",
    value: function onChangeProperty() {} // ãããã¨ãªã

    /**
     * @summary å¢çãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeBoundary",
    value: function onChangeBoundary() {
      this._status = Status$3.TRIANGLE_DIRTY;
      this._triangles = null;
      this.needToCreateRegions();
    }
    /**
     * @summary ããªããã£ãã®æ´æ°
     *
     * å¥å:
     *   this.entity
     *   this._triangles
     * åºå:
     *   this._transform
     *   this._pivot
     *   this._bbox
     *   this._primitive.mesh
     *
     * @private
     */

  }, {
    key: "_updatePrimitiveMesh",
    value: function _updatePrimitiveMesh() {
      var cb_data = new BoundaryConbiner(this.entity); // ããªããã£ãã®æ´æ°
      //   primitive.transform
      //   primitive.pivot
      //   primitive.bbox

      this._updateTransformPivotBBox(cb_data); // ã¡ãã·ã¥çæ


      var mesh_data = {
        vtype: [{
          name: "a_position",
          size: 3
        }, {
          name: "a_normal",
          size: 3
        }],
        vertices: this._createVertices(cb_data),
        indices: this._createIndices(cb_data)
      };
      var mesh = new Mesh(this.entity.scene.glenv, mesh_data); // ã¡ãã·ã¥è¨­å®

      this._primitive.mesh = mesh;
      this._pickPrimitive.mesh = mesh;
    }
    /**
     * @summary ããªããã£ãã®æ´æ°
     *
     * @desc
     * <pre>
     * åºå:
     *   this._transform
     *   this._pivot
     *   this._bbox
     * </pre>
     *
     * @param {BoundaryConbiner} cb_data  å¥åãã¼ã¿
     *
     * @private
     */

  }, {
    key: "_updateTransformPivotBBox",
    value: function _updateTransformPivotBBox(cb_data) {
      // å¤æè¡åã®æ´æ°
      var transform = this._transform;
      transform[12] = cb_data.origin[0];
      transform[13] = cb_data.origin[1];
      transform[14] = cb_data.origin[2]; // çµ±è¨

      var xmin = Number.MAX_VALUE;
      var ymin = Number.MAX_VALUE;
      var zmin = Number.MAX_VALUE;
      var xmax = -Number.MAX_VALUE;
      var ymax = -Number.MAX_VALUE;
      var zmax = -Number.MAX_VALUE; // [cb_data.upper, cb_data.lower]

      var points_array = [cb_data.upper];

      if (cb_data.lower) {
        points_array.push(cb_data.lower);
      }

      for (var j = 0; j < points_array.length; ++j) {
        var points = points_array[j];

        for (var i = 0; i < cb_data.num_points; ++i) {
          var b = 3 * i;
          var x = points[b];
          var y = points[b + 1];
          var z = points[b + 2];

          if (x < xmin) {
            xmin = x;
          }

          if (y < ymin) {
            ymin = y;
          }

          if (z < zmin) {
            zmin = z;
          }

          if (x > xmax) {
            xmax = x;
          }

          if (y > ymax) {
            ymax = y;
          }

          if (z > zmax) {
            zmax = z;
          }
        }
      } // ä¸­å¿ç¹


      var pivot = this._pivot;
      pivot[0] = (xmin + xmax) / 2;
      pivot[1] = (ymin + ymax) / 2;
      pivot[2] = (zmin + zmax) / 2; // å¢çç®±

      var bbox = this._bbox;
      var bmin = bbox[0];
      var bmax = bbox[1];
      bmin[0] = xmin;
      bmin[1] = ymin;
      bmin[2] = zmin;
      bmax[0] = xmax;
      bmax[1] = ymax;
      bmax[2] = zmax;
    }
    /**
     * @summary é ç¹éåã®çæ
     *
     * @desc
     * çæãããå½¢å¼ã¯ [Px, Py, Pz, Nx, Ny, Nz, ...] ã®ãããªå½¢ã§ãããããã®åº§æ¨ã¯ã­ã¼ã«ã«åº§æ¨ç³»ã«ãªãã
     * éåã®é ç¹ãã¼ã¿ã¯ 2 ã¤ã®é åã§åãããä¸é¢ããªã´ã³ã®é ç¹éå(S1) â å´é¢ããªã´ã³ã®é ç¹éå(S2) ã®é åºã§æ ¼ç´ãããã
     * ãã ã cb_data.lower == null ã®ã¨ããéåã¯ S1 é¨åããè¨­å®ãããªãã
     *
     * S1 ã¯ cb_data.upper ã«å¯¾å¿ããé ç¹ãã¼ã¿ãåãé åºã§æ ¼ç´ãããã
     *
     * S2 ã¯ cb_data.num_points åã®åè§å½¢ã«å¯¾ããé ç¹ãã¼ã¿ãé çªã«ä¸¦ãã§ããã
     * ååè§å½¢ã®é ç¹ãã¼ã¿ã¯ å·¦ä¸ãå³ä¸ãå·¦ä¸ãå³ä¸ ã®é åºã§æ ¼ç´ããã¦ããã
     *
     * å¥å: this.entity._boundaries
     *
     * @param {BoundaryConbiner} cb_data  å¥åãã¼ã¿
     *
     * @return {Float32Array}  Mesh ç¨ã®é ç¹éå
     *
     * @private
     */

  }, {
    key: "_createVertices",
    value: function _createVertices(cb_data) {
      var fpv = 6; // 1é ç¹ãã¼ã¿ãããã® float æ°

      var s1_num_floats = fpv * cb_data.num_points; // ä¸é¢ã®ãã¼ã¿ãµã¤ãº

      var s2_num_floats = cb_data.lower ? fpv * (4 * cb_data.num_points) : 0; // å´é¢ã®ãã¼ã¿ãµã¤ãº

      var s3_num_floats = cb_data.lower ? s1_num_floats : 0; // åºé¢ã®ãã¼ã¿ãµã¤ãº

      var vertices = new Float32Array(s1_num_floats + s2_num_floats + s3_num_floats); // ä¸é¢ã®æ³ç·ãåå¾

      var unormal = GeoMath.normalize3(cb_data.origin, GeoMath.createVector3()); // ä¸é¢ã®é ç¹ãã¼ã¿

      for (var i = 0; i < cb_data.num_points; ++i) {
        var b = 3 * i;
        var px = cb_data.upper[b];
        var py = cb_data.upper[b + 1];
        var pz = cb_data.upper[b + 2];
        var vi = fpv * i;
        vertices[vi] = px; // a_position.x

        vertices[vi + 1] = py; // a_position.y

        vertices[vi + 2] = pz; // a_position.z

        setVec3ToArray(unormal, vertices, vi + 3); // a_normal
      } // å´é¢ã®é ç¹ãã¼ã¿


      if (cb_data.lower) {
        var p00 = GeoMath.createVector3(); // å·¦ä¸ä½ç½®

        var p10 = GeoMath.createVector3(); // å³ä¸ä½ç½®

        var p01 = GeoMath.createVector3(); // å·¦ä¸ä½ç½®

        var p11 = GeoMath.createVector3(); // å³ä¸ä½ç½®

        var snormal = GeoMath.createVector3(); // å´é¢ã®æ³ç·

        var beg_i = 0; // bo ã®æåã®é ç¹ã®ã¤ã³ããã¯ã¹

        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = this.entity._boundaries[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var bo = _step9.value;
            var end_i = beg_i + bo.num_points; // bo ã®æå¾ã®é ç¹ã®ã¤ã³ããã¯ã¹ + 1

            for (var _i = beg_i; _i < end_i; ++_i) {
              var i0 = _i;
              var i1 = _i + 1 < end_i ? _i + 1 : beg_i; // åéã®ä½ç½®ãåå¾

              var b0 = 3 * i0;
              var b1 = 3 * i1;
              setArrayToVec3(cb_data.lower, b0, p00);
              setArrayToVec3(cb_data.lower, b1, p10);
              setArrayToVec3(cb_data.upper, b0, p01);
              setArrayToVec3(cb_data.upper, b1, p11); // å´é¢ã®æ³ç·ãåå¾

              setTriangleNormal(p00, p10, p01, snormal); // åéã®é ç¹ãã¼ã¿ãè¨­å®

              var _vi = s1_num_floats + 4 * fpv * _i;

              setVec3ToArray(p00, vertices, _vi); // a_position

              setVec3ToArray(snormal, vertices, _vi + 3); // a_normal

              _vi += fpv;
              setVec3ToArray(p10, vertices, _vi); // a_position

              setVec3ToArray(snormal, vertices, _vi + 3); // a_normal

              _vi += fpv;
              setVec3ToArray(p01, vertices, _vi); // a_position

              setVec3ToArray(snormal, vertices, _vi + 3); // a_normal

              _vi += fpv;
              setVec3ToArray(p11, vertices, _vi); // a_position

              setVec3ToArray(snormal, vertices, _vi + 3); // a_normal
            }

            beg_i = end_i;
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
              _iterator9["return"]();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }
      }

      if (cb_data.lower) {
        var bnormal = GeoMath.scale3(-1.0, unormal, GeoMath.createVector3()); // åºé¢ã®é ç¹ãã¼ã¿

        for (var _i2 = 0; _i2 < cb_data.num_points; ++_i2) {
          var _b = 3 * _i2;

          var _px = cb_data.lower[_b];
          var _py = cb_data.lower[_b + 1];
          var _pz = cb_data.lower[_b + 2];

          var _vi2 = s1_num_floats + s2_num_floats + fpv * _i2;

          vertices[_vi2] = _px; // a_position.x

          vertices[_vi2 + 1] = _py; // a_position.y

          vertices[_vi2 + 2] = _pz; // a_position.z

          setVec3ToArray(bnormal, vertices, _vi2 + 3); // a_normal
        }
      }

      return vertices;
    }
    /**
     * @summary ã¤ã³ããã¯ã¹éåã®çæ
     *
     * å¥å: this._triangles
     *
     * @param {BoundaryConbiner} cb_data  å¥åãã¼ã¿
     *
     * @return {Uint32Array}  ã¤ã³ããã¯ã¹éå
     *
     * @private
     */

  }, {
    key: "_createIndices",
    value: function _createIndices(cb_data) {
      // é ç¹ã®ä¸¦ã³ã¯ _createVertices() ãåç§
      var num_upper_triangles = this._triangles.length / 3;
      var num_side_triangles = cb_data.lower ? 2 * cb_data.num_points : 0;
      var num_bottom_triangles = cb_data.lower ? num_upper_triangles : 0;
      var indices = new Uint32Array(3 * (num_upper_triangles + num_side_triangles + num_bottom_triangles)); // ååã«ä¸é¢ã®ããªã´ã³ãè¨­å®

      indices.set(this._triangles); // å´é¢ã®ããªã´ã³ãè¨­å®

      if (cb_data.lower) {
        var num_quads = cb_data.num_points;
        var ioffset = 3 * num_upper_triangles; // indices åã®ç¾å¨ã®åè§å½¢ã®ãªãã»ãã

        var voffset = cb_data.num_points; // é ç¹éååã®ç¾å¨ã®åè§å½¢ã®ãªãã»ãã

        for (var i = 0; i < num_quads; ++i, ioffset += 6, voffset += 4) {
          // å·¦ä¸ä¸è§å½¢
          indices[ioffset] = voffset;
          indices[ioffset + 1] = voffset + 1;
          indices[ioffset + 2] = voffset + 2; // å³ä¸ä¸è§å½¢

          indices[ioffset + 3] = voffset + 2;
          indices[ioffset + 4] = voffset + 1;
          indices[ioffset + 5] = voffset + 3;
        }
      } // åºé¢ã®ããªã´ã³ãè¨­å®


      if (cb_data.lower) {
        var len = this._triangles.length / 3;

        var _voffset = cb_data.num_points + 4 * cb_data.num_points;

        for (var _i3 = 0; _i3 < len; ++_i3) {
          indices[(num_upper_triangles + num_side_triangles + _i3) * 3 + 0] = this._triangles[_i3 * 3 + 0] + _voffset;
          indices[(num_upper_triangles + num_side_triangles + _i3) * 3 + 1] = this._triangles[_i3 * 3 + 2] + _voffset;
          indices[(num_upper_triangles + num_side_triangles + _i3) * 3 + 2] = this._triangles[_i3 * 3 + 1] + _voffset;
        }
      }

      return indices;
    }
    /**
     * @summary ããªããã£ãã®ãã­ããã£ãæ´æ°
     *
     * å¥å: this.entity
     * åºå: this._properties
     *
     * @private
     */

  }, {
    key: "_updatePrimitiveProperties",
    value: function _updatePrimitiveProperties() {
      var owner = this.entity;
      var props = this._properties;
      GeoMath.copyVector3(owner._color, props.color);
      props.opacity = owner._opacity;
      props.lighting = this.extruded_height !== 0.0;
    }
  }]);

  return PrimitiveProducer;
}(Entity.PrimitiveProducer);
/**
 * @summary PolygonEntity ã® FlakePrimitiveProducer
 *
 * @private
 */


var FlakePrimitiveProducer$2 =
/*#__PURE__*/
function (_Entity$FlakePrimitiv) {
  _inherits(FlakePrimitiveProducer, _Entity$FlakePrimitiv);

  /**
   * @param {mapray.PolygonEntity} entity
   */
  function FlakePrimitiveProducer(entity) {
    var _this4;

    _classCallCheck(this, FlakePrimitiveProducer);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(FlakePrimitiveProducer).call(this, entity));
    _this4._material_map = Object.keys(RenderTarget).reduce(function (map, key) {
      var render_target = RenderTarget[key];
      map.set(render_target, entity._getMaterial(render_target));
      return map;
    }, new Map());
    _this4._properties = null;
    _this4._area_manager = new PolygonAreaManager(entity);
    return _this4;
  }
  /**
   * @override
   */


  _createClass(FlakePrimitiveProducer, [{
    key: "getAreaStatus",
    value: function getAreaStatus(area) {
      return this._area_manager.getAreaStatus(area);
    }
    /**
     * @override
     */

  }, {
    key: "createMesh",
    value: function createMesh(area, dpows, dem) {
      // ConvexPolygon ã®éåãã¾ãã¯ Entity.AreaStatus.FULL
      var polygons = this._area_manager.getAreaContent(area);

      var msize = Math.PI * Math.pow(2, 1 - area.z);
      var x_min = area.x * msize - Math.PI;
      var y_min = Math.PI - (area.y + 1) * msize;
      var div_x = 1 << dpows[0];
      var div_y = 1 << dpows[1]; // ãµãã¡ãã·ã¥ã®éåãçæ

      var submeshes = this._createSubmeshes(x_min, y_min, x_min + msize, y_min + msize, div_x, div_y, polygons); // ã¡ãã·ã¥çæ


      var mesh_data = {
        vtype: [{
          name: "a_position",
          size: 3
        }, {
          name: "a_normal",
          size: 3
        }],
        vertices: this._createVertices(submeshes, area, dem),
        indices: this._createIndices(submeshes)
      };
      return new Mesh(this.entity.scene.glenv, mesh_data);
    }
    /**
     * @override
     */

  }, {
    key: "getMaterialAndProperties",
    value: function getMaterialAndProperties(stage) {
      if (this._properties === null) {
        var entity = this.entity;
        this._properties = {
          color: GeoMath.createVector3f(entity._color),
          opacity: entity._opacity,
          lighting: false
        };
      }

      return {
        material: this._material_map.get(stage.getRenderTarget()),
        properties: this._properties
      };
    }
    /**
     * @summary æ¼ãåºãã¢ã¼ããå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeExtruded",
    value: function onChangeExtruded() {} // flake_mode ãªã®ã§æ¼ãåºãã¢ã¼ãã¯é¢ä¿ãªã

    /**
     * @summary ãã­ããã£ãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeProperty",
    value: function onChangeProperty() {
      this._properties = null;
    }
    /**
     * @summary å¢çãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeBoundary",
    value: function onChangeBoundary() {
      this._area_manager.notifyForUpdateContent();

      this.notifyForUpdate();
    }
    /**
     * @summary é ç¹éåãçæ
     *
     * @param {iterable.<Submesh>} submeshes
     * @param {mapray.Area}        area
     * @param {mapray.DemBinary}   dem
     *
     * @return {Float32Array}
     *
     * @private
     */

  }, {
    key: "_createVertices",
    value: function _createVertices(submeshes, area, dem) {
      var origin = AreaUtil.getCenter(area, GeoMath.createVector3());
      var sampler = dem.newSampler(area); // é ç¹éåãçæ

      var num_vertices = 0;
      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = submeshes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var smesh = _step10.value;
          num_vertices += smesh.getNumVertices();
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
            _iterator10["return"]();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }

      var vertices = new Float32Array(6 * num_vertices); // é ç¹éåã«åº§æ¨ãæ¸ãè¾¼ã

      var offset = 0;
      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = submeshes[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var _smesh = _step11.value;
          offset = _smesh.addVertices(origin, sampler, vertices, offset);
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
            _iterator11["return"]();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }

      return vertices;
    }
    /**
     * @summary ã¤ã³ããã¯ã¹éåãçæ
     *
     * @param {iterable.<Submesh>} submeshes
     *
     * @return {Uint32Array}
     *
     * @private
     */

  }, {
    key: "_createIndices",
    value: function _createIndices(submeshes) {
      // ã¤ã³ããã¯ã¹éåãçæ
      var num_triangles = 0;
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = submeshes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var smesh = _step12.value;
          num_triangles += smesh.getNumTriangles();
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
            _iterator12["return"]();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }

      var indices = new Uint32Array(3 * num_triangles); // ã¤ã³ããã¯ã¹éåã«ã¤ã³ããã¯ã¹ãæ¸ãè¾¼ã

      var voffset = 0;
      var ioffset = 0;
      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = submeshes[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          var _smesh2 = _step13.value;
          ioffset = _smesh2.addIndices(voffset, indices, ioffset);
          voffset += _smesh2.getNumVertices();
        }
      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
            _iterator13["return"]();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }

      return indices;
    }
    /**
     * @summary ãµãã¡ãã·ã¥ã®éåãçæ
     *
     * <p>polygons ã¯é åã¨äº¤å·®ãã ConvexPolygon ã®éåã§ããããã ãé åãå¤è§å½¢ã§è¦ããã¦ããã¨ãã¯
     * Entity.AreaStatus.FULL ã«ãªãå ´åãããã</p>
     *
     * @param {number} x_min  é åã®æå° x åº§æ¨
     * @param {number} y_min  é åã®æå° y åº§æ¨
     * @param {number} x_max  é åã®æå¤§ x åº§æ¨
     * @param {number} y_max  é åã®æå¤§ y åº§æ¨
     * @param {number} div_x  é åã® x æ¹åã®åå²æ°
     * @param {number} div_y  é åã® y æ¹åã®åå²æ°
     * @param {iterable.<mapray.ConvexPolygon>|mapray.Entity.AreaStatus} polygons
     *
     * @return {iterable.<Submesh>}  ãµãã¡ãã·ã¥ã®éå
     *
     * @private
     */

  }, {
    key: "_createSubmeshes",
    value: function _createSubmeshes(x_min, y_min, x_max, y_max, div_x, div_y, polygons) {
      if (polygons === Entity.AreaStatus.FULL) {
        // é ååã¯å¤è§å½¢ã«è¦ããã¦ãã
        return [new RectSubmesh(x_min, y_min, x_max, y_max, div_x, div_y)];
      } else if (polygons.length == 0) {
        // é ååã«å¤è§å½¢ã¯ç¡ã
        return [];
      } else if (div_x == 1 && div_y == 1) {
        // ããä»¥ä¸åå²ã§ããªãã®ã§åãåãå¤è§å½¢ãè¿ã
        var t1 = [x_min, y_min, x_max, y_min, x_min, y_max]; // å·¦ä¸ä¸è§å½¢

        var t2 = [x_min, y_max, x_max, y_min, x_max, y_max]; // å³ä¸ä¸è§å½¢

        var m1 = this._create_clipped_polygons_submeshes(t1, polygons);

        var m2 = this._create_clipped_polygons_submeshes(t2, polygons);

        return m1.concat(m2);
      } else {
        if (div_x >= div_y) {
          // å·¦å³åå²
          var msize = (x_max - x_min) / 2;
          var div_w = div_x / 2;

          var _m = this._create_submeshes_sp(x_min, y_min, x_min + msize, y_max, div_w, div_y, polygons);

          var _m2 = this._create_submeshes_sp(x_min + msize, y_min, x_max, y_max, div_w, div_y, polygons);

          return _m.concat(_m2);
        } else {
          // ä¸ä¸åå²
          var _msize = (y_max - y_min) / 2;

          var _div_w = div_y / 2;

          var _m3 = this._create_submeshes_sp(x_min, y_min, x_max, y_min + _msize, div_x, _div_w, polygons);

          var _m4 = this._create_submeshes_sp(x_min, y_min + _msize, x_max, y_max, div_x, _div_w, polygons);

          return _m3.concat(_m4);
        }
      }
    }
    /**
     * @summary ãµãã¡ãã·ã¥ã®éåãçæ
     *
     * @desc
     * <p>_createSubmeshes() ã¨ã®éãã¯ polygons ã« Entity.AreaStatus.FULL ãæå®ã§ããªãã
     * ã¾ããpolygons ã«ã¯é åã®å¤å´ã®å¤è§å½¢ãå«ã¾ãã¦ããå¯è½æ§ãããã</p>
     *
     * @param {number} x_min  é åã®æå° x åº§æ¨
     * @param {number} y_min  é åã®æå° y åº§æ¨
     * @param {number} x_max  é åã®æå¤§ x åº§æ¨
     * @param {number} y_max  é åã®æå¤§ y åº§æ¨
     * @param {number} div_x  é åã® x æ¹åã®åå²æ°
     * @param {number} div_y  é åã® y æ¹åã®åå²æ°
     * @param {iterable.<mapray.ConvexPolygon>} polygons
     *
     * @return {Submesh[]}  ãµãã¡ãã·ã¥ã®éå
     *
     * @private
     */

  }, {
    key: "_create_submeshes_sp",
    value: function _create_submeshes_sp(x_min, y_min, x_max, y_max, div_x, div_y, polygons) {
      // é åãå¸å¤è§å½¢ã«å¤æ
      var area_rect = ConvexPolygon.createByRectangle(x_min, y_min, x_max, y_max);
      var selected_polygons = [];
      var _iteratorNormalCompletion14 = true;
      var _didIteratorError14 = false;
      var _iteratorError14 = undefined;

      try {
        for (var _iterator14 = polygons[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
          var polygon = _step14.value;

          if (polygon.includes(area_rect)) {
            // polygon ã¯ area_rect ãè¦ã
            // ã¤ã¾ã area_rect ã¯å¨ä½ã®å¤è§å½¢ã«è¦ããã¦ãã
            selected_polygons = Entity.AreaStatus.FULL;
            break;
          }

          try {
            if (area_rect.hasIntersection(polygon)) {
              // é åã¨äº¤å·®ãã¦ããã®ã§ polygon è¿½å 
              selected_polygons.push(polygon);
            }
          } catch (e) {// polygon ã®äº¤å·®å¤å®ã«å¤±æããã¨ãã¯ polygon ã¯ç¡ããã¨ã«ãã
          }
        }
      } catch (err) {
        _didIteratorError14 = true;
        _iteratorError14 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
            _iterator14["return"]();
          }
        } finally {
          if (_didIteratorError14) {
            throw _iteratorError14;
          }
        }
      }

      return this._createSubmeshes(x_min, y_min, x_max, y_max, div_x, div_y, selected_polygons);
    }
    /**
     * @summary å¸å¤è§å½¢ã®ãµãã¡ãã·ã¥ã®éåãçæ
     * 
     * @desc
     * <p>area_triangle ã®ä¸è§å½¢ã§ src_polygons ã®å¸å¤è§å½¢ãåãåãããããã®åãåãããå¸å¤è§å½¢ã«å¯¾å¿ãã
     * PolygonsSubmesh ã¤ã³ã¹ã¿ã³ã¹ã®éåãçæããã</p>
     *
     * arit = Area Right Isosceles Triangle (é åç´è§äºç­è¾ºä¸è§å½¢)
     *
     * @param {number[]}                        arit_coords   é åã®ä¸è§å½¢åº§æ¨éå (å·¦ä¸ã¾ãã¯å³ä¸ã®ä¸è§å½¢)
     * @param {iterable.<mapray.ConvexPolygon>} src_polygons  åãåãå¯¾è±¡ã®å¸å¤è§å½¢ã®éå
     *
     * @return {PolygonsSubmesh[]}  PolygonsSubmesh ã®éå
     *
     * @private
     */

  }, {
    key: "_create_clipped_polygons_submeshes",
    value: function _create_clipped_polygons_submeshes(arit_coords, src_polygons) {
      var area_polygon = new ConvexPolygon(arit_coords);
      var clipped_polygons = [];
      var _iteratorNormalCompletion15 = true;
      var _didIteratorError15 = false;
      var _iteratorError15 = undefined;

      try {
        for (var _iterator15 = src_polygons[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
          var polygon = _step15.value;

          try {
            var clipped = area_polygon.getIntersection(polygon);

            if (clipped !== null) {
              clipped_polygons.push(clipped);
            }
          } catch (e) {// polygon ã®åãæãã«å¤±æããã¨ãã¯ polygon ã®åãæãã¯è¿ããªã
          }
        }
      } catch (err) {
        _didIteratorError15 = true;
        _iteratorError15 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
            _iterator15["return"]();
          }
        } finally {
          if (_didIteratorError15) {
            throw _iteratorError15;
          }
        }
      }

      if (clipped_polygons.length > 0) {
        return [new PolygonsSubmesh(arit_coords, clipped_polygons)];
      } else {
        return [];
      }
    }
  }]);

  return FlakePrimitiveProducer;
}(Entity.FlakePrimitiveProducer);
/**
 * @summary å¤è§å½¢ã®å¢ç
 *
 * @classdesc
 * <p>å¤è§å½¢ã®1ã¤ã®å¢çãè¡¨ç¾ããã</p>
 * <p>å¤å´å¢çã®ã¨ãã¯åæè¨åããåå´å¢çã®ã¨ãã¯æè¨åãã§æ ¼ç´ãããã</p>
 *
 * @private
 */


var Boundary =
/*#__PURE__*/
function () {
  /**
   * @desc
   * <p>points ã¯ addOuterBoundary(), addInnerBoundary() ã¨åãå½¢å¼ã§ããã</p>
   *
   * @param {number[]} points    å¢çã®é ç¹ãã¼ã¿
   * @param {boolean}  is_inner  åå´å¢çãï¼
   */
  function Boundary(points, is_inner) {
    _classCallCheck(this, Boundary);

    var num_points = Math.floor(points.length / 3);
    this._points = new Float64Array(3 * num_points);
    this._num_points = num_points;
    var is_ccw = Boundary.isCCW(points, num_points);
    var si;
    var si_step;

    if (!is_inner && is_ccw || is_inner && !is_ccw) {
      // é æ¹å
      si = 0;
      si_step = 3;
    } else {
      // éæ¹å
      si = 3 * (num_points - 1);
      si_step = -3;
    } // åé¨ã®éåã«ã³ãã¼


    for (var i = 0; i < num_points; ++i) {
      this._points[3 * i] = points[si];
      this._points[3 * i + 1] = points[si + 1];
      this._points[3 * i + 2] = points[si + 2];
      si += si_step;
    }
  }
  /**
   * @summary é ç¹åº§æ¨ã®éå
   * @type {number[]}
   * @readonly
   */


  _createClass(Boundary, [{
    key: "points",
    get: function get() {
      return this._points;
    }
    /**
     * @summary é ç¹æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "num_points",
    get: function get() {
      return this._num_points;
    }
    /**
     * @summary å¢çã¯åæè¨åããï¼
     *
     * @param {number[]} points  å¢çã®é ç¹ãã¼ã¿
     *
     * @return {boolean}  åæè¨åãã®ã¨ã true, ããä»¥å¤ã®ã¨ã false
     */

  }], [{
    key: "isCCW",
    value: function isCCW(points, num_points) {
      // é ä¸ã®ç¹ãåãé«ããªãå·¦å´åªå
      var top_i;
      var top_x = -Number.MAX_VALUE;
      var top_y = -Number.MAX_VALUE;

      for (var i = 0; i < num_points; ++i) {
        var x = points[3 * i];
        var y = points[3 * i + 1];

        if (y > top_y || y == top_y && x < top_x) {
          top_i = i;
          top_x = x;
          top_y = y;
        }
      } // top ã®åæ¹ã®ç¹


      var next_i = top_i == num_points - 1 ? 0 : top_i + 1;
      var next_x = points[3 * next_i];
      var next_y = points[3 * next_i + 1]; // top ã®å¾æ¹ã®ç¹

      var prev_i = top_i == 0 ? num_points - 1 : top_i - 1;
      var prev_x = points[3 * prev_i];
      var prev_y = points[3 * prev_i + 1]; // prev ã¨ next ã¯ top ããä¸ã¾ãã¯åãé«ãã ããå°ãªãã¨ãã©ã¡ããä¸æ¹ã¯ top ããä¸ã«ãªã
      // ã¾ãã¨ãã¸ã¯äº¤å·®ããªããã¨ãåæãªã®ã§ã2 ã¤ã®ã¨ãã¸ã®åè§ã¯ 0 åº¦ããå¤§ãã 180 åº¦æªæºã«ãªã
      // ãããã£ã¦ a, b ã®è¡åå¼ãæ­£ã®ã¨ãåæè¨åããããä»¥å¤ã®ã¨ãæè¨åã

      var ax = next_x - top_x;
      var ay = next_y - top_y;
      var bx = prev_x - top_x;
      var by = prev_y - top_y;
      return ax * by - bx * ay > 0;
    }
  }]);

  return Boundary;
}();
/**
 * @summary å¢çç·ãã¼ã¿ãçµå
 *
 * @classdesc
 * <p>pe._bounaries ã«å¯¾å¿ããä¸é ç¹ã¨åºé ç¹ã® LOCS å¹³å¦åéåãåå¾ããã</p>
 * <p>pe._extruded_height === 0 ã®ã¨ãã¯ lower ã« null ãè¨­å®ããã</p>
 *
 * <pre>
 * ãã­ããã£:
 *   origin: Vector3       // LOCS ã®åç¹ä½ç½® (GOCS)
 *   num_points: number    // upper ã®é ç¹æ°
 *   upper: Float64Array   // ä¸é ç¹ (LOCS, é åºã¯ pe._bounaries.points ã®é£çµ)
 *   lower: Float64Array   // åºé ç¹ (LOCS, é åºã¯ upper ã¨åã, nullable)
 * </pre>
 *
 * @private
 */


var BoundaryConbiner =
/**
 * @desc
 * <pre>
 * å¥å:
 *   pe.viewer
 *   pe.altitude_mode
 *   pe._extruded_height
 *   pe._bounaries
 * </pre>
 *
 * @param {mapray.PolygonEntity} pe  å¼ã³åºãå´ã®ããªã´ã³ã¨ã³ãã£ãã£
 */
function BoundaryConbiner(pe) {
  _classCallCheck(this, BoundaryConbiner);

  /*
  pe._extruded_height !== 0             == 0    
                                                
              ---  _.-*---*._        _.-*---*._ 
  upper_points    *-_      _-*      *-_      _-*
              --- |  *----*  |         *----*   
                  |  |    |  |                  
              --- |  |    |  |                  
  lower_points    *-_|    |_-*         (null)   
              ---    *----*                     
  */
  var viewer = pe.scene.viewer;
  var altitude_mode = pe.altitude_mode;

  var src_points = pe._getCombinedBoundaryPoints();

  var num_points = pe._countNumPointsOnBoundaries();

  var base_points = Float64Array.from(src_points);

  if (altitude_mode === AltitudeMode.RELATIVE) {
    var elevation = viewer.getExistingElevation(pe._getPosition());

    for (var i = 0; i < num_points; ++i) {
      var ai = 3 * i + 2;
      base_points[ai] += elevation;
    }
  }

  var upper_points = null;
  var lower_points = null;

  if (pe._extruded_height !== 0) {
    if (altitude_mode === AltitudeMode.CLAMP) {
      upper_points = base_points;
      lower_points = Float64Array.from(src_points);

      for (var _i4 = 0; _i4 < num_points; ++_i4) {
        var _ai = 3 * _i4 + 2;

        lower_points[_ai] = 0;
      }
    } else {
      // altitude_mode !== AltitudeMode.ABSOLUTE || altitude_mode !== AltitudeMode.RELATIVE
      lower_points = base_points;
      upper_points = Float64Array.from(src_points);

      for (var _i5 = 0; _i5 < num_points; ++_i5) {
        var _ai2 = 3 * _i5 + 2;

        upper_points[_ai2] = lower_points[_ai2] + pe._extruded_height;
      }
    }
  } else {
    upper_points = base_points;
  }

  var origin = pe._getPosition().getAsGocs(GeoMath.createVector3()); // LOCS å¹³å¦åéå


  var upper_ocs_points = GeoPoint.toGocsArray(upper_points, num_points, new Float64Array(3 * num_points));

  for (var _i6 = 0; _i6 < num_points; ++_i6) {
    var d = 3 * _i6;
    upper_ocs_points[d] -= origin[0];
    upper_ocs_points[d + 1] -= origin[1];
    upper_ocs_points[d + 2] -= origin[2];
  }

  var lower_ocs_points = null;

  if (lower_points) {
    // ASSERT: lower_points != null
    lower_ocs_points = GeoPoint.toGocsArray(lower_points, num_points, new Float64Array(3 * num_points));

    for (var _i7 = 0; _i7 < num_points; ++_i7) {
      var _d = 3 * _i7;

      lower_ocs_points[_d] -= origin[0];
      lower_ocs_points[_d + 1] -= origin[1];
      lower_ocs_points[_d + 2] -= origin[2];
    }
  } // ãã­ããã£ãè¨­å®


  this.origin = origin;
  this.num_points = num_points;
  this.upper = upper_ocs_points;
  this.lower = lower_ocs_points;
};
/**
 * @summary å¤è§å½¢ã®é åç®¡ç
 *
 * @private
 */


var PolygonAreaManager =
/*#__PURE__*/
function (_QAreaManager) {
  _inherits(PolygonAreaManager, _QAreaManager);

  /**
   * @param {mapray.PolygonEntity} entity  ç®¡çå¯¾è±¡ã®ã¨ã³ãã£ãã£
   */
  function PolygonAreaManager(entity) {
    var _this5;

    _classCallCheck(this, PolygonAreaManager);

    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(PolygonAreaManager).call(this));
    _this5._entity = entity;
    return _this5;
  }
  /**
   * @override
   */


  _createClass(PolygonAreaManager, [{
    key: "getInitialContent",
    value: function getInitialContent() {
      var src_indices = this._entity._createTriangles() || [];
      var num_src_indices = src_indices.length;

      var src_coords = this._entity._getCombinedBoundary2DPoints();

      var content = []; // ConvexPolygon ã®éå

      for (var _si = 0; _si < num_src_indices; _si += 3) {
        var i0 = src_indices[_si];
        var i1 = src_indices[_si + 1];
        var i2 = src_indices[_si + 2];

        this._add_polygon_to_array(src_coords, i0, i1, i2, content);
      }

      return content;
    }
    /**
     * @override
     */

  }, {
    key: "createAreaContent",
    value: function createAreaContent(min_x, min_y, msize, parent_content) {
      // åä½çã¡ã«ã«ãã«ã§ã®é åã«å¤æ
      var x_area_min = Math.PI * min_x;
      var y_area_min = Math.PI * min_y;
      var x_area_max = Math.PI * (min_x + msize);
      var y_area_max = Math.PI * (min_y + msize); // é åãå¸å¤è§å½¢ã«å¤æ

      var area_rect = ConvexPolygon.createByRectangle(x_area_min, y_area_min, x_area_max, y_area_max);
      var content = []; // ConvexPolygon ã®éå

      var _iteratorNormalCompletion16 = true;
      var _didIteratorError16 = false;
      var _iteratorError16 = undefined;

      try {
        for (var _iterator16 = parent_content[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
          var polygon = _step16.value;

          if (polygon.includes(area_rect)) {
            // polygon ã¯ area_rect ãè¦ã
            // ã¤ã¾ã area_rect ã¯å¨ä½ã®å¤è§å½¢ã«è¦ããã¦ãã
            return Entity.AreaStatus.FULL;
          }

          try {
            if (area_rect.hasIntersection(polygon)) {
              // é åã¨äº¤å·®ãã¦ããã®ã§ polygon è¿½å 
              content.push(polygon);
            }
          } catch (e) {// polygon ã®äº¤å·®å¤å®ã«å¤±æããã¨ãã¯ polygon ã¯ç¡ããã¨ã«ãã
          }
        }
      } catch (err) {
        _didIteratorError16 = true;
        _iteratorError16 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
            _iterator16["return"]();
          }
        } finally {
          if (_didIteratorError16) {
            throw _iteratorError16;
          }
        }
      }

      return content.length > 0 ? content : Entity.AreaStatus.EMPTY;
    }
    /**
     * @summary ä¸è§å½¢ãå¸å¤è§å½¢ã¨ãã¦è¿½å 
     *
     * @param {number[]} src_coords  å¥åé ç¹ã®åº§æ¨éå (çµç·¯åº¦)
     * @param {number}   si0         ä¸è§å½¢ã®é ç¹ 0
     * @param {number}   si1         ä¸è§å½¢ã®é ç¹ 1
     * @param {number}   si2         ä¸è§å½¢ã®é ç¹ 2
     * @param {mapray.ConvexPolygon[]} dst_polygons  åºååã® ConvexPolygon éå
     *
     * @private
     */

  }, {
    key: "_add_polygon_to_array",
    value: function _add_polygon_to_array(src_coords, si0, si1, si2, dst_polygons) {
      var Degree = GeoMath.DEGREE;
      var RAngle = Math.PI / 2; // ç´è§

      var TwoPI = 2 * Math.PI; // 2Ï
      // ä¸è§å½¢ã®é ç¹åº§æ¨éå (åä½çã¡ã«ã«ãã«åº§æ¨ç³») ãä½æ

      var vertices = [];
      var mx_min_1 = Number.MAX_VALUE; // ãªãã»ããå¦çåã®æå° mx åº§æ¨

      for (var _i8 = 0, _arr = [si0, si1, si2]; _i8 < _arr.length; _i8++) {
        var _si2 = _arr[_i8];
        var lon = src_coords[2 * _si2] * Degree;
        var lat = src_coords[2 * _si2 + 1] * Degree;

        if (Math.abs(lat) >= RAngle) {
          // ç·¯åº¦ã®çµ¶å¯¾å¤ã RAngle ä»¥ä¸ã®é ç¹ãå­å¨ããä¸è§å½¢ã¯é¤å¤
          // â» ã¾ã æ¤è¨ãã¦ããªãã®ã§ãã¨ããããã®å¦ç½®
          return;
        }

        var mx = lon;
        var my = GeoMath.invGudermannian(lat);
        vertices.push(mx);
        vertices.push(my);
        mx_min_1 = Math.min(mx, mx_min_1);
      } // mx_min_2: mx åº§æ¨ã mx_min_1 ã ã£ãé ç¹ã®ãªãã»ããå¾ã® mx åº§æ¨


      var mx_min_2 = mx_min_1 - TwoPI * (Math.floor((mx_min_1 - Math.PI) / TwoPI) + 1);

      if (mx_min_2 < -Math.PI || mx_min_2 >= Math.PI) {
        // æ°å¤è¨ç®èª¤å·®ã«ããç¨ã«åºéããã¯ã¿åºãå¯è½æ§ãããã®ã§
        mx_min_2 = -Math.PI;
      } // Assert: -Math.PI <= mx_min_2 < Math.PI
      // mx åº§æ¨ã«ãªãã»ãããé©ç¨


      var mx_max_2 = -Number.MAX_VALUE; // ãªãã»ããå¾ã®æå¤§ mx åº§æ¨

      for (var i = 0; i < 3; ++i) {
        var ix = 2 * i;
        var mx_1 = vertices[ix]; // ãªãã»ããåã® mx åº§æ¨
        // mx_2: ãªãã»ããå¾ã® mx åº§æ¨

        var dx_1 = mx_1 - mx_min_1; // Assert: dx_1 >= 0

        var mx_2 = mx_min_2 + dx_1; // Assert: mx_2 >= mx_min_2
        // Assert: (mx_1 == mx_min_1) â (mx_2 == mx_min_2)

        vertices[ix] = mx_2;
        mx_max_2 = Math.max(mx_2, mx_max_2);
      } // ãªãã»ãããé©ç¨ããä¸è§å½¢ãå ãã


      dst_polygons.push(new ConvexPolygon(vertices)); // ä¸è§å½¢ã 180 åº¦å­åç·ãã¾ããã¨ã
      // 360 åº¦å·¦ã«ããããä¸è§å½¢ããã1ã¤å ãã

      if (mx_max_2 > Math.PI) {
        for (var _i9 = 0; _i9 < 3; ++_i9) {
          var _ix = 2 * _i9;

          var _mx_ = vertices[_ix]; // ãªãã»ããå¾ã® mx åº§æ¨

          var mx_3 = _mx_ - TwoPI; // 360 åº¦å·¦ã«ãããã mx åº§æ¨

          vertices[_ix] = mx_3;
        }

        dst_polygons.push(new ConvexPolygon(vertices));
      }
    }
  }]);

  return PolygonAreaManager;
}(QAreaManager);
/**
 * @summary ãµãã¡ãã·ã¥
 *
 * @private
 */


var Submesh =
/*#__PURE__*/
function () {
  /**
   */
  function Submesh() {
    _classCallCheck(this, Submesh);
  }
  /**
   * @summary é ç¹æ°ãåå¾
   *
   * @return {number}  é ç¹æ°
   *
   * @abstract
   */


  _createClass(Submesh, [{
    key: "getNumVertices",
    value: function getNumVertices() {
      throw "";
    }
    /**
     * @summary ä¸è§å½¢æ°ãåå¾
     *
     * @return {number}  ä¸è§å½¢æ°
     *
     * @abstract
     */

  }, {
    key: "getNumTriangles",
    value: function getNumTriangles() {
      throw "";
    }
    /**
     * @summary é ç¹éåã«é ç¹ãã¼ã¿ãæ¸ãè¾¼ã
     *
     * @param {mapray.Vector3} origin    åº§æ¨ç³»ã®åç¹ (GOCS)
     * @param {mapray.Sampler} sampler   DEM ãµã³ãã©ã¼
     * @param {number[]}       vertices  æ¸ãè¾¼ã¿åã®éå
     * @param {number}         offset    æ¸ãè¾¼ã¿éå§ã¤ã³ããã¯ã¹
     *
     * @return {number}  offset + æ¸ãè¾¼ãã è¦ç´ æ°
     *
     * @abstract
     */

  }, {
    key: "addVertices",
    value: function addVertices(origin, sampler, vertices, offset) {
      throw "";
    }
    /**
     * @summary ã¤ã³ããã¯ã¹éåã«ã¤ã³ããã¯ã¹ãæ¸ãè¾¼ã
     *
     * @param {number}   voffset  this ç¨é ç¹ã®åé ­ã®é ç¹ã¤ã³ããã¯ã¹
     * @param {number[]} indices  æ¸ãè¾¼ã¿åã®éå
     * @param {number}   ioffset  æ¸ãè¾¼ã¿éå§ã¤ã³ããã¯ã¹
     *
     * @return {number}  ioffset + æ¸ãè¾¼ãã è¦ç´ æ°
     *
     * @abstract
     */

  }, {
    key: "addIndices",
    value: function addIndices(voffset, indices, ioffset) {
      throw "";
    }
  }]);

  return Submesh;
}();
/**
 * @summary ç©å½¢ãµãã¡ãã·ã¥
 *
 * @private
 */


var RectSubmesh =
/*#__PURE__*/
function (_Submesh) {
  _inherits(RectSubmesh, _Submesh);

  /**
   * @param {number} x_min
   * @param {number} y_min
   * @param {number} x_max
   * @param {number} y_max
   * @param {number} div_x
   * @param {number} div_y
   */
  function RectSubmesh(x_min, y_min, x_max, y_max, div_x, div_y) {
    var _this6;

    _classCallCheck(this, RectSubmesh);

    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(RectSubmesh).call(this));
    _this6._x_min = x_min;
    _this6._y_min = y_min;
    _this6._x_max = x_max;
    _this6._y_max = y_max;
    _this6._div_x = div_x;
    _this6._div_y = div_y;
    return _this6;
  }
  /**
   * @override
   */


  _createClass(RectSubmesh, [{
    key: "getNumVertices",
    value: function getNumVertices() {
      return (this._div_x + 1) * (this._div_y + 1);
    }
    /**
     * @override
     */

  }, {
    key: "getNumTriangles",
    value: function getNumTriangles() {
      return 2 * this._div_x * this._div_y;
    }
    /**
     * @override
     */

  }, {
    key: "addVertices",
    value: function addVertices(origin, sampler, vertices, offset) {
      // å»ã¿å¹
      var mx_step = (this._x_max - this._x_min) / this._div_x;
      var my_step = (this._y_max - this._y_min) / this._div_y;
      var end_iu = this._div_x + 1;
      var end_iv = this._div_y + 1;
      var index = offset;

      for (var iv = 0, my = this._y_min; iv < end_iv; ++iv, my += my_step) {
        var ey = Math.exp(my);
        var ey2 = ey * ey;
        var sinÏ = (ey2 - 1) / (ey2 + 1);
        var cosÏ = 2 * ey / (ey2 + 1);

        for (var iu = 0, mx = this._x_min; iu < end_iu; ++iu, mx += mx_step) {
          var sinÎ» = Math.sin(mx);
          var cosÎ» = Math.cos(mx);
          var height = sampler.sample(mx, my);
          var radius = GeoMath.EARTH_RADIUS + height; // æ³ç· (GOCS)

          var nx = cosÏ * cosÎ»;
          var ny = cosÏ * sinÎ»;
          var nz = sinÏ; // ä½ç½® (GOCS)

          var gx = radius * nx;
          var gy = radius * ny;
          var gz = radius * nz;
          vertices[index++] = gx - origin[0]; // x

          vertices[index++] = gy - origin[1]; // y

          vertices[index++] = gz - origin[2]; // z

          vertices[index++] = nx; // nx

          vertices[index++] = ny; // ny

          vertices[index++] = nz; // nz
        }
      }

      return index;
    }
    /**
     * @override
     */

  }, {
    key: "addIndices",
    value: function addIndices(voffset, indices, ioffset) {
      var div_x = this._div_x;
      var div_y = this._div_y;
      var index = ioffset;

      for (var y = 0; y < div_y; ++y) {
        for (var x = 0; x < div_x; ++x) {
          var i00 = voffset + (div_x + 1) * y + x; // å·¦ä¸é ç¹

          var i10 = i00 + 1; // å³ä¸é ç¹

          var i01 = i00 + div_x + 1; // å·¦ä¸é ç¹

          var i11 = i01 + 1; // å³ä¸é ç¹
          // å·¦ä¸ä¸è§å½¢

          indices[index++] = i00;
          indices[index++] = i10;
          indices[index++] = i01; // å³ä¸ä¸è§å½¢

          indices[index++] = i01;
          indices[index++] = i10;
          indices[index++] = i11;
        }
      }

      return index;
    }
  }]);

  return RectSubmesh;
}(Submesh);
/**
 * @summary å¸å¤è§å½¢éåãµãã¡ãã·ã¥
 *
 * @private
 */


var PolygonsSubmesh =
/*#__PURE__*/
function (_Submesh2) {
  _inherits(PolygonsSubmesh, _Submesh2);

  /**
   * this ã®çå­ä¸­ã¯ãã©ã¡ã¼ã¿ã®ãªãã¸ã§ã¯ããå¤æ´ããªããã¨ã
   *
   * @param {number[]}                     arit_coords  é åã®ä¸è§å½¢åº§æ¨éå (å·¦ä¸ã¾ãã¯å³ä¸ã®ä¸è§å½¢)
   * @param {iterable.<mapray.ConvexPolygon>} polygons  arit_coords ã®ä¸ã«ããå¸å¤è§å½¢éå
   */
  function PolygonsSubmesh(arit_coords, polygons) {
    var _this7;

    _classCallCheck(this, PolygonsSubmesh);

    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(PolygonsSubmesh).call(this));
    _this7._arit_coords = arit_coords;
    _this7._polygons = polygons;
    _this7._num_vertices = 0;
    _this7._num_triangles = 0;
    var _iteratorNormalCompletion17 = true;
    var _didIteratorError17 = false;
    var _iteratorError17 = undefined;

    try {
      for (var _iterator17 = polygons[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
        var polygon = _step17.value;
        _this7._num_vertices += polygon.num_vertices;
        _this7._num_triangles += polygon.num_vertices - 2;
      }
    } catch (err) {
      _didIteratorError17 = true;
      _iteratorError17 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
          _iterator17["return"]();
        }
      } finally {
        if (_didIteratorError17) {
          throw _iteratorError17;
        }
      }
    }

    return _this7;
  }
  /**
   * @override
   */


  _createClass(PolygonsSubmesh, [{
    key: "getNumVertices",
    value: function getNumVertices() {
      return this._num_vertices;
    }
    /**
     * @override
     */

  }, {
    key: "getNumTriangles",
    value: function getNumTriangles() {
      return this._num_triangles;
    }
    /**
     * @override
     */

  }, {
    key: "addVertices",
    value: function addVertices(origin, sampler, vertices, offset) {
      var plane = this._get_elevation_plane(sampler);

      var index = offset;
      var _iteratorNormalCompletion18 = true;
      var _didIteratorError18 = false;
      var _iteratorError18 = undefined;

      try {
        for (var _iterator18 = this._polygons[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
          var polygon = _step18.value;
          index = this._add_polygon_vertices(polygon, plane, origin, vertices, index);
        }
      } catch (err) {
        _didIteratorError18 = true;
        _iteratorError18 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
            _iterator18["return"]();
          }
        } finally {
          if (_didIteratorError18) {
            throw _iteratorError18;
          }
        }
      }

      return index;
    }
    /**
     * @override
     */

  }, {
    key: "addIndices",
    value: function addIndices(voffset, indices, ioffset) {
      var iofs_next = ioffset;
      var vofs_next = voffset;
      var _iteratorNormalCompletion19 = true;
      var _didIteratorError19 = false;
      var _iteratorError19 = undefined;

      try {
        for (var _iterator19 = this._polygons[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
          var polygon = _step19.value;
          iofs_next = this._add_polygon_indices(polygon, vofs_next, indices, iofs_next);
          vofs_next += polygon.num_vertices;
        }
      } catch (err) {
        _didIteratorError19 = true;
        _iteratorError19 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion19 && _iterator19["return"] != null) {
            _iterator19["return"]();
          }
        } finally {
          if (_didIteratorError19) {
            throw _iteratorError19;
          }
        }
      }

      return iofs_next;
    }
    /**
     * @summary å¸å¤è§å½¢ã®é ç¹ãè¿½å 
     *
     * @param {mapray.ConvexPolygon} polygon   å¸å¤è§å½¢
     * @param {number[]}             plane     å¹³é¢ä¿æ°
     * @param {mapray.Vector3}       origin    åº§æ¨ç³»ã®åç¹ (GOCS)
     * @param {number[]}             vertices  æ¸ãè¾¼ã¿åã®éå
     * @param {number}               offset    æ¸ãè¾¼ã¿éå§ã¤ã³ããã¯ã¹
     *
     * @return {number}  offset + æ¸ãè¾¼ãã è¦ç´ æ°
     *
     * @private
     */

  }, {
    key: "_add_polygon_vertices",
    value: function _add_polygon_vertices(polygon, plane, origin, vertices, offset) {
      var index = offset;
      var num_vertices = polygon.num_vertices;
      var src_vertices = polygon.vertices;

      for (var vi = 0; vi < num_vertices; ++vi) {
        var mx = src_vertices[2 * vi];
        var my = src_vertices[2 * vi + 1];
        var ey = Math.exp(my);
        var ey2 = ey * ey;
        var sinÎ» = Math.sin(mx);
        var cosÎ» = Math.cos(mx);
        var sinÏ = (ey2 - 1) / (ey2 + 1);
        var cosÏ = 2 * ey / (ey2 + 1); // mx*plane[0] + my*plane[1] + height*plane[2] + plane[3] == 0

        var height = -(mx * plane[0] + my * plane[1] + plane[3]) / plane[2];
        var radius = GeoMath.EARTH_RADIUS + height; // æ³ç· (GOCS)

        var nx = cosÏ * cosÎ»;
        var ny = cosÏ * sinÎ»;
        var nz = sinÏ; // ä½ç½® (GOCS)

        var gx = radius * nx;
        var gy = radius * ny;
        var gz = radius * nz;
        vertices[index++] = gx - origin[0]; // x

        vertices[index++] = gy - origin[1]; // y

        vertices[index++] = gz - origin[2]; // z

        vertices[index++] = nx; // nx

        vertices[index++] = ny; // ny

        vertices[index++] = nz; // nz
      }

      return index;
    }
    /**
     * @summary å¸å¤è§å½¢ã®ã¤ã³ããã¯ã¹ãè¿½å 
     *
     * @param {mapray.ConvexPolygon} polygon  å¸å¤è§å½¢
     * @param {number}               voffset  this ç¨é ç¹ã®åé ­ã®é ç¹ã¤ã³ããã¯ã¹
     * @param {number[]}             indices  æ¸ãè¾¼ã¿åã®éå
     * @param {number}               ioffset  æ¸ãè¾¼ã¿éå§ã¤ã³ããã¯ã¹
     *
     * @return {number}  ioffset + æ¸ãè¾¼ãã è¦ç´ æ°
     *
     * @private
     */

  }, {
    key: "_add_polygon_indices",
    value: function _add_polygon_indices(polygon, voffset, indices, ioffset) {
      var index = ioffset;
      var num_triangles = polygon.num_vertices - 2;

      for (var i = 1; i <= num_triangles; ++i) {
        indices[index++] = voffset;
        indices[index++] = voffset + i;
        indices[index++] = voffset + i + 1;
      }

      return index;
    }
    /**
     * @summary å¹³é¢ãã¼ã¹ã§æ¨é«ãè¨ç®ããããã®ä¿æ°ãåå¾
     *
     * @param {mapray.Sampler} sampler
     *
     * @return {number[]}  å¹³é¢ä¿æ° [x, y, z, w]
     *
     * @private
     */

  }, {
    key: "_get_elevation_plane",
    value: function _get_elevation_plane(sampler) {
      var coords = this._arit_coords; // ä¸è§å½¢ã®é ç¹ã®é«ããåå¾

      var z_coords = new Array(3);

      for (var i = 0; i < 3; ++i) {
        var mx = coords[2 * i];
        var my = coords[2 * i + 1];
        z_coords[i] = sampler.sample(mx, my);
      }

      var ox = coords[0];
      var oy = coords[1];
      var oz = z_coords[0];
      var x1 = coords[2] - ox;
      var y1 = coords[3] - oy;
      var z1 = z_coords[1] - oz;
      var x2 = coords[4] - ox;
      var y2 = coords[5] - oy;
      var z2 = z_coords[2] - oz; // [nx, ny, nz] = [x1, y1, z1] x [x2, y2, z2]

      var nx = y1 * z2 - z1 * y2;
      var ny = z1 * x2 - x1 * z2;
      var nz = x1 * y2 - y1 * x2;
      return [nx, ny, nz, -ox * nx - oy * ny - oz * nz];
    }
  }]);

  return PolygonsSubmesh;
}(Submesh);
/**
 * @summary éåãããã¯ãã«ãè¨­å®
 *
 * array[index] ãã vec ã«è¨­å®ããã
 *
 * @private
 */


function setArrayToVec3(array, index, vec) {
  vec[0] = array[index];
  vec[1] = array[index + 1];
  vec[2] = array[index + 2];
}
/**
 * @summary éåãããã¯ãã«ãè¨­å®
 *
 * vec ãã array[index] ã«è¨­å®ããã
 *
 * @private
 */


function setVec3ToArray(vec, array, index) {
  array[index] = vec[0];
  array[index + 1] = vec[1];
  array[index + 2] = vec[2];
}
/**
 * @summary 3é ç¹ããæ­£è¦åæ³ç·ãã¯ãã«ãè¨­å®
 * @private
 */


function setTriangleNormal(p0, p1, p2, normal) {
  for (var i = 0; i < 3; ++i) {
    temp_normal_ax[i] = p1[i] - p0[i];
    temp_normal_ay[i] = p2[i] - p0[i];
  }

  GeoMath.cross3(temp_normal_ax, temp_normal_ay, normal);
  GeoMath.normalize3(normal, normal);
  return normal;
}

var temp_normal_ax = GeoMath.createVector3();
var temp_normal_ay = GeoMath.createVector3();
/**
 * @summary åé¨ã¹ãã¼ã¿ã¹
 * @enum {object}
 * @constant
 * @private
 */

var Status$3 = {
  INVALID: {
    id: "INVALID"
  },
  NORMAL: {
    id: "NORMAL"
  },
  TRIANGLE_DIRTY: {
    id: "TRIANGLE_DIRTY"
  },
  MESH_DIRTY: {
    id: "MESH_DIRTY"
  }
};

// https://tc39.github.io/ecma262/#sec-typedarray-objects

typedArrayConstructor('Int8', function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/**
 * glTF ã® bufferView ã«å¯¾å¿
 * @memberof mapray.gltf
 * @private
 */
var BufferView =
/*#__PURE__*/
function () {
  /**
   * åæå
   * @param {mapray.gltf.Context} ctx    èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   * @param {number}              index  ãããã¡ãã¥ã¼ç´¢å¼
   */
  function BufferView(ctx, index) {
    _classCallCheck(this, BufferView);

    // glTF ã® bufferView ãªãã¸ã§ã¯ã (specification/2.0/schema/bufferView.schema.json)
    var jbufferView = ctx.gjson.bufferViews[index];
    this._buffer = ctx.findBuffer(jbufferView.buffer);
    this._byteLength = jbufferView.byteLength;
    this._target = jbufferView.target; // ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER

    this._byteOffset = jbufferView.byteOffset !== undefined ? jbufferView.byteOffset : 0;
    this._byteStride = jbufferView.byteStride !== undefined ? jbufferView.byteStride : 0;
  }
  /**
   * åç§ãã gltf.Buffer ã¤ã³ã¹ã¿ã³ã¹ãåå¾
   * @type {mapray.gltf.Buffer}
   * @readonly
   */


  _createClass(BufferView, [{
    key: "rebuildBySplitter",

    /**
     * ãããã¡åå²ç¨ã®åæ§ç¯å¦ç
     *
     * @param {mapray.gltf.Buffer} buffer  é¨åãããã¡
     */
    value: function rebuildBySplitter(buffer) {
      // é¨åãããã¡å¨ä½ãåç§ããããã«ãã
      this._buffer = buffer;
      this._byteLength = buffer.byteLength;
      this._byteOffset = 0;
    }
  }, {
    key: "buffer",
    get: function get() {
      return this._buffer;
    }
    /**
     * ãã¡ããã¡åé ­ããã®ãã¤ããªãã»ãã
     * @type {number}
     * @readonly
     */

  }, {
    key: "byteOffset",
    get: function get() {
      return this._byteOffset;
    }
    /**
     * ã¤ã³ã¿ãªã¼ãã®ãã¤ãã¹ãã©ã¤ã
     * @type {number}
     * @readonly
     */

  }, {
    key: "byteStride",
    get: function get() {
      return this._byteStride;
    }
  }]);

  return BufferView;
}();

/**
 * glTF ã® accessor ã«å¯¾å¿
 * @memberof mapray.gltf
 * @private
 */

var Accessor =
/*#__PURE__*/
function () {
  /**
   * åæå
   * @param {mapray.gltf.Context} ctx    èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   * @param {number}              index  ã¢ã¯ã»ãµç´¢å¼
   */
  function Accessor(ctx, index) {
    _classCallCheck(this, Accessor);

    // glTF ã® accessor ãªãã¸ã§ã¯ã (specification/2.0/schema/accessor.schema.json)
    var jaccessor = ctx.gjson.accessors[index];
    this._type = jaccessor.type; // æå­å: SCALAR, VEC2, VEC3, VEC4, MAT2, MAT3, MAT4

    this._componentType = jaccessor.componentType; // GL_UNSIGNED_INT ...

    this._count = jaccessor.count; // >= 1

    this._bufferView = new BufferView(ctx, jaccessor.bufferView);
    this._byteOffset = jaccessor.byteOffset !== undefined ? jaccessor.byteOffset : 0;
    this._normalized = jaccessor.normalized || false;
    this._min = jaccessor.min ? jaccessor.min.slice() : null;
    this._max = jaccessor.max ? jaccessor.max.slice() : null;
    this._index = index;
  }
  /**
   * å¯¾å¿ãã glTF ãªãã¸ã§ã¯ãã§ã®ç´¢å¼ãåå¾
   * @type {number}
   * @readonly
   */


  _createClass(Accessor, [{
    key: "getRangeInBuffer",

    /**
     * ãããã¡åã§ã®ãã¼ã¿ç¯å²ãåå¾
     *
     * @return {object}  ãã¼ã¿ç¯å² = { first: åé ­ãªãã»ãã, last: æ«å°¾ãªãã»ãã + 1 }
     */
    value: function getRangeInBuffer() {
      var view = this._bufferView;
      var compo_size = Accessor._ComponentData[this._componentType].bytes;
      var data_size = compo_size * Accessor._NumComponents[this._type]; // ãã¼ã¿ã®ãã¤ãæ°

      var stride = view.byteStride == 0 ? data_size : view.byteStride; // ã¹ãã©ã¤ã

      var first_offset = this._byteOffset + view.byteOffset; // ãããã¡åã§ã®åé ­ãªãã»ãã

      return {
        first: first_offset,
        last: first_offset + stride * (this._count - 1) + data_size // ãããã¡åã§ã®æ«å°¾ãªãã»ãã + 1

      };
    }
    /**
     * ãã¤ããªã¼ãã¼ãä¿®æ­£
     *
     * @param  {mapray.BitVector} modmap  ä¿®æ­£ããã
     */

  }, {
    key: "modifyByteOrder",
    value: function modifyByteOrder(modmap) {
      var compo_data = Accessor._ComponentData[this._componentType];
      var compo_bytes = compo_data.bytes;

      if (compo_bytes == 1) {
        return; // 1 ãã¤ãè¦ç´ ã¯ãã¤ããªã¼ãã¼ããªãã®ã§å¦çããªã
      }

      var num_compos = Accessor._NumComponents[this._type]; // å±æ§ã®è¦ç´ æ°

      var byte_offset = this._byteOffset + this._bufferView.byteOffset; // ãããã¡åé ­ããã®ãã¤ãæ°

      var compo_stride = this._bufferView.byteStride == 0 ? // è¦ç´ åä½ã®ã¹ãã©ã¤ã
      num_compos : this._bufferView.byteStride / compo_bytes;
      var arraybuffer = this._bufferView.buffer.binary;
      var dataview = new DataView(arraybuffer, byte_offset);
      var typedarray = new compo_data.typedarray(arraybuffer, byte_offset);
      var getCompo = compo_data.getcompo; // DataView ãã¼ã¿åå¾é¢æ°

      var compo_shorts = compo_bytes / 2; // 1 è¦ç´ ã® short æ°

      var short_offset = byte_offset / 2; // ãããã¡åé ­ããã® short æ°

      var short_stride = compo_stride * compo_shorts; // short åä½ã®ã¹ãã©ã¤ã

      for (var i = 0; i < this._count; ++i) {
        var short_base_index = short_offset + i * short_stride;
        var compo_base_index = i * compo_stride;

        for (var c = 0; c < num_compos; ++c) {
          var short_index = short_base_index + c * compo_shorts;

          if (modmap.getBit(short_index)) {
            continue; // ãã§ã«ä¿®æ­£æ¸ã¿ã®è¦ç´ ãªã®ã§ã¹ã­ãã
          }

          var compo_index = compo_base_index + c; // ãªãã«ã¨ã³ãã£ã¢ã³ (glTF ä»æ§) ãæ³å®ãã¦è¦ç´ ãèª­ã¿è¾¼ã

          var value = getCompo.call(dataview, compo_index * compo_bytes, true); // ãã¤ãã£ãã¨ã³ãã£ã¢ã³ (WebGL ä»æ§) ã§è¦ç´ ãæ¸ãæ»ã

          typedarray[compo_index] = value;
          modmap.setBit(short_index, true);
        }
      }
    }
    /**
     * ç¯å²ãã§ãã¯
     *
     * @param  {number} first  ãããã¡ã«å¯¾ããéå§ä½ç½®
     * @param  {number} last   ãããã¡ã«å¯¾ããçµäºä½ç½® + 1
     * @return {boolean}       æåã®ãã¤ããç¯å²ã«å«ã¾ãããï¼
     */

  }, {
    key: "isIncluded",
    value: function isIncluded(first, last) {
      var byte_offset = this._byteOffset + this._bufferView.byteOffset;
      return first <= byte_offset && byte_offset < last;
    }
    /**
     * ãããã¡åå²ç¨ã®åæ§ç¯å¦ç
     *
     * @param {mapray.gltf.Buffer} buffer  é¨åãããã¡
     * @param {number}             first   åãããã¡ã«å¯¾ãã buffer ã®éå§ä½ç½®
     */

  }, {
    key: "rebuildBySplitter",
    value: function rebuildBySplitter(buffer, first) {
      this._index = -1; // åãããã¡åé ­ããã®ãã¼ã¿ã®ãã¤ãä½ç½®

      var old_byte_offset = this._byteOffset + this._bufferView.byteOffset; // é¨åãããã¡åé ­ããã®ãã¼ã¿ã®ãã¤ãä½ç½®

      this._byteOffset = old_byte_offset - first; // bufferView ãé¨åãããã¡ã¨ä¸è´ããããã«æ´æ°

      this._bufferView.rebuildBySplitter(buffer);
    }
  }, {
    key: "index",
    get: function get() {
      return this._index;
    }
    /**
     * åç§ãã gltf.BufferView ã¤ã³ã¹ã¿ã³ã¹ãåå¾
     * @type {mapray.gltf.BufferView}
     * @readonly
     */

  }, {
    key: "bufferView",
    get: function get() {
      return this._bufferView;
    }
    /**
     * ãã¼ã¿ã®åãåå¾
     * @type {string}
     * @readonly
     */

  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
    /**
     * ãã¼ã¿è¦ç´ ã®åãåå¾
     * @type {number}
     * @readonly
     */

  }, {
    key: "componentType",
    get: function get() {
      return this._componentType;
    }
    /**
     * ãã¼ã¿ã®åæ°ãåå¾
     * @type {number}
     * @readonly
     */

  }, {
    key: "count",
    get: function get() {
      return this._count;
    }
    /**
     * ãããã¡ãã¥ã¼åé ­ããã®ãã¤ããªãã»ãããåå¾
     * @type {number}
     * @readonly
     */

  }, {
    key: "byteOffset",
    get: function get() {
      return this._byteOffset;
    }
    /**
     * æ­£è¦åãããï¼
     * @type {boolean}
     * @readonly
     */

  }, {
    key: "normalized",
    get: function get() {
      return this._normalized;
    }
    /**
     * åº§æ¨ã®æå°å¤
     * @type {?number[]}
     * @readonly
     */

  }, {
    key: "min",
    get: function get() {
      return this._min;
    }
    /**
     * åº§æ¨ã®æå¤§å¤
     * @type {?number[]}
     * @readonly
     */

  }, {
    key: "max",
    get: function get() {
      return this._max;
    }
  }]);

  return Accessor;
}();

Accessor._NumComponents = {
  'SCALAR': 1,
  'VEC2': 2,
  'VEC3': 3,
  'VEC4': 4,
  'MAT2': 4,
  'MAT3': 9,
  'MAT4': 16
};
Accessor._ComponentData = {
  5120: {
    bytes: 1,
    getcompo: DataView.prototype.getInt8,
    typedarray: Int8Array
  },
  // BYTE
  5121: {
    bytes: 1,
    getcompo: DataView.prototype.getUint8,
    typedarray: Uint8Array
  },
  // UNSIGNED_BYTE
  5122: {
    bytes: 2,
    getcompo: DataView.prototype.getInt16,
    typedarray: Int16Array
  },
  // SHORT
  5123: {
    bytes: 2,
    getcompo: DataView.prototype.getUint16,
    typedarray: Uint16Array
  },
  // UNSIGNED_SHORT
  5125: {
    bytes: 4,
    getcompo: DataView.prototype.getUint32,
    typedarray: Uint32Array
  },
  // UNSIGNED_INT
  5126: {
    bytes: 4,
    getcompo: DataView.prototype.getFloat32,
    typedarray: Float32Array
  } // FLOAT

};

/**
 * glTF ã® material ã«å¯¾å¿
 * @memberof mapray.gltf
 * @private
 */

var Material$1 =
/*#__PURE__*/
function () {
  /**
   * åæå
   * @param {mapray.gltf.Context} ctx    èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   * @param {number}              index  ãããªã¢ã«ç´¢å¼
   */
  function Material(ctx, index) {
    _classCallCheck(this, Material);

    var jmaterial = ctx.gjson.materials[index];
    this._commonData = new CommonData(jmaterial, ctx);
    this._pbrMetallicRoughness = {
      baseColorFactor: [1.0, 1.0, 1.0, 1.0],
      baseColorTexture: null,
      metallicFactor: 1.0,
      roughnessFactor: 1.0,
      metallicRoughnessTexture: null
    };
    this._doubleSided = false;
    this._alphaMode = "OPAQUE";
    this._alphaCutoff = 0.5;
    this._emissiveFactor = [0.0, 0.0, 0.0];
    this._emissiveTexture = null;
    this._normalTexture = null;
    this._occlusionTexture = null; // glTF ã® material ãªãã¸ã§ã¯ã (specification/2.0/schema/material.schema.json)

    this._setupPbrMetallicRoughness(jmaterial, ctx);

    this._setupGenericParameters(jmaterial, ctx);
  }
  /**
   * glTF ãªãã¸ã§ã¯ãã®å±éãã¼ã¿
   *
   * @type {mapray.gltf.CommonData}
   * @readonly
   */


  _createClass(Material, [{
    key: "_setupPbrMetallicRoughness",

    /**
     * this._pbrMetallicRoughness ãè¨­å®
     *
     * @param {object}              jmaterial  glTF ã® material ãªãã¸ã§ã¯ã
     * @param {mapray.gltf.Context} ctx        èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
     * @private
     */
    value: function _setupPbrMetallicRoughness(jmaterial, ctx) {
      if (jmaterial.pbrMetallicRoughness === undefined) {
        return;
      } // glTF ã® pbrMetallicRoughness ãªãã¸ã§ã¯ã (specification/2.0/schema/material.pbrMetallicRoughness.schema.json)


      var src = jmaterial.pbrMetallicRoughness;
      var dst = this._pbrMetallicRoughness;

      if (src.baseColorFactor !== undefined) {
        dst.baseColorFactor = src.baseColorFactor.slice();
      }

      if (src.baseColorTexture !== undefined) {
        dst.baseColorTexture = new TextureInfo(src.baseColorTexture, ctx);
        ctx.addTextureInfo(dst.baseColorTexture);
      }

      if (src.metallicFactor !== undefined) {
        dst.metallicFactor = src.metallicFactor;
      }

      if (src.roughnessFactor !== undefined) {
        dst.roughnessFactor = src.roughnessFactor;
      }

      if (src.metallicRoughnessTexture !== undefined) {
        dst.metallicRoughnessTexture = new TextureInfo(src.metallicRoughnessTexture, ctx);
        ctx.addTextureInfo(dst.metallicRoughnessTexture);
      }
    }
    /**
     * this._doubleSided ãªã©ãè¨­å®
     *
     * @param {object}              jmaterial  glTF ã® material ãªãã¸ã§ã¯ã
     * @param {mapray.gltf.Context} ctx        èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
     * @private
     */

  }, {
    key: "_setupGenericParameters",
    value: function _setupGenericParameters(jmaterial, ctx) {
      if (jmaterial.doubleSided !== undefined) {
        this._doubleSided = jmaterial.doubleSided;
      }

      if (jmaterial.alphaMode !== undefined) {
        this._alphaMode = jmaterial.alphaMode;
      }

      if (jmaterial.alphaCutoff !== undefined) {
        this._alphaCutoff = jmaterial.alphaCutoff;
      }

      if (jmaterial.emissiveFactor !== undefined) {
        this._emissiveFactor = jmaterial.emissiveFactor.slice();
      }

      if (jmaterial.emissiveTexture !== undefined) {
        this._emissiveTexture = new TextureInfo(jmaterial.emissiveTexture, ctx);
        ctx.addTextureInfo(this._emissiveTexture);
      }

      if (jmaterial.normalTexture !== undefined) {
        this._normalTexture = new NormalTextureInfo(jmaterial.normalTexture, ctx);
        ctx.addTextureInfo(this._normalTexture);
      }

      if (jmaterial.occlusionTexture !== undefined) {
        this._occlusionTexture = new OcclusionTextureInfo(jmaterial.occlusionTexture, ctx);
        ctx.addTextureInfo(this._occlusionTexture);
      }
    }
  }, {
    key: "commonData",
    get: function get() {
      return this._commonData;
    }
    /**
     * MetallicRoughness PBR ãã©ã¡ã¼ã¿
     * @type {object}
     * @readonly
     */

  }, {
    key: "pbrMetallicRoughness",
    get: function get() {
      return this._pbrMetallicRoughness;
    }
    /**
     * ä¸¡é¢ã¬ã³ããªã³ã°ã®æç¡
     * @type {boolean}
     * @readonly
     */

  }, {
    key: "doubleSided",
    get: function get() {
      return this._doubleSided;
    }
    /**
     * Î±ã¢ã¼ã
     * @type {string}
     * @readonly
     */

  }, {
    key: "alphaMode",
    get: function get() {
      return this._alphaMode;
    }
    /**
     * Î±ã«ãããªã
     * @type {number}
     * @readonly
     */

  }, {
    key: "alphaCutoff",
    get: function get() {
      return this._alphaCutoff;
    }
    /**
     * èªå·±çºåä¿æ°
     * @type {mapray.Vector3}
     * @readonly
     */

  }, {
    key: "emissiveFactor",
    get: function get() {
      return this._emissiveFactor;
    }
    /**
     * èªå·±çºåãã¯ã¹ãã£
     * @type {?mapray.gltf.TextureInfo}
     * @readonly
     */

  }, {
    key: "emissiveTexture",
    get: function get() {
      return this._emissiveTexture;
    }
    /**
     * æ³ç·ãã¯ã¹ãã£
     * @type {?mapray.gltf.NormalTextureInfo}
     * @readonly
     */

  }, {
    key: "normalTexture",
    get: function get() {
      return this._normalTexture;
    }
    /**
     * é®è½ãã¯ã¹ãã£
     * @type {?mapray.gltf.OcclusionTextureInfo}
     * @readonly
     */

  }, {
    key: "occlusionTexture",
    get: function get() {
      return this._occlusionTexture;
    }
  }]);

  return Material;
}();

/**
 * glTF ã® primitive ã«å¯¾å¿
 * @memberof mapray.gltf
 * @private
 */

var Primitive$1 =
/*#__PURE__*/
function () {
  /**
   * åæå
   * @param {object}              jprimitive  glTF ã® primitive ãªãã¸ã§ã¯ã (specification/2.0/schema/mesh.primitive.schema.json)
   * @param {mapray.gltf.Context} ctx         èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   */
  function Primitive(jprimitive, ctx) {
    _classCallCheck(this, Primitive);

    this._mode = jprimitive.mode !== undefined ? jprimitive.mode : 4;
    this._attributes = {};
    this._indices = null;
    this._material = null;

    this._setupAttributes(jprimitive.attributes, ctx);

    this._setupIndices(jprimitive, ctx);

    this._setupMaterial(jprimitive, ctx);
  }
  /**
   * ããªããã£ãã¢ã¼ã
   *
   * @type {number}
   * @readonly
   */


  _createClass(Primitive, [{
    key: "_setupAttributes",

    /**
     * this._attributes ãè¨­å®
     *
     * @param {object}              jattributes  glTF ã® primitive/attributes ãªãã¸ã§ã¯ã
     * @param {mapray.gltf.Context} ctx          èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
     * @private
     */
    value: function _setupAttributes(jattributes, ctx) {
      for (var name in jattributes) {
        var accessor = new Accessor(ctx, jattributes[name]);
        this._attributes[name] = accessor;
        ctx.addAccessor(accessor, "ATTRIBUTE");
      }
    }
    /**
     * this._indices ãè¨­å®
     *
     * @param {object}              jprimitive  glTF ã® primitive ãªãã¸ã§ã¯ã
     * @param {mapray.gltf.Context} ctx         èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
     * @private
     */

  }, {
    key: "_setupIndices",
    value: function _setupIndices(jprimitive, ctx) {
      if (jprimitive.indices !== undefined) {
        var accessor = new Accessor(ctx, jprimitive.indices);
        this._indices = accessor;
        ctx.addAccessor(accessor, "INDEX");
      }
    }
    /**
     * this._material ãè¨­å®
     *
     * @param {object}              jprimitive  glTF ã® primitive ãªãã¸ã§ã¯ã
     * @param {mapray.gltf.Context} ctx         èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
     * @private
     */

  }, {
    key: "_setupMaterial",
    value: function _setupMaterial(jprimitive, ctx) {
      if (jprimitive.material !== undefined) {
        this._material = new Material$1(ctx, jprimitive.material);
      }
    }
  }, {
    key: "mode",
    get: function get() {
      return this._mode;
    }
    /**
     * @summary é ç¹å±æ§ã®è¾æ¸
     *
     * <p>é ç¹å±æ§åãã Accessor ãå¼ãè¾æ¸</p>
     *
     * @type {object}
     * @readonly
     */

  }, {
    key: "attributes",
    get: function get() {
      return this._attributes;
    }
    /**
     * ã¤ã³ããã¯ã¹
     *
     * @type {?mapray.gltf.Accessor}
     * @readonly
     */

  }, {
    key: "indices",
    get: function get() {
      return this._indices;
    }
    /**
     * ãããªã¢ã«
     *
     * @type {?mapray.gltf.Material}
     * @readonly
     */

  }, {
    key: "material",
    get: function get() {
      return this._material;
    }
  }]);

  return Primitive;
}();

/**
 * glTF ã® mesh ã«å¯¾å¿
 * @memberof mapray.gltf
 * @private
 */

var Mesh$1 =
/*#__PURE__*/
function () {
  /**
   * åæå
   * @param {mapray.gltf.Context} ctx    èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   * @param {number}              index  ã¡ãã·ã¥ç´¢å¼
   */
  function Mesh(ctx, index) {
    _classCallCheck(this, Mesh);

    this._primitives = []; // glTF ã® mesh ãªãã¸ã§ã¯ã (specification/2.0/schema/mesh.schema.json)

    var jmesh = ctx.gjson.meshes[index];
    var jprimitives = jmesh.primitives;

    for (var i = 0; i < jprimitives.length; ++i) {
      // glTF ã® primitive ãªãã¸ã§ã¯ã (specification/2.0/schema/mesh.primitive.schema.json)
      var jprimitive = jprimitives[i];

      this._primitives.push(new Primitive$1(jprimitive, ctx));
    }
  }
  /**
   * ããªããã£ãã®éåãåå¾
   *
   * @type {mapray.gltf.Primitive[]}
   * @readonly
   */


  _createClass(Mesh, [{
    key: "primitives",
    get: function get() {
      return this._primitives;
    }
  }]);

  return Mesh;
}();

/**
 * glTF ã® node ã«å¯¾å¿
 * @memberof mapray.gltf
 * @private
 */

var Node$1 =
/*#__PURE__*/
function () {
  /**
   * åæå
   * @param {mapray.gltf.Context} ctx    èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   * @param {number}              index  ãã¼ãç´¢å¼
   */
  function Node(ctx, index) {
    _classCallCheck(this, Node);

    // glTF ã® node ãªãã¸ã§ã¯ã (specification/2.0/schema/node.schema.json)
    var jnode = ctx.gjson.nodes[index];
    this._commonData = new CommonData(jnode, ctx);
    this._children = [];
    this._matrix = null;
    this._mesh = null;

    this._setupChildren(jnode, ctx);

    this._setupMatrix(jnode);

    this._setupMesh(jnode, ctx);
  }
  /**
   * glTF ãªãã¸ã§ã¯ãã®å±éãã¼ã¿
   *
   * @type {mapray.gltf.CommonData}
   * @readonly
   */


  _createClass(Node, [{
    key: "_setupChildren",

    /**
     * this._children ãè¨­å®
     *
     * @param {object}              jnode  glTF ã® node ãªãã¸ã§ã¯ã
     * @param {mapray.gltf.Context} ctx    èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
     * @private
     */
    value: function _setupChildren(jnode, ctx) {
      var children = jnode.children;
      if (children === undefined) return;

      for (var i = 0; i < children.length; ++i) {
        var index = children[i];

        this._children.push(new Node(ctx, index));
      }
    }
    /**
     * this._matrix ãè¨­å®
     *
     * @param {object} jnode  glTF ã® node ãªãã¸ã§ã¯ã
     * @private
     */

  }, {
    key: "_setupMatrix",
    value: function _setupMatrix(jnode) {
      if (jnode.matrix) {
        // è¡åæå®
        this._matrix = GeoMath.createMatrix(jnode.matrix);
      } else if (jnode.scale || jnode.rotation || jnode.translation) {
        // SQT æå®
        var _ref = jnode.scale || [1, 1, 1],
            _ref2 = _slicedToArray(_ref, 3),
            sx = _ref2[0],
            sy = _ref2[1],
            sz = _ref2[2];

        var _ref3 = jnode.rotation || [0, 0, 0, 1],
            _ref4 = _slicedToArray(_ref3, 4),
            qx = _ref4[0],
            qy = _ref4[1],
            qz = _ref4[2],
            qw = _ref4[3];

        var _ref5 = jnode.translation || [0, 0, 0],
            _ref6 = _slicedToArray(_ref5, 3),
            tx = _ref6[0],
            ty = _ref6[1],
            tz = _ref6[2]; //                        [ 1 - 2y^2 - 2z^2,      2x y - 2w z,      2x z + 2w y ]
        // rotation[x, y, z, w] = [     2x y + 2w z,  1 - 2x^2 - 2z^2,      2y z - 2w x ]
        //                        [     2x z - 2w y,      2y z + 2w x,  1 - 2x^2 - 2y^2 ]


        this._matrix = GeoMath.createMatrix([(1 - 2 * (qy * qy + qz * qz)) * sx, 2 * (qx * qy + qz * qw) * sx, 2 * (qx * qz - qy * qw) * sx, 0, 2 * (qx * qy - qz * qw) * sy, (1 - 2 * (qx * qx + qz * qz)) * sy, 2 * (qx * qw + qy * qz) * sy, 0, 2 * (qy * qw + qx * qz) * sz, 2 * (qy * qz - qx * qw) * sz, (1 - 2 * (qx * qx + qy * qy)) * sz, 0, tx, ty, tz, 1]);
      }
    }
    /**
     * this._mesh ãè¨­å®
     *
     * @param {object}              jnode  glTF ã® node ãªãã¸ã§ã¯ã
     * @param {mapray.gltf.Context} ctx    èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
     * @private
     */

  }, {
    key: "_setupMesh",
    value: function _setupMesh(jnode, ctx) {
      var index = jnode.mesh;
      if (index === undefined) return; // ã¡ãã·ã¥ãªãã®ãã¼ã

      this._mesh = new Mesh$1(ctx, index);
    }
  }, {
    key: "commonData",
    get: function get() {
      return this._commonData;
    }
    /**
     * å­ãã¼ãã®éåãåå¾
     * @type {mapray.gltf.Node[]}
     * @readonly
     */

  }, {
    key: "children",
    get: function get() {
      return this._children;
    }
    /**
     * å¤æè¡åãåå¾
     * @type {?mapray.Matrix}
     * @readonly
     */

  }, {
    key: "matrix",
    get: function get() {
      return this._matrix;
    }
    /**
     * ã¡ãã·ã¥ãåå¾
     * @type {?mapray.gltf.Mesh}
     * @readonly
     */

  }, {
    key: "mesh",
    get: function get() {
      return this._mesh;
    }
  }]);

  return Node;
}();

/**
 * @summary glTF scene
 *
 * @classdesc
 * <p>glTF ã® scene ã«å¯¾å¿ãããªãã¸ã§ã¯ãã§ããã</p>
 *
 * @memberof mapray.gltf
 * @private
 * @see https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/schema/scene.schema.json
 */

var Scene$1 =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.gltf.Context} ctx    èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   * @param {number}              index  ã·ã¼ã³ç´¢å¼
   */
  function Scene(ctx, index) {
    _classCallCheck(this, Scene);

    // glTF ã® scene ãªãã¸ã§ã¯ã
    var jscene = ctx.gjson.scenes[index];
    this._commonData = new CommonData(jscene, ctx);
    this._root_nodes = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (jscene.nodes || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var node_index = _step.value;

        this._root_nodes.push(new Node$1(ctx, node_index));
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
  /**
   * glTF ãªãã¸ã§ã¯ãã®å±éãã¼ã¿
   *
   * @type {mapray.gltf.CommonData}
   * @readonly
   */


  _createClass(Scene, [{
    key: "commonData",
    get: function get() {
      return this._commonData;
    }
    /**
     * æä¸ä½ãã¼ãã®éå
     *
     * @type {mapray.gltf.Node[]}
     * @readonly
     */

  }, {
    key: "root_nodes",
    get: function get() {
      return this._root_nodes;
    }
    /**
     * @summary ã·ã¼ã³åãåå¾
     *
     * <p>ã·ã¼ã³åãå­å¨ããã°ã·ã¼ã³åã®æå­åãè¿ããå­å¨ããªããã° null ãè¿ãã</p>
     *
     * @type {?string}
     * @readonly
     */

  }, {
    key: "name",
    get: function get() {
      return this._commonData.getName();
    }
  }]);

  return Scene;
}();

/**
 * ãããã¡ã®åå²ãè£å©
 *
 * @memberof mapray.gltf
 * @private
 */
var BufferSplitter =
/*#__PURE__*/
function () {
  /**
   */
  function BufferSplitter() {
    _classCallCheck(this, BufferSplitter);

    // å¦çããããããã«æåã¨æå¾ã¯ã«ããã¼ã®æ­çãç½®ã
    var frag0 = new Fragment(-2, -1);
    var frag1 = new Fragment(Math.pow(2, 32) + 1, Math.pow(2, 32) + 2);
    frag0.next = frag1;
    frag1.prev = frag0;
    this._fragments = frag0;
  }
  /**
   * åå²ãæ´æ°
   *
   * @param {mapray.gltf.Accessor} accessor  ãããã¡ãåç§ããã¢ã¯ã»ãµ
   */


  _createClass(BufferSplitter, [{
    key: "update",
    value: function update(accessor) {
      var range = accessor.getRangeInBuffer();

      this._updateByRange({
        first: BufferSplitter._floor4(range.first),
        last: range.last
      });
    }
    /**
     * åå²ã®æ´æ°ãçµäº
     *
     * @param {mapray.gltf.Buffer} buffer  åå²ããããããã¡
     */

  }, {
    key: "close",
    value: function close(buffer) {
      // åé ­ã®ããã¼ãåé¤
      this._fragments = this._fragments.next; // é¨åãããã¡ãè¨­å®

      for (var frag = this._fragments;; frag = frag.next) {
        if (frag.next === null) {
          // æå¾ã®ããã¼ãåé¤
          frag.prev.next = null;
          break;
        }

        frag.buffer = buffer.createSubBuffer(frag.first, frag.last);
      }
    }
    /**
     * ã¢ã¯ã»ãµãé¨åãããã¡ã§åæ§ç¯
     *
     * @param {mapray.gltf.Accessor} accessor  åæ§ç¯ããã¢ã¯ã»ãµ
     */

  }, {
    key: "rebuildAccessor",
    value: function rebuildAccessor(accessor) {
      for (var frag = this._fragments; frag !== null; frag = frag.next) {
        if (accessor.isIncluded(frag.first, frag.last)) {
          accessor.rebuildBySplitter(frag.buffer, frag.first);
          break;
        }
      }
    }
    /**
     * åå²ãæ´æ°
     *
     * @param {object} range  Accessor ã®ç¯å²
     * @private
     */

  }, {
    key: "_updateByRange",
    value: function _updateByRange(range) {
      for (var frag = this._fragments; frag.next !== null;) {
        if (frag.isInside(range)) {
          // frag æ­çã¨ frag.next æ­çã®éã«æ°ãã range æ­çãæ¿å¥
          var frag0 = frag;
          var frag1 = frag.next;
          var fragx = new Fragment(range.first, range.last);
          frag0.next = fragx;
          frag1.prev = fragx;
          fragx.prev = frag0;
          fragx.next = frag1;
          break;
        } else if (frag.isTouch(range)) {
          // range ã« frag ãçµ±åããfrag ãåé¤ããfrag.prev ããå§ãã
          var _frag = frag.prev;
          var _frag2 = frag.next;
          _frag.next = _frag2;
          _frag2.prev = _frag;
          range = frag.mergeRange(range);
          frag = _frag;
        } else {
          frag = frag.next;
        }
      }
    }
    /**
     * 4 ã®åæ°ã«åãä¸ã
     *
     * @param  {number} value  åãä¸ããå¤
     * @return {number}        value ã 4 ã®åæ°ã«åãä¸ããæ´æ°
     * @private
     */

  }], [{
    key: "_floor4",
    value: function _floor4(value) {
      return 4 * Math.floor(value / 4);
    }
  }]);

  return BufferSplitter;
}();
/**
 * ãããã¡ã®æ­ç
 *
 * @memberof mapray.gltf.BufferSplitter
 * @private
 */


var Fragment =
/*#__PURE__*/
function () {
  /**
   * @param {number} first  åé ­ãªãã»ãã
   * @param {number} last   æ«å°¾ãªãã»ãã + 1
   */
  function Fragment(first, last) {
    _classCallCheck(this, Fragment);

    this.first = first;
    this.last = last;
    this.buffer = null; // é¨åãããã¡

    this.prev = null;
    this.next = null;
  }
  /**
   * range ã¯ frag ã¨ frag.next ã®éã®åå´ãï¼
   *
   * @param  {object} range
   * @return {boolean}
   * @private
   */


  _createClass(Fragment, [{
    key: "isInside",
    value: function isInside(range) {
      return this.last < range.first && range.last < this.next.first;
    }
    /**
     * range ã¯ frag ã¨æ¥è§¦ãã¦ãããï¼
     *
     * @param  {object} range
     * @return {boolean}
     */

  }, {
    key: "isTouch",
    value: function isTouch(range) {
      return this.last >= range.first && range.last >= this.first;
    }
    /**
     * this ã¨ range ãçµåãã range ãåå¾
     *
     * @param  {object} range
     * @return {object}
     */

  }, {
    key: "mergeRange",
    value: function mergeRange(range) {
      return {
        first: Math.min(this.first, range.first),
        last: Math.max(this.last, range.last)
      };
    }
  }]);

  return Fragment;
}();

/**
 * @summary ãããéå
 *
 * @memberof mapray
 * @private
 */
var BitVector =
/*#__PURE__*/
function () {
  /**
   * åæå¤ã¯ãã¹ã¦ã®ãããã false ã§ããã
   *
   * @param {number} length  ãããæ°
   */
  function BitVector(length) {
    _classCallCheck(this, BitVector);

    this._length = length;
    this._array = new Uint32Array(Math.ceil(length / 32));
  }
  /**
   * @summary ãããæ°
   * @type {number}
   * @readonly
   */


  _createClass(BitVector, [{
    key: "setBit",

    /**
     * @summary ããããè¨­å®
     *
     * @param {number}  index  ã¤ã³ããã¯ã¹
     * @param {boolean} value  å¤
     */
    value: function setBit(index, value) {
      var uint32_index = Math.floor(index / 32);
      var uint32_value = this._array[uint32_index];
      var uint32_mask = 1 << index % 32;
      this._array[uint32_index] = value ? uint32_value | uint32_mask : uint32_value & ~uint32_mask;
    }
    /**
     * @summary ããããåå¾
     *
     * @param  {number}  index  ã¤ã³ããã¯ã¹
     * @return {boolean}        å¤
     */

  }, {
    key: "getBit",
    value: function getBit(index) {
      var uint32_index = Math.floor(index / 32);
      var uint32_value = this._array[uint32_index];
      var uint32_mask = 1 << index % 32;
      return (uint32_value & uint32_mask) != 0;
    }
  }, {
    key: "length",
    get: function get() {
      return this._length;
    }
  }]);

  return BitVector;
}();

/**
 * ã³ã³ãã­ã¹ãã§ã® Buffer ç®¡çã¢ã¤ãã 
 *
 * @memberof mapray.gltf
 * @private
 */

var BufferEntry =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.gltf.Buffer} buffer  ãããã¡
   */
  function BufferEntry(buffer) {
    _classCallCheck(this, BufferEntry);

    this._buffer = buffer;
    this._attrib_accessors = [];
    this._index_accessors = [];
  }
  /**
   * ç®¡çå¯¾è±¡ã®ãããã¡ãåå¾
   *
   * @type {mapray.gltf.Buffer}
   * @readonly
   */


  _createClass(BufferEntry, [{
    key: "addAttributeAccessor",

    /**
     * é ç¹å±æ§ã§ä½¿ããã¦ãã Accessor ã¤ã³ã¹ã¿ã³ã¹ãè¿½å 
     */
    value: function addAttributeAccessor(accessor) {
      this._attrib_accessors.push(accessor);
    }
    /**
     * ã¤ã³ããã¯ã¹ã§ä½¿ããã¦ãã Accessor ã¤ã³ã¹ã¿ã³ã¹ãè¿½å 
     */

  }, {
    key: "addIndexAccessor",
    value: function addIndexAccessor(accessor) {
      this._index_accessors.push(accessor);
    }
    /**
     * ãã¤ããªããã·ã³ã®ãã¤ããªã¼ãã¼ã«åããã¦æ¸ãæã
     */

  }, {
    key: "rewriteByteOrder",
    value: function rewriteByteOrder() {
      var modmap = new BitVector(Math.ceil(this._buffer.byteLength / 2));
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._getUnitedOriginalAccessors()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var accessor = _step.value;
          accessor.modifyByteOrder(modmap);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * ãããã¡ãåå²ããAccessor ãåæ§ç¯
     */

  }, {
    key: "splitBufferAndRebuildAccessors",
    value: function splitBufferAndRebuildAccessors() {
      this._splitBufferAndRebuildAccessors(this._attrib_accessors);

      this._splitBufferAndRebuildAccessors(this._index_accessors);
    }
    /**
     * ãããã¡ãåå²ããAccessor ãåæ§ç¯
     *
     * @param {iterable.<mapray.gltf.Accessor>} accessors  å¥å Accessor åå¾©å­
     */

  }, {
    key: "_splitBufferAndRebuildAccessors",
    value: function _splitBufferAndRebuildAccessors(accessors) {
      var splitter = new BufferSplitter();
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = BufferEntry._getOriginalAccessors(accessors)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var accessor = _step2.value;
          splitter.update(accessor);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      splitter.close(this._buffer);
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = accessors[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _accessor = _step3.value;
          splitter.rebuildAccessor(_accessor);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
    /**
     * ãããã¡ãåç§ã¦ããåå Accessor ã®åå¾©å­
     *
     * @return {iterable.<mapray.gltf.Accessor>}  åå Accessor åå¾©å­
     * @private
     */

  }, {
    key: "_getUnitedOriginalAccessors",
    value: function _getUnitedOriginalAccessors() {
      return BufferEntry._getOriginalAccessors(this._attrib_accessors.concat(this._index_accessors));
    }
    /**
     * åå Accessor ã®åå¾©å­ãåå¾
     *
     * @param  {iterable.<mapray.gltf.Accessor>} accessors  å¥å Accessor åå¾©å­
     * @return {iterable.<mapray.gltf.Accessor>}            åå Accessor åå¾©å­
     * @private
     */

  }, {
    key: "buffer",
    get: function get() {
      return this._buffer;
    }
  }], [{
    key: "_getOriginalAccessors",
    value: function _getOriginalAccessors(accessors) {
      var orig_accessors = new Map();
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = accessors[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var accessor = _step4.value;
          var key = accessor.index;

          if (!orig_accessors.has(key)) {
            orig_accessors.set(key, accessor);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return orig_accessors.values();
    }
  }]);

  return BufferEntry;
}();

/**
 * ã³ã³ãã­ã¹ãã§ã® Image ç®¡çã¢ã¤ãã 
 *
 * @memberof mapray.gltf
 * @private
 */
var ImageEntry =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.gltf.Image} image  ã¤ã¡ã¼ã¸
   */
  function ImageEntry(image) {
    _classCallCheck(this, ImageEntry);

    this._image = image;
    this._texinfo_objects = [];
  }
  /**
   * ã¤ã¡ã¼ã¸ãåå¾
   * @type {mapray.gltf.Texture}
   * @readonly
   */


  _createClass(ImageEntry, [{
    key: "addTextureInfo",

    /**
     * TextureInfo ã¤ã³ã¹ã¿ã³ã¹ãè¿½å 
     *
     * @param {mapray.gltf.TextureInfo} info  è¿½å ãã TextureInfo ã¤ã³ã¹ã¿ã³ã¹
     */
    value: function addTextureInfo(info) {
      this._texinfo_objects.push(info);
    }
    /**
     * ãã¯ã¹ãã£æå ±ãåæ§ç¯
     */

  }, {
    key: "rebuildTextureInfo",
    value: function rebuildTextureInfo() {
      var texinfo_objects = this._texinfo_objects;

      if (texinfo_objects.length <= 1) {
        // ã¤ã¡ã¼ã¸ãè¤æ°ã® TextureInfo ããåç§ãããªãã®ã§
        // ä½ãå¤æ´ããªã
        return;
      } // ãã®ç»åãä½¿ã£ã¦ããä»£è¡¨ãã¯ã¹ãã£


      var representative_texture = texinfo_objects[0].texture; // ãã®ç»åãä½¿ã£ã¦ãã (ãã¯ã¹ãã£æå ±åã®) ãã¯ã¹ãã£ã
      // ä»£è¡¨ãã¯ã¹ãã£ã«ç½®ãæãã

      for (var i = 1; i < texinfo_objects.length; ++i) {
        texinfo_objects[i].texture = representative_texture;
      }
    }
  }, {
    key: "image",
    get: function get() {
      return this._image;
    }
  }]);

  return ImageEntry;
}();

/**
 * glTF ã® buffer ã«å¯¾å¿
 * @memberof mapray.gltf
 * @private
 */
var Buffer =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.gltf.Context} [ctx]    èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   * @param {number}              [index]  buffers ç´¢å¼
   */
  function Buffer(ctx, index) {
    var _this = this;

    _classCallCheck(this, Buffer);

    if (ctx === undefined) {
      // å¼æ°ãªãæ§ç¯ (ç¹æ®ã¤ã³ã¹ã¿ã³ã¹ç¨)
      this._index = -1;
      this._byteLength = 0;
      this._uri = null;
      this._binary = null;
    } else {
      this._index = index; // glTF ã® buffer ãªãã¸ã§ã¯ã (specification/2.0/schema/buffer.schema.json)

      var jbuffer = ctx.gjson.buffers[index];
      this._byteLength = jbuffer.byteLength;

      if (jbuffer.uri !== undefined) {
        ctx.onStartLoadBuffer();
        ctx.loadBinary(jbuffer.uri).then(function (buffer) {
          // ãã¤ããªãã¼ã¿ã®åå¾ã«æå
          _this._binary = buffer;
          ctx.onFinishLoadBuffer();
        })["catch"](function (error) {
          // ãã¤ããªãã¼ã¿ã®åå¾ã«å¤±æ
          console.error(error);
          ctx.onFinishLoadBuffer(error);
        });
      } else {
        // todo: GLB-stored Buffer
        this._uri = null;
        this._binary = null;
      }
    }
  }
  /**
   * å¯¾å¿ãã glTF ãªãã¸ã§ã¯ãã§ã®ç´¢å¼ãåå¾
   * @type {number}
   * @readonly
   */


  _createClass(Buffer, [{
    key: "createSubBuffer",

    /**
     * é¨åãããã¡ãçæ
     *
     * @param  {number} first  æåã®ãã¤ãä½ç½®
     * @param  {number} last   æå¾ã®ãã¤ãä½ç½® + 1
     * @return {mapray.gltf.Buffer}  é¨åãããã¡
     */
    value: function createSubBuffer(first, last) {
      var subBuffer = new Buffer();
      subBuffer._byteLength = last - first;
      subBuffer._binary = this._binary.slice(first, last);
      return subBuffer;
    }
  }, {
    key: "index",
    get: function get() {
      return this._index;
    }
    /**
     * ãã¤ããªãã¼ã¿
     * @type {ArrayBuffer}
     * @readonly
     */

  }, {
    key: "binary",
    get: function get() {
      return this._binary;
    }
    /**
     * ãã¤ããªãã¼ã¿ã®ãã¤ãæ°ãåå¾
     * @type {number}
     * @readonly
     */

  }, {
    key: "byteLength",
    get: function get() {
      return this._byteLength;
    }
  }]);

  return Buffer;
}();

/**
 * glTF ã® image ã«å¯¾å¿
 * @memberof mapray.gltf
 * @private
 */

var Image$1 =
/*#__PURE__*/
function () {
  /**
   * åæå
   * @param {mapray.gltf.Context} ctx    èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
   * @param {number}              index  images ç´¢å¼
   */
  function Image(ctx, index) {
    var _this = this;

    _classCallCheck(this, Image);

    this._index = index; // glTF ã® image ãªãã¸ã§ã¯ã (specification/2.0/schema/image.schema.json)

    var jimage = ctx.gjson.images[index];

    if (jimage.uri !== undefined) {
      ctx.onStartLoadImage();
      ctx.loadImage(jimage.uri).then(function (image) {
        _this._image = image;
        ctx.onFinishLoadImage();
      })["catch"](function (error) {
        ctx.onFinishLoadImage(error);
      });
    } else if (jimage.bufferView !== undefined) {
      this._bufferView = new BufferView(ctx, jimage.bufferView);
    } // mimeType ã¯ "image/jpeg" ã¾ãã¯ "image/png" ã§ bufferView ã®ã¨ãã¯å¿é 
    // uri ã®ã¨ãã¯ä»»æã§ããã mimeType ãæå®ããã¦ããã¨ããã¿ã¤ãã¯ mimeType ã¨è§£éãã


    this._mimeType = jimage.mimeType;
    this._image = null;
  }
  /**
   * å¯¾å¿ãã glTF ãªãã¸ã§ã¯ãã§ã®ç´¢å¼ãåå¾
   * @type {number}
   * @readonly
   */


  _createClass(Image, [{
    key: "index",
    get: function get() {
      return this._index;
    }
    /**
     * ç»åãã¼ã¿
     * @type {HTMLImageElement}
     * @readonly
     */

  }, {
    key: "image",
    get: function get() {
      return this._image;
    }
  }]);

  return Image;
}();

/**
 * glTF èª­è¾¼ã¿ã³ã³ãã­ã¹ã
 *
 * @memberof mapray.gltf
 * @private
 */

var Context =
/*#__PURE__*/
function () {
  /**
   * @param  {object} body       Tool.load() ã®ååãã©ã¡ã¼ã¿ãåç§
   * @param  {object} [options]  Tool.load() ã®ååãã©ã¡ã¼ã¿ãåç§
   */
  function Context(body, options) {
    _classCallCheck(this, Context);

    var opts = options || {};
    this._gjson = body;
    this._base_resource = opts.base_resource;
    this._binary_type = opts.binary_type;
    this._image_type = opts.image_type;
    this._supported_extensions = opts.supported_extensions || [];
    this._resolve = null; // Promise ã® resolve() é¢æ°

    this._reject = null; // Promise ã® reject() é¢æ°

    this._used_extensions = new Set(); // ã³ã³ãã³ããä½¿ç¨ããæ¡å¼µæ©è½åã®éå

    this._scenes = [];
    this._default_scene_index = -1;
    this._buffer_entries = []; // å±æç¨ãããã¡ã®ç®¡ç (çéå)

    this._image_entries = []; // å±æç¨ã¤ã¡ã¼ã¸ã®ç®¡ç (çéå)

    this._body_finished = false; // body ã®è§£æãçµãããï¼

    this._load_count = 0; // ç¾å¨ãªã¯ã¨ã¹ãä¸­ã®ãªãã¸ã§ã¯ãæ°

    this._load_error = null; // ã¨ã©ã¼ãçºçããã¨ãã®ã¨ã©ã¼ãªãã¸ã§ã¯ã

    this._settled = false; // Promise ã®ç¶æã Fulfilled ã¾ãã¯ Rejected ãï¼
  }
  /**
   * @summary glTF ã®èª­è¾¼ã¿ã¨è§£æ
   *
   * @return {Promise}  èª­è¾¼ã¿ Promise (mapray.gltf.Content)
   */


  _createClass(Context, [{
    key: "load",
    value: function load() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        _this._resolve = resolve;
        _this._reject = reject; // glTF ãã¼ã¸ã§ã³ãç¢ºèª

        var version = _this._loadVersion();

        if (version.major < 2) {
          reject(new Error("glTF version error"));
          return;
        } // ã³ã³ãã³ãã«å¿é ã®æ¡å¼µæ©è½ããµãã¼ããã¦ããããç¢ºèª


        var supported_ext = _this._getSupportedExtensionNames();

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _this._enumRequiredExtensionNames()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var required_ext = _step.value;

            if (!supported_ext.has(required_ext)) {
              reject(new Error("glTF extension error: " + required_ext));
              return;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        _this._loadExtensionsUsed();

        _this._loadScenes();

        _this._loadDefaultSceneIndex();

        _this._onFinishLoadBody();
      });
    }
    /**
     * glTF ãã¼ã¸ã§ã³ãè§£æ
     *
     * @return {object}  { major: major_version, minor: minor_version }
     * @private
     */

  }, {
    key: "_loadVersion",
    value: function _loadVersion() {
      // asset.schema
      var asset = this._gjson.asset; // å¿é 

      var version = asset.version; // å¿é 

      var version_array = /^(\d+)\.(\d+)/.exec(version);
      var major_version = Number(version_array[1]);
      var minor_version = Number(version_array[2]);
      return {
        major: major_version,
        minor: minor_version
      };
    }
    /**
     * @summary å¿é ã®æ¡å¼µæ©è½ã®ååãåæ
     *
     * @desc
     * <p>glTF ã¢ã»ããããå¿é ã®æ¡å¼µæ©è½ãè§£æãã¦ã
     *    ãã®æ¡å¼µæ©è½ã®ååãåæããã</p>
     *
     * @return {iterable.<string>}  æ¡å¼µæ©è½åã®åæ
     *
     * @private
     */

  }, {
    key: "_enumRequiredExtensionNames",
    value: function _enumRequiredExtensionNames() {
      return this._gjson.extensionsRequired || [];
    }
    /**
     * @summary å¯¾å¿å¯è½ãªæ¡å¼µæ©è½ã®ååã®éåãåå¾
     *
     * @desc
     * <p>glTF ã®ã­ã¼ãã¼ã¨ã¯ã©ã¤ã¢ã³ããå¯¾å¿ã§ããæ¡å¼µæ©è½ã®
     *    ååã®éåãåå¾ããã</p>
     *
     * @return {Set.<string>}  æ¡å¼µæ©è½åã®éå
     *
     * @private
     */

  }, {
    key: "_getSupportedExtensionNames",
    value: function _getSupportedExtensionNames() {
      // ã­ã¼ãã¼èªèº«ãå¯¾å¿ã§ããæ¡å¼µæ©è½
      // â» ä»ã®ã¨ãããµãã¼ãã§ããæ¡å¼µæ©è½ã¯ãªã
      var supported_extensions_by_loader = []; // ã­ã¼ãã¼ãå¼ã³åºãå´ãå¯¾å¿ã§ããæ¡å¼µæ©è½

      var supported_extensions_by_client = this._supported_extensions;
      return new Set(supported_extensions_by_loader.concat(supported_extensions_by_client));
    }
    /**
     * @summary ã³ã³ãã³ããä½¿ç¨ããæ¡å¼µæ©è½ãèª­ã¿è¾¼ã
     *
     * @desc
     * <p>extensionsUsed ãã­ããã£ãèª­ã¿è¾¼ã¿ this._used_extensions ãè¨­å®ããã</p>
     *
     * @private
     */

  }, {
    key: "_loadExtensionsUsed",
    value: function _loadExtensionsUsed() {
      this._used_extensions = new Set(this._gjson.extensionsUsed || []);
    }
    /**
     * @summary ãã¹ã¦ã®ã·ã¼ã³ãèª­ã¿è¾¼ã
     *
     * <p>ã·ã¼ã³ãèª­ã¿è¾¼ã¿ããªãã¸ã§ã¯ãã this._scenes ã®éåã«è¨­å®ããã</p>
     *
     * @private
     */

  }, {
    key: "_loadScenes",
    value: function _loadScenes() {
      var num_scenes = (this._gjson.scenes || []).length;
      var scenes = [];

      for (var index = 0; index < num_scenes; ++index) {
        scenes.push(new Scene$1(this, index));
      }

      this._scenes = scenes;
    }
    /**
     * @summary æ¢å®ã·ã¼ã³ã®ç´¢å¼ãèª­ã¿è¾¼ã
     *
     * <p>æ¢å®ã®ã·ã¼ã³ç´¢å¼ãè§£æããthis._default_scene_index ã«è¨­å®ããã</p>
     *
     * @private
     */

  }, {
    key: "_loadDefaultSceneIndex",
    value: function _loadDefaultSceneIndex() {
      if (typeof this._gjson.scene == 'number') {
        this._default_scene_index = this._gjson.scene;
      }
    }
    /**
     * glTF æä¸ä½ãªãã¸ã§ã¯ã
     * @type {object}
     * @readonly
     */

  }, {
    key: "extractUsedExtensions",

    /**
     * @summary æ¡å¼µæ©è½ã®æ½åº
     *
     * @desc
     * <p>æ¡å¼µæ©è½åºæãªãã¸ã§ã¯ã extensions ãã extensionsUsed
     *    ã«å­å¨ãããã®ã ããæ½åºããã</p>
     *
     * @param {object} extensions
     *
     * @return {object}
     */
    value: function extractUsedExtensions(extensions) {
      var dict = {};

      for (var key in extensions) {
        if (this._used_extensions.has(key)) {
          dict[key] = extensions[key];
        }
      }

      return dict;
    }
    /**
     * ãããã¡ãã¼ã¿ã®èª­ã¿è¾¼ã¿ãéå§
     * @param {mapray.gltf.Context} ctx  èª­ã¿è¾¼ã¿ã³ã³ãã­ã¹ã
     * @param {string}              url  ãããã¡ãã¼ã¿ã® URL
     * @private
     */

  }, {
    key: "loadBinary",
    value: function loadBinary(path) {
      return this._base_resource.loadSubResource(path, {
        type: this._binary_type
      });
    }
  }, {
    key: "loadImage",
    value: function loadImage(path) {
      return this._base_resource.loadSubResource(path, {
        type: this._image_type
      });
    }
    /**
     * ãããã¡ãæ¤ç´¢
     * @param  {number} index        ãããã¡ç´¢å¼
     * @return {mapray.gltf.Buffer}  gltf.Buffer ãªãã¸ã§ã¯ã
     */

  }, {
    key: "findBuffer",
    value: function findBuffer(index) {
      if (this._buffer_entries[index] === undefined) {
        this._buffer_entries[index] = new BufferEntry(new Buffer(this, index));
      }

      return this._buffer_entries[index].buffer;
    }
    /**
     * ã¤ã¡ã¼ã¸ãæ¤ç´¢
     * @param  {number} index       ã¤ã¡ã¼ã¸ç´¢å¼
     * @return {mapray.gltf.Image}  gltf.Image ãªãã¸ã§ã¯ã
     */

  }, {
    key: "findImage",
    value: function findImage(index) {
      if (this._image_entries[index] === undefined) {
        this._image_entries[index] = new ImageEntry(new Image$1(this, index));
      }

      return this._image_entries[index].image;
    }
    /**
     * gltf.Accessor ãè¿½å 
     *
     * @param {mapray.gltf.Accessor} accessor  ã¢ã¯ã»ãµãªãã¸ã§ã¯ã
     * @param {string}               usage     ç¨é ("ATTRIBUTE" | "INDEX")
     */

  }, {
    key: "addAccessor",
    value: function addAccessor(accessor, usage) {
      var entry = this._buffer_entries[accessor.bufferView.buffer.index];

      switch (usage) {
        case "ATTRIBUTE":
          entry.addAttributeAccessor(accessor);
          break;

        case "INDEX":
          entry.addIndexAccessor(accessor);
          break;
      }
    }
    /**
     * gltf.TextureInfo ãè¿½å 
     *
     * @param {mapray.gltf.TextureInfo} info  ãã¯ã¹ãã£æå ±
     */

  }, {
    key: "addTextureInfo",
    value: function addTextureInfo(info) {
      var image = info.texture.source;
      var entry = this._image_entries[image.index];
      entry.addTextureInfo(info);
    }
    /**
     * ãã¤ããªãèª­ã¿è¾¼ã¿å§ããã¨ãã®å¦ç
     */

  }, {
    key: "onStartLoadBuffer",
    value: function onStartLoadBuffer() {
      this._load_count += 1;
    }
    /**
     * ãã¤ããªãèª­ã¿è¾¼ã¿çµãã£ãã¨ãã®å¦ç
     *
     * @param {Error} [error]  å¤±æããã¨ãã®ã¨ã©ã¼ãªãã¸ã§ã¯ã
     */

  }, {
    key: "onFinishLoadBuffer",
    value: function onFinishLoadBuffer(error) {
      if (error) {
        this._load_error = error;
      }

      this._load_count -= 1;

      this._onFinishLoadSomething();
    }
    /**
     * ç»åãèª­ã¿è¾¼ã¿å§ããã¨ãã®å¦ç
     */

  }, {
    key: "onStartLoadImage",
    value: function onStartLoadImage() {
      this._load_count += 1;
    }
    /**
     * ç»åãèª­ã¿è¾¼ã¿çµãã£ãã¨ãã®å¦ç
     *
     * @param {Error} [error]  å¤±æããã¨ãã®ã¨ã©ã¼ãªãã¸ã§ã¯ã
     */

  }, {
    key: "onFinishLoadImage",
    value: function onFinishLoadImage(error) {
      if (error) {
        this._load_error = error;
      }

      this._load_count -= 1;

      this._onFinishLoadSomething();
    }
    /**
     * glTF æ¬ä½ãèª­ã¿è¾¼ã¿çµãã£ãã¨ãã®å¦ç
     * @private
     */

  }, {
    key: "_onFinishLoadBody",
    value: function _onFinishLoadBody() {
      this._body_finished = true;

      this._onFinishLoadSomething();
    }
    /**
     * ä½ããèª­ã¿è¾¼ã¿çµãã£ãã¨ãã®å¦ç
     * @private
     */

  }, {
    key: "_onFinishLoadSomething",
    value: function _onFinishLoadSomething() {
      if (this._settled) ; else if (this._load_error !== null) {
        // ã©ããã§å¤±æãã
        this._reject(this._load_error);

        this._settled = true;
      } else if (this._body_finished && this._load_count == 0) {
        // å¤é¨ãã¡ã¤ã«ãå«ãã¦ããã¹ã¦èª­ã¿è¾¼ã¿çµãã£ã
        this._rewriteBuffersForByteOrder();

        this._splitBuffersAndRebuildAccessors();

        this._rebuildTextureInfo();

        this._resolve(new Content(this, this._scenes, this._default_scene_index));

        this._settled = true;
      }
    }
    /**
     * ãã¹ã¦ã®ãããã¡ã®ãã¤ããªã¼ãã¼ãæ¸ãæãã
     * @private
     */

  }, {
    key: "_rewriteBuffersForByteOrder",
    value: function _rewriteBuffersForByteOrder() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._buffer_entries[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var entry = _step2.value;

          if (entry !== undefined) {
            entry.rewriteByteOrder();
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    /**
     * ãããã¡ãåå²ããAccessor ãåæ§ç¯
     * @private
     */

  }, {
    key: "_splitBuffersAndRebuildAccessors",
    value: function _splitBuffersAndRebuildAccessors() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this._buffer_entries[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var entry = _step3.value;

          if (entry !== undefined) {
            entry.splitBufferAndRebuildAccessors();
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
    /**
     * ãã¯ã¹ãã£æå ±ãåæ§ç¯
     * @private
     */

  }, {
    key: "_rebuildTextureInfo",
    value: function _rebuildTextureInfo() {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._image_entries[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var entry = _step4.value;

          if (entry !== undefined) {
            entry.rebuildTextureInfo();
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }, {
    key: "gjson",
    get: function get() {
      return this._gjson;
    }
  }]);

  return Context;
}();

/**
 * glTF é¢é£ã®ãã¼ã«
 *
 * @memberof mapray.gltf
 * @private
 */

var Tool =
/*#__PURE__*/
function () {
  function Tool() {
    _classCallCheck(this, Tool);
  }

  _createClass(Tool, null, [{
    key: "load",

    /**
     * @summary glTF ãã¼ã¿ãè§£æãã¦ãªãã¸ã§ã¯ããæ§ç¯
     *
     * @param  {object} body       ãã¼ã¿ã®æ¬ä½ (JSON ãªãã¸ã§ã¯ã)
     * @param  {object} [options]  ãªãã·ã§ã³éå
     * @param  {string} [options.base_resouece]     åºåºã¨ãªããªã½ã¼ã¹
     * @param  {any} [options.binary_type]  ãã¤ããªã¿ã¤ã
     * @param  {any} [options.image_type]   ã¤ã¡ã¼ã¸ã¿ã¤ã
     * @param  {string[]} [options.supported_extensions]  ã­ã¼ãã¼ãå¼ã³åºãå´ãå¯¾å¿ã§ãã glTF æ¡å¼µæ©è½ã®ãªã¹ã
     * @return {Promise}           èª­è¾¼ã¿ Promise (mapray.gltf.Content)
     */
    value: function load(body, options) {
      var context = new Context(body, options);
      return context.load();
    }
  }]);

  return Tool;
}();

/**
 * @summary ã·ã¼ã³ã®èª­ã¿è¾¼ã¿
 * @memberof mapray
 */

var SceneLoader =
/*#__PURE__*/
function (_Loader) {
  _inherits(SceneLoader, _Loader);

  /**
   * @desc
   * <p>url ã§æå®ããã·ã¼ã³ãã¼ã¿ã®èª­ã¿è¾¼ã¿ãéå§ããscene ã«ã¨ã³ãã£ãã£ãæ§ç¯ããã</p>
   * <p>èª­ã¿è¾¼ã¿ãçµäºããã¨ã options.callback ãå¼ã³åºãã</p>
   * @param {mapray.Scene} scene      èª­ã¿è¾¼ã¿åã®ã·ã¼ã³
   * @param {string}       resource        ã·ã¼ã³ãªã½ã¼ã¹
   * @param {object}       [options]  ãªãã·ã§ã³éå
   * @param {mapray.Loader.TransformCallback} [options.transform]  ãªã½ã¼ã¹è¦æ±å¤æé¢æ°
   * @param {mapray.Loader.EntityCallback}         [options.onEntity]   ã¨ã³ãã£ãã£ã³ã¼ã«ããã¯
   * @param {mapray.SceneLoader.FinishCallback}    [options.callback]   çµäºã³ã¼ã«ããã¯é¢æ°
   */
  function SceneLoader(scene, resource) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, SceneLoader);

    if (resource instanceof Resource) ; else if (typeof resource === "string") {
      resource = new URLResource(resource, {
        type: "json",
        transform: options.transform
      });
    } else {
      throw new Error("Unsupported Resource: " + resource);
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SceneLoader).call(this, scene, resource, {
      onEntity: options.onEntity,
      onLoad: options.callback
    }));
    _this._glenv = scene.glenv;
    _this._references = {};
    _this._finished = false;
    return _this;
  }
  /**
   * @summary ãªãã¸ã§ã¯ãåç§ãåå¾
   * @desc
   * <p>æ³¨æ: ã·ã¼ã³ã®èª­ã¿è¾¼ã¿ãçµäºãããã¨ãç¢ºèªãã¦ãããã®ã¡ã½ãããå¼ã³åºããã¨ã</p>
   * @param  {string}                                   id  è­å¥å­
   * @return {?(mapray.ModelContainer|mapray.Entity)}  ãªãã¸ã§ã¯ã
   */


  _createClass(SceneLoader, [{
    key: "getReference",
    value: function getReference(id) {
      var ref = this._references[id];
      return ref !== undefined ? ref : null;
    }
    /**
     * @summary ãªãã¸ã§ã¯ãåç§ãè¨­å®
     * @desc
     * <p>ãªãã¸ã§ã¯ã item ãè­å¥å­ id ã§åç§ã§ããããã« this ã«è¨­å®ããã</p>
     * @param {string}                                   id    è­å¥å­
     * @param {mapray.ModelContainer|mapray.Entity} item  ãªãã¸ã§ã¯ã
     * @private
     */

  }, {
    key: "_setReference",
    value: function _setReference(id, item) {
      // åç§ãè¨­å®
      this._references[id] = item;
    }
    /**
     * @summary èª­ã¿è¾¼ã¿å¦çã®å®æãç¶æ¿ã¯ã©ã¹ã«ãã£ã¦å®è£ãããã
     * @private
     */

  }, {
    key: "_load",
    value: function _load() {
      var _this2 = this;

      return this._resource.load({
        type: ResourceType.JSON
      }).then(function (oscene) {
        // JSON ãã¼ã¿ã®åå¾ã«æå
        _this2._check_cancel();

        return _this2._load_object(oscene);
      });
    }
    /**
     * JSON ã·ã¼ã³ãªãã¸ã§ã¯ããè§£æ
     * @private
     */

  }, {
    key: "_load_object",
    value: function _load_object(oscene) {
      var _this3 = this;

      return Promise.resolve().then(function () {
        return _this3._load_model_register(oscene);
      }).then(function () {
        return _this3._postload_object(oscene);
      });
    }
    /**
     * æ®ãã®ãªãã¸ã§ã¯ããèª­ã¿è¾¼ã
     * @private
     */

  }, {
    key: "_postload_object",
    value: function _postload_object(oscene) {
      if (this.status !== Loader.Status.LOADING) return;

      this._load_entity_list(oscene);
    }
    /**
     * @private
     */

  }, {
    key: "_load_model_register",
    value: function _load_model_register(oscene) {
      var model_register = oscene["model_register"];
      if (!model_register) return;
      var keys = Object.keys(model_register);
      var asyncTasks = [];

      for (var i = 0; i < keys.length; ++i) {
        var id = keys[i];
        var model = model_register[id];
        asyncTasks.push(this._load_model_container(oscene, id, model));
      }

      return Promise.all(asyncTasks);
    }
    /**
     * @private
     */

  }, {
    key: "_load_model_container",
    value: function _load_model_container(oscene, id, model) {
      var _this4 = this;

      var url = model.link;
      if (!this._resource.resolveResourceSupported()) return Promise.reject(new Error("Sub Resource is not supported"));

      var gltf_resource = this._resource.resolveResource(url);

      return gltf_resource.load({
        type: ResourceType.JSON
      }).then(function (json) {
        // ã¢ãã«ãã¼ã¿ã®åå¾ã«æå
        _this4._check_cancel(); // ãã¼ã¿ãè§£æãã¦ gltf.Content ãæ§ç¯


        return Tool.load(json, {
          base_resource: gltf_resource,
          binary_type: ResourceType.BINARY,
          image_type: ResourceType.IMAGE,
          supported_extensions: ModelContainer.getSupportedExtensions_glTF()
        });
      }).then(function (content) {
        // ã¢ãã«ãã¼ã¿ã®æ§ç¯ã«æå
        var container = new ModelContainer(_this4._scene, content);

        if (model.offset_transform) {
          var matrix = SceneLoader.parseOffsetTransform(model.offset_transform);
          container.setOffsetTransform(matrix);
        }

        _this4._setReference(id, container);
      });
    }
    /**
     * @private
     */

  }, {
    key: "_load_entity_list",
    value: function _load_entity_list(oscene) {
      var entity_list = oscene["entity_list"];
      if (!entity_list) return;
      var scene = this._scene;

      for (var i = 0; i < entity_list.length; ++i) {
        var item = entity_list[i];
        var type = item.type;
        var entity = null;

        switch (type) {
          case "markerline":
            entity = new MarkerLineEntity(scene, {
              json: item,
              refs: this._references
            });
            break;

          case "path":
            entity = new PathEntity(scene, {
              json: item,
              refs: this._references
            });
            break;

          case "text":
            entity = new TextEntity(scene, {
              json: item,
              refs: this._references
            });
            break;

          case "model":
            entity = new ModelEntity(scene, {
              json: item,
              refs: this._references
            });
            break;

          case "polygon":
            entity = new PolygonEntity(scene, {
              json: item,
              refs: this._references
            });
            break;

          default:
            console.error("mapray: unknown entity type: " + type);
            break;
        }

        if (entity) {
          this._onEntity(this, entity, item);

          var id = item.id;

          if (id) {
            this._setReference(id, entity);
          }
        }
      }
    }
    /**
     * ã¹ã­ã¼ã <OFFSET-TRANSFORM> ã®ãªãã¸ã§ã¯ããè§£æ
     *
     * @param  {object} offset_transform  <OFFSET-TRANSFORM> ãªãã¸ã§ã¯ã
     * @return {mapray.Matrix}            ãªãã»ããå¤æè¡å
     * @package
     */

  }], [{
    key: "parseOffsetTransform",
    value: function parseOffsetTransform(offset_transform) {
      var ot = offset_transform; // <OFFSET-TRANSFORM-PARAMS>

      var translate = ot.translate || [0, 0, 0];
      var orientation = new Orientation(ot.heading, ot.tilt, ot.roll);
      var scale = ot.scale !== undefined ? ot.scale : [1, 1, 1]; // <PARAM-SCALE3>

      if (typeof scale == 'number') {
        // ã¹ã±ã¼ã«ããã¯ãã«ã«æ­£è¦å
        scale = [scale, scale, scale];
      } // scale -> orientation -> translate é ã®å¤æ


      var matrix = GeoMath.createMatrix();
      orientation.getTransformMatrix(scale, matrix);
      matrix[12] = translate[0];
      matrix[13] = translate[1];
      matrix[14] = translate[2];
      return matrix;
    }
  }]);

  return SceneLoader;
}(Loader);
/**
 * @summary çµäºã³ã¼ã«ããã¯
 * @callback FinishCallback
 * @desc
 * <p>ã·ã¼ã³ã®èª­ã¿è¾¼ã¿ãçµäºããã¨ãã«å¼ã³åºãããé¢æ°ã®åã§ããã</p>
 * @param {mapray.SceneLoader} loader     èª­ã¿è¾¼ã¿ãå®è¡ããã­ã¼ãã¼
 * @param {boolean}            isSuccess  æåããã¨ã true, å¤±æããã¨ã false
 * @memberof mapray.SceneLoader
 */


SceneLoader._defaultHeaders = {};

/**
 * @summary è¿½å ã³ã³ããã®è¡¨ç¤ºå¶å¾¡
 *
 * @class ContainerController
 */
var ContainerController =
/*#__PURE__*/
function () {
  /**
   * @summary ã³ã³ã¹ãã©ã¯ã¿
   * @param {HTMLElement}                         container           ã«ã¼ãã³ã³ããï¼Viewerã¯ã©ã¹ã®container_elementï¼
   * @param {object}                              options             è¡¨ç¤ºãªãã·ã§ã³
   * @param {boolean}                             options.visibility  è¡¨ç¤ºã»éè¡¨ç¤º
   * @param {ContainerPosition}                   options.position    è¡¨ç¤ºä½ç½®
   * @memberof ContainerController
   */
  function ContainerController(container, options) {
    _classCallCheck(this, ContainerController);

    this._visibility = options && options.visibility || true;
    this._position = options && options.position || ContainerPosition.TOP_LEFT;
    var container_element;

    if (typeof container == "string") {
      // ã³ã³ããã ID æå®ããã¨ã
      container_element = document.getElementById(container);
    } else {
      // ã³ã³ãããç´æ¥è¦ç´ ã§æå®ã®ã¨ã
      container_element = container;
    }

    this._viewer_container = container_element;
    this._container = null;
    this._is_compact = false;
    var self = this;
    window.addEventListener("resize", function () {
      self._sizeChanged();
    }, false);
  }
  /**
   * @summary è¡¨ç¤ºã»éè¡¨ç¤ºã®è¨­å®
   *
   * @param {boolean} visibility
   * @memberof ContainerController
   */


  _createClass(ContainerController, [{
    key: "setVisibility",
    value: function setVisibility(visibility) {
      this._visibility = visibility; // è¡¨ç¤ºç¶æã®æ´æ°

      this._setContainerVisibility();
    }
    /**
     * @summary è¡¨ç¤ºä½ç½®
     *
     * @param {ContainerPosition}   position
     * @memberof ContainerController
     */

  }, {
    key: "setPosition",
    value: function setPosition(position) {
      this._position = position; // ã³ã³ããã®åä½æ

      this._deleteContainer();

      this.createContainer();
    }
    /**
     * @summary ã³ã³ããã®è¡¨ç¤ºè¨­å®
     *
     * @memberof ContainerController
     */

  }, {
    key: "_setContainerVisibility",
    value: function _setContainerVisibility() {
      if (this._container) {
        this._visibility ? this._container.style.visibility = "visible" : this._container.style.visibility = "collapse";
      }
    }
    /**
     * @summary ã¤ã³ã¹ã¿ã³ã¹ã®ç ´æ£
     *
     * @memberof ContainerController
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      var self = this;
      window.removeEventListener("resize", function () {
        self._sizeChanged();
      }, false);

      this._deleteContainer();
    }
    /**
     * @summary è¿½å ã³ã³ããã®åé¤
     *
     * @memberof ContainerController
     */

  }, {
    key: "_deleteContainer",
    value: function _deleteContainer() {
      var parent_container = this._container.parentElement;
      parent_container.removeChild(this._container);
      this._container = null;
    }
    /**
     * @summary ãªãµã¤ãºã¤ãã³ã
     *
     * @memberof ContainerController
     * @abstract
     */

  }, {
    key: "_sizeChanged",
    value: function _sizeChanged() {}
    /**
     * @summary è¿½å ã³ã³ããã®ä½æ
     *
     * @memberof ContainerController
     * @abstract
     */

  }, {
    key: "createContainer",
    value: function createContainer() {}
  }]);

  return ContainerController;
}();
/**
 * @summary ã­ã´ã»èä½æ¨©è¡¨ç¤ºä½ç½®ã®åæå
 * @enum {object}
 * @memberof ContainerController
 * @constant
 */


var ContainerPosition = {
  /** 
   * å·¦ä¸
   */
  TOP_LEFT: {
    id: "top-left"
  },

  /** 
   * å³ä¸ 
   */
  TOP_RIGHT: {
    id: "top-right"
  },

  /**
   * å·¦ä¸
   */
  BOTTOM_LEFT: {
    id: "bottom-left"
  },

  /**
   * å³ä¸
   */
  BOTTOM_RIGHT: {
    id: "bottom-right"
  }
};
{
  ContainerController._compact_size = 500;
  ContainerController.ContainerPosition = ContainerPosition;
}

/**
 * @summary ã­ã´ã®è¡¨ç¤ºå¶å¾¡
 *
 * @class LogoController
 * @extends {mapray.ContainerController}
 */

var LogoController =
/*#__PURE__*/
function (_ContainerController) {
  _inherits(LogoController, _ContainerController);

  /**
   * @summary ã³ã³ã¹ãã©ã¯ã¿
   * @param {HTMLElement}                                 container           ã«ã¼ãã³ã³ããï¼Viewerã¯ã©ã¹ã®container_elementï¼
   * @param {object}                                      options             è¡¨ç¤ºãªãã·ã§ã³
   * @param {boolean}                                     options.visibility  è¡¨ç¤ºã»éè¡¨ç¤º
   * @param {ContainerController.ContainerPosition}       options.position    è¡¨ç¤ºä½ç½®
   * @memberof LogoController
   */
  function LogoController(container, options) {
    var _this;

    _classCallCheck(this, LogoController);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LogoController).call(this, container, options));
    _this._position = options && options.position || ContainerController.ContainerPosition.BOTTOM_LEFT;
    return _this;
  }
  /**
   * @summary ãªãµã¤ãºã¤ãã³ã
   *
   * @memberof LogoController
   */


  _createClass(LogoController, [{
    key: "_sizeChanged",
    value: function _sizeChanged() {
      if (this._container) {
        var sub_container = this._container.children[0];
        var parent_container = this._container.parentElement;

        if (parent_container.parentElement.clientWidth < ContainerController._compact_size) {
          sub_container.classList.add("mapray-logo-compact");
        } else {
          sub_container.classList.remove("mapray-logo-compact");
        }
      }
    }
    /**
     * @summary è¿½å ã³ã³ããã®ä½æ
     *
     * @memberof LogoController
     */

  }, {
    key: "createContainer",
    value: function createContainer() {
      var name = "control-" + this._position.id;

      var parent_container = this._viewer_container.getElementsByClassName(name)[0];

      var main_container = document.createElement("div");
      main_container.className = "control";
      var sub_container = document.createElement("a");
      sub_container.className = "mapray-logo";
      sub_container.href = "https://mapray.com";
      sub_container.target = "_blank";
      main_container.appendChild(sub_container);
      this._container = main_container;
      parent_container.appendChild(this._container);

      this._sizeChanged();
    }
  }]);

  return LogoController;
}(ContainerController);

/**
 * @summary èä½æ¨©è¡¨ç¤ºã®è¡¨ç¤ºå¶å¾¡
 *
 * @class AttributionController
 * @extends {mapray.ContainerController}
 */

var AttributionController =
/*#__PURE__*/
function (_ContainerController) {
  _inherits(AttributionController, _ContainerController);

  /**
   * @summary ã³ã³ã¹ãã©ã¯ã¿
   * @param {HTMLElement}                             container                       ã«ã¼ãã³ã³ããï¼Viewerã¯ã©ã¹ã®container_elementï¼
   * @param {object}                                  options                         è¡¨ç¤ºãªãã·ã§ã³
   * @param {boolean}                                 options.isVisible               è¡¨ç¤ºã»éè¡¨ç¤º
   * @param {ContainerController.ContainerPosition}   options.position                è¡¨ç¤ºä½ç½®
   * @param {array}                                   options.attributions            èä½æ¨©ãªã¹ã
   * @param {string}                                  options.attributions.display    è¡¨ç¤ºå
   * @param {string}                                  options.attributions.link       ãªã³ã¯
   * @memberof AttributionController
   */
  function AttributionController(container, options) {
    var _this;

    _classCallCheck(this, AttributionController);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AttributionController).call(this, container, options));
    _this._position = options && options.position || ContainerController.ContainerPosition.BOTTOM_RIGHT;
    _this._attributions = [];

    if (options && options.attributions) {
      _this.copyAttributions(options.attributions);
    } else {
      _this.copyAttributions(AttributionController._default_attribution);
    }

    return _this;
  }
  /**
   * @summary èä½æ¨©è¡¨ç¤ºã®è¿½å 
   *
   * @param {object}  attribution            èä½æ¨©è¡¨ç¤ºãªãã¸ã§ã¯ã
   * @param {string}  attribution.display    è¡¨ç¤ºå
   * @param {string}  attribution.link       ãªã³ã¯
   * @memberof AttributionController
   */


  _createClass(AttributionController, [{
    key: "addAttribution",
    value: function addAttribution(attribution) {
      this._attributions.push(attribution); // ã³ã³ããã®åä½æ


      this._deleteContainer();

      this.createContainer();
    }
    /**
     * @summary èä½æ¨©è¡¨ç¤ºã®ãªã»ãã
     *
     * @memberof AttributionController
     */

  }, {
    key: "clearAttribution",
    value: function clearAttribution() {
      this._attributions = []; // ã³ã³ããã®åä½æ

      this._deleteContainer();

      this.createContainer();
    }
    /**
     * @summary ãªãµã¤ãºã¤ãã³ã
     *
     * @memberof AttributionController
     */

  }, {
    key: "_sizeChanged",
    value: function _sizeChanged() {
      if (this._container) {
        var parent_container = this._container.parentElement;

        if (parent_container.parentElement.clientWidth < ContainerController._compact_size) {
          this._container.classList.add("mapray-attribution-compact");
        } else {
          this._container.classList.remove("mapray-attribution-compact");
        }
      }
    }
    /**
     * @summary è¿½å ã³ã³ããã®ä½æ
     *
     * @memberof AttributionController
     */

  }, {
    key: "createContainer",
    value: function createContainer() {
      var name = "control-" + this._position.id;

      var parent_container = this._viewer_container.getElementsByClassName(name)[0];

      var main_container = document.createElement("div");
      main_container.classList.add("control");
      main_container.classList.add("mapray-attribution");
      var sub_container = document.createElement("div");
      sub_container.classList.add("mapray-attribution-container");
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._attributions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var attribution = _step.value;

          if (attribution.display) {
            var attribution_container = document.createElement("a");

            if (attribution.link) {
              attribution_container.href = attribution.link;
              attribution_container.target = "_blank";
            }

            var text = document.createTextNode(attribution.display);
            attribution_container.appendChild(text);
            sub_container.appendChild(attribution_container);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      main_container.appendChild(sub_container);
      this._container = main_container;
      parent_container.appendChild(this._container);

      this._sizeChanged();
    }
  }, {
    key: "copyAttributions",
    value: function copyAttributions(src) {
      this._attributions = src.map(function (d) {
        return d;
      });
    }
  }]);

  return AttributionController;
}(ContainerController); // ã¯ã©ã¹å¤æ°ã®å®ç¾©


{
  AttributionController._default_attribution = [{
    display: "Â©Mapray",
    link: "https://mapray.com"
  }, {
    display: "Â©JAXA",
    link: "http://www.jaxa.jp/"
  }, {
    display: "æ¸¬éæ³ã«åºã¥ãå½åå°çé¢é·æ¿èªï¼è¤è£½ï¼H30JHf626",
    link: "https://www.gsi.go.jp/kiban/index.html"
  }];
}

/**
 * @summary è¡¨ç¤ºç®¡ç
 * @classdesc
 * <p>mapray ã®è¡¨ç¤ºãç®¡çããã¯ã©ã¹ã§ããã</p>
 * @memberof mapray
 */

var Viewer =
/*#__PURE__*/
function () {
  /**
   * @param {string|Element}                  container                           ã³ã³ãã (ID ã¾ãã¯è¦ç´ )
   * @param {object}                          [options]                           çæãªãã·ã§ã³
   * @param {mapray.DemProvider}              [options.dem_provider]              DEM ãã­ãã¤ã
   * @param {mapray.ImageProvider}            [options.image_provider]            ç»åãã­ãã¤ã
   * @param {array}                           [options.layers]                    å°å³ã¬ã¤ã¤ã¼æå ±ã®éå
   * @param {boolean}                         [options.ground_visibility=true]    å°è¡¨ã®å¯è¦æ§
   * @param {boolean}                         [options.entity_visibility=true]    ã¨ã³ãã£ãã£ã®å¯è¦æ§
   * @param {mapray.RenderCallback}           [options.render_callback]           ã¬ã³ããªã³ã°ã³ã¼ã«ããã¯
   * @param {mapray.Viewer.RenderMode}        [options.render_mode]               ã¬ã³ããªã³ã°ã¢ã¼ã
   * @param {mapray.DebugStats}               [options.debug_stats]               ãããã°çµ±è¨ãªãã¸ã§ã¯ã
   * @param {mapray.LogoController}           [options.logo_controller]           ã­ã´è¡¨ç¤ºå¶å¾¡ãªãã¸ã§ã¯ã
   * @param {mapray.AttributionController}    [options.attribution_controller]    èä½æ¨©è¡¨ç¤ºå¶å¾¡ãªãã¸ã§ã¯ã
   */
  function Viewer(container, options) {
    _classCallCheck(this, Viewer);

    var container_element;

    if (typeof container == "string") {
      // ã³ã³ããã ID æå®ããã¨ã
      container_element = document.getElementById(container);
    } else {
      // ã³ã³ãããç´æ¥è¦ç´ ã§æå®ã®ã¨ã
      container_element = container;
    }

    var canvas = this._createCanvas(container_element); // ã¤ã³ã¹ã¿ã³ã¹å¤æ°


    this._container_element = container_element;
    this._canvas_element = canvas;
    this._glenv = new GLEnv(canvas);
    this._camera = new Camera(canvas);
    this._animation = this._createAnimationBindingBlock();
    this._dem_provider = this._createDemProvider(options);
    this._image_provider = this._createImageProvider(options);
    this._layers = this._createLayerCollection(options);
    this._globe = new Globe(this._glenv, this._dem_provider);
    this._tile_texture_cache = new TileTextureCache(this._glenv, this._image_provider);
    this._scene = new Scene(this, this._glenv);
    this._ground_visibility = Viewer._getBoolOption(options, "ground_visibility", true);
    this._entity_visibility = Viewer._getBoolOption(options, "entity_visibility", true);
    this._render_mode = options && options.render_mode || RenderMode.SURFACE;
    this._debug_stats = options && options.debug_stats || null;
    this._point_cloud_collection = this._createPointCloudCollection(options);
    this._render_callback = this._createRenderCallback(options);
    this._frame_req_id = 0;
    this._previous_time = undefined;
    this._is_destroyed = false;
    this._sun_direction = GeoMath.createVector3([0, 0, 1]);
    this._postProcesses = []; // ãã¦ã¹ã»Attributionéçº

    this._logo_controller = options && options.logo_controller || new LogoController(this._container_element);
    this._attribution_controller = options && options.attribution_controller || new AttributionController(this._container_element); // ã­ã´ã»èä½æ¨©è¡¨ç¤ºç¨ã³ã³ããã®ä½æ

    this._createLogoAttributionContainer();

    this._logo_controller.createContainer();

    this._attribution_controller.createContainer(); // æåã®ãã¬ã¼ã ã®æºå


    this._requestNextFrame();

    this._updateCanvasSize();
  }
  /**
   * @summary ã¤ã³ã¹ã¿ã³ã¹ãç ´æ£
   *
   * @desc
   * <p>æ¬¡ã®é çªã§å¦çãè¡ããã¤ã³ã¹ã¿ã³ã¹ãç ´æ£ããã</p>
   *
   * <ol>
   *   <li>ã¢ãã¡ã¼ã·ã§ã³ãã¬ã¼ã ãæ­¢ããã(this.{@link mapray.Viewer#render_callback render_callback} ã® {@link mapray.RenderCallback#onUpdateFrame onUpdateFrame()} ãå¼ã³åºãããªããªã)</li>
   *   <li>this.{@link mapray.Viewer#render_callback render_callback} ã® {@link mapray.RenderCallback#onStop onStop()} ãå¼ã³åºãã({@link mapray.RenderCallback#onStart onStart()} ããã§ã«å¼ã³åºããã¦ããå ´å)</li>
   *   <li>{@link mapray.RenderCallback} ã¤ã³ã¹ã¿ã³ã¹ã this ããåãé¢ãã({@link mapray.RenderCallback#viewer} ãã­ããã£ã¯ null ãè¿ãããã«ãªã)</li>
   *   <li>this.{@link mapray.Viewer#canvas_element canvas_element} ã this.{@link mapray.Viewer#container_element container_element} ããåãå¤ãã(ã­ã£ã³ãã¹ã¯è¡¨ç¤ºãããªããªã)</li>
   *   <li>ãã¼ã¿ãã­ãã¤ãã®ãªã¯ã¨ã¹ããã·ã¼ã³ãã¼ã¿ã®ã­ã¼ãã®åãæ¶ããè©¦ã¿ãã</li>
   * </ol>
   *
   * <p>ãã®ã¡ã½ãããå¼ã³åºããå¾ã¯ this ã«ç´æ¥çã¾ãã¯éæ¥çã«ã¢ã¯ã»ã¹ãããã¨ã¯ã§ããªãããã ã {@link mapray.Viewer#destroy destroy()} ã®å¼ã³åºãã¯é¤ãã</p>
   *
   * <p>ãã®ã¡ã½ããã¯ {@link mapray.RenderCallback} ã®ã¡ã½ããããå¼ã³åºãã¦ã¯ãªããªãã</p>
   */


  _createClass(Viewer, [{
    key: "destroy",
    value: function destroy() {
      if (this._is_destroyed) {
        // ãã§ã« this ã¯ç ´æ£æ¸ã¿
        return;
      } // ãã¬ã¼ã ãæ­¢ãã


      if (this._frame_req_id != 0) {
        window.maprayCancelAnimationFrame(this._frame_req_id);
        this._frame_req_id = 0;
      } // RenderCallback ã®åãå¤ã


      this._render_callback.detach();

      this._render_callback = this._createRenderCallback(); // NullRenderCallback
      // ã­ã£ã³ãã¹ãã³ã³ããããå¤ã

      this._container_element.removeChild(this._canvas_element); // DemProvider ã®ãªã¯ã¨ã¹ããåãæ¶ã


      this._globe.cancel(); // ImageProvider ã®ãªã¯ã¨ã¹ããåãæ¶ã


      this._tile_texture_cache.cancel(); // åã¬ã¤ã¤ã¼ã® ã®ãªã¯ã¨ã¹ããåãæ¶ã


      this._layers.cancel(); // å SceneLoader ã®èª­ã¿è¾¼ã¿ãåãæ¶ã


      this._scene.cancelLoaders(); // ãã¦ã¹ã»Attributionéçº


      this._logo_controller._destroy();

      this._attribution_controller._destroy();

      this._attribution_controller = null; // ã­ã´ã»èä½æ¨©ç¨ã³ã³ããã®åé¤

      this._deleteLogoAttributionContainer(); // ç ´æ£ç¢ºå®


      this._is_destroyed = true;
    }
    /**
     * ã­ã£ã³ãã¹è¦ç´ ãçæ
     * @param  {Element}           container
     * @return {HTMLCanvasElement}
     * @private
     */

  }, {
    key: "_createCanvas",
    value: function _createCanvas(container) {
      var canvas = document.createElement("canvas");
      canvas.className = "mapray-canvas";
      canvas.style.width = "100%";
      canvas.style.height = "100%";
      container.appendChild(canvas);
      return canvas;
    }
    /**
     * DemProvider ãçæ
     * @private
     */

  }, {
    key: "_createDemProvider",
    value: function _createDemProvider(options) {
      if (options && options.dem_provider) return options.dem_provider;else return new StandardDemProvider("/dem/", ".bin");
    }
    /**
     * animation.BindingBlock ãçæ
     * @private
     */

  }, {
    key: "_createAnimationBindingBlock",
    value: function _createAnimationBindingBlock() {
      var _this = this;

      var abb = new EasyBindingBlock();
      abb.addDescendantUnbinder(function () {
        _this._unbindDescendantAnimations();
      });
      return abb;
    }
    /**
     * ImageProvider ãçæ
     * @private
     */

  }, {
    key: "_createImageProvider",
    value: function _createImageProvider(options) {
      if (options && options.image_provider) return options.image_provider;else return new StandardImageProvider("http://cyberjapandata.gsi.go.jp/xyz/std/", ".png", 256, 0, 18);
    }
    /**
     * LayerCollection ãçæ
     * @private
     */

  }, {
    key: "_createLayerCollection",
    value: function _createLayerCollection(options) {
      var layers = options && options.layers ? options.layers : {};
      return new LayerCollection(this, layers);
    }
    /**
     * PointCloudCollection ãçæ
     * @private
     */

  }, {
    key: "_createPointCloudCollection",
    value: function _createPointCloudCollection(options) {
      var point_cloud_providers = options && options.point_cloud_providers ? options.point_cloud_providers : {};
      return new PointCloudCollection(this._scene, point_cloud_providers);
    }
    /**
     * RenderCallback ãçæ
     * @private
     */

  }, {
    key: "_createRenderCallback",
    value: function _createRenderCallback(options) {
      var callback;
      if (options && options.render_callback) callback = options.render_callback;else callback = new NullRenderCallback();
      callback.attach(this);
      return callback;
    }
    /**
     * @summary ã­ã´ã»èä½æ¨©è¡¨ç¤ºç¨ã³ã³ããã®ä½æ
     *
     * @memberof Viewer
     */

  }, {
    key: "_createLogoAttributionContainer",
    value: function _createLogoAttributionContainer() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Viewer._positions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var position = _step.value;
          var container = document.createElement("div");
          container.className = position;

          this._container_element.appendChild(container);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * @summary ã­ã´ã»èä½æ¨©è¡¨ç¤ºç¨ã³ã³ããã®åé¤
     *
     * @memberof Viewer
     */

  }, {
    key: "_deleteLogoAttributionContainer",
    value: function _deleteLogoAttributionContainer() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = Viewer._positions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var position = _step2.value;
          var container = document.getElementById(position);

          if (container) {
            this._container_element.removeChild(position);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    /**
     * ãã¼ã«å¤ã®ãªãã·ã§ã³ãåå¾
     * @private
     */

  }, {
    key: "setVisibility",

    /**
     * @summary å¯è¦æ§ãè¨­å®
     * @desc
     * <p>target ã«å±ãããªãã¸ã§ã¯ããè¡¨ç¤ºãããã©ãããæå®ããã</p>
     * <p>å¯è¦æ§ã¯ Viewer ã®æ§ç¯å­ã® ground_visibility ã¨ entity_visibility ãªãã·ã§ã³ã§ãæå®ãããã¨ãã§ããã</p>
     *
     * @param {mapray.Viewer.Category} target      è¡¨ç¤ºå¯¾è±¡
     * @param {boolean}                visibility  è¡¨ç¤ºããã¨ã true, è¡¨ç¤ºããªãã¨ã false
     *
     * @see {@link mapray.Viewer#getVisibility}
     */
    value: function setVisibility(target, visibility) {
      switch (target) {
        case Category.GROUND:
          this._ground_visibility = visibility;
          break;

        case Category.ENTITY:
          this._entity_visibility = visibility;
          break;

        default:
          throw new Error("invalid target: " + target);
      }
    }
    /**
     * @summary å¯è¦æ§ãåå¾
     * @desc
     * <p>target ã«å±ãããªãã¸ã§ã¯ããè¡¨ç¤ºãããã©ãããåå¾ããã</p>
     *
     * @param  {mapray.Viewer.Category} target  è¡¨ç¤ºå¯¾è±¡
     * @return {boolean}  è¡¨ç¤ºããã¨ã true, è¡¨ç¤ºããªãã¨ã false
     *
     * @see {@link mapray.Viewer#setVisibility}
     */

  }, {
    key: "getVisibility",
    value: function getVisibility(target, visibility) {
      switch (target) {
        case Category.GROUND:
          return this._ground_visibility;

        case Category.ENTITY:
          return this._entity_visibility;

        default:
          throw new Error("invalid target: " + target);
      }
    }
    /**
     * @summary æå®ä½ç½®ã®æ¨é«ãåå¾
     * @desc
     * <p>ç·¯åº¦ lat, çµåº¦ lon ãç¤ºãå ´æã®æ¨é«ãè¿ãã</p>
     * <p>ç¾å¨ã¡ã¢ãªã«å­å¨ãã DEM ãã¼ã¿ã®ä¸­ã§æãæ­£ç¢ºåº¦ãé«ããã¼ã¿ããæ¨é«ãè¨ç®ããã</p>
     * <p>ããã«æ­£ç¢ºåº¦ãé«ã DEM ãã¼ã¿ããµã¼ãã¼ã«å­å¨ããã°ããããéåæã«èª­ã¿è¾¼ãããã®ããæéãç½®ãã¦ãã®ã¡ã½ãããå¼ã³åºãã¨ãããã«æ­£ç¢ºãªå¤ãåå¾ã§ãããã¨ãããã</p>
     * @param  {number} lat  ç·¯åº¦ (Degrees)
     * @param  {number} lon  çµåº¦ (Degrees)
     * @return {number}      æ¨é« (Meters)
     */

  }, {
    key: "getElevation",
    value: function getElevation(lat, lon) {
      // æ­£è¦åç·¯çµåº¦ (Degrees)
      var _lon = lon + 180 * Math.floor((90 - lat) / 360 + Math.floor((90 + lat) / 360));

      var nlat = 90 - Math.abs(90 - lat + 360 * Math.floor((90 + lat) / 360)); // æ­£è¦åç·¯åº¦ [-90,90]

      var nlon = _lon - 360 - 360 * Math.floor((_lon - 180) / 360); // æ­£è¦åç·¯åº¦ [-180,180)
      // åä½çã¡ã«ã«ãã«åº§æ¨

      var xm = nlon * GeoMath.DEGREE;
      var ym = GeoMath.invGudermannian(nlat * GeoMath.DEGREE); // åºåºã¿ã¤ã«åº§æ¨ (å·¦ä¸(0, 0)ãå³ä¸(1, 1))

      var dPI = 2 * Math.PI;
      var xt = xm / dPI + 0.5;
      var yt = 0.5 - ym / dPI;

      if (yt < 0 || yt > 1) {
        // ç·¯åº¦ã Web ã¡ã«ã«ãã«ã®ç¯å²å¤ (æ¥µã«è¿ã)
        return 0;
      } // æ­£ç¢ºåº¦ãæãé«ã DEM ã¿ã¤ã«ã®åå¾


      var globe = this._globe;
      var dem = globe.findHighestAccuracy(xt, yt);

      if (dem === null) {
        // ã¾ã æ¨é«ãåå¾ãããã¨ãã§ããªã
        return 0;
      } // æ¨é«ããµã³ãã«


      var Ï = globe.dem_provider.getResolutionPower();
      var size = 1 << Ï; // 2^Ï

      var pow = Math.pow(2, dem.z); // 2^ze

      var uf = size * (pow * xt - dem.x);
      var vf = size * (pow * yt - dem.y);
      var ui = GeoMath.clamp(Math.floor(uf), 0, size - 1);
      var vi = GeoMath.clamp(Math.floor(vf), 0, size - 1);
      var heights = dem.getHeights(ui, vi);
      var h00 = heights[0];
      var h10 = heights[1];
      var h01 = heights[2];
      var h11 = heights[3]; // æ¨é«ãè£é

      var s = uf - ui;
      var t = vf - vi;
      return (h00 * (1 - s) + h10 * s) * (1 - t) + (h01 * (1 - s) + h11 * s) * t;
    }
    /**
     * @summary ç¾è¡ã®æ¨é«ãåå¾
     *
     * @desc
     * <p>ç¾å¨ã¡ã¢ãªã¼ã«ããæé«ç²¾åº¦ã®æ¨é«å¤ãåå¾ããã</p>
     * <p>ã¾ã  DEM ãã¼ã¿ãå­å¨ããªããã¾ãã¯çµåº¦, ç·¯åº¦ãç¯å²å¤ã®å ´æã¯æ¨é«ã 0 ã¨ããã</p>
     *
     * <p>ãã®ã¡ã½ããã¯ DEM ã®ãªã¯ã¨ã¹ãã¯çºçããªããã¾ã DEM ã®ã­ã£ãã·ã¥ã«ã¯å½±é¿ãä¸ããªãã</p>
     *
     * <p>ä¸è¬çã«ç»é¢ã«è¡¨ç¤ºããã¦ããªãå ´æã¯æ¨é«ã®ç²¾åº¦ãä½ãã</p>
     *
     * @param  {mapray.GeoPoint} position  ä½ç½® (é«åº¦ã¯ç¡è¦ããã)
     * @return {number}                    æ¨é«
     *
     * @see mapray.Viewer#getExistingElevations
     */

  }, {
    key: "getExistingElevation",
    value: function getExistingElevation(position) {
      var array = [position.longitude, position.latitude, 0];

      this._globe.getExistingElevations(1, array, 0, 3, array, 2, 3);

      return array[2];
    }
    /**
     * @summary ç¾è¡ã®æ¨é« (è¤æ°) ãåå¾
     *
     * @desc
     * <p>ç¾å¨ã¡ã¢ãªã¼ã«ããæé«ç²¾åº¦ã®æ¨é«å¤ãä¸æ¬ã§åå¾ããã</p>
     * <p>ã¾ã  DEM ãã¼ã¿ãå­å¨ããªããã¾ãã¯çµåº¦, ç·¯åº¦ãç¯å²å¤ã®å ´æã¯æ¨é«ã 0 ã¨ããã</p>
     *
     * <p>ãã®ã¡ã½ããã¯ DEM ã®ãªã¯ã¨ã¹ãã¯çºçããªããã¾ã DEM ã®ã­ã£ãã·ã¥ã«ã¯å½±é¿ãä¸ããªãã</p>
     *
     * <p>ä¸è¬çã«ç»é¢ã«è¡¨ç¤ºããã¦ããªãå ´æã¯æ¨é«ã®ç²¾åº¦ãä½ãã</p>
     *
     * @param  {number}   num_points  å¥åºåãã¼ã¿æ°
     * @param  {number[]} src_array   å¥åéå (çµåº¦, ç·¯åº¦, ...)
     * @param  {number}   src_offset  å¥åãã¼ã¿ã®åé ­ã¤ã³ããã¯ã¹
     * @param  {number}   src_stride  å¥åãã¼ã¿ã®ã¹ãã©ã¤ã
     * @param  {number[]} dst_array   åºåéå (æ¨é«, ...)
     * @param  {number}   dst_offset  åºåãã¼ã¿ã®åé ­ã¤ã³ããã¯ã¹
     * @param  {number}   dst_stride  åºåãã¼ã¿ã®ã¹ãã©ã¤ã
     * @return {number[]}             dst_array
     *
     * @see mapray.Viewer#getExistingElevation
     */

  }, {
    key: "getExistingElevations",
    value: function getExistingElevations(num_points, src_array, src_offset, src_stride, dst_array, dst_offset, dst_stride) {
      return this._globe.getExistingElevations(num_points, src_array, src_offset, src_stride, dst_array, dst_offset, dst_stride);
    }
    /**
     * @summary ã¬ã¤ã¨å°è¡¨ã®äº¤ç¹ãåå¾
     * @desc
     * <p>ray ã¨å°è¡¨ã®æãè¿ãäº¤ç¹ãåå¾ããããã ãäº¤ç¹ãå­å¨ããªãå ´åã¯ null ãè¿ãã</p>
     * @param  {mapray.Ray}      ray  ã¬ã¤ (GOCS)
     * @return {?mapray.Vector3}      äº¤ç¹ã¾ãã¯ null
     */

  }, {
    key: "getRayIntersection",
    value: function getRayIntersection(ray) {
      var globe = this._globe;

      if (globe.status !== Globe.Status.READY) {
        // Globe ã®æºåãã§ãã¦ããªã
        return null;
      }

      var distance = globe.root_flake.findRayDistance(ray, Number.MAX_VALUE);

      if (distance === Number.MAX_VALUE) {
        // äº¤ç¹ãè¦ã¤ãããªãã£ã
        return null;
      } // P = Q + distance V


      var p = GeoMath.createVector3();
      var q = ray.position;
      var v = ray.direction;
      p[0] = q[0] + distance * v[0];
      p[1] = q[1] + distance * v[1];
      p[2] = q[2] + distance * v[2];
      return p;
    }
    /**
     * @summary Canvasç»é¢ã®ã­ã£ããã£
     *
     * @param  {object}  options  ãªãã·ã§ã³
     * @return {blob}             ãã¼ã¿
     */

  }, {
    key: "capture",
    value: function () {
      var _capture = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var _this2 = this;

        var options,
            mimeType,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {
                  type: 'jpeg'
                };

                if (this._canvas_element) {
                  _context.next = 3;
                  break;
                }

                throw new Error('Canvas is null.');

              case 3:
                mimeType = options.type === 'png' ? 'image/png' : 'image/jpeg';
                _context.next = 6;
                return new Promise(function (resolve) {
                  _this2._postProcesses.push(function () {
                    _this2._canvas_element.toBlob(resolve, mimeType);

                    return false;
                  });
                });

              case 6:
                return _context.abrupt("return", _context.sent);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function capture() {
        return _capture.apply(this, arguments);
      }

      return capture;
    }()
    /**
     * æ¬¡ã®ãã¬ã¼ã æ´æ°ãè¦æ±ããã
     * @private
     */

  }, {
    key: "_requestNextFrame",
    value: function _requestNextFrame() {
      var _this3 = this;

      this._frame_req_id = window.maprayRequestAnimationFrame(function () {
        return _this3._updateFrame();
      });
    }
    /**
     * ãã¬ã¼ã æ´æ°ã®ã¨ãã«å¼ã³åºãããã
     * @private
     * @see mapray.RenderStage
     */

  }, {
    key: "_updateFrame",
    value: function _updateFrame() {
      var delta_time = this._updateTime();

      this._requestNextFrame();

      this._updateCanvasSize();

      this._render_callback.onUpdateFrameInner(delta_time);

      if (this._debug_stats !== null) {
        this._debug_stats.clearStats();
      }

      var stage = new RenderStage(this);
      stage.render();

      this._postProcess();

      this._finishDebugStats();
    }
    /**
     * ç¾å¨ã®ãã¥ã¼ã«ããã¦æå®ãããã¹ã¯ãªã¼ã³ä½ç½®ã®æå ±ãåå¾ãã¾ã
     * @param {Vector2} screen_position ã¹ã¯ãªã¼ã³ä½ç½®ï¼ã­ã£ã³ãã¹å·¦ä¸ãåç¹ã¨ãããã¯ã»ã«åº§æ¨ï¼
     * @return {mapray.Viewer.PickResult} ããã¯çµæ
     */

  }, {
    key: "pick",
    value: function pick(screen_position) {
      var stage = new PickStage(this, screen_position);
      stage.render();
      return stage.pick_result;
    }
    /**
     * @summary æéã®æ´æ°
     * @return {number}  åãã¬ã¼ã ããã®çµéæé (ç§)
     * @private
     */

  }, {
    key: "_updateTime",
    value: function _updateTime() {
      var now_time = window.maprayNow();
      var delta_time = this._previous_time !== undefined ? (now_time - this._previous_time) / 1000 : 0;
      this._previous_time = now_time;
      return delta_time;
    }
    /**
     * @summary Canvas ãµã¤ãºãæ´æ°
     * @private
     */

  }, {
    key: "_updateCanvasSize",
    value: function _updateCanvasSize() {
      var canvas = this._canvas_element; // è¦ç´ ã®ãµã¤ãºã¨ã­ã£ã³ãã¹ã®ãµã¤ãºãä¸è´ããã

      if (canvas.width != canvas.clientWidth) {
        canvas.width = canvas.clientWidth;
      }

      if (canvas.height != canvas.clientHeight) {
        canvas.height = canvas.clientHeight;
      }
    }
    /**
     * @summary ãã¹ããã­ã»ã¹ãå®è¡
     * @private
     */

  }, {
    key: "_postProcess",
    value: function _postProcess() {
      if (this._postProcesses.length === 0) {
        return;
      }

      var nextProcesses = [];

      this._postProcesses.forEach(function (item) {
        if (item()) {
          nextProcesses.push(item);
        }
      });

      this._postProcesses = nextProcesses;
    }
    /**
     * @summary ãããã°çµ±è¨ã®æçµå¦ç
     * @private
     */

  }, {
    key: "_finishDebugStats",
    value: function _finishDebugStats() {
      var stats = this._debug_stats;

      if (stats === null) {
        // çµ±è¨ãªãã¸ã§ã¯ãã¯æå®ããã¦ããªã
        return;
      } // çµ±è¨å¤ã®åå¾


      stats.num_wait_reqs_dem = this._globe.getNumDemWaitingRequests();
      stats.num_wait_reqs_img = this._tile_texture_cache.getNumWaitingRequests(); // çµ±è¨ã®æ´æ°ãéç¥

      stats.onUpdate();
    }
    /**
     * EasyBindingBlock.DescendantUnbinder å¦ç
     *
     * @private
     */

  }, {
    key: "_unbindDescendantAnimations",
    value: function _unbindDescendantAnimations() {
      this._scene.animation.unbindAllRecursively();
    }
    /**
     * å¤ªé½ãã¯ãã«ã®æå ±ãè¨­å®ãã¾ã
     * @param {Vector3} direction æ¹åï¼GOCS  æ­£è¦åããã¦ãããã¨ï¼
     */

  }, {
    key: "setSunDirection",
    value: function setSunDirection(direction) {
      GeoMath.copyVector3(direction, this._sun_direction);
    }
    /**
     * å¤ªé½ãã¯ãã«ã®æå ±ã®ã³ãã¼ãåå¾ãã¾ã
     * @param {Vector3} dst æ¹åï¼GOCS  æ­£è¦åããã¦ãããã¨ï¼
     * @return {Vector3} ãã¯ãã«ã®ã³ãã¼ï¼GOCSï¼
     */

  }, {
    key: "getSunDirection",
    value: function getSunDirection(dst) {
      return GeoMath.copyVector3(this._sun_direction, dst);
    }
  }, {
    key: "container_element",

    /**
     * @summary ã³ã³ããè¦ç´  (ã­ã£ã³ãã¹è¦ç´ ãä¿æãã)
     * @type {Element}
     * @readonly
     */
    get: function get() {
      return this._container_element;
    }
    /**
     * @summary ã­ã£ã³ãã¹è¦ç´ 
     * @type {Element}
     * @readonly
     */

  }, {
    key: "canvas_element",
    get: function get() {
      return this._canvas_element;
    }
    /**
     * @summary ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿è¨­å®
     * @type {mapray.animation.BindingBlock}
     * @readonly
     */

  }, {
    key: "animation",
    get: function get() {
      return this._animation;
    }
    /**
     * DEM ãã¼ã¿ãã­ãã¤ã
     * @type {mapray.DemProvider}
     * @readonly
     */

  }, {
    key: "dem_provider",
    get: function get() {
      return this._dem_provider;
    }
    /**
     * @summary ç»åãã­ãã¤ã
     * @type {mapray.ImageProvider}
     * @readonly
     */

  }, {
    key: "image_provider",
    get: function get() {
      return this._image_provider;
    }
    /**
     * @summary å°å³ã¬ã¤ã¤ã¼ç®¡ç
     * @type {mapray.LayerCollection}
     * @readonly
     */

  }, {
    key: "layers",
    get: function get() {
      return this._layers;
    }
    /**
     * @summary ç¹ç¾¤ç®¡ç
     * @type {mapray.PointCloudCollection}
     * @readonly
     */

  }, {
    key: "point_cloud_collection",
    get: function get() {
      return this._point_cloud_collection;
    }
    /**
     * @summary ã¬ã³ããªã³ã°ã³ã¼ã«ããã¯
     * @type {mapray.RenderCallback}
     * @readonly
     */

  }, {
    key: "render_callback",
    get: function get() {
      return this._render_callback;
    }
    /**
     * @summary ã¬ã³ããªã³ã°ã¢ã¼ã
     * @type {mapray.RenderMode}
     * @readonly
     */

  }, {
    key: "render_mode",
    get: function get() {
      return this._render_mode;
    }
    /**
     * @summary ã¬ã³ããªã³ã°ã¢ã¼ããè¨­å®
     * @type {mapray.RenderMode}
     */
    ,
    set: function set(val) {
      this._render_mode = val;
    }
    /**
     * @summary ãããã°çµ±è¨ãªãã¸ã§ã¯ã
     * @type {?mapray.DebugStats}
     * @readonly
     */

  }, {
    key: "debug_stats",
    get: function get() {
      return this._debug_stats;
    }
    /**
     * @summary ã«ã¡ã©
     * @type {mapray.Camera}
     * @readonly
     */

  }, {
    key: "camera",
    get: function get() {
      return this._camera;
    }
    /**
     * @summary ã¢ãã«ã·ã¼ã³
     * @type {mapray.Scene}
     * @readonly
     */

  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
    /**
     * åé¨çã«å®è£ã§ä½¿ç¨ããã WebGL ã¬ã³ããªã³ã°ã³ã³ãã­ã¹ãæå ±
     * @type {mapray.GLEnv}
     * @readonly
     * @package
     */

  }, {
    key: "glenv",
    get: function get() {
      return this._glenv;
    }
    /**
     * @type {mapray.Globe}
     * @readonly
     * @package
     */

  }, {
    key: "globe",
    get: function get() {
      return this._globe;
    }
    /**
     * åé¨çã«å®è£ã§ä½¿ç¨ãããå°å³ç»åã¿ã¤ã«ç®¡ç
     * @type {mapray.TileTextureCache}
     * @readonly
     * @package
     */

  }, {
    key: "tile_texture_cache",
    get: function get() {
      return this._tile_texture_cache;
    }
    /**
     *
     * @type {mapray.LogoController}
     * @readonly
     * @memberof Viewer
     */

  }, {
    key: "logo_controller",
    get: function get() {
      return this._logo_controller;
    }
    /**
     *
     * @type {mapray.AttributionController}
     * @readonly
     * @memberof Viewer
     */

  }, {
    key: "attribution_controller",
    get: function get() {
      return this._attribution_controller;
    }
    /**
     * @summary å¤ªé½ãã¯ãã«ãéå¬éã¨ãããAPIã§ã¯ãã¡ã¢ãªã¼ç ´å£ãèµ·ãããªã Viewer#getSunDirection ãå¬éããã
     * @type {Vector3}
     * @private
     * @readonly
     * @memberof Viewer
     */

  }, {
    key: "sun_direction",
    get: function get() {
      return this._sun_direction;
    }
  }], [{
    key: "_getBoolOption",
    value: function _getBoolOption(options, name, defaultValue) {
      return options && options[name] !== undefined ? options[name] : defaultValue;
    }
  }]);

  return Viewer;
}();
/**
 * @summary ããã¯çµæ
 * @typedef {object} PickResult
 * @desc
 * <p>é¢æ°å {@link mapray.Viewer.pick} ã®æ»ãå¤ã®ãªãã¸ã§ã¯ãæ§é ã§ããã</p>
 * @property {mapray.Vector3} [point] ããã¯ãã3æ¬¡åä½ç½®
 * @property {mapray.Entity} [entity|undefined] ããã¯ããã¨ã³ãã£ãã£ï¼ããã¯ä½ç½®ã«ã¨ã³ãã£ãã£ããªãå ´åã¯undefinedï¼
 * @memberof mapray.Viewer
 */

/**
 * @summary è¡¨ç¤ºå¯¾è±¡ã®åæå
 * @desc
 * <p>{@link mapray.Viewer#setVisibility} ã¨ {@link mapray.Viewer#getVisibility} ã¡ã½ããã® target å¼æ°ã«æå®ããå¤ã®åã§ããã</p>
 * @enum {object}
 * @memberof mapray.Viewer
 * @constant
 */


var Category = {
  /**
   * å°è¡¨ (ã¬ã¤ã¤ã¼ãå«ã)
   */
  GROUND: {
    id: "GROUND"
  },

  /**
   * ã¨ã³ãã£ãã£
   */
  ENTITY: {
    id: "ENTITY"
  }
};
/**
 * @summary ã¬ã³ããªã³ã°ã¢ã¼ãã®åæå
 * @desc
 * {@link mapray.Viewer} ã®æ§ç¯å­ã® options.render_mode ãã©ã¡ã¼ã¿ãã¾ãã¯ {@link mapray.Viewer#render_mode} ãã­ããã£ã«æå®ããå¤ã®åã§ããã
 * @enum {object}
 * @memberof mapray.Viewer
 * @constant
 */

var RenderMode = {
  /**
   * ããªã´ã³é¢ (æ¢å®å¤)
   */
  SURFACE: {
    id: "SURFACE"
  },

  /**
   * ã¯ã¤ã¤ã¼ãã¬ã¼ã 
   */
  WIREFRAME: {
    id: "WIREFRAME"
  }
}; // ã¯ã©ã¹å®æ°ã®å®ç¾©

{
  Viewer.Category = Category;
  Viewer.RenderMode = RenderMode; // ãã¦ã¹ã»Attributionéçº

  Viewer.ContainerPosition = ContainerController.ContainerPosition; // ã­ã´ã»èä½æ¨©è¡¨ç¤ºç¨ã³ã³ããåç§°

  Viewer._positions = ["control-top-left", "control-top-right", "control-bottom-left", "control-bottom-right"];
}

/**
 * @summary ã¯ã©ã¦ã DEM ãã­ãã¤ã
 * @memberof mapray
 * @extends mapray.DemProvider
 */

var CloudDemProvider =
/*#__PURE__*/
function (_DemProvider) {
  _inherits(CloudDemProvider, _DemProvider);

  /**
   * @param {string} api_key  API ã­ã¼ã®æå­å
   */
  function CloudDemProvider(api_key) {
    var _this;

    _classCallCheck(this, CloudDemProvider);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CloudDemProvider).call(this));
    _this._headers = {
      'X-Api-Key': api_key
    };
    return _this;
  }
  /**
   * @override
   */


  _createClass(CloudDemProvider, [{
    key: "requestTile",
    value: function requestTile(z, x, y, callback) {
      var actrl = new AbortController();
      fetch(this._makeURL(z, x, y), {
        headers: this._headers,
        signal: actrl.signal
      }).then(function (response) {
        return response.ok ? response.arrayBuffer() : Promise.reject(Error(response.statusText));
      }).then(function (buffer) {
        // ãã¼ã¿åå¾ã«æå
        callback(buffer);
      })["catch"](function () {
        // ãã¼ã¿åå¾ã«å¤±æã¾ãã¯åãæ¶ã
        callback(null);
      });
      return actrl;
    }
    /**
     * @override
     */

  }, {
    key: "cancelRequest",
    value: function cancelRequest(id) {
      var actrl = id; // è¦æ± ID ã AbortController ã«å¤æ

      actrl.abort(); // åãæ¶ããã®ã§è¦æ±ãä¸­æ­¢
    }
    /**
     * URL ãä½æ
     * @private
     */

  }, {
    key: "_makeURL",
    value: function _makeURL(z, x, y) {
      return 'https://tiles.mapray.com/dem/' + z + '/' + x + '/' + y + '.bin';
    }
  }]);

  return CloudDemProvider;
}(DemProvider);

var pin_vs_code = "/**\n * ãã­ã¹ã (é ç¹ã·ã§ã¼ã)\n */\n\nattribute vec4 a_position;     // é ç¹ä½ç½® (ã¢ãã«åº§æ¨ç³»)\nattribute vec2 a_offset;       // é ç¹å¤ä½ (ã¹ã¯ãªã¼ã³åº§æ¨ç³»)\nattribute vec2 a_texcoord;     // ãã¯ã¹ãã£åº§æ¨\nattribute vec2 a_texmaskcoord; // ãã¯ã¹ãã£ãã¹ã¯åº§æ¨\nattribute vec3 a_fg_color;     // åæ¯è²\nattribute vec3 a_bg_color;     // èæ¯è²\n\nuniform mat4 u_obj_to_clip;    // ã¢ãã«åº§æ¨ç³»ããã¯ãªããåº§æ¨ç³»ã¸ã®å¤æ\nuniform vec2 u_sparam;         // ç»é¢ãã©ã¡ã¼ã¿: {2/w, 2/h}\n\nvarying vec2 v_texcoord;       // ãã¯ã¹ãã£åº§æ¨\nvarying vec2 v_texmaskcoord;   // ãã¯ã¹ãã£ãã¹ã¯åº§æ¨\nvarying vec3 v_fg_color;       // åæ¯è²\nvarying vec3 v_bg_color;       // èæ¯è²\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n    gl_Position.xy += a_offset * u_sparam * gl_Position.w;\n    v_texcoord = a_texcoord;\n    v_texmaskcoord = a_texmaskcoord;\n    v_fg_color = a_fg_color;\n    v_bg_color = a_bg_color;\n}\n";

var pin_fs_code = "/**\n * ãã­ã¹ã (ãã©ã°ã¡ã³ãã·ã§ã¼ã)\n */\n\nprecision mediump float;\n\nvarying vec2 v_texcoord;        // ã¢ã¤ã³ã³ã®ãã¯ã¹ãã£åº§æ¨\nvarying vec2 v_texmaskcoord;    // ã¢ã¤ã³ã³ãã¹ã¯ã®ãã¯ã¹ãã£åº§æ¨\nvarying vec3 v_fg_color;        // åæ¯è²\nvarying vec3 v_bg_color;        // èæ¯è²\n\nuniform sampler2D u_image;      // ã¢ã¤ã³ã³ç»å\nuniform sampler2D u_image_mask; // ã¢ã¤ã³ã³ãã¹ã¯ç»å\n\n\nvoid\nmain()\n{\n    float alpha = texture2D( u_image, v_texcoord ).w;          // è¼åº¦\n    float mask = texture2D( u_image_mask, v_texmaskcoord ).w;  // ãã¹ã¯\n    alpha *= mask;\n    gl_FragColor = vec4(v_fg_color * alpha + v_bg_color * (1.0 - alpha), 1.0);\n}\n";

/**
 * @summary ãã­ã¹ããããªã¢ã«
 * @memberof mapray
 * @extends mapray.EntityMaterial
 * @private
 * @see mapray.PinEntity
 */

var PinMaterial =
/*#__PURE__*/
function (_EntityMaterial) {
  _inherits(PinMaterial, _EntityMaterial);

  /**
   * @param {mapray.GLEnv} glenv
   */
  function PinMaterial(glenv) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, PinMaterial);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PinMaterial).call(this, glenv, pin_vs_code, options.ridMaterial ? rid_fs_code : pin_fs_code)); // ä¸å¤ãã©ã¡ã¼ã¿ãäºåè¨­å®

    _this.bindProgram();

    _this.setInteger("u_image", PinMaterial.TEXUNIT_IMAGE);

    _this.setInteger("u_image_mask", PinMaterial.TEXUNIT_IMAGE_MASK);

    return _this;
  }
  /**
   * @override
   */


  _createClass(PinMaterial, [{
    key: "isTranslucent",
    value: function isTranslucent(stage, primitive) {
      return false;
    }
    /**
     * @override
     */

  }, {
    key: "setParameters",
    value: function setParameters(stage, primitive) {
      _get(_getPrototypeOf(PinMaterial.prototype), "setParameters", this).call(this, stage, primitive);

      var props = primitive.properties; // mat4 u_obj_to_clip

      this.setObjToClip(stage, primitive); // ç»é¢ãã©ã¡ã¼ã¿: {2/w, 2/h}
      // vec2 u_sparam

      var sparam = PinMaterial._sparam;
      sparam[0] = 2 / stage._width;
      sparam[1] = 2 / stage._height;
      this.setVector2("u_sparam", sparam);

      if (stage.getRenderTarget() === RenderTarget.SCENE) {
        // ãã¯ã¹ãã£ã®ãã¤ã³ã
        // sampler2D u_image
        var image = props["image"];
        this.bindTexture2D(PinMaterial.TEXUNIT_IMAGE, image.handle); // ãã¯ã¹ãã£ãã¹ã¯ã®ãã¤ã³ã
        // sampler2D u_image_mask

        var image_mask = props["image_mask"];
        this.bindTexture2D(PinMaterial.TEXUNIT_IMAGE_MASK, image_mask.handle);
      }
    }
  }]);

  return PinMaterial;
}(EntityMaterial); // ã¯ã©ã¹å®æ°ã®å®ç¾©


{
  PinMaterial.TEXUNIT_IMAGE = 0; // ç»åã®ãã¯ã¹ãã£ã¦ããã

  PinMaterial.TEXUNIT_IMAGE_MASK = 1; // ç»åã®ãã¯ã¹ãã£ã¦ããã
  // è¨ç®ç¨ä¸æé å

  PinMaterial._sparam = GeoMath.createVector2f();
  PinMaterial._bg_color = GeoMath.createVector3f();
  PinMaterial._fg_color = GeoMath.createVector3f();
}

/**
 * @classdesc
 * ã¢ã¤ã³ã³ç»åã®ã­ã¼ãã¼ã§ãã
 * ä½ããã®ãã­ããã£ã«å¿ãã¦ãã¢ã¤ã³ã³ãèª­ã¿è¾¼ã¾ãã¾ãã
 * åä¸ãªã½ã¼ã¹ãè¦æ±ãããå ´åã¯ãèª­ã¿è¾¼ã¿ä¸­ã¾ãã¯èª­ã¿è¾¼ã¿æ¸ã¿ã®ã¢ã¤ã³ã³ãè¿å´ãã¾ãã
 * åä¸ãªã½ã¼ã¹ã§ãããã®å¤å®ã«ã¯ãgetKey(prop)é¢æ°ã«ããè¿å´ãããå¤ãç¨ãã¾ãã
 * @private
 */

var IconLoader =
/*#__PURE__*/
function () {
  /**
   * @summary ã³ã³ã¹ãã©ã¯ã¿
   */
  function IconLoader() {
    _classCallCheck(this, IconLoader);

    this._cache = new Map();
  }
  /**
   * @summary ãã­ããã£ã«å¿ããã¢ã¤ã³ã³ãè¿å´ãã¾ãã
   * ãã§ã«åä¸ãªã½ã¼ã¹ãçæããå ´åã¯çææ¸ã¿ã®ã¤ã³ã¹ã¿ã³ã¹ãè¿å´ããããã§ãªãå ´åã¯doCreate(prop)ã«ããçæãã¾ãã
   * @param {any} prop
   * @return {IconLoaderItem}
   */


  _createClass(IconLoader, [{
    key: "create",
    value: function create(prop) {
      var key = this.getKey(prop);

      var value = this._cache.get(key);

      if (!value) this._cache.set(key, value = this.doCreate(prop));
      return value;
    }
    /**
     * @summary ãã­ããã£ã«å¿ããã¢ã¤ã³ã³ãçæãã¾ãã
     * @abstract
     * @param {any} prop ãã­ããã£
     * @return {IconLoaderItem}
     */

  }, {
    key: "doCreate",
    value: function doCreate(prop) {}
    /**
     * @summary ãã­ããã£ã«å¿ããã­ã¼ãè¿å´ãã¾ãã
     * å¿è¦ã«å¿ãã¦ãªã¼ãã¼ã©ã¤ãããããã¨ãæ³å®ããé¢æ°ã§ãã
     * ãã£ãã©ã«ãã§ã¯ããã­ããã£èªä½ãã­ã¼ã¨ãªãããã«åä½ãã¾ãã
     * @param {any} prop ãã­ããã£
     */

  }, {
    key: "getKey",
    value: function getKey(prop) {
      return prop;
    }
    /**
     * @summary ãã­ããã£ã«å¿ããã¢ã¤ã³ã³ã®èª­ã¿è¾¼ã¿ãéå§ããã¤ã³ã¹ã¿ã³ã¹ãè¿å´ãã¾ãã
     * èª­ã¿è¾¼ã¿ã¯éå§ãã¾ããèª­ã¿è¾¼ã¿å®äºãã¦ããªãå¯è½æ§ãããã¾ãã
     * ãã®é¢æ°ã¯asyncé¢æ°ã§ã¯ããã¾ãããèª­ã¿è¾¼ã¿çµäºãç£è¦ããã«ã¯ããã®é¢æ°ã®è¿å´å¤ã«å¯¾ãã¦onEnd(callback)ãå¼ã³åºãã¾ãã
     * @param {any} prop ãã­ããã£
     * @return {IconLoaderItem}
     */

  }, {
    key: "load",
    value: function load(prop) {
      var icon = this.create(prop);
      icon.load();
      return icon;
    }
  }]);

  return IconLoader;
}();
/**
 * @classdesc ã¢ã¤ã³ã³ç»åã­ã¼ãã¼ã®ã¢ã¤ã³ã³ã§ããæ½è±¡ã¯ã©ã¹ã§ãã
 * ã¹ãã¼ã¿ã¹ã®ç®¡çãèª­ã¿è¾¼ã¿å®äºå¾ã®éç¥ç­ãè¡ãã¾ãã
 * @private
 */


var IconLoaderItem =
/*#__PURE__*/
function () {
  function IconLoaderItem() {
    _classCallCheck(this, IconLoaderItem);

    this._status = IconLoaderItem.Status.NOT_LOADED;
    this._funcs = [];
    this._icon = null;
  }
  /**
   * @summary ã¢ã¤ã³ã³ã®ç¶æ
   * @type {IconLoaderItem.Status}
   * @readonly
   */


  _createClass(IconLoaderItem, [{
    key: "isLoaded",

    /**
     * @summary ã¢ã¤ã³ã³ã®èª­ã¿è¾¼ã¿ãå®äºãã¦ããã
     * @return {boolean}
     */
    value: function isLoaded() {
      return this._status === IconLoaderItem.Status.LOADED;
    }
    /**
     * @summary ã¢ã¤ã³ã³ã®èª­ã¿è¾¼ã¿ãå®äºããæç¹ã§å¼ã³åºãããã³ã¼ã«ããã¯é¢æ°ãç»é²ãã¾ãã
     * ãã®é¢æ°ãå¼ã³åºããæç¹ã§èª­ã¿è¾¼ã¿ãå®äºãã¦ããå ´åã¯ãå³åº§ã«ã³ã¼ã«ããã¯é¢æ°ãå®è¡ãã¾ãã
     * @param {function}
     */

  }, {
    key: "onEnd",
    value: function onEnd(func) {
      var alreadyDone = this._status === IconLoaderItem.Status.LOADED || this._status === IconLoaderItem.Status.ABORTED;
      if (alreadyDone) func(this);else this._funcs.push(func);
    }
    /**
     * @summary ã¢ã¤ã³ã³èª­ã¿è¾¼ã¿é¢æ°ï¼doLoad()ï¼ãå®è¡ããæåæãå¤±ææããããå¾ç¶å¦çãè¡ãã¾ãã
     */

  }, {
    key: "load",
    value: function () {
      var _load = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var i;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this._status === IconLoaderItem.Status.NOT_LOADED)) {
                  _context.next = 14;
                  break;
                }

                this._status = IconLoaderItem.Status.LOADING;
                _context.prev = 2;
                _context.next = 5;
                return this.doLoad();

              case 5:
                this._icon = _context.sent;
                this._status = IconLoaderItem.Status.LOADED;
                _context.next = 12;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](2);
                this._status = IconLoaderItem.Status.ABORTED;

              case 12:
                for (i = 0; i < this._funcs.length; i++) {
                  this._funcs[i](this);
                }

                this._funcs.length = 0;

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 9]]);
      }));

      function load() {
        return _load.apply(this, arguments);
      }

      return load;
    }()
    /**
     * @summary ã¢ã¤ã³ã³ãèª­ã¿è¾¼ã¿ã¾ãããã®é¢æ°ã¯ãªã¼ãã¼ã©ã¤ãããããã¨ãæ³å®ããã¦ãã¾ãã
     * @abstract
     * @return {Image}
     */

  }, {
    key: "doLoad",
    value: function () {
      var _doLoad = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                throw new Error("doLoad() is not implemented in: " + this.constructor.name);

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function doLoad() {
        return _doLoad.apply(this, arguments);
      }

      return doLoad;
    }()
    /**
     * @summary ã¢ã¤ã³ã³ãåå¾ãã¾ãã
     * ã¢ã¤ã³ã³ãèª­ã¿è¾¼ã¾ããã¾ã§ã¯nullãè¿å´ãã¾ãã
     * @return {Image|null}
     */

  }, {
    key: "draw",

    /**
     * @summary ã¢ã¤ã³ã³ãã­ã£ã³ãã¹ã³ã³ãã­ã¹ãã«æç»ãã¾ãã
     * @param {CanvasRenderingContext2D} context
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */
    value: function draw(context, x, y, width, height) {
      context.drawImage(this.icon, x, y, width, height);
    }
  }, {
    key: "status",
    get: function get() {
      return this._status;
    }
  }, {
    key: "icon",
    get: function get() {
      return this._icon;
    }
    /**
     * @summary ã¢ã¤ã³ã³ã®å¹
     * ã¢ã¤ã³ã³ãèª­ã¿è¾¼ã¾ããã¾ã§ã¯-1ãè¿å´ãã¾ãã
     * @return {number}
     */

  }, {
    key: "width",
    get: function get() {
      return this._icon ? this.icon.width : -1;
    }
    /**
     * @summary ã¢ã¤ã³ã³ã®é«ã
     * ã¢ã¤ã³ã³ãèª­ã¿è¾¼ã¾ããã¾ã§ã¯-1ãè¿å´ãã¾ãã
     * @return {number}
     */

  }, {
    key: "height",
    get: function get() {
      return this._icon ? this.icon.height : -1;
    }
  }]);

  return IconLoaderItem;
}();
/**
 * @private
 */


IconLoaderItem.Status = {
  NOT_LOADED: "not loaded",
  LOADING: "loading",
  LOADED: "loaded",
  ABORTED: "aborted"
};
/**
 * @classdesc ã¢ã¤ã³ã³ç»åã®URLãæå®ãã¦ã¢ã¤ã³ã³ãèª­ã¿è¾¼ãã¢ã¤ã³ã³ã­ã¼ãã¼ã§ãã
 * urlã¯ä¸è¨ã®ããã«çæãã¾ãã
 * url = urlPrefix + id + urlSuffix
 * @private
 */

var URLTemplateIconLoader =
/*#__PURE__*/
function (_IconLoader) {
  _inherits(URLTemplateIconLoader, _IconLoader);

  /**
   * @param {string} urlPrefix
   * @param {string} urlSuffix
   */
  function URLTemplateIconLoader(urlPrefix, urlSuffix) {
    var _this;

    _classCallCheck(this, URLTemplateIconLoader);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(URLTemplateIconLoader).call(this));
    _this.urlPrefix = urlPrefix;
    _this.urlSuffix = urlSuffix;
    return _this;
  }
  /**
   * @override
   */


  _createClass(URLTemplateIconLoader, [{
    key: "doCreate",
    value: function doCreate(id) {
      return new URLIconLoaderItem(this.urlPrefix + id + this.urlSuffix);
    }
  }]);

  return URLTemplateIconLoader;
}(IconLoader);
/**
 * @classdesc URLTemplateIconLoaderã®ã¢ã¤ã³ã³ã§ãã
 *
 * @private
 */


var URLIconLoaderItem =
/*#__PURE__*/
function (_IconLoaderItem) {
  _inherits(URLIconLoaderItem, _IconLoaderItem);

  /**
   * @param {string} url
   */
  function URLIconLoaderItem(url) {
    var _this2;

    _classCallCheck(this, URLIconLoaderItem);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(URLIconLoaderItem).call(this));
    _this2.url = url;
    return _this2;
  }
  /**
   * @override
   */


  _createClass(URLIconLoaderItem, [{
    key: "doLoad",
    value: function () {
      var _doLoad2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return Dom.loadImage(this.url, {
                  crossOrigin: "Anonymous"
                });

              case 2:
                return _context3.abrupt("return", _context3.sent);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function doLoad() {
        return _doLoad2.apply(this, arguments);
      }

      return doLoad;
    }()
  }]);

  return URLIconLoaderItem;
}(IconLoaderItem);
/**
 * @classdesc ãã­ã¹ãã¢ã¤ã³ã³ãçæããã¢ã¤ã³ã³ã­ã¼ãã¼ã§ãã
 *
 * @private
 */


var TextIconLoader =
/*#__PURE__*/
function (_IconLoader2) {
  _inherits(TextIconLoader, _IconLoader2);

  function TextIconLoader() {
    _classCallCheck(this, TextIconLoader);

    return _possibleConstructorReturn(this, _getPrototypeOf(TextIconLoader).apply(this, arguments));
  }

  _createClass(TextIconLoader, [{
    key: "doCreate",

    /**
     * ãã­ããã£ã«å¿ããã¢ã¤ã³ã³ãçæãã¾ãã
     * @param {string} prop.text ãã­ããã£
     */
    value: function doCreate(prop) {
      return new TextIconLoaderItem(prop.text, prop.props);
    }
    /**
     * ãã­ããã£ã«å¿ããã­ã¼ãè¿å´ãã¾ãã
     * @param {string} prop.text ãã­ããã£
     */

  }, {
    key: "getKey",
    value: function getKey(prop) {
      return prop.text;
    }
  }]);

  return TextIconLoader;
}(IconLoader);
/**
 * @classdesc TextIconLoaderã®ã¢ã¤ã³ã³ã§ãã
 *
 * @private
 */


var TextIconLoaderItem =
/*#__PURE__*/
function (_IconLoaderItem2) {
  _inherits(TextIconLoaderItem, _IconLoaderItem2);

  /**
   * @param {string}         text                text
   * @param {mapray.Vector2} [props.size]        size in pixel
   * @param {string}         [props.font_family] font family
   */
  function TextIconLoaderItem(text) {
    var _this3;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, TextIconLoaderItem);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(TextIconLoaderItem).call(this));
    _this3.text = text;
    _this3.props = props;
    return _this3;
  }
  /**
   * @override
   */


  _createClass(TextIconLoaderItem, [{
    key: "doLoad",
    value: function () {
      var _doLoad3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        var props, size, fontFamily, context;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                props = this.props;
                size = props.size ? props.size[0] : 20;
                fontFamily = props.font_family ? "'" + props.font_family + "'" : Dom.SYSTEM_FONT_FAMILY;
                context = Dom.createCanvasContext(size, size);
                context.textAlign = "center";
                context.textBaseline = "alphabetic";
                context.font = size * 0.6756756757 + "px " + fontFamily;
                context.fillText(this.text, size * 0.5, size * 0.7432432432);
                return _context4.abrupt("return", context.canvas);

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function doLoad() {
        return _doLoad3.apply(this, arguments);
      }

      return doLoad;
    }()
    /**
     * @override
     */

  }, {
    key: "draw",
    value: function draw(context, x, y, width, height) {
      context.drawImage(this.icon, x, y, width, height);
    }
  }]);

  return TextIconLoaderItem;
}(IconLoaderItem);
/**
 * @classdesc ç»åããã¢ã¤ã³ã³ãçæããã¢ã¤ã³ã³ã­ã¼ãã¼ã§ãã
 * 
 * @private
 */


var ImageIconLoader =
/*#__PURE__*/
function (_IconLoader3) {
  _inherits(ImageIconLoader, _IconLoader3);

  function ImageIconLoader() {
    _classCallCheck(this, ImageIconLoader);

    return _possibleConstructorReturn(this, _getPrototypeOf(ImageIconLoader).apply(this, arguments));
  }

  _createClass(ImageIconLoader, [{
    key: "doCreate",

    /**
     * ãã­ããã£ã«å¿ããã¢ã¤ã³ã³ãçæãã¾ãã
     * @param {string} prop.text ãã­ããã£
     */
    value: function doCreate(image_src) {
      return new ImageIconLoaderItem(image_src);
    }
  }]);

  return ImageIconLoader;
}(IconLoader);
/**
 * @classdesc ImageIconLoaderã®ã¢ã¤ã³ã³ã§ãã
 * 
 * @private
 */


var ImageIconLoaderItem =
/*#__PURE__*/
function (_IconLoaderItem3) {
  _inherits(ImageIconLoaderItem, _IconLoaderItem3);

  /**
   * @param {string|HTMLImageElement|HTMLCanvasElement} image_src image source
   */
  function ImageIconLoaderItem(image_src) {
    var _this4;

    _classCallCheck(this, ImageIconLoaderItem);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(ImageIconLoaderItem).call(this));
    _this4._image_src = image_src;
    return _this4;
  }
  /**
   * @override
   */


  _createClass(ImageIconLoaderItem, [{
    key: "doLoad",
    value: function () {
      var _doLoad4 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        var image_src, image;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                image_src = this._image_src;

                if (!(image_src instanceof Resource)) {
                  _context5.next = 7;
                  break;
                }

                _context5.next = 4;
                return image_src.load({
                  type: ResourceType.IMAGE
                });

              case 4:
                _context5.t0 = _context5.sent;
                _context5.next = 22;
                break;

              case 7:
                if (!(typeof image_src === "string")) {
                  _context5.next = 13;
                  break;
                }

                _context5.next = 10;
                return Dom.loadImage(image_src);

              case 10:
                _context5.t1 = _context5.sent;
                _context5.next = 21;
                break;

              case 13:
                if (!(image_src instanceof HTMLImageElement)) {
                  _context5.next = 19;
                  break;
                }

                _context5.next = 16;
                return Dom.waitForLoad(image_src);

              case 16:
                _context5.t2 = _context5.sent;
                _context5.next = 20;
                break;

              case 19:
                _context5.t2 = image_src instanceof HTMLCanvasElement ? image_src : null;

              case 20:
                _context5.t1 = _context5.t2;

              case 21:
                _context5.t0 = _context5.t1;

              case 22:
                image = _context5.t0;

                if (image) {
                  _context5.next = 25;
                  break;
                }

                throw new Error("not supported: " + image_src);

              case 25:
                return _context5.abrupt("return", image);

              case 26:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function doLoad() {
        return _doLoad4.apply(this, arguments);
      }

      return doLoad;
    }()
  }]);

  return ImageIconLoaderItem;
}(IconLoaderItem);

/**
 * @summary ãã³ã¨ã³ãã£ãã£
 * @memberof mapray
 * @extends mapray.Entity
 *
 * @example
 * var pin = new mapray.PinEntity(viewer.scene);
 * pin.addTextPin( "32", new mapray.GeoPoint(139.768, 35.635) );
 * pin.addTextPin( "A", new mapray.GeoPoint(139.768, 35.636), { fg_color: [0.0, 0.0, 1.0], bg_color: [1.0, 0.0, 0.0] } );
 * pin.addTextPin( "å§", new mapray.GeoPoint(139.768, 35.637), { size: 50 } );
 * pin.addTextPin( "çµ", new mapray.GeoPoint(139.768, 35.639), { size: 50, font_family: "Georgia" } );
 * pin.addPin( new mapray.GeoPoint(139.766, 35.6361) );
 * pin.addMakiIconPin( "ferry-15", new mapray.GeoPoint(139.764, 35.6361), { size: 150, fg_color: [0.2, 0.2, 0.2], bg_color: [1.0, 1.0, 1.0] } );
 * pin.addMakiIconPin( "car-15",   new mapray.GeoPoint(139.762, 35.6361), { size: 60, fg_color: [1.0, 1.0, 1.0], bg_color: [0.2, 0.2, 0.2] } );
 * pin.addMakiIconPin( "bus-15",   new mapray.GeoPoint(139.760, 35.6361), { size: 40, fg_color: [1.0, 0.3, 0.1], bg_color: [0.1, 0.3, 1.0] } );
 * pin.addMakiIconPin( "bus-15",   new mapray.GeoPoint(139.759, 35.6361) );
 * pin.addMakiIconPin( "car-15",   new mapray.GeoPoint(139.758, 35.6361) );
 * viewer.scene.addEntity(pin);
 *
 */

var PinEntity =
/*#__PURE__*/
function (_AbstractPointEntity) {
  _inherits(PinEntity, _AbstractPointEntity);

  /**
   * @param {mapray.Scene} scene        æå±å¯è½ã·ã¼ã³
   * @param {object}       [opts]       ãªãã·ã§ã³éå
   * @param {object}       [opts.json]  çææå ±
   * @param {object}       [opts.refs]  åç§è¾æ¸
   */
  function PinEntity(scene, opts) {
    var _this;

    _classCallCheck(this, PinEntity);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PinEntity).call(this, scene, opts)); // è¦ªãã­ããã£

    _this._parent_props = {
      fg_color: null,
      bg_color: null,
      size: null,
      font_family: null
    }; // Entity.PrimitiveProducer ã¤ã³ã¹ã¿ã³ã¹

    _this._primitive_producer = new PrimitiveProducer$5(_assertThisInitialized(_this));

    _this._animation.addDescendantUnbinder(function () {
      _this._unbindDescendantAnimations();
    });

    _this._setupAnimationBindingBlock(); // çææå ±ããè¨­å®


    if (opts && opts.json) {
      _this._setupByJson(opts.json);
    }

    return _this;
  }
  /**
   * @override
   */


  _createClass(PinEntity, [{
    key: "getPrimitiveProducer",
    value: function getPrimitiveProducer() {
      return this._primitive_producer;
    }
    /**
     * @override
     */

  }, {
    key: "onChangeAltitudeMode",
    value: function onChangeAltitudeMode(prev_mode) {
      this._primitive_producer.onChangeAltitudeMode();
    }
    /**
     * EasyBindingBlock.DescendantUnbinder å¦ç
     *
     * @private
     */

  }, {
    key: "_unbindDescendantAnimations",
    value: function _unbindDescendantAnimations() {
      // ãã¹ã¦ã®ã¨ã³ããªã¼ãè§£é¤
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var entry = _step.value;
          entry.animation.unbindAllRecursively();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * ã¢ãã¡ã¼ã·ã§ã³ã® BindingBlock ãåæå
     *
     * @private
     */

  }, {
    key: "_setupAnimationBindingBlock",
    value: function _setupAnimationBindingBlock() {
      var _this2 = this;

      var block = this.animation; // å®ä½ã¯ EasyBindingBlock

      var number = Type.find("number");
      var vector2 = Type.find("vector2");
      var vector3 = Type.find("vector3"); // ãã©ã¡ã¼ã¿å: fg_color
      // ãã©ã¡ã¼ã¿å: vector3
      //   ã¢ã¤ã³ã³ã®è²

      block.addEntry("fg_color", [vector3], null, function (value) {
        _this2.setFGColor(value);
      }); // ãã©ã¡ã¼ã¿å: bg_color
      // ãã©ã¡ã¼ã¿å: vector3
      //   ã¢ã¤ã³ã³èæ¯ã®è²

      block.addEntry("bg_color", [vector3], null, function (value) {
        _this2.setBGColor(value);
      }); // ãã©ã¡ã¼ã¿å: size
      // ãã©ã¡ã¼ã¿å: vector2 | number
      //   åã vector2 ã®ã¨ã ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãºX, Y é ã§ããã¨è§£é
      //   åã number ã®ã¨ã ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãºX, Y ã¯åå¤

      var size_temp = GeoMath.createVector2();
      var size_type;

      var size_tsolver = function size_tsolver(curve) {
        size_type = AnimUtil.findFirstTypeSupported(curve, [vector2, number]);
        return size_type;
      };

      block.addEntry("size", [vector2, number], size_tsolver, function (value) {
        if (size_type === vector2) {
          _this2.setSize(value);
        } else {
          // size_type === number
          size_temp[0] = value;
          size_temp[1] = value;

          _this2.setSize(size_temp);
        }
      });
    }
    /**
     * @summary ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãºãæå®
     * @param {mapray.Vector3} size  ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãº
     */

  }, {
    key: "setSize",
    value: function setSize(size) {
      this._setVector2Property("size", size);
    }
    /**
     * @summary ã¢ã¤ã³ã³ã®è²ãè¨­å®
     * @param {mapray.Vector3} color  ã¢ã¤ã³ã³ã®è²
     */

  }, {
    key: "setFGColor",
    value: function setFGColor(color) {
      this._setVector3Property("fg_color", color);
    }
    /**
     * @summary ã¢ã¤ã³ã³èæ¯ã®è²ãè¨­å®
     * @param {mapray.Vector3} color  ã¢ã¤ã³ã³èæ¯ã®è²
     */

  }, {
    key: "setBGColor",
    value: function setBGColor(color) {
      this._setVector3Property("bg_color", color);
    }
    /**
     * @summary ãã­ã¹ãã¢ã¤ã³ã³ã®ãã©ã³ããè¨­å®
     * @param {string} font_family  ãã©ã³ããã¡ããªã¼
     */

  }, {
    key: "setFontFamily",
    value: function setFontFamily(font_family) {
      this._setValueProperty("font_family", font_family);
    }
    /**
     * Add Pin
     * @param {mapray.GeoPoint} position         ä½ç½®
     * @param {object}          [props]          ãã­ããã£
     * @param {float}           [props.size]     ã¢ã¤ã³ã³ãµã¤ãº
     * @param {mapray.Vector3}  [props.fg_color] ã¢ã¤ã³ã³è²
     * @param {mapray.Vector3}  [props.bg_color] èæ¯è²
     * @param {string}          [props.id]       Entryãè­å¥ããID
     * @return {mapray.PinEntity.TextPinEntry}   è¿½å ããEntry
     */

  }, {
    key: "addPin",
    value: function addPin(position, props) {
      return this.addTextPin("", position, props);
    }
    /**
     * Add Maki Icon Pin
     * @param {string}          id      ã          ID of Maki Icon
     * @param {mapray.GeoPoint} position            ä½ç½®
     * @param {object}          [props]             ãã­ããã£
     * @param {float}           [props.size]        ã¢ã¤ã³ã³ãµã¤ãº
     * @param {mapray.Vector3}  [props.fg_color]    ã¢ã¤ã³ã³è²
     * @param {mapray.Vector3}  [props.bg_color]    èæ¯è²
     * @param {string}          [props.id]          Entryãè­å¥ããID
     * @return {mapray.PinEntity.MakiIconPinEntry}  è¿½å ããEntry
     */

  }, {
    key: "addMakiIconPin",
    value: function addMakiIconPin(id, position, props) {
      var entry = new MakiIconPinEntry(this, id, position, props);

      this._entries.push(entry);

      this._primitive_producer.onAddEntry();

      return entry;
    }
    /**
     * Add Text Pin
     * @param {string}          text    ã          ãã³ã«è¡¨ç¤ºããããã­ã¹ã
     * @param {mapray.GeoPoint} position            ä½ç½®
     * @param {object}          [props]             ãã­ããã£
     * @param {float}           [props.size]        ã¢ã¤ã³ã³ãµã¤ãº
     * @param {mapray.Vector3}  [props.fg_color]    ã¢ã¤ã³ã³è²
     * @param {mapray.Vector3}  [props.bg_color]    èæ¯è²
     * @param {string}          [props.font_family] ãã©ã³ããã¡ããªã¼
     * @param {string}          [props.id]          Entryãè­å¥ããID
     * @return {mapray.PinEntity.TextPinEntry}      è¿½å ããEntry
     */

  }, {
    key: "addTextPin",
    value: function addTextPin(text, position, props) {
      var entry = new TextPinEntry(this, text, position, props);

      this._entries.push(entry);

      this._primitive_producer.onAddEntry();

      return entry;
    }
    /**
     * @summary å°ç¨ãããªã¢ã«ãåå¾
     * @private
     */

  }, {
    key: "_getMaterial",
    value: function _getMaterial(render_target) {
      var scene = this.scene;

      if (render_target === RenderTarget.SCENE) {
        if (!scene._PinEntity_pin_material) {
          // scene ã«ãããªã¢ã«ãã­ã£ãã·ã¥
          scene._PinEntity_pin_material = new PinMaterial(scene.glenv);
        }

        return scene._PinEntity_pin_material;
      } else if (render_target === RenderTarget.RID) {
        if (!scene._PinEntity_pin_material_pick) {
          // scene ã«ãããªã¢ã«ãã­ã£ãã·ã¥
          scene._PinEntity_pin_material_pick = new PinMaterial(scene.glenv, {
            ridMaterial: true
          });
        }

        return scene._PinEntity_pin_material_pick;
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setValueProperty",
    value: function _setValueProperty(name, value) {
      var props = this._parent_props;

      if (props[name] != value) {
        props[name] = value;

        this._primitive_producer.onChangeParentProperty();
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setVector3Property",
    value: function _setVector3Property(name, value) {
      var dst = this._parent_props[name];

      if (!dst) {
        dst = this._parent_props[name] = GeoMath.createVector3f(value);

        this._primitive_producer.onChangeParentProperty();
      } else if (dst[0] !== value[0] || dst[1] !== value[1] || dst[2] !== value[2]) {
        GeoMath.copyVector3(value, dst);

        this._primitive_producer.onChangeParentProperty();
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setVector2Property",
    value: function _setVector2Property(name, value) {
      var dst = this._parent_props[name];

      if (!dst) {
        this._parent_props[name] = GeoMath.createVector2f(value);

        this._primitive_producer.onChangeParentProperty();
      } else if (dst[0] !== value[0] || dst[1] !== value[1]) {
        GeoMath.copyVector2(value, dst);

        this._primitive_producer.onChangeParentProperty();
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setupByJson",
    value: function _setupByJson(json) {
      var position = new GeoPoint();
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = json.entries[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var entry = _step2.value;
          position.setFromArray(entry.position);
          this.addPin(position, entry);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (json.size) this.setSize(json.size);
      if (json.fg_color) this.setFGColor(json.fg_color);
      if (json.bg_color) this.setBGColor(json.bg_color);
      if (json.font_family) this.setBGColor(json.font_family);
    }
    /**
     * @summary IDã§Entryãåå¾
     * @param {string}  id  ID
     * @return {mapray.PinEntity.MakiIconPinEntry|mapray.PinEntity.TextPinEntry}  IDãä¸è´ããEntryï¼ç¡ããã°undefinedï¼
     */

  }, {
    key: "getEntry",
    value: function getEntry(id) {
      return this._entries.find(function (entry) {
        return entry.id === id;
      });
    }
  }]);

  return PinEntity;
}(AbstractPointEntity); // ã¯ã©ã¹å®æ°ã®å®ç¾©


{
  PinEntity.SAFETY_PIXEL_MARGIN = 1;
  PinEntity.MAX_IMAGE_WIDTH = 4096;
  PinEntity.CIRCLE_SEP_LENGTH = 32;
  PinEntity.DEFAULT_SIZE = GeoMath.createVector2f([30, 30]);
  PinEntity.DEFAULT_FONT_FAMILY = "sans-serif";
  PinEntity.DEFAULT_FG_COLOR = GeoMath.createVector3f([1.0, 1.0, 1.0]);
  PinEntity.DEFAULT_BG_COLOR = GeoMath.createVector3f([0.35, 0.61, 0.81]);
  PinEntity.SAFETY_PIXEL_MARGIN = 1;
  PinEntity.MAX_IMAGE_WIDTH = 4096;
}
/**
 * @summary PrimitiveProducer
 *
 * TODO: relative ã§æ¨é«ã®å¤åã®ãã³ã«ãã¯ã¹ãã£ãçæããå¿è¦ã¯ãªãã®ã§
 *       Layout ã§ã®ãã¯ã¹ãã£ã®çæã¨ã¡ãã·ã¥ã®çæãåé¢ãã
 *
 * @private
 */

var PrimitiveProducer$5 =
/*#__PURE__*/
function (_Entity$PrimitiveProd) {
  _inherits(PrimitiveProducer, _Entity$PrimitiveProd);

  /**
   * @param {mapray.PinEntity} entity
   */
  function PrimitiveProducer(entity) {
    var _this3;

    _classCallCheck(this, PrimitiveProducer);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(PrimitiveProducer).call(this, entity));
    _this3._glenv = entity.scene.glenv;
    _this3._dirty = true; // ããªããã£ãã®è¦ç´ 

    _this3._transform = GeoMath.setIdentity(GeoMath.createMatrix());
    _this3._properties = {
      image: null,
      // ç»å
      image_mask: null // ãã¹ã¯ç»å

    }; // ããªããã£ã

    var primitive = new Primitive(_this3._glenv, null, entity._getMaterial(RenderTarget.SCENE), _this3._transform);
    primitive.properties = _this3._properties;
    _this3._primitive = primitive;
    var pickPrimitive = new Primitive(_this3._glenv, null, entity._getMaterial(RenderTarget.RID), _this3._transform);
    pickPrimitive.properties = _this3._properties;
    _this3._pickPrimitive = pickPrimitive; // ããªããã£ãéå

    _this3._primitives = [];
    _this3._pickPrimitives = [];
    return _this3;
  }
  /**
   * @override
   */


  _createClass(PrimitiveProducer, [{
    key: "createRegions",
    value: function createRegions() {
      var region = new EntityRegion();
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.entity._entries[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var position = _step3.value.position;
          region.addPoint(position);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return [region];
    }
    /**
     * @override
     */

  }, {
    key: "onChangeElevation",
    value: function onChangeElevation(regions) {
      this._dirty = true;
    }
    /**
     * @override
     */

  }, {
    key: "getPrimitives",
    value: function getPrimitives(stage) {
      this._updatePrimitive(stage);

      return stage.getRenderTarget() === RenderTarget.SCENE ? this._primitives : this._pickPrimitives;
    }
    /**
     * @summary è¦ªãã­ããã£ãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeParentProperty",
    value: function onChangeParentProperty() {
      this._dirty = true;
    }
    /**
     * @summary å­ãã­ããã£ãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeChildProperty",
    value: function onChangeChildProperty() {
      this._dirty = true;
    }
    /**
     * @summary é«åº¦ã¢ã¼ããå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeAltitudeMode",
    value: function onChangeAltitudeMode() {
      this._dirty = true;
    }
    /**
     * @summary ã¨ã³ããªãè¿½å ããããã¨ãéç¥
     */

  }, {
    key: "onAddEntry",
    value: function onAddEntry() {
      // å¤åããå¯è½æ§ããã
      this.needToCreateRegions();
      this._dirty = true;
    }
    /**
     * @summary ããªããã£ãã®æ´æ°
     *
     * @desc
     * å¥å:
     *   this.entity._entries
     *   this._dirty
     * åºå:
     *   this._transform
     *   this._properties.image
     *   this._primitive.mesh
     *   this._primitives
     *   this._dirty
     *
     * @return {array.<mapray.Prmitive>}  this._primitives
     *
     * @private
     */

  }, {
    key: "_updatePrimitive",
    value: function _updatePrimitive() {
      if (!this._dirty) {
        // æ´æ°ããå¿è¦ã¯ãªã
        return;
      }

      if (this.entity._entries.length == 0) {
        this._primitives = [];
        this._pickPrimitives = [];
        this._dirty = false;
        return;
      } // åã¨ã³ããªã¼ã® GOCS ä½ç½®ãçæ (å¹³å¦åéå)


      var gocs_array = this._createFlatGocsArray(); // ããªããã£ãã®æ´æ°
      //   primitive.transform


      this._updateTransform(gocs_array);

      var layout = new Layout$1(this, gocs_array);

      if (!layout.isValid()) {
        // æ´æ°ã«å¤±æ
        this._primitives = [];
        this._pickPrimitives = [];
        this._dirty = false;
        return;
      } // ãã¯ã¹ãã£è¨­å®


      var properties = this._properties;

      if (properties.image) {
        properties.image.dispose();
      }

      properties.image = layout.texture;

      if (properties.image_mask) {
        properties.image_mask.dispose();
      }

      properties.image_mask = layout.texture_mask; // ã¡ãã·ã¥çæ

      var mesh_data = {
        vtype: [{
          name: "a_position",
          size: 3
        }, {
          name: "a_offset",
          size: 2
        }, {
          name: "a_texcoord",
          size: 2
        }, {
          name: "a_texmaskcoord",
          size: 2
        }, {
          name: "a_fg_color",
          size: 3
        }, {
          name: "a_bg_color",
          size: 3
        }],
        vertices: layout.vertices,
        indices: layout.indices
      };
      var mesh = new Mesh(this._glenv, mesh_data); // ã¡ãã·ã¥è¨­å®
      //   primitive.mesh

      var primitive = this._primitive;

      if (primitive.mesh) {
        primitive.mesh.dispose();
      }

      var pickPrimitive = this._pickPrimitive;

      if (pickPrimitive.mesh) {
        pickPrimitive.mesh.dispose();
      }

      primitive.mesh = mesh;
      pickPrimitive.mesh = mesh; // æ´æ°ã«æå

      this._primitives = [primitive];
      this._pickPrimitives = [pickPrimitive];
      this._dirty = false;
    }
    /**
     * @summary ããªããã£ãã®æ´æ°
     *
     * @desc
     * æ¡ä»¶:
     *   this.entity._entries.length > 0
     * å¥å:
     *   this.entity._entries.length
     * åºå:
     *   this._transform
     *
     * @param {number[]} gocs_array  GOCS å¹³å¦åéå
     *
     * @private
     */

  }, {
    key: "_updateTransform",
    value: function _updateTransform(gocs_array) {
      var num_entries = this.entity._entries.length;
      var xsum = 0;
      var ysum = 0;
      var zsum = 0;

      for (var i = 0; i < num_entries; ++i) {
        var ibase = 3 * i;
        xsum += gocs_array[ibase];
        ysum += gocs_array[ibase + 1];
        zsum += gocs_array[ibase + 2];
      } // å¤æè¡åã®æ´æ°


      var transform = this._transform;
      transform[12] = xsum / num_entries;
      transform[13] = ysum / num_entries;
      transform[14] = zsum / num_entries;
    }
    /**
     * @summary GOCS å¹³å¦åéåãåå¾
     *
     * å¥å: this.entity._entries
     *
     * @return {number[]}  GOCS å¹³å¦åéå
     * @private
     */

  }, {
    key: "_createFlatGocsArray",
    value: function _createFlatGocsArray() {
      var num_points = this.entity._entries.length;
      return GeoPoint.toGocsArray(this._getFlatGeoPoints_with_Absolute(), num_points, new Float64Array(3 * num_points));
    }
    /**
     * @summary GeoPoint å¹³å¦åéåãåå¾ (çµ¶å¯¾é«åº¦)
     *
     * å¥å: this.entity._entries
     *
     * @return {number[]}  GeoPoint å¹³å¦åéå
     * @private
     */

  }, {
    key: "_getFlatGeoPoints_with_Absolute",
    value: function _getFlatGeoPoints_with_Absolute() {
      var owner = this.entity;
      var entries = owner._entries;
      var num_points = entries.length;
      var flat_array = new Float64Array(3 * num_points); // flat_array[] ã«çµåº¦è¦ç´ ã¨ç·¯åº¦è¦ç´ ãè¨­å®

      for (var i = 0; i < num_points; ++i) {
        var pos = entries[i].position;
        flat_array[3 * i] = pos.longitude;
        flat_array[3 * i + 1] = pos.latitude;
      }

      switch (owner.altitude_mode) {
        case AltitudeMode.RELATIVE:
        case AltitudeMode.CLAMP:
          // flat_array[] ã®é«åº¦è¦ç´ ã«ç¾å¨ã®æ¨é«ãè¨­å®
          owner.scene.viewer.getExistingElevations(num_points, flat_array, 0, 3, flat_array, 2, 3);

          if (owner.altitude_mode === AltitudeMode.RELATIVE) {
            // flat_array[] ã®é«åº¦è¦ç´ ã«çµ¶å¯¾é«åº¦ãè¨­å®
            for (var _i = 0; _i < num_points; ++_i) {
              flat_array[3 * _i + 2] += entries[_i].position.altitude;
            }
          }

          break;

        default:
          // AltitudeMode.ABSOLUTE
          // flat_array[] ã®é«åº¦è¦ç´ ã«çµ¶å¯¾é«åº¦ãè¨­å®
          for (var _i2 = 0; _i2 < num_points; ++_i2) {
            flat_array[3 * _i2 + 2] = entries[_i2].position.altitude;
          }

          break;
      }

      return flat_array;
    }
  }]);

  return PrimitiveProducer;
}(Entity.PrimitiveProducer);
/**
 * @summary ãã³è¦ç´ 
 * @hideconstructor
 * @memberof mapray.PinEntity
 * @public
 * @abstract
 */


var AbstractPinEntry =
/*#__PURE__*/
function () {
  function AbstractPinEntry(owner, position, props) {
    _classCallCheck(this, AbstractPinEntry);

    this._owner = owner;
    this._position = position.clone(); // animation.BindingBlock

    this._animation = new EasyBindingBlock();

    this._setupAnimationBindingBlock();

    this._props = Object.assign({}, props); // props ã®è¤è£½

    this._copyPropertyVector3f("fg_color"); // deep copy


    this._copyPropertyVector3f("bg_color"); // deep copy


    this._copyPropertyVector2f("size"); // deep copy

  }

  _createClass(AbstractPinEntry, [{
    key: "_loadIcon",
    value: function _loadIcon() {
      throw new Error("loadIcon() is not implemented: " + this.constructor.name);
    }
    /**
     * @summary ä½ç½®
     * @type {mapray.GeoPoint}
     * @readonly
     * @package
     */

  }, {
    key: "_setupAnimationBindingBlock",

    /**
     * ã¢ãã¡ã¼ã·ã§ã³ã® BindingBlock ãåæå
     *
     * @private
     */
    value: function _setupAnimationBindingBlock() {
      var _this4 = this;

      var block = this.animation; // å®ä½ã¯ EasyBindingBlock

      var number = Type.find("number");
      var vector2 = Type.find("vector2");
      var vector3 = Type.find("vector3"); // ãã©ã¡ã¼ã¿å: position
      // ãã©ã¡ã¼ã¿å: vector3
      //   ãã¯ãã«ã®è¦ç´ ã longitude, latitude, altitude é ã§ããã¨è§£é

      var position_temp = new GeoPoint();
      block.addEntry("position", [vector3], null, function (value) {
        position_temp.setFromArray(value); // Vector3 -> GeoPoint

        _this4.setPosition(position_temp);
      }); // ãã©ã¡ã¼ã¿å: fg_color
      // ãã©ã¡ã¼ã¿å: vector3
      //   ã¢ã¤ã³ã³ã®è²

      block.addEntry("fg_color", [vector3], null, function (value) {
        _this4.setFGColor(value);
      }); // ãã©ã¡ã¼ã¿å: bg_color
      // ãã©ã¡ã¼ã¿å: vector3
      //   ã¢ã¤ã³ã³èæ¯ã®è²

      block.addEntry("bg_color", [vector3], null, function (value) {
        _this4.setBGColor(value);
      }); // ãã©ã¡ã¼ã¿å: size
      // ãã©ã¡ã¼ã¿å: vector2 | number
      //   åã vector2 ã®ã¨ã ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãºX, Y é ã§ããã¨è§£é
      //   åã number ã®ã¨ã ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãºX, Y ã¯åå¤

      var size_temp = GeoMath.createVector2();
      var size_type;

      var size_tsolver = function size_tsolver(curve) {
        size_type = AnimUtil.findFirstTypeSupported(curve, [vector2, number]);
        return size_type;
      };

      block.addEntry("size", [vector2, number], size_tsolver, function (value) {
        if (size_type === vector2) {
          _this4.setSize(value);
        } else {
          // size_type === number
          size_temp[0] = value;
          size_temp[1] = value;

          _this4.setSize(size_temp);
        }
      });
    }
    /**
     * @summary ã¢ãã«åç¹ä½ç½®ãè¨­å®
     *
     * @param {mapray.GeoPoint} position  ã¢ãã«åç¹ã®ä½ç½®
     */

  }, {
    key: "setPosition",
    value: function setPosition(position) {
      if (this._position.longitude !== position.longitude || this._position.latitude !== position.latitude || this._position.altitude !== position.altitude) {
        // ä½ç½®ãå¤æ´ããã
        this._position.assign(position);

        this._owner.getPrimitiveProducer().onChangeChildProperty();
      }
    }
    /**
     * @summary ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãºãæå®
     * @param {mapray.Vector3} size  ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãº
     */

  }, {
    key: "setSize",
    value: function setSize(size) {
      this._setVector2Property("size", size);
    }
    /**
     * @summary ã¢ã¤ã³ã³ã®è²ãè¨­å®
     * @param {mapray.Vector3} color  ã¢ã¤ã³ã³ã®è²
     */

  }, {
    key: "setFGColor",
    value: function setFGColor(color) {
      this._setVector3Property("fg_color", color);
    }
    /**
     * @summary ã¢ã¤ã³ã³èæ¯ã®è²ãè¨­å®
     * @param {mapray.Vector3} color  ã¢ã¤ã³ã³èæ¯ã®è²
     */

  }, {
    key: "setBGColor",
    value: function setBGColor(color) {
      this._setVector3Property("bg_color", color);
    }
    /**
     * @private
     */

  }, {
    key: "_copyPropertyVector3f",
    value: function _copyPropertyVector3f(name) {
      var props = this._props;

      if (props.hasOwnProperty(name)) {
        props[name] = GeoMath.createVector3f(props[name]);
      }
    }
    /**
     * @private
     */

  }, {
    key: "_copyPropertyVector2f",
    value: function _copyPropertyVector2f(name) {
      var props = this._props;

      if (props.hasOwnProperty(name)) {
        if (typeof props[name] === 'number') {
          props[name] = GeoMath.createVector2f([props[name], props[name]]);
        } else {
          props[name] = GeoMath.createVector2f(props[name]);
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setVector3Property",
    value: function _setVector3Property(name, value) {
      var dst = this._props[name];

      if (!dst) {
        dst = this._props[name] = GeoMath.createVector3f(value);

        this._owner.getPrimitiveProducer().onChangeChildProperty();
      } else if (dst[0] !== value[0] || dst[1] !== value[1] || dst[2] !== value[2]) {
        GeoMath.copyVector3(value, dst);

        this._owner.getPrimitiveProducer().onChangeChildProperty();
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setVector2Property",
    value: function _setVector2Property(name, value) {
      var dst = this._props[name];

      if (!dst) {
        this._props[name] = GeoMath.createVector2f(value);

        this._owner.getPrimitiveProducer().onChangeChildProperty();
      } else if (dst[0] !== value[0] || dst[1] !== value[1]) {
        GeoMath.copyVector2(value, dst);

        this._owner.getPrimitiveProducer().onChangeChildProperty();
      }
    }
  }, {
    key: "isLoaded",
    value: function isLoaded() {
      return this._icon.isLoaded();
    }
  }, {
    key: "draw",
    value: function draw(context, x, y, width, height) {
      this._icon.draw(context, x, y, width, height);
    }
  }, {
    key: "position",
    get: function get() {
      return this._position;
    }
    /**
     * @summary ID
     * @type {string}
     * @readonly
     */

  }, {
    key: "id",
    get: function get() {
      return this._props.hasOwnProperty("id") ? this._props.id : "";
    }
    /**
     * @summary ã¢ã¤ã³ã³ãµã¤ãº (Pixels)
     * @type {mapray.Vector2}
     * @readonly
     * @package
     */

  }, {
    key: "size",
    get: function get() {
      var props = this._props;
      var parent = this._owner._parent_props;
      return props.size || parent.size || (this.icon ? GeoMath.createVector2f([this.icon.width, this.icon.height]) : PinEntity.DEFAULT_SIZE);
    }
    /**
     * @summary ã¢ã¤ã³ã³è²
     * @type {mapray.Vector3}
     * @readonly
     * @package
     */

  }, {
    key: "fg_color",
    get: function get() {
      var props = this._props;
      var parent = this._owner._parent_props;
      return props.fg_color || parent.fg_color || PinEntity.DEFAULT_FG_COLOR;
    }
    /**
     * @summary ã¢ã¤ã³ã³èæ¯è²
     * @type {mapray.Vector3}
     * @readonly
     * @package
     */

  }, {
    key: "bg_color",
    get: function get() {
      var props = this._props;
      var parent = this._owner._parent_props;
      return props.bg_color || parent.bg_color || PinEntity.DEFAULT_BG_COLOR;
    }
    /**
     * @summary ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿è¨­å®
     *
     * @type {mapray.animation.BindingBlock}
     * @readonly
     */

  }, {
    key: "animation",
    get: function get() {
      return this._animation;
    }
  }, {
    key: "icon",
    get: function get() {
      return this._icon;
    }
  }]);

  return AbstractPinEntry;
}();

PinEntity.AbstractPinEntry = AbstractPinEntry;
/**
 * @summary MakiIconè¦ç´ 
 * @hideconstructor
 * @memberof mapray.PinEntity
 * @extends mapray.PinEntity.AbstractPinEntry
 * @public
 */

var MakiIconPinEntry =
/*#__PURE__*/
function (_AbstractPinEntry) {
  _inherits(MakiIconPinEntry, _AbstractPinEntry);

  /**
   * @param {mapray.PinEntity}    owner               ææè
   * @param {string}              id                  Makiã¢ã¤ã³ã³ã®ID
   * @param {mapray.GeoPoint}     position            ä½ç½®
   * @param {object}              [props]             ãã­ããã£
   * @param {float}               [props.size]        ã¢ã¤ã³ã³ãµã¤ãº
   * @param {mapray.Vector3}      [props.fg_color]    ã¢ã¤ã³ã³è²
   * @param {mapray.Vector3}      [props.bg_color]    èæ¯è²
   * @param {string}              [props.id]          Entryãè­å¥ããID
   */
  function MakiIconPinEntry(owner, id, position, props) {
    var _this5;

    _classCallCheck(this, MakiIconPinEntry);

    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(MakiIconPinEntry).call(this, owner, position, props));

    _this5.setId(id);

    _this5._setupMakiIconPinAnimationBindingBlock();

    return _this5;
  }
  /**
   * ã¢ãã¡ã¼ã·ã§ã³ã® BindingBlock ãåæå
   *
   * @private
   */


  _createClass(MakiIconPinEntry, [{
    key: "_setupMakiIconPinAnimationBindingBlock",
    value: function _setupMakiIconPinAnimationBindingBlock() {
      var _this6 = this;

      var block = this.animation; // å®ä½ã¯ EasyBindingBlock

      var string = Type.find("string"); // ãã©ã¡ã¼ã¿å: id
      // ãã©ã¡ã¼ã¿å: string
      //   ã¢ã¤ã³ã³ã®ID

      block.addEntry("id", [string], null, function (value) {
        _this6.setId(value);
      });
    }
    /**
     * @summary ã¢ã¤ã³ã³ã®IDãè¨­å®
     * @param {string} maki_id  ã¢ã¤ã³ã³ã®ID
     */

  }, {
    key: "setId",
    value: function setId(maki_id) {
      var _this7 = this;

      if (this._maki_id !== maki_id) {
        // ã¢ã¤ã³ã³ã®IDãå¤æ´ããã
        this._maki_id = maki_id;
        this._icon = MakiIconPinEntry.makiIconLoader.load(maki_id);

        this._icon.onEnd(function (item) {
          _this7._owner.getPrimitiveProducer()._dirty = true;
        });
      }
    }
  }]);

  return MakiIconPinEntry;
}(AbstractPinEntry);

PinEntity.MakiIconPinEntry = MakiIconPinEntry;
{
  MakiIconPinEntry.makiIconLoader = new URLTemplateIconLoader("https://resource.mapray.com/styles/v1/icons/maki/", ".svg");
}
/**
 * @summary MakiIconè¦ç´ 
 * @hideconstructor
 * @memberof mapray.PinEntity
 * @extends mapray.PinEntity.AbstractPinEntry
 * @public
 */

var TextPinEntry =
/*#__PURE__*/
function (_AbstractPinEntry2) {
  _inherits(TextPinEntry, _AbstractPinEntry2);

  /**
   * @param {mapray.PinEntity}  owner                ææè
   * @param {string}            text                 ãã­ã¹ã
   * @param {mapray.GeoPoint}   position             ä½ç½®
   * @param {object}            [props]              ãã­ããã£
   * @param {float}             [props.size]         ã¢ã¤ã³ã³ãã¯ã»ã«ãµã¤ãº
   * @param {mapray.Vector3}    [props.fg_color]     ã¢ã¤ã³ã³è²
   * @param {mapray.Vector3}    [props.bg_color]     èæ¯è²
   * @param {string}            [props.font_family]  ãã©ã³ããã¡ããªã¼
   * @param {string}            [props.id]           Entryãè­å¥ããID
   */
  function TextPinEntry(owner, text, position, props) {
    var _this8;

    _classCallCheck(this, TextPinEntry);

    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(TextPinEntry).call(this, owner, position, props));

    _this8.setText(text);

    _this8._setupTextPinAnimationBindingBlock();

    return _this8;
  }
  /**
   * @summary ãã©ã³ããã¡ããªã¼
   * @type {string}
   * @readonly
   * @package
   */


  _createClass(TextPinEntry, [{
    key: "_setupTextPinAnimationBindingBlock",

    /**
     * ã¢ãã¡ã¼ã·ã§ã³ã® BindingBlock ãåæå
     *
     * @private
     */
    value: function _setupTextPinAnimationBindingBlock() {
      var _this9 = this;

      var block = this.animation; // å®ä½ã¯ EasyBindingBlock

      var string = Type.find("string"); // ãã©ã¡ã¼ã¿å: text
      // ãã©ã¡ã¼ã¿å: string
      //   ãã­ã¹ã

      block.addEntry("text", [string], null, function (value) {
        _this9.setText(value);
      });
    }
    /**
     * @summary ãã­ã¹ããè¨­å®
     * @param {string} text  ãã­ã¹ã
     */

  }, {
    key: "setText",
    value: function setText(text) {
      var _this10 = this;

      if (this._text !== text) {
        // ãã­ã¹ããå¤æ´ããã
        this._text = text;
        this._icon = TextPinEntry.textIconLoader.load({
          text: this._text,
          props: {
            size: this.size,
            font_family: this.font_family
          }
        });

        this._icon.onEnd(function (item) {
          _this10._owner.getPrimitiveProducer()._dirty = true;
        });
      }
    }
  }, {
    key: "font_family",
    get: function get() {
      var props = this._props;
      var parent = this._owner._parent_props;
      return props.font_family || parent.font_family || PinEntity.DEFAULT_FONT_FAMILY;
    }
  }]);

  return TextPinEntry;
}(AbstractPinEntry);

PinEntity.TextPinEntry = TextPinEntry;
{
  TextPinEntry.textIconLoader = new TextIconLoader();
}
/**
 * @summary è¦ç´ ã Canvas ä¸ã«ã¬ã¤ã¢ã¦ã
 *
 * @memberof mapray.PinEntity
 * @private
 */

var Layout$1 =
/*#__PURE__*/
function () {
  /**
   * @desc
   * å¥å:
   *   owner._glenv
   *   owner.entity._entries
   *   owner._transform
   *
   * @param {PrimitiveProducer} owner       ææè
   * @param {number[]}          gocs_array  GOCS å¹³å¦åéå
   */
  function Layout(owner, gocs_array) {
    _classCallCheck(this, Layout);

    this._owner = owner;
    this._items = this._createItemList();
    this._is_valid = true;

    var row_layouts = this._createRowLayouts();

    if (row_layouts.length == 0) {
      // æå¹ãªãã­ã¹ãã1ã¤ãç¡ã
      this._is_valid = false;
      return;
    } // ã¢ã¤ãã ã®éç½®ã®è¨­å®ã¨ã­ã£ã³ãã¹ãµã¤ãºã®æ±ºå®


    var size = this._setupLocation(row_layouts);

    this._texture = this._createTexture(size.width, size.height);
    this._texture_mask = this._createTextureMask();
    this._vertices = this._createVertices(size.width, size.height, gocs_array);
    this._indices = this._createIndices();
  }
  /**
   * @summary æå¹ãªãªãã¸ã§ã¯ããï¼
   * @desc
   * <p>ç¡å¹ã®ã¨ããä»ã®ã¡ã½ããã¯å¼ã³åºããªãã</p>
   * @return {boolean}  æå¹ã®ã¨ã true, ç¡å¹ã®ã¨ã false
   */


  _createClass(Layout, [{
    key: "isValid",
    value: function isValid() {
      return this._is_valid;
    }
    /**
     * @summary ãã¯ã¹ãã£
     * @type {mapray.Texture}
     * @readonly
     */

  }, {
    key: "_createItemList",

    /**
     * @summary ã¬ã¤ã¢ã¦ãã¢ã¤ãã ã®ãªã¹ããçæ
     * @return {array.<mapray.PinEntity.LItem>}
     * @private
     */
    value: function _createItemList() {
      var map = new Map();
      var items = [];
      var counter = 0;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._owner.entity._entries[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var entry = _step4.value;

          if (entry.isLoaded()) {
            var item = map.get(entry.icon);

            if (!item) {
              map.set(entry.icon, item = new LItem$1(this));
              items.push(item);
            }

            item.add(counter++, entry);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return items;
    }
    /**
     * @summary RowLayout ã®ãªã¹ããçæ
     * @return {array.<mapray.PinEntity.RowLayout>}
     * @private
     */

  }, {
    key: "_createRowLayouts",
    value: function _createRowLayouts() {
      // ã¢ã¤ãã ãªã¹ãã®è¤è£½
      var items = [].concat(this._items); // RowLayout åã§ãã¾ãé«ãã«å·®ãåºãªãããã«ãã¢ã¤ãã ãªã¹ããé«ãã§æ´å

      items.sort(function (a, b) {
        return a.height_pixel - b.height_pixel;
      }); // ãªã¹ããçæ

      var row_layouts = [];

      while (items.length > 0) {
        var row_layout = new RowLayout$1(items);

        if (row_layout.isValid()) {
          row_layouts.push(row_layout);
        }
      }

      return row_layouts;
    }
    /**
     * @summary ãã¯ã¹ãã£ãçæ
     * @param  {number} width    æ¨ªå¹
     * @param  {number} height   é«ã
     * @return {mapray.Texture}  ãã­ã¹ããã¯ã¹ãã£
     * @private
     */

  }, {
    key: "_createTexture",
    value: function _createTexture(width, height) {
      var context = Dom.createCanvasContext(width, height);
      var items = this._items;

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        if (item.is_canceled) continue;
        item.draw(context);
      }

      var glenv = this._owner._glenv;
      var opts = {
        usage: Texture.Usage.ICON
      };
      return new Texture(glenv, context.canvas, opts);
    }
  }, {
    key: "_createTextureMask",
    value: function _createTextureMask() {
      var context = Dom.createCanvasContext(3, 3);
      context.fillRect(1, 1, 1, 1);
      var glenv = this._owner._glenv;
      var opts = {
        usage: Texture.Usage.ICON,
        mag_filter: glenv.context.NEAREST
      };
      return new Texture(glenv, context.canvas, opts);
    }
    /**
     * @summary é ç¹éåãçæ
     *
     * @param  {number}   width       æ¨ªå¹
     * @param  {number}   height      é«ã
     * @param  {number[]} gocs_array  GOCS å¹³å¦åéå
     * @return {array.<number>}  é ç¹éå [å·¦ä¸0, å³ä¸0, å·¦ä¸0, å³ä¸0, ...]
     *
     * @private
     */

  }, {
    key: "_createVertices",
    value: function _createVertices(width, height, gocs_array) {
      var vertices = []; // ãã­ã¹ãéåã®åç¹ (GOCS)

      var transform = this._owner._transform;
      var xo = transform[12];
      var yo = transform[13];
      var zo = transform[14];
      /*
           |<size.x->|               
           |         |               
           |    |<--rx--->|          
          ___-------___     ----     
         /             \      ^      
       /                 \    ry     
      |                   |   |  ----
      |                   |   v    ^ 
      |         c         | ----  size.y
      |                   |   ^    V 
      |                   |   |  ----
       \                 /    |      
        '----_0___3_----'     |      
              |   |           |      
              |   |           h      
              |   |           |      
              |   |           |      
              |   |           |      
              |   |           v      
              1---2 ------------     
                                     
             >| w |<                 
      */

      var xn = 1 / width;
      var yn = 1 / height;
      var items = this._items;

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        if (item.is_canceled) continue;

        for (var ie = 0; ie < item.entries.length; ie++) {
          var eitem = item.entries[ie];
          var entry = eitem.entry;
          var size = entry.size;
          var rx = size[0] * 1.5 / 2;
          var ry = size[1] * 1.5 / 2;
          var h = ry * 2;
          var w = Math.max(2, rx / 10); // Relativize based on (xo, yo, zo)

          var ibase = eitem.index * 3;
          var xm = gocs_array[ibase] - xo;
          var ym = gocs_array[ibase + 1] - yo;
          var zm = gocs_array[ibase + 2] - zo;
          var fg_color = entry.fg_color;
          var bg_color = entry.bg_color; // Image dimensions (Image Coordinate)

          var xc = item.pos_x;
          var yc = item.pos_y;
          var xsize = item.width;
          var ysize = item.height;

          var vertices_push_texture = function vertices_push_texture(px, py) {
            vertices.push((xc + xsize * px) * xn, 1 - (yc + ysize * py) * yn);
          }; // p0


          vertices.push(xm, ym, zm); // a_position

          vertices.push(-w / 2, h - ry); // a_offset

          vertices_push_texture(0.5 - w / 2 / rx, 1.5 / 2 + 0.5); // a_texcoord

          vertices.push(-0.25 + 0.5, -0.25 + 0.5); // a_texmaskcoord

          vertices.push.apply(vertices, _toConsumableArray(fg_color));
          vertices.push.apply(vertices, _toConsumableArray(bg_color)); // p1

          vertices.push(xm, ym, zm); // a_position

          vertices.push(-w / 2, 0); // a_offset

          vertices_push_texture(0.5 - w / 2 / rx, 1.5 / 2 + 0.5); // a_texcoord

          vertices.push(-0.25 + 0.5, -0.25 + 0.5); // a_texmaskcoord

          vertices.push.apply(vertices, _toConsumableArray(fg_color));
          vertices.push.apply(vertices, _toConsumableArray(bg_color)); // p2

          vertices.push(xm, ym, zm); // a_position

          vertices.push(w / 2, 0); // a_offset

          vertices_push_texture(0.5 + w / 2 / rx, 1.5 / 2 + 0.5); // a_texcoord

          vertices.push(-0.25 + 0.5, -0.25 + 0.5); // a_texmaskcoord

          vertices.push.apply(vertices, _toConsumableArray(fg_color));
          vertices.push.apply(vertices, _toConsumableArray(bg_color)); // p3

          vertices.push(xm, ym, zm); // a_position

          vertices.push(w / 2, h - ry); // a_offset

          vertices_push_texture(0.5 + w / 2 / rx, 1.5 / 2 + 0.5); // a_texcoord

          vertices.push(-0.25 + 0.5, -0.25 + 0.5); // a_texmaskcoord

          vertices.push.apply(vertices, _toConsumableArray(fg_color));
          vertices.push.apply(vertices, _toConsumableArray(bg_color)); // c

          vertices.push(xm, ym, zm); // a_position

          vertices.push(0, h); // a_offset

          vertices_push_texture(0.5, 0.5); // a_texcoord

          vertices.push(0.5, 0.5); // a_texmaskcoord

          vertices.push.apply(vertices, _toConsumableArray(fg_color));
          vertices.push.apply(vertices, _toConsumableArray(bg_color));

          for (var k = 1; k < PinEntity.CIRCLE_SEP_LENGTH; k++) {
            var th = (k / PinEntity.CIRCLE_SEP_LENGTH * 2 - 0.5) * Math.PI;
            var cos_th = Math.cos(th);
            var sin_th = Math.sin(th);
            vertices.push(xm, ym, zm); // a_position

            vertices.push(rx * cos_th, ry * sin_th + h); // a_offset

            vertices_push_texture(1.5 * cos_th / 2 + 0.5, -1.5 * sin_th / 2 + 0.5); // a_texcoord

            vertices.push(cos_th * 0.25 + 0.5, sin_th * 0.25 + 0.5); // a_texmaskcoord

            vertices.push.apply(vertices, _toConsumableArray(fg_color));
            vertices.push.apply(vertices, _toConsumableArray(bg_color));
          }
        }
      }

      return vertices;
    }
    /**
     * @summary ã¤ã³ããã¯ã¹éåãçæ
     * @return {array.<number>}  ã¤ã³ããã¯ã¹éå []
     * @private
     */

  }, {
    key: "_createIndices",
    value: function _createIndices() {
      var indices = [];
      var items = this._items;

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        if (item.is_canceled) continue;

        for (var ie = 0; ie < item.entries.length; ie++) {
          var eitem = item.entries[ie];
          var base = (4 + 1 + PinEntity.CIRCLE_SEP_LENGTH - 1) * eitem.index;
          var p = base;
          var p0 = p;
          var p3 = p + 3;
          indices.push(p, p + 1, p + 2);
          indices.push(p, p + 2, p + 3);
          p += 4;
          var centerPos = p++;
          indices.push(centerPos, p0, p3);
          indices.push(centerPos, p3, p);

          for (var j = 1; j < PinEntity.CIRCLE_SEP_LENGTH - 1; j++) {
            indices.push(centerPos, p++, p);
          }

          indices.push(centerPos, p++, p0);
        }
      }

      return indices;
    }
    /**
     * @summary ã¢ã¤ãã ã®éç½®ãè¨­å®
     * @param  {array.<mapray.PinEntity.RowLayout>} row_layouts
     * @return {object}                              ã­ã£ã³ãã¹ãµã¤ãº
     * @private
     */

  }, {
    key: "_setupLocation",
    value: function _setupLocation(row_layouts) {
      var width = 0;
      var height = 0;
      height += PinEntity.SAFETY_PIXEL_MARGIN;

      for (var i = 0; i < row_layouts.length; ++i) {
        var row_layout = row_layouts[i];
        row_layout.locate(height);
        width = Math.max(row_layout.width_assumed, width);
        height += row_layout.height_pixel + PinEntity.SAFETY_PIXEL_MARGIN;
      }

      return {
        width: width,
        height: height
      };
    }
  }, {
    key: "texture",
    get: function get() {
      return this._texture;
    }
    /**
     * @summary ãã¯ã¹ãã£ãã¹ã¯
     * @type {mapray.Texture}
     * @readonly
     */

  }, {
    key: "texture_mask",
    get: function get() {
      return this._texture_mask;
    }
    /**
     * @summary é ç¹éå
     * @desc
     * æ¡ä»¶:
     *   this._entries.length > 0
     * å¥å:
     *   this._entries
     *   this._transform
     * @type {Float32Array}
     * @readonly
     */

  }, {
    key: "vertices",
    get: function get() {
      return this._vertices;
    }
    /**
     * @summary ã¤ã³ããã¯ã¹éå
     * @type {Uint32Array}
     * @readonly
     */

  }, {
    key: "indices",
    get: function get() {
      return this._indices;
    }
  }]);

  return Layout;
}();
/**
 * @summary ã¬ã¤ã¢ã¦ãå¯¾è±¡
 * @memberof mapray.PinEntity
 * @private
 */


var LItem$1 =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.PinEntity.Layout} layout   ææè
   * @param {mapray.PinEntity.Entry}  entry    PinEntityã®ã¨ã³ããª
   */
  function LItem(layout) {
    _classCallCheck(this, LItem);

    this.entries = []; // ãã­ã¹ãã®åºç¹

    this._pos_x = 0; // å·¦ç«¯

    this._pos_y = 0; // ãã¼ã¹ã©ã¤ã³ä½ç½®

    this._height = this._width = null;
    this._is_canceled = false;
  }

  _createClass(LItem, [{
    key: "add",
    value: function add(index, entry) {
      var size = entry.size;
      if (this._width === null || this._width < size[0]) this._width = size[0];
      if (this._height === null || this._height < size[1]) this._height = size[1];
      this.entries.push({
        index: index,
        entry: entry
      });
    }
    /**
     * @type {number}
     * @readonly
     */

  }, {
    key: "cancel",

    /**
     * @summary åãæ¶ãç¶æã«ç§»è¡
     */
    value: function cancel() {
      this._is_canceled = true;
    }
    /**
     * @summary éç½®ãæ±ºå®
     * @param {number} x  ãã­ã¹ãç©å½¢å·¦è¾ºã® X åº§æ¨ (ã­ã£ã³ãã¹åº§æ¨ç³»)
     * @param {number} y  ãã­ã¹ãç©å½¢ä¸è¾ºã® Y åº§æ¨ (ã­ã£ã³ãã¹åº§æ¨ç³»)
     */

  }, {
    key: "locate",
    value: function locate(x, y) {
      this._pos_x = x;
      this._pos_y = y;
    }
  }, {
    key: "draw",
    value: function draw(context) {
      this.entries[0].entry.draw(context, this._pos_x, this.pos_y, this.width, this.height);
    }
  }, {
    key: "pos_x",
    get: function get() {
      return this._pos_x;
    }
    /**
     * @type {number}
     * @readonly
     */

  }, {
    key: "pos_y",
    get: function get() {
      return this._pos_y;
    }
    /**
     * @type {number}
     * @readonly
     */

  }, {
    key: "width",
    get: function get() {
      return this._width;
    }
  }, {
    key: "height",
    get: function get() {
      return this._height;
    }
    /**
     * ã­ã£ã³ãã¹ä¸ã§ã®ãã­ã¹ãã®æ¨ªç»ç´ æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "width_pixel",
    get: function get() {
      return Math.ceil(this._width);
    }
    /**
     * ã­ã£ã³ãã¹ä¸ã§ã®ãã­ã¹ãã®ç¸¦ç»ç´ æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "height_pixel",
    get: function get() {
      return Math.ceil(this._height);
    }
    /**
     * åãæ¶ãç¶æãï¼
     * @type {boolean}
     * @readonly
     */

  }, {
    key: "is_canceled",
    get: function get() {
      return this._is_canceled;
    }
  }]);

  return LItem;
}();
/**
 * @summary æ°´å¹³ã¬ã¤ã¢ã¦ã
 * @memberof mapray.PinEntity
 * @private
 */


var RowLayout$1 =
/*#__PURE__*/
function () {
  /**
   * @desc
   * <p>ã¬ã¤ã¢ã¦ãããããã¾ãã¯ã¬ã¤ã¢ã¦ãã«å¤±æããã¢ã¤ãã ã¯ src_items ããåé¤ãããã</p>
   * <p>ã¬ã¤ã¢ã¦ãã«å¤±æããã¢ã¤ãã ã¯åãæ¶ã (is_canceled) ã«ãªãã</p>
   * @param {array.<mapray.PinEntity.LItem>} src_items  ã¢ã¤ãã ãªã¹ã
   */
  function RowLayout(src_items) {
    _classCallCheck(this, RowLayout);

    var width_assumed_total = 0;
    var height_pixel_max = 0;
    var row_items = [];
    width_assumed_total += PinEntity.SAFETY_PIXEL_MARGIN; // å·¦ãã¼ã¸ã³

    while (src_items.length > 0) {
      var item = src_items.shift();
      var width_assumed = item.width_pixel + PinEntity.SAFETY_PIXEL_MARGIN; // ãã­ã¹ãå¹ + å³ãã¼ã¸ã³

      if (width_assumed_total + width_assumed <= PinEntity.MAX_IMAGE_WIDTH) {
        // è¡ã«ã¢ã¤ãã ãè¿½å 
        row_items.push(item);
        width_assumed_total += width_assumed;
        height_pixel_max = Math.max(item.height_pixel, height_pixel_max);
      } else {
        if (row_items.length == 0) {
          // ãã­ã¹ããé·ããã¦è¡¨ç¤ºã§ããªã
          item.cancel();
        } else {
          // æ¬¡ã®è¡ã«ãªãããå·®ãæ»ãã¦çµäº
          src_items.unshift(item);
          break;
        }
      }
    }

    this._items = row_items;
    this._width_assumed = width_assumed_total;
    this._height_pixel = height_pixel_max;
  }
  /**
   * @summary æå¹ãªãªãã¸ã§ã¯ããï¼
   * @desc
   * <p>ç¡å¹ã®ã¨ããä»ã®ã¡ã½ããã¯å¼ã³åºããªãã</p>
   * @return {boolean}  æå¹ã®ã¨ã true, ç¡å¹ã®ã¨ã false
   */


  _createClass(RowLayout, [{
    key: "isValid",
    value: function isValid() {
      return this._items.length > 0;
    }
    /**
     * 
     * @type {array.<mapray.PinEntity.LItem>}
     * @readonly
     */

  }, {
    key: "locate",

    /**
     * @summary ã¬ã¤ã¢ã¦ãã®éç½®ãæ±ºå®
     * @param {number} y  ãã­ã¹ãç©å½¢ä¸è¾ºã® Y åº§æ¨ (ã­ã£ã³ãã¹åº§æ¨ç³»)
     */
    value: function locate(y) {
      var items = this._items;
      var x = 0;
      x += PinEntity.SAFETY_PIXEL_MARGIN; // å·¦ãã¼ã¸ã³

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        item.locate(x, y);
        x += item.width_pixel + PinEntity.SAFETY_PIXEL_MARGIN; // ãã­ã¹ãå¹ + å³ãã¼ã¸ã³
      }
    }
  }, {
    key: "items",
    get: function get() {
      return this._items;
    }
    /**
     * ã­ã£ã³ãã¹ä¸ã§ã®è¡ã®æ¨ªå æç»ç´ æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "width_assumed",
    get: function get() {
      return this._width_assumed;
    }
    /**
     * ã­ã£ã³ãã¹ä¸ã§ã®è¡ã®ç¸¦ç»ç´ æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "height_pixel",
    get: function get() {
      return this._height_pixel;
    }
  }]);

  return RowLayout;
}();

var image_icon_vs_code = "/**\n * ãã­ã¹ã (é ç¹ã·ã§ã¼ã)\n */\n\nattribute vec4 a_position;     // é ç¹ä½ç½® (ã¢ãã«åº§æ¨ç³»)\nattribute vec2 a_offset;       // é ç¹å¤ä½ (ã¹ã¯ãªã¼ã³åº§æ¨ç³»)\nattribute vec2 a_texcoord;     // ãã¯ã¹ãã£åº§æ¨\n\nuniform mat4 u_obj_to_clip;    // ã¢ãã«åº§æ¨ç³»ããã¯ãªããåº§æ¨ç³»ã¸ã®å¤æ\nuniform vec2 u_sparam;         // ç»é¢ãã©ã¡ã¼ã¿: {2/w, 2/h}\n\nvarying vec2 v_texcoord;       // ãã¯ã¹ãã£åº§æ¨\n\nvoid\nmain()\n{\n    gl_Position = u_obj_to_clip * a_position;\n    gl_Position.xy += a_offset * u_sparam * gl_Position.w;\n    v_texcoord = a_texcoord;\n}\n";

var image_icon_fs_code = "/**\n * ãã­ã¹ã (ãã©ã°ã¡ã³ãã·ã§ã¼ã)\n */\n\nprecision mediump float;\n\nvarying vec2 v_texcoord;        // ãã¯ã¹ãã£åº§æ¨\nuniform sampler2D u_image;      // ç»å\n\n\nvoid\nmain()\n{\n    gl_FragColor = texture2D( u_image, v_texcoord );\n}\n";

/**
 * @summary ã¤ã¡ã¼ã¸ã¢ã¤ã³ã³ãããªã¢ã«
 * @memberof mapray
 * @extends mapray.EntityMaterial
 * @private
 * @see mapray.ImageIconEntity
 */

var ImageIconMaterial =
/*#__PURE__*/
function (_EntityMaterial) {
  _inherits(ImageIconMaterial, _EntityMaterial);

  /**
   * @param {mapray.GLEnv} glenv
   */
  function ImageIconMaterial(glenv) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ImageIconMaterial);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ImageIconMaterial).call(this, glenv, image_icon_vs_code, options.ridMaterial ? rid_fs_code : image_icon_fs_code)); // ä¸å¤ãã©ã¡ã¼ã¿ãäºåè¨­å®

    _this.bindProgram();

    _this.setInteger("u_image", ImageIconMaterial.TEXUNIT_IMAGE); // this.setInteger( "u_image_mask", ImageIconMaterial.TEXUNIT_IMAGE_MASK );


    return _this;
  }
  /**
   * @override
   */


  _createClass(ImageIconMaterial, [{
    key: "isTranslucent",
    value: function isTranslucent(stage, primitive) {
      // åéæç»åã¯éå¯¾å¿
      return false;
    }
    /**
     * @override
     */

  }, {
    key: "setParameters",
    value: function setParameters(stage, primitive) {
      _get(_getPrototypeOf(ImageIconMaterial.prototype), "setParameters", this).call(this, stage, primitive);

      var props = primitive.properties; // mat4 u_obj_to_clip

      this.setObjToClip(stage, primitive); // ç»é¢ãã©ã¡ã¼ã¿: {2/w, 2/h}
      // vec2 u_sparam

      var sparam = ImageIconMaterial._sparam;
      sparam[0] = 2 / stage._width;
      sparam[1] = 2 / stage._height;
      this.setVector2("u_sparam", sparam);

      if (stage.getRenderTarget() === RenderTarget.SCENE) {
        // ãã¯ã¹ãã£ã®ãã¤ã³ã
        // sampler2D u_image
        var image = props["image"];
        this.bindTexture2D(ImageIconMaterial.TEXUNIT_IMAGE, image.handle); // ãã¯ã¹ãã£ãã¹ã¯ã®ãã¤ã³ã
        // sampler2D u_image_mask
        // var image_mask = props["image_mask"];
        // this.bindTexture2D( ImageIconMaterial.TEXUNIT_IMAGE_MASK, image_mask.handle );
      }
    }
  }]);

  return ImageIconMaterial;
}(EntityMaterial); // ã¯ã©ã¹å®æ°ã®å®ç¾©


{
  ImageIconMaterial.TEXUNIT_IMAGE = 0; // ç»åã®ãã¯ã¹ãã£ã¦ããã
  // ImageIconMaterial.TEXUNIT_IMAGE_MASK = 1;  // ç»åãã¹ã¯ã®ãã¯ã¹ãã£ã¦ããã
  // è¨ç®ç¨ä¸æé å

  ImageIconMaterial._sparam = GeoMath.createVector2f();
  ImageIconMaterial._bg_color = GeoMath.createVector3f();
  ImageIconMaterial._fg_color = GeoMath.createVector3f();
}

/**
 * @summary ç»åã¢ã¤ã³ã³ã¨ã³ãã£ãã£
 * @memberof mapray
 * @extends mapray.Entity
 */

var ImageIconEntity =
/*#__PURE__*/
function (_AbstractPointEntity) {
  _inherits(ImageIconEntity, _AbstractPointEntity);

  /**
   * @param {mapray.Scene} scene        æå±å¯è½ã·ã¼ã³
   * @param {object}       [opts]       ãªãã·ã§ã³éå
   * @param {object}       [opts.json]  çææå ±
   * @param {object}       [opts.refs]  åç§è¾æ¸
   * @param {mapray.Loader.TransformCallback} [opts.transform] 
   */
  function ImageIconEntity(scene, opts) {
    var _this;

    _classCallCheck(this, ImageIconEntity);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ImageIconEntity).call(this, scene, opts)); // è¦ªãã­ããã£

    _this._parent_props = {
      size: null,
      origin: null
    }; // Entity.PrimitiveProducer ã¤ã³ã¹ã¿ã³ã¹

    _this._primitive_producer = new PrimitiveProducer$6(_assertThisInitialized(_this));

    _this._animation.addDescendantUnbinder(function () {
      _this._unbindDescendantAnimations();
    });

    _this._setupAnimationBindingBlock(); // çææå ±ããè¨­å®


    if (opts && opts.json) {
      _this._setupByJson(opts.json);
    }

    return _this;
  }
  /**
   * @override
   */


  _createClass(ImageIconEntity, [{
    key: "getPrimitiveProducer",
    value: function getPrimitiveProducer() {
      return this._primitive_producer;
    }
    /**
     * EasyBindingBlock.DescendantUnbinder å¦ç
     *
     * @private
     */

  }, {
    key: "_unbindDescendantAnimations",
    value: function _unbindDescendantAnimations() {
      // ãã¹ã¦ã®ã¨ã³ããªã¼ãè§£é¤
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var entry = _step.value;
          entry.animation.unbindAllRecursively();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * ã¢ãã¡ã¼ã·ã§ã³ã® BindingBlock ãåæå
     *
     * @private
     */

  }, {
    key: "_setupAnimationBindingBlock",
    value: function _setupAnimationBindingBlock() {
      var _this2 = this;

      var block = this.animation; // å®ä½ã¯ EasyBindingBlock

      var number = Type.find("number");
      var vector2 = Type.find("vector2"); // ãã©ã¡ã¼ã¿å: size
      // ãã©ã¡ã¼ã¿å: vector2 | number
      //   åã vector2 ã®ã¨ã ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãºX, Y é ã§ããã¨è§£é
      //   åã number ã®ã¨ã ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãºX, Y ã®å¤

      var size_temp = GeoMath.createVector2();
      var size_type;

      var size_tsolver = function size_tsolver(curve) {
        size_type = AnimUtil.findFirstTypeSupported(curve, [vector2, number]);
        return size_type;
      };

      block.addEntry("size", [vector2, number], size_tsolver, function (value) {
        if (size_type === vector2) {
          _this2.setSize(value);
        } else {
          // size_type === number
          size_temp[0] = value;
          size_temp[1] = value;

          _this2.setSize(size_temp);
        }
      });
    }
    /**
     * @summary ã¢ã¤ã³ã³ã®ãµã¤ãºãæå®
     * @param {mapray.Vector2} size  ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãº
     */

  }, {
    key: "setSize",
    value: function setSize(size) {
      this._setVector2Property("size", size);
    }
    /**
     * @summary ã¢ã¤ã³ã³ã®åç¹ä½ç½®ãæå®
     * @param {mapray.Vector2} origin  ã¢ã¤ã³ã³ã®åç¹ä½ç½®
     */

  }, {
    key: "setOrigin",
    value: function setOrigin(origin) {
      this._setVector2Property("origin", origin);
    }
    /**
     * @summary Add Image Icon
     * @param {URL|HTMLImageElement|HTMLCanvasElement} image_src    ç»å
     * @param {mapray.GeoPoint} position            ä½ç½®
     * @param {object}          [props]             ãã­ããã£
     * @param {mapray.Vector2}  [props.size]        ã¢ã¤ã³ã³ãµã¤ãº
     * @param {string}          [props.id]          Entryãè­å¥ããID
     * @param {mapray.Loader.Transform} [props.transform] URLå¤æé¢æ°
     * @return {mapray.ImageIconEntity.ImageEntry}  è¿½å ããEntry
     */

  }, {
    key: "addImageIcon",
    value: function addImageIcon(image_src, position, props) {
      var entry = new ImageEntry$1(this, image_src, position, props);

      this._entries.push(entry);

      this._primitive_producer.onAddEntry();

      return entry;
    }
    /**
     * @summary å°ç¨ãããªã¢ã«ãåå¾
     * @private
     */

  }, {
    key: "_getMaterial",
    value: function _getMaterial(render_target) {
      var scene = this.scene;

      if (render_target === RenderTarget.SCENE) {
        if (!scene._ImageEntity_image_material) {
          // scene ã«ãããªã¢ã«ãã­ã£ãã·ã¥
          scene._ImageEntity_image_material = new ImageIconMaterial(scene.glenv);
        }

        return scene._ImageEntity_image_material;
      } else if (render_target === RenderTarget.RID) {
        if (!scene._ImageEntity_image_material_pick) {
          // scene ã«ãããªã¢ã«ãã­ã£ãã·ã¥
          scene._ImageEntity_image_material_pick = new ImageIconMaterial(scene.glenv, {
            ridMaterial: true
          });
        }

        return scene._ImageEntity_image_material_pick;
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setValueProperty",
    value: function _setValueProperty(name, value) {
      var props = this._parent_props;

      if (props[name] != value) {
        props[name] = value;

        this._primitive_producer.onChangeParentProperty();
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setVector2Property",
    value: function _setVector2Property(name, value) {
      var dst = this._parent_props[name];

      if (!dst) {
        this._parent_props[name] = GeoMath.createVector2f(value);

        this._primitive_producer.onChangeParentProperty();
      } else if (dst[0] !== value[0] || dst[1] !== value[1]) {
        GeoMath.copyVector2(value, dst);

        this._primitive_producer.onChangeParentProperty();
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setupByJson",
    value: function _setupByJson(json) {
      var position = new GeoPoint();
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = json.entries[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var entry = _step2.value;
          position.setFromArray(entry.position);
          this.addImageIcon(position, entry);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (json.size) this.setSize(json.size);
      if (json.origin) this.setOrigin(json.origin);
    }
    /**
     * @summary IDã§Entryãåå¾
     * @param {string}  id  ID
     * @return {mapray.ImageIconEntity.ImageEntry}  IDãä¸è´ããEntryï¼ç¡ããã°undefinedï¼
     */

  }, {
    key: "getEntry",
    value: function getEntry(id) {
      return this._entries.find(function (entry) {
        return entry.id === id;
      });
    }
  }]);

  return ImageIconEntity;
}(AbstractPointEntity); // ã¯ã©ã¹å®æ°ã®å®ç¾©


{
  ImageIconEntity.DEFAULT_COLOR = GeoMath.createVector3f([1, 1, 1]);
  ImageIconEntity.SAFETY_PIXEL_MARGIN = 1;
  ImageIconEntity.MAX_IMAGE_WIDTH = 4096;
  ImageIconEntity.CIRCLE_SEP_LENGTH = 32;
  ImageIconEntity.DEFAULT_ICON_SIZE = GeoMath.createVector2f([30, 30]);
  ImageIconEntity.DEFAULT_ORIGIN = GeoMath.createVector2f([0.5, 0.5]);
  ImageIconEntity.SAFETY_PIXEL_MARGIN = 1;
  ImageIconEntity.MAX_IMAGE_WIDTH = 4096;
}
/**
 * @summary PrimitiveProducer
 *
 * TODO: relative ã§æ¨é«ã®å¤åã®ãã³ã«ãã¯ã¹ãã£ãçæããå¿è¦ã¯ãªãã®ã§
 *       Layout ã§ã®ãã¯ã¹ãã£ã®çæã¨ã¡ãã·ã¥ã®çæãåé¢ãã
 *
 * @private
 */

var PrimitiveProducer$6 =
/*#__PURE__*/
function (_Entity$PrimitiveProd) {
  _inherits(PrimitiveProducer, _Entity$PrimitiveProd);

  /**
   * @param {mapray.ImageIconEntity} entity
   */
  function PrimitiveProducer(entity) {
    var _this3;

    _classCallCheck(this, PrimitiveProducer);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(PrimitiveProducer).call(this, entity));
    _this3._glenv = entity.scene.glenv;
    _this3._dirty = true; // ããªããã£ãã®è¦ç´ 

    _this3._transform = GeoMath.setIdentity(GeoMath.createMatrix());
    _this3._properties = {
      image: null // ã¢ã¤ã³ã³ç»å

    }; // ããªããã£ã

    var primitive = new Primitive(_this3._glenv, null, entity._getMaterial(RenderTarget.SCENE), _this3._transform);
    primitive.properties = _this3._properties;
    _this3._primitive = primitive;
    var pickPrimitive = new Primitive(_this3._glenv, null, entity._getMaterial(RenderTarget.RID), _this3._transform);
    pickPrimitive.properties = _this3._properties;
    _this3._pickPrimitive = pickPrimitive; // ããªããã£ãéå

    _this3._primitives = [];
    _this3._pickPrimitives = [];
    return _this3;
  }
  /**
   * @override
   */


  _createClass(PrimitiveProducer, [{
    key: "createRegions",
    value: function createRegions() {
      var region = new EntityRegion();
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.entity._entries[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var position = _step3.value.position;
          region.addPoint(position);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return [region];
    }
    /**
     * @override
     */

  }, {
    key: "onChangeElevation",
    value: function onChangeElevation(regions) {
      this._dirty = true;
    }
    /**
     * @override
     */

  }, {
    key: "getPrimitives",
    value: function getPrimitives(stage) {
      this._updatePrimitive();

      return stage.getRenderTarget() === RenderTarget.SCENE ? this._primitives : this._pickPrimitives;
    }
    /**
     * @summary è¦ªãã­ããã£ãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeParentProperty",
    value: function onChangeParentProperty() {
      this._dirty = true;
    }
    /**
     * @summary å­ãã­ããã£ãå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeChildProperty",
    value: function onChangeChildProperty() {
      this._dirty = true;
    }
    /**
     * @summary é«åº¦ã¢ã¼ããå¤æ´ããããã¨ãéç¥
     */

  }, {
    key: "onChangeAltitudeMode",
    value: function onChangeAltitudeMode() {
      this._dirty = true;
    }
    /**
     * @summary ã¨ã³ããªãè¿½å ããããã¨ãéç¥
     */

  }, {
    key: "onAddEntry",
    value: function onAddEntry() {
      // å¤åããå¯è½æ§ããã
      this.needToCreateRegions();
      this._dirty = true;
    }
    /**
     * @summary ããªããã£ãã®æ´æ°
     *
     * @desc
     * å¥å:
     *   this.entity._entries
     *   this._dirty
     * åºå:
     *   this._transform
     *   this._properties.image
     *   this._primitive.mesh
     *   this._primitives
     *   this._dirty
     *
     * @return {array.<mapray.Prmitive>}  this._primitives
     *
     * @private
     */

  }, {
    key: "_updatePrimitive",
    value: function _updatePrimitive() {
      if (!this._dirty) {
        // æ´æ°ããå¿è¦ã¯ãªã
        return;
      }

      if (this.entity._entries.length == 0) {
        this._primitives = [];
        this._pickPrimitives = [];
        this._dirty = false;
        return;
      } // åã¨ã³ããªã¼ã® GOCS ä½ç½®ãçæ (å¹³å¦åéå)


      var gocs_array = this._createFlatGocsArray(); // ããªããã£ãã®æ´æ°
      //   primitive.transform


      this._updateTransform(gocs_array);

      var layout = new Layout$2(this, gocs_array);

      if (!layout.isValid()) {
        // æ´æ°ã«å¤±æ
        this._primitives = [];
        this._pickPrimitives = [];
        this._dirty = false;
        return;
      } // ãã¯ã¹ãã£è¨­å®


      var properties = this._properties;

      if (properties.image) {
        properties.image.dispose();
      }

      properties.image = layout.texture; // ã¡ãã·ã¥çæ

      var mesh_data = {
        vtype: [{
          name: "a_position",
          size: 3
        }, {
          name: "a_offset",
          size: 2
        }, {
          name: "a_texcoord",
          size: 2
        }],
        vertices: layout.vertices,
        indices: layout.indices
      };
      var mesh = new Mesh(this._glenv, mesh_data); // ã¡ãã·ã¥è¨­å®
      //   primitive.mesh

      var primitive = this._primitive;

      if (primitive.mesh) {
        primitive.mesh.dispose();
      }

      primitive.mesh = mesh;
      var pickPrimitive = this._pickPrimitive;

      if (pickPrimitive.mesh) {
        pickPrimitive.mesh.dispose();
      }

      pickPrimitive.mesh = mesh; // æ´æ°ã«æå

      this._primitives = [primitive];
      this._pickPrimitives = [pickPrimitive];
      this._dirty = false;
    }
    /**
     * @summary ããªããã£ãã®æ´æ°
     *
     * @desc
     * æ¡ä»¶:
     *   this.entity._entries.length > 0
     * å¥å:
     *   this.entity._entries.length
     * åºå:
     *   this._transform
     *
     * @param {number[]} gocs_array  GOCS å¹³å¦åéå
     *
     * @private
     */

  }, {
    key: "_updateTransform",
    value: function _updateTransform(gocs_array) {
      var num_entries = this.entity._entries.length;
      var xsum = 0;
      var ysum = 0;
      var zsum = 0;

      for (var i = 0; i < num_entries; ++i) {
        var ibase = 3 * i;
        xsum += gocs_array[ibase];
        ysum += gocs_array[ibase + 1];
        zsum += gocs_array[ibase + 2];
      } // å¤æè¡åã®æ´æ°


      var transform = this._transform;
      transform[12] = xsum / num_entries;
      transform[13] = ysum / num_entries;
      transform[14] = zsum / num_entries;
    }
    /**
     * @summary GOCS å¹³å¦åéåãåå¾
     *
     * å¥å: this.entity._entries
     *
     * @return {number[]}  GOCS å¹³å¦åéå
     * @private
     */

  }, {
    key: "_createFlatGocsArray",
    value: function _createFlatGocsArray() {
      var num_points = this.entity._entries.length;
      return GeoPoint.toGocsArray(this._getFlatGeoPoints_with_Absolute(), num_points, new Float64Array(3 * num_points));
    }
    /**
     * @summary GeoPoint å¹³å¦åéåãåå¾ (çµ¶å¯¾é«åº¦)
     *
     * å¥å: this.entity._entries
     *
     * @return {number[]}  GeoPoint å¹³å¦åéå
     * @private
     */

  }, {
    key: "_getFlatGeoPoints_with_Absolute",
    value: function _getFlatGeoPoints_with_Absolute() {
      var owner = this.entity;
      var entries = owner._entries;
      var num_points = entries.length;
      var flat_array = new Float64Array(3 * num_points); // flat_array[] ã«çµåº¦è¦ç´ ã¨ç·¯åº¦è¦ç´ ãè¨­å®

      for (var i = 0; i < num_points; ++i) {
        var pos = entries[i].position;
        flat_array[3 * i] = pos.longitude;
        flat_array[3 * i + 1] = pos.latitude;
      }

      switch (owner.altitude_mode) {
        case AltitudeMode.RELATIVE:
        case AltitudeMode.CLAMP:
          // flat_array[] ã®é«åº¦è¦ç´ ã«ç¾å¨ã®æ¨é«ãè¨­å®
          owner.scene.viewer.getExistingElevations(num_points, flat_array, 0, 3, flat_array, 2, 3);

          if (owner.altitude_mode === AltitudeMode.RELATIVE) {
            // flat_array[] ã®é«åº¦è¦ç´ ã«çµ¶å¯¾é«åº¦ãè¨­å®
            for (var _i = 0; _i < num_points; ++_i) {
              flat_array[3 * _i + 2] += entries[_i].position.altitude;
            }
          }

          break;

        default:
          // AltitudeMode.ABSOLUTE
          // flat_array[] ã®é«åº¦è¦ç´ ã«çµ¶å¯¾é«åº¦ãè¨­å®
          for (var _i2 = 0; _i2 < num_points; ++_i2) {
            flat_array[3 * _i2 + 2] = entries[_i2].position.altitude;
          }

          break;
      }

      return flat_array;
    }
  }]);

  return PrimitiveProducer;
}(Entity.PrimitiveProducer);
/**
 * @summary è¦ç´ 
 * @hideconstructor
 * @memberof mapray.ImageIconEntity
 * @public
 */


var ImageEntry$1 =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.ImageIconEntity} owner        ææè
   * @param {string}                 image_src    ã¢ã¤ã³ã³ç»å
   * @param {mapray.GeoPoint}        position     ä½ç½®
   * @param {object}                 [props]      ãã­ããã£
   * @param {mapray.Vector2}         [props.size] ã¢ã¤ã³ã³ãµã¤ãº
   * @param {string}                 [props.id]   Entryãè­å¥ããID
   * @param {mapray.Loader.Transform} [props.transform] URLå¤æé¢æ°
   */
  function ImageEntry(owner, image_src, position, props) {
    _classCallCheck(this, ImageEntry);

    this._owner = owner;
    this._position = position.clone(); // animation.BindingBlock

    this._animation = new EasyBindingBlock();

    this._setupAnimationBindingBlock();

    this._props = Object.assign({}, props); // props ã®è¤è£½

    this._copyPropertyVector2f("size"); // deep copy


    this._copyPropertyVector2f("origin"); // deep copy


    this.setImage(image_src);
  }
  /**
   * @summary ä½ç½®
   * @type {mapray.GeoPoint}
   * @readonly
   * @package
   */


  _createClass(ImageEntry, [{
    key: "_setupAnimationBindingBlock",

    /**
     * ã¢ãã¡ã¼ã·ã§ã³ã® BindingBlock ãåæå
     *
     * @private
     */
    value: function _setupAnimationBindingBlock() {
      var _this4 = this;

      var block = this.animation; // å®ä½ã¯ EasyBindingBlock

      var number = Type.find("number");
      var string = Type.find("string");
      var vector2 = Type.find("vector2");
      var vector3 = Type.find("vector3"); // ãã©ã¡ã¼ã¿å: image_src
      // ãã©ã¡ã¼ã¿å: string
      //   ç»åã®ãã¹

      block.addEntry("image_src", [string], null, function (value) {
        _this4.setImage(value);
      }); // ãã©ã¡ã¼ã¿å: position
      // ãã©ã¡ã¼ã¿å: vector3
      //   ãã¯ãã«ã®è¦ç´ ã longitude, latitude, altitude é ã§ããã¨è§£é

      var position_temp = new GeoPoint();
      block.addEntry("position", [vector3], null, function (value) {
        position_temp.setFromArray(value); // Vector3 -> GeoPoint

        _this4.setPosition(position_temp);
      }); // ãã©ã¡ã¼ã¿å: size
      // ãã©ã¡ã¼ã¿å: vector2 | number
      //   åã vector2 ã®ã¨ã ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãºX, Y é ã§ããã¨è§£é
      //   åã number ã®ã¨ã ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãºX, Y ã¯åå¤

      var size_temp = GeoMath.createVector2();
      var size_type;

      var size_tsolver = function size_tsolver(curve) {
        size_type = AnimUtil.findFirstTypeSupported(curve, [vector2, number]);
        return size_type;
      };

      block.addEntry("size", [vector2, number], size_tsolver, function (value) {
        if (size_type === vector2) {
          _this4.setSize(value);
        } else {
          // size_type === number
          size_temp[0] = value;
          size_temp[1] = value;

          _this4.setSize(size_temp);
        }
      });
    }
    /**
     * @summary ç»åã®ãã¹ãè¨­å®
     * @param {string} image_src  ç»åã®ãã¹
     */

  }, {
    key: "setImage",
    value: function setImage(image_src) {
      var _this5 = this;

      if (this._image_src !== image_src) {
        // ç»åã®ãã¹ãå¤æ´ããã
        this._image_src = image_src;
        var resource = image_src instanceof Resource ? image_src : new URLResource(image_src, {
          transform: this._props.transform
        });
        this._icon = ImageEntry.iconLoader.load(resource);

        this._icon.onEnd(function (item) {
          _this5._owner.getPrimitiveProducer()._dirty = true;
        });
      }
    }
    /**
     * @summary ãã­ã¹ãåç¹ä½ç½®ãè¨­å®
     *
     * @param {mapray.GeoPoint} position  ãã­ã¹ãåç¹ã®ä½ç½®
     */

  }, {
    key: "setPosition",
    value: function setPosition(position) {
      if (this._position.longitude !== position.longitude || this._position.latitude !== position.latitude || this._position.altitude !== position.altitude) {
        // ä½ç½®ãå¤æ´ããã
        this._position.assign(position);

        this._owner.getPrimitiveProducer().onChangeChildProperty();
      }
    }
    /**
     * @summary ã¢ã¤ã³ã³ã®ãµã¤ãºãæå®
     * @param {mapray.Vector2} size  ã¢ã¤ã³ã³ã®ãã¯ã»ã«ãµã¤ãº
     */

  }, {
    key: "setSize",
    value: function setSize(size) {
      this._setVector2Property("size", size);
    }
    /**
     * @private
     */

  }, {
    key: "_copyPropertyVector3f",
    value: function _copyPropertyVector3f(name) {
      var props = this._props;

      if (props.hasOwnProperty(name)) {
        props[name] = GeoMath.createVector3f(props[name]);
      }
    }
    /**
     * @private
     */

  }, {
    key: "_copyPropertyVector2f",
    value: function _copyPropertyVector2f(name) {
      var props = this._props;

      if (props.hasOwnProperty(name)) {
        if (typeof props[name] === 'number') {
          props[name] = GeoMath.createVector2f([props[name], props[name]]);
        } else {
          props[name] = GeoMath.createVector2f(props[name]);
        }
      }
    }
    /**
     * @private
     */

  }, {
    key: "_setVector2Property",
    value: function _setVector2Property(name, value) {
      var dst = this._props[name];

      if (!dst) {
        this._props[name] = GeoMath.createVector2f(value);

        this._owner.getPrimitiveProducer().onChangeChildProperty();
      } else if (dst[0] !== value[0] || dst[1] !== value[1]) {
        GeoMath.copyVector2(value, dst);

        this._owner.getPrimitiveProducer().onChangeChildProperty();
      }
    }
  }, {
    key: "isLoaded",
    value: function isLoaded() {
      return this._icon.isLoaded();
    }
  }, {
    key: "draw",
    value: function draw(context, x, y, width, height) {
      this._icon.draw(context, x, y, width, height);
    }
  }, {
    key: "position",
    get: function get() {
      return this._position;
    }
    /**
     * @summary ID
     * @type {string}
     * @readonly
     */

  }, {
    key: "id",
    get: function get() {
      return this._props.hasOwnProperty("id") ? this._props.id : "";
    }
    /**
     * @summary ã¢ã¤ã³ã³ãµã¤ãº (Pixels)
     * @type {mapray.Vector2}
     * @readonly
     * @package
     */

  }, {
    key: "size",
    get: function get() {
      var props = this._props;
      var parent = this._owner._parent_props;
      return props.size || parent.size || GeoMath.createVector2f([this._icon.width, this._icon.height]);
    }
    /**
     * @summary ã¢ã¤ã³ã³ãªãªã¸ã³ä½ç½® (å·¦ä¸ã(0, 0)ãå³ä¸ã(1, 1)ã¨ãããæ°å­ãæå®ããã)
     * @type {mapray.Vector2}
     * @readonly
     * @package
     */

  }, {
    key: "origin",
    get: function get() {
      var props = this._props;
      var parent = this._owner._parent_props;
      return props.origin || parent.origin || ImageIconEntity.DEFAULT_ORIGIN;
    }
    /**
     * @summary ã¢ãã¡ã¼ã·ã§ã³ãã©ã¡ã¼ã¿è¨­å®
     *
     * @type {mapray.animation.BindingBlock}
     * @readonly
     */

  }, {
    key: "animation",
    get: function get() {
      return this._animation;
    }
  }, {
    key: "icon",
    get: function get() {
      return this._icon;
    }
  }]);

  return ImageEntry;
}();

ImageIconEntity.ImageEntry = ImageEntry$1;
{
  ImageEntry$1.iconLoader = new ImageIconLoader();
}
/**
 * @summary Pinç»åã Canvas ä¸ã«ã¬ã¤ã¢ã¦ã
 * @memberof mapray.ImageIconEntity
 * @private
 */

var Layout$2 =
/*#__PURE__*/
function () {
  /**
   * @desc
   * å¥å:
   *   owner._glenv
   *   owner.entity._entries
   *   owner._transform
   *
   * @param {PrimitiveProducer} owner       ææè
   * @param {number[]}          gocs_array  GOCS å¹³å¦åéå
   */
  function Layout(owner, gocs_array) {
    _classCallCheck(this, Layout);

    this._owner = owner;
    this._items = this._createItemList();
    this._is_valid = true;

    var row_layouts = this._createRowLayouts();

    if (row_layouts.length == 0) {
      // æå¹ãªãã­ã¹ãã1ã¤ãç¡ã
      this._is_valid = false;
      return;
    } // ã¢ã¤ãã ã®éç½®ã®è¨­å®ã¨ã­ã£ã³ãã¹ãµã¤ãºã®æ±ºå®


    var size = this._setupLocation(row_layouts);

    this._texture = this._createTexture(size.width, size.height);
    this._vertices = this._createVertices(size.width, size.height, gocs_array);
    this._indices = this._createIndices();
  }
  /**
   * @summary æå¹ãªãªãã¸ã§ã¯ããï¼
   * @desc
   * <p>ç¡å¹ã®ã¨ããä»ã®ã¡ã½ããã¯å¼ã³åºããªãã</p>
   * @return {boolean}  æå¹ã®ã¨ã true, ç¡å¹ã®ã¨ã false
   */


  _createClass(Layout, [{
    key: "isValid",
    value: function isValid() {
      return this._is_valid;
    }
    /**
     * @summary ãã¯ã¹ãã£
     * @type {mapray.Texture}
     * @readonly
     */

  }, {
    key: "_createItemList",

    /**
     * @summary ã¬ã¤ã¢ã¦ãã¢ã¤ãã ã®ãªã¹ããçæ
     * @return {array.<mapray.ImageIconEntity.LItem>}
     * @private
     */
    value: function _createItemList() {
      var map = new Map();
      var items = [];
      var counter = 0;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this._owner.entity._entries[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var entry = _step4.value;

          if (entry.isLoaded()) {
            var item = map.get(entry.icon);

            if (!item) {
              map.set(entry.icon, item = new LItem$2(this));
              items.push(item);
            }

            item.add(counter++, entry);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return items;
    }
    /**
     * @summary RowLayout ã®ãªã¹ããçæ
     * @return {array.<mapray.ImageIconEntity.RowLayout>}
     * @private
     */

  }, {
    key: "_createRowLayouts",
    value: function _createRowLayouts() {
      // ã¢ã¤ãã ãªã¹ãã®è¤è£½
      var items = [].concat(this._items); // RowLayout åã§ãã¾ãé«ãã«å·®ãåºãªãããã«ãã¢ã¤ãã ãªã¹ããé«ãã§æ´å

      items.sort(function (a, b) {
        return a.height_pixel - b.height_pixel;
      }); // ãªã¹ããçæ

      var row_layouts = [];

      while (items.length > 0) {
        var row_layout = new RowLayout$2(items);

        if (row_layout.isValid()) {
          row_layouts.push(row_layout);
        }
      }

      return row_layouts;
    }
    /**
     * @summary ãã¯ã¹ãã£ãçæ
     * @param  {number} width    æ¨ªå¹
     * @param  {number} height   é«ã
     * @return {mapray.Texture}  ãã­ã¹ããã¯ã¹ãã£
     * @private
     */

  }, {
    key: "_createTexture",
    value: function _createTexture(width, height) {
      var context = Dom.createCanvasContext(width, height);
      var items = this._items;

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        if (item.is_canceled) continue;
        item.draw(context);
      }

      var glenv = this._owner._glenv;
      var opts = {
        usage: Texture.Usage.ICON
      };
      return new Texture(glenv, context.canvas, opts);
    }
    /**
     * @summary é ç¹éåãçæ
     *
     * @param  {number}   width       æ¨ªå¹
     * @param  {number}   height      é«ã
     * @param  {number[]} gocs_array  GOCS å¹³å¦åéå
     * @return {array.<number>}  é ç¹éå [å·¦ä¸0, å³ä¸0, å·¦ä¸0, å³ä¸0, ...]
     *
     * @private
     */

  }, {
    key: "_createVertices",
    value: function _createVertices(width, height, gocs_array) {
      var vertices = []; // ãã­ã¹ãéåã®åç¹ (GOCS)

      var transform = this._owner._transform;
      var xo = transform[12];
      var yo = transform[13];
      var zo = transform[14];
      /*
       |<----size[0]px---->|
       0-------------------3 ------------------
      |                   |  ^              ^ 
      |                   |  | origin[1]    | 
      |                   |  |              | 
      |                   |  v              | size[1]px
      |           o       | ---             | 
      |                   |  ^              | 
      |                   |  | 1-origin[1]  | 
      |                   |  v              v 
      1-------------------2 ------------------
      
      |           |<----->|    1 - origin[0]
      |<--------->|            origin[0]
      */

      var xn = 1 / width;
      var yn = 1 / height;
      var items = this._items;

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        if (item.is_canceled) continue;

        for (var ie = 0; ie < item.entries.length; ie++) {
          var eitem = item.entries[ie];
          var entry = eitem.entry;
          var size = entry.size;
          var origin = entry.origin; // Relativize based on (xo, yo, zo)

          var ibase = eitem.index * 3;
          var xm = gocs_array[ibase] - xo;
          var ym = gocs_array[ibase + 1] - yo;
          var zm = gocs_array[ibase + 2] - zo; // Image dimensions (Image Coordinate)

          var xc = item.pos_x;
          var yc = item.pos_y;
          var xsize = item.width;
          var ysize = item.height; // p0

          vertices.push(xm, ym, zm); // a_position

          vertices.push(-origin[0] * size[0], origin[1] * size[1]); // a_offset

          vertices.push(xc * xn, 1.0 - yc * yn); // a_texcoord
          // p1

          vertices.push(xm, ym, zm); // a_position

          vertices.push(-origin[0] * size[0], -(1 - origin[1]) * size[1]); // a_offset

          vertices.push(xc * xn, 1 - (yc + ysize) * yn); // a_texcoord
          // p2

          vertices.push(xm, ym, zm); // a_position

          vertices.push((1 - origin[0]) * size[0], -(1 - origin[1]) * size[1]); // a_offset

          vertices.push((xc + xsize) * xn, 1 - (yc + ysize) * yn); // a_texcoord
          // p3

          vertices.push(xm, ym, zm); // a_position

          vertices.push((1 - origin[0]) * size[0], origin[1] * size[1]); // a_offset

          vertices.push((xc + xsize) * xn, 1 - yc * yn); // a_texcoord
        }
      }

      return vertices;
    }
    /**
     * @summary ã¤ã³ããã¯ã¹éåãçæ
     * @return {array.<number>}  ã¤ã³ããã¯ã¹éå []
     * @private
     */

  }, {
    key: "_createIndices",
    value: function _createIndices() {
      var indices = [];
      var items = this._items;

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        if (item.is_canceled) continue;

        for (var ie = 0; ie < item.entries.length; ie++) {
          var eitem = item.entries[ie];
          var base = 4 * eitem.index;
          var p = base;
          indices.push(p, p + 1, p + 2);
          indices.push(p, p + 2, p + 3);
        }
      }

      return indices;
    }
    /**
     * @summary ã¢ã¤ãã ã®éç½®ãè¨­å®
     * @param  {array.<mapray.ImageIconEntity.RowLayout>} row_layouts
     * @return {object}                              ã­ã£ã³ãã¹ãµã¤ãº
     * @private
     */

  }, {
    key: "_setupLocation",
    value: function _setupLocation(row_layouts) {
      var width = 0;
      var height = 0;
      height += ImageIconEntity.SAFETY_PIXEL_MARGIN;

      for (var i = 0; i < row_layouts.length; ++i) {
        var row_layout = row_layouts[i];
        row_layout.locate(height);
        width = Math.max(row_layout.width_assumed, width);
        height += row_layout.height_pixel + ImageIconEntity.SAFETY_PIXEL_MARGIN;
      }

      return {
        width: width,
        height: height
      };
    }
  }, {
    key: "texture",
    get: function get() {
      return this._texture;
    }
    /**
     * @summary é ç¹éå
     * @desc
     * æ¡ä»¶:
     *   this._entries.length > 0
     * å¥å:
     *   this._entries
     *   this._transform
     * @type {Float32Array}
     * @readonly
     */

  }, {
    key: "vertices",
    get: function get() {
      return this._vertices;
    }
    /**
     * @summary ã¤ã³ããã¯ã¹éå
     * @type {Uint32Array}
     * @readonly
     */

  }, {
    key: "indices",
    get: function get() {
      return this._indices;
    }
  }]);

  return Layout;
}();
/**
 * @summary ã¬ã¤ã¢ã¦ãå¯¾è±¡
 * @memberof mapray.ImageIconEntity
 * @private
 */


var LItem$2 =
/*#__PURE__*/
function () {
  /**
   * @param {mapray.ImageIconEntity.Layout} layout   ææè
   * @param {mapray.ImageIconEntity.Entry}  entry    ImageIconEntityã®ã¨ã³ããª
   */
  function LItem(layout) {
    _classCallCheck(this, LItem);

    this.entries = []; // ãã­ã¹ãã®åºç¹

    this._pos_x = 0; // å·¦ç«¯

    this._pos_y = 0; // ãã¼ã¹ã©ã¤ã³ä½ç½®

    this._height = this._width = null;
    this._is_canceled = false;
  }

  _createClass(LItem, [{
    key: "add",
    value: function add(index, entry) {
      var size = entry.size;
      if (this._width === null || this._width < size[0]) this._width = size[0];
      if (this._height === null || this._height < size[1]) this._height = size[1];
      this.entries.push({
        index: index,
        entry: entry
      });
    }
    /**
     * @type {number}
     * @readonly
     */

  }, {
    key: "cancel",

    /**
     * @summary åãæ¶ãç¶æã«ç§»è¡
     */
    value: function cancel() {
      this._is_canceled = true;
    }
    /**
     * @summary éç½®ãæ±ºå®
     * @param {number} x  ãã­ã¹ãç©å½¢å·¦è¾ºã® X åº§æ¨ (ã­ã£ã³ãã¹åº§æ¨ç³»)
     * @param {number} y  ãã­ã¹ãç©å½¢ä¸è¾ºã® Y åº§æ¨ (ã­ã£ã³ãã¹åº§æ¨ç³»)
     */

  }, {
    key: "locate",
    value: function locate(x, y) {
      this._pos_x = x;
      this._pos_y = y;
    }
  }, {
    key: "draw",
    value: function draw(context) {
      this.entries[0].entry.draw(context, this._pos_x, this.pos_y, this.width, this.height); // @Todo: fix this
    }
  }, {
    key: "pos_x",
    get: function get() {
      return this._pos_x;
    }
    /**
     * @type {number}
     * @readonly
     */

  }, {
    key: "pos_y",
    get: function get() {
      return this._pos_y;
    }
    /**
     * @type {number}
     * @readonly
     */

  }, {
    key: "width",
    get: function get() {
      return this._width;
    }
  }, {
    key: "height",
    get: function get() {
      return this._height;
    }
    /**
     * ã­ã£ã³ãã¹ä¸ã§ã®ãã­ã¹ãã®æ¨ªç»ç´ æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "width_pixel",
    get: function get() {
      return Math.ceil(this._width);
    }
    /**
     * ã­ã£ã³ãã¹ä¸ã§ã®ãã­ã¹ãã®ç¸¦ç»ç´ æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "height_pixel",
    get: function get() {
      return Math.ceil(this._height);
    }
    /**
     * åãæ¶ãç¶æãï¼
     * @type {boolean}
     * @readonly
     */

  }, {
    key: "is_canceled",
    get: function get() {
      return this._is_canceled;
    }
  }]);

  return LItem;
}();
/**
 * @summary æ°´å¹³ã¬ã¤ã¢ã¦ã
 * @memberof mapray.ImageIconEntity
 * @private
 */


var RowLayout$2 =
/*#__PURE__*/
function () {
  /**
   * @desc
   * <p>ã¬ã¤ã¢ã¦ãããããã¾ãã¯ã¬ã¤ã¢ã¦ãã«å¤±æããã¢ã¤ãã ã¯ src_items ããåé¤ãããã</p>
   * <p>ã¬ã¤ã¢ã¦ãã«å¤±æããã¢ã¤ãã ã¯åãæ¶ã (is_canceled) ã«ãªãã</p>
   * @param {array.<mapray.ImageIconEntity.LItem>} src_items  ã¢ã¤ãã ãªã¹ã
   */
  function RowLayout(src_items) {
    _classCallCheck(this, RowLayout);

    var width_assumed_total = 0;
    var height_pixel_max = 0;
    var row_items = [];
    width_assumed_total += ImageIconEntity.SAFETY_PIXEL_MARGIN; // å·¦ãã¼ã¸ã³

    while (src_items.length > 0) {
      var item = src_items.shift();
      var width_assumed = item.width_pixel + ImageIconEntity.SAFETY_PIXEL_MARGIN; // ãã­ã¹ãå¹ + å³ãã¼ã¸ã³

      if (width_assumed_total + width_assumed <= ImageIconEntity.MAX_IMAGE_WIDTH) {
        // è¡ã«ã¢ã¤ãã ãè¿½å 
        row_items.push(item);
        width_assumed_total += width_assumed;
        height_pixel_max = Math.max(item.height_pixel, height_pixel_max);
      } else {
        if (row_items.length == 0) {
          // ãã­ã¹ããé·ããã¦è¡¨ç¤ºã§ããªã
          item.cancel();
        } else {
          // æ¬¡ã®è¡ã«ãªãããå·®ãæ»ãã¦çµäº
          src_items.unshift(item);
          break;
        }
      }
    }

    this._items = row_items;
    this._width_assumed = width_assumed_total;
    this._height_pixel = height_pixel_max;
  }
  /**
   * @summary æå¹ãªãªãã¸ã§ã¯ããï¼
   * @desc
   * <p>ç¡å¹ã®ã¨ããä»ã®ã¡ã½ããã¯å¼ã³åºããªãã</p>
   * @return {boolean}  æå¹ã®ã¨ã true, ç¡å¹ã®ã¨ã false
   */


  _createClass(RowLayout, [{
    key: "isValid",
    value: function isValid() {
      return this._items.length > 0;
    }
    /**
     * 
     * @type {array.<mapray.ImageIconEntity.LItem>}
     * @readonly
     */

  }, {
    key: "locate",

    /**
     * @summary ã¬ã¤ã¢ã¦ãã®éç½®ãæ±ºå®
     * @param {number} y  ãã­ã¹ãç©å½¢ä¸è¾ºã® Y åº§æ¨ (ã­ã£ã³ãã¹åº§æ¨ç³»)
     */
    value: function locate(y) {
      var items = this._items;
      var x = 0;
      x += ImageIconEntity.SAFETY_PIXEL_MARGIN; // å·¦ãã¼ã¸ã³

      for (var i = 0; i < items.length; ++i) {
        var item = items[i];
        item.locate(x, y);
        x += item.width_pixel + ImageIconEntity.SAFETY_PIXEL_MARGIN; // ãã­ã¹ãå¹ + å³ãã¼ã¸ã³
      }
    }
  }, {
    key: "items",
    get: function get() {
      return this._items;
    }
    /**
     * ã­ã£ã³ãã¹ä¸ã§ã®è¡ã®æ¨ªå æç»ç´ æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "width_assumed",
    get: function get() {
      return this._width_assumed;
    }
    /**
     * ã­ã£ã³ãã¹ä¸ã§ã®è¡ã®ç¸¦ç»ç´ æ°
     * @type {number}
     * @readonly
     */

  }, {
    key: "height_pixel",
    get: function get() {
      return this._height_pixel;
    }
  }]);

  return RowLayout;
}();

var propertyIsEnumerable = objectPropertyIsEnumerable.f; // `Object.{ entries, values }` methods implementation

var createMethod$5 = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      key = keys[i++];

      if (!descriptors || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

var objectToArray = {
  // `Object.entries` method
  // https://tc39.github.io/ecma262/#sec-object.entries
  entries: createMethod$5(true),
  // `Object.values` method
  // https://tc39.github.io/ecma262/#sec-object.values
  values: createMethod$5(false)
};

var $values = objectToArray.values; // `Object.values` method
// https://tc39.github.io/ecma262/#sec-object.values

_export({
  target: 'Object',
  stat: true
}, {
  values: function values(O) {
    return $values(O);
  }
});

/**
 * GeoJSONå½¢å¼ï¼<a href="https://tools.ietf.org/html/rfc7946">rfc7946</a>ï¼ã®ãã¼ã¿ãã·ã¼ã³ã«èª­ã¿è¾¼ã¿ã¾ãã
 * @memberof mapray
 */

var GeoJSONLoader =
/*#__PURE__*/
function (_Loader) {
  _inherits(GeoJSONLoader, _Loader);

  /**
   * @desc
   * <p>url ã§æå®ããã·ã¼ã³ãã¼ã¿ã®èª­ã¿è¾¼ã¿ãéå§ããscene ã«ã¨ã³ãã£ãã£ãæ§ç¯ããã</p>
   * <p>èª­ã¿è¾¼ã¿ãçµäºããã¨ã options.callback ãå¼ã³åºãã</p>
   * @param {mapray.Scene} scene      èª­ã¿è¾¼ã¿åã®ã·ã¼ã³
   * @param {string}       resource        ã·ã¼ã³ãã¡ã¤ã«ã® URL
   * @param {object}       [options]  ãªãã·ã§ã³éå
   * @param {mapray.Loader.TransformCallback} [options.transform]  ãªã½ã¼ã¹è¦æ±å¤æé¢æ°
   * @param {mapray.GeoJSONLoader.FinishCallback}    [options.callback]   çµäºã³ã¼ã«ããã¯é¢æ°
   * @param {mapray.Loader.EntityCallback}           [options.onEntity]   ã¨ã³ãã£ãã£ã³ã¼ã«ããã¯é¢æ°
   */
  function GeoJSONLoader(scene, resource) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, GeoJSONLoader);

    if (resource instanceof Resource) ; else if (typeof resource === "string") {
      resource = new URLResource(resource, {
        type: "json",
        transform: options.transform
      });
    } else {
      throw new Error("Unsupported Resource: " + resource);
    }

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GeoJSONLoader).call(this, scene, resource, {
      onEntity: options.onEntity,
      onLoad: options.onLoad
    })); // PinEntity

    _this._getPointFGColor = options.getPointFGColor || defaultGetPointFGColorCallback;
    _this._getPointBGColor = options.getPointBGColor || defaultGetPointBGColorCallback;
    _this._getPointSize = options.getPointSize || defaultGetPointSizeCallback;
    _this._getPointIconId = options.getPointIconId || defaultGetPointIconIdCallback; // MarkerLineEntity

    _this._getLineColor = options.getLineColor || defaultGetLineColorCallback;
    _this._getLineWidth = options.getLineWidth || defaultGetLineWidthCallback; // PolygonEntity

    _this._getFillColor = options.getFillColor || defaultGetFillColorCallback;
    _this._getExtrudedHeight = options.getExtrudedHeight || defaultGetExtrudedHeightCallback; // Common

    _this._getAltitudeMode = options.getAltitudeMode || defaultGetAltitudeModeCallback;
    _this._getAltitude = options.getAltitude || defaultGetAltitudeCallback;
    _this._glenv = scene.glenv;
    _this._references = {};
    _this._cancelled = false;
    _this._finished = false;
    return _this;
  }
  /**
   * @summary èª­ã¿è¾¼ã¿å¦çã®å®æãç¶æ¿ã¯ã©ã¹ã«ãã£ã¦å®è£ãããã
   * @private
   */


  _createClass(GeoJSONLoader, [{
    key: "_load",
    value: function _load() {
      var _this2 = this;

      return this._resource.load({
        type: ResourceType.JSON
      }).then(function (geoJson) {
        // JSON ãã¼ã¿ã®åå¾ã«æå
        _this2._check_cancel();

        _this2._load_geojson_object(geoJson);
      });
    }
    /**
     * Load GeoJSON Object
     * @private
     */

  }, {
    key: "_load_geojson_object",
    value: function _load_geojson_object(geojson) {
      var success;

      if (geojson.type === TYPES.FEATURE_COLLECTION) {
        var features = geojson.features;
        success = false;

        for (var i = 0, len = features.length; i < len; i++) {
          var feature = features[i];

          var s = this._load_geojson_object(feature.featureId ? feature.feature : feature); // @ToDo: Unknown
          // var s = this._load_geojson_object( feature );


          if (s && !success) success = s;
        }
      } else if (geojson.type === TYPES.FEATURE) {
        var geometry = geojson.geometry;
        success = this._load_geometry_object(geometry, geojson);
      } else if (SUPPORTED_GEOMETRY_TYPES.indexOf(geojson.type) !== -1) {
        success = this._load_geometry_object(geojson, null);
      } else {
        throw new Error("Unnsupported Type: " + geojson.type);
      }

      if (this._cancelled) return false;
      return success;
    }
    /**
     * Load Geometry Object
     * @private
     */

  }, {
    key: "_load_geometry_object",
    value: function _load_geometry_object(geometry) {
      var geojson = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var coords = geometry.coordinates;

      if (!coords && !geometry) {
        return false;
      }

      switch (geometry.type) {
        case GEOMETRY_TYPES.POINT:
        case GEOMETRY_TYPES.MULTI_POINT:
          return this._loadPoint(geometry, geojson);

        case GEOMETRY_TYPES.LINE_STRING:
        case GEOMETRY_TYPES.MULTI_LINE_STRING:
          return this._loadLines(geometry, geojson);

        case GEOMETRY_TYPES.POLYGON:
        case GEOMETRY_TYPES.MULTI_POLYGON:
          return this._loadPolygons(geometry, geojson);

        case GEOMETRY_TYPES.GEOMETRY_COLLECTION:
          return true;

        default:
          throw new Error("Invalid GeoJSON type: " + geometry.type);
      }
    }
    /**
     * fetch() ã® init å¼æ°ã«ä¸ãããªãã¸ã§ã¯ããçæ
     * @private
     */

  }, {
    key: "_make_fetch_params",
    value: function _make_fetch_params(tr) {
      var init = {
        signal: this._abort_ctrl.signal,
        credentials: (tr.credentials || CredentialMode.OMIT).credentials
      };

      if (tr.headers) {
        init.headers = tr.headers || GeoJSONLoader._defaultHeaders;
      }

      return init;
    }
    /**
     * @private
     */

  }, {
    key: "_loadLines",
    value: function _loadLines(geometry, geojson) {
      var _this3 = this;

      var color4 = this._getLineColor(geojson);

      var width = this._getLineWidth(geojson);

      var altitude = this._getAltitude(geojson);

      var altitude_mode = this._getAltitudeMode(geojson);

      if (!geometry || color4.length !== 4) {
        return false;
      }

      var type = geometry.type;
      var coords = geometry.coordinates;
      var rgb = color4.slice(0, 3);
      var alpha = color4[3]; // If multiline, split entity

      if (type === GEOMETRY_TYPES.MULTI_LINE_STRING) {
        coords.forEach(function (points) {
          if (!_this3._generateLine(points, width, rgb, alpha, altitude_mode, altitude, geojson)) {
            return false;
          }
        });
        return true;
      } else {
        // type === GEOMETRY_TYPES.LINE_STRING
        return this._generateLine(coords, width, rgb, alpha, altitude_mode, altitude, geojson);
      }
    }
    /**
     * @private
     */

  }, {
    key: "_generateLine",
    value: function _generateLine(points, width, color, opaticy, altitude_mode, altitude, geojson) {
      if (!points) {
        return false;
      }

      var entity = new MarkerLineEntity(this._scene);
      entity.altitude_mode = altitude_mode;

      var fp = this._flatten(points, altitude);

      entity.addPoints(fp);
      entity.setLineWidth(width);
      entity.setColor(color);
      entity.setOpacity(opaticy);

      this._onEntity(this, entity, geojson);

      return true;
    }
    /**
     * @private
     */

  }, {
    key: "_loadPoint",
    value: function _loadPoint(geometry, geojson) {
      var fgColor = this._getPointFGColor(geojson);

      var bgColor = this._getPointBGColor(geojson);

      var iconId = this._getPointIconId(geojson);

      var size = this._getPointSize(geojson);

      var altitude_mode = this._getAltitudeMode(geojson);

      var altitude = this._getAltitude(geojson);

      if (!geometry) {
        return false;
      }

      var type = geometry.type;
      var props = {
        "fg_color": fgColor.slice(0, 3),
        "bg_color": bgColor.slice(0, 3),
        size: size
      }; // If multiline, split entity

      if (type === GEOMETRY_TYPES.POINT) {
        var entity = new PinEntity(this._scene);
        entity.altitude_mode = altitude_mode;

        var alt = this._getActualValue(altitude, geometry.coordinates[2], GeoJSONLoader.defaultAltitude);

        var coords = new GeoPoint(geometry.coordinates[0], geometry.coordinates[1], alt);

        if (iconId !== null) {
          entity.addMakiIconPin(iconId, coords, props);
        } else {
          entity.addPin(coords, props);
        }

        this._onEntity(this, entity, geojson);
      } else {
        // type === GEOMETRY_TYPES.MULTI_POINT
        var entity = new PinEntity(this._scene);
        entity.altitude_mode = altitude_mode;

        for (var i = 0; i < geometry.coordinates.length; i++) {
          var targetCoordinates = geometry.coordinates[i];

          var alt = this._getActualValue(altitude, geometry.coordinates[2], GeoJSONLoader.defaultAltitude);

          var coords = new GeoPoint(targetCoordinates[0], targetCoordinates[1], alt);

          if (iconId !== null) {
            entity.addMakiIconPin(iconId, coords, props); // entity.addPin( coords, props );
          } else {
            entity.addPin(coords, props);
          }
        }

        this._onEntity(this, entity, geojson);
      }

      return true;
    }
    /**
     * @private
     */

  }, {
    key: "_loadPolygons",
    value: function _loadPolygons(geometry, geojson) {
      var _this4 = this;

      var color4 = this._getFillColor(geojson);

      var altitude_mode = this._getAltitudeMode(geojson);

      var altitude = this._getAltitude(geojson);

      var extruded_height = this._getExtrudedHeight(geojson);

      if (!geometry || color4.length !== 4) {
        return false;
      }

      var type = geometry.type;
      var coords = geometry.coordinates;
      var rgb = color4.slice(0, 3);
      var alpha = color4[3]; // If multiline, split entity

      if (type === GEOMETRY_TYPES.MULTI_POLYGON) {
        coords.forEach(function (points) {
          if (!_this4._generatePolygon(points, rgb, alpha, altitude_mode, altitude, extruded_height, geojson)) {
            return false;
          }
        });
        return true;
      } else {
        // type === GEOMETRY_TYPES.POLYGON
        return this._generatePolygon(coords, rgb, alpha, altitude_mode, altitude, extruded_height, geojson);
      }
    }
    /**
     * @private
     */

  }, {
    key: "_generatePolygon",
    value: function _generatePolygon(pointsList, color, opaticy, altitude_mode, altitude, extruded_height, geojson) {
      if (!pointsList) {
        return false;
      }

      var entity = new PolygonEntity(this._scene);
      entity.altitude_mode = altitude_mode;
      entity.extruded_height = extruded_height;
      entity.setColor(color);
      entity.setOpacity(opaticy);

      for (var i = 0; i < pointsList.length; i++) {
        var fp = this._flatten(pointsList[i], altitude, pointsList[i].length - 1);

        if (!fp) return false;
        if (i === 0) entity.addOuterBoundary(fp);else entity.addInnerBoundary(fp);
      }

      this._onEntity(this, entity, geojson);

      return true;
    }
    /**
     * @private
     */

  }, {
    key: "_getActualValue",
    value: function _getActualValue(valueFromCallback, valueInGeoJSON, defaultValue) {
      return valueFromCallback != null ? valueFromCallback : // value from callback is the most prioritized
      valueInGeoJSON != null ? valueInGeoJSON : // value in GeoJSON will be used if defined
      defaultValue // default value
      ;
    }
    /**
     * @private
     */

  }, {
    key: "_flatten",
    value: function _flatten(ary, altitude) {
      var _this5 = this;

      var len = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ary.length;
      return ary.reduce(function (p, c, i) {
        return i >= len ? p : p.concat(c.slice(0, 2), _this5._getActualValue(altitude, c[2], GeoJSONLoader.defaultAltitude));
      }, []);
    }
  }]);

  return GeoJSONLoader;
}(Loader);

{
  GeoJSONLoader._defaultHeaders = {};
  GeoJSONLoader.defaultLineColor = [0, 0, 0, 1];
  GeoJSONLoader.defaultFillColor = [0, 0, 0, 1];
  GeoJSONLoader.defaultLineWidth = 1;
  GeoJSONLoader.defaultPointFGColor = [1.0, 1.0, 1.0];
  GeoJSONLoader.defaultPointBGColor = [0.35, 0.61, 0.81];
  GeoJSONLoader.defaultPointSize = 30;
  GeoJSONLoader.defaultPointIconId = null;
  GeoJSONLoader.defaultAltitude = 0.0;
  GeoJSONLoader.defaultExtrudedHeight = 0.0;
}

function defaultGetLineColorCallback(geojson) {
  return GeoJSONLoader.defaultLineColor;
}

function defaultGetLineWidthCallback(geojson) {
  return GeoJSONLoader.defaultLineWidth;
}

function defaultGetFillColorCallback(geojson) {
  return GeoJSONLoader.defaultFillColor;
}

function defaultGetPointFGColorCallback(geojson) {
  return GeoJSONLoader.defaultPointFGColor;
}

function defaultGetPointBGColorCallback(geojson) {
  return GeoJSONLoader.defaultPointBGColor;
}

function defaultGetPointSizeCallback(geojson) {
  return GeoJSONLoader.defaultPointSize;
}

function defaultGetPointIconIdCallback(geojson) {
  return GeoJSONLoader.defaultPointIconId;
}

function defaultGetAltitudeModeCallback(geojson) {
  return AltitudeMode.ABSOLUTE;
}

function defaultGetAltitudeCallback(geojson) {
  return null;
}

function defaultGetExtrudedHeightCallback(geojson) {
  return GeoJSONLoader.defaultExtrudedHeight;
}

var TYPES = {
  FEATURE: "Feature",
  FEATURE_COLLECTION: "FeatureCollection"
};
var GEOMETRY_TYPES = {
  POINT: "Point",
  MULTI_POINT: "MultiPoint",
  LINE_STRING: "LineString",
  MULTI_LINE_STRING: "MultiLineString",
  POLYGON: "Polygon",
  MULTI_POLYGON: "MultiPolygon",
  GEOMETRY_COLLECTION: "GeometryCollection",
  FEATURE: "Feature"
};
var SUPPORTED_GEOMETRY_TYPES = Object.values(GEOMETRY_TYPES);

/**
 * @summary ãããã°çµ±è¨
 * @classdesc
 * <p>ã¨ã³ã¸ã³éçºç¨ã®çµ±è¨ãªãã¸ã§ã¯ãã§ããã<p>
 * <p>NOTE: ãªãã¸ã§ã¯ãã®æ¯èãã¯ã¨ã³ã¸ã³ã®å®è£ã«ä¾å­ãããããä¸è¬ã¢ããªã®éçºã§ã¯ä½¿ç¨ã§ããªãã<p>
 * @memberof mapray
 */
var DebugStats =
/*#__PURE__*/
function () {
  /**
   */
  function DebugStats() {
    _classCallCheck(this, DebugStats);

    /**
     *  @summary ãªã¯ã¨ã¹ãå¾ã¡ã® DEM æ°
     *  @member mapray.DebugStats#num_wait_reqs_dem
     *  @type {number}
     */

    /**
     *  @summary ãªã¯ã¨ã¹ãå¾ã¡ã®ç»åæ°
     *  @member mapray.DebugStats#num_wait_reqs_img
     *  @type {number}
     */

    /**
     *  @summary æç»å°è¡¨æ­çæ°
     *  @member mapray.DebugStats#num_drawing_flakes
     *  @type {number}
     */

    /**
     *  @summary æç»å°è¡¨æ­é ç¹æ°
     *  @member mapray.DebugStats#num_drawing_flake_vertices
     *  @type {number}
     */

    /**
     *  @summary å°è¡¨æ­çå¦ç A ã®æ°
     *  @member mapray.DebugStats#num_procA_flakes
     *  @type {number}
     */

    /**
     *  @summary å°è¡¨æ­çå¦ç B ã®æ°
     *  @member mapray.DebugStats#num_procB_flakes
     *  @type {number}
     */
    this.clearStats();
  }
  /**
   * çµ±è¨å¤ãã¯ãªã¢
   * @package
   */


  _createClass(DebugStats, [{
    key: "clearStats",
    value: function clearStats() {
      this.num_wait_reqs_dem = 0;
      this.num_wait_reqs_img = 0;
      this.num_drawing_flakes = 0;
      this.num_drawing_flake_vertices = 0;
      this.num_procA_flakes = 0;
      this.num_procB_flakes = 0;
    }
    /**
     * @summary æ´æ°ãå®äºããã¨ãã«å¼ã³åºããã
     * @abstract
     */

  }, {
    key: "onUpdate",
    value: function onUpdate() {}
  }]);

  return DebugStats;
}();

var trim$1 = stringTrim.trim;
var $parseInt = global_1.parseInt;
var hex = /^[+-]?0[Xx]/;
var FORCED$8 = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22; // `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix

var numberParseInt = FORCED$8 ? function parseInt(string, radix) {
  var S = trim$1(String(string));
  return $parseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));
} : $parseInt;

// https://tc39.github.io/ecma262/#sec-parseint-string-radix

_export({
  global: true,
  forced: parseInt != numberParseInt
}, {
  parseInt: numberParseInt
});

var getOwnPropertyDescriptor$5 = objectGetOwnPropertyDescriptor.f;
var nativeEndsWith = ''.endsWith;
var min$6 = Math.min;
var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegexpLogic('endsWith'); // https://github.com/zloirock/core-js/pull/702

var MDN_POLYFILL_BUG$1 =  !CORRECT_IS_REGEXP_LOGIC$1 && !!function () {
  var descriptor = getOwnPropertyDescriptor$5(String.prototype, 'endsWith');
  return descriptor && !descriptor.writable;
}(); // `String.prototype.endsWith` method
// https://tc39.github.io/ecma262/#sec-string.prototype.endswith

_export({
  target: 'String',
  proto: true,
  forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1
}, {
  endsWith: function endsWith(searchString
  /* , endPosition = @length */
  ) {
    var that = String(requireObjectCoercible(this));
    notARegexp(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : min$6(toLength(endPosition), len);
    var search = String(searchString);
    return nativeEndsWith ? nativeEndsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/**
 * @summary ãã¼ã¿ã»ãããè¡¨ç¾ããæ½è±¡ã¯ã©ã¹
 */

var AbstractDataset =
/*#__PURE__*/
function () {
  /**
   * @param {MaprayApi} api
   */
  function AbstractDataset(api) {
    _classCallCheck(this, AbstractDataset);

    this._aip = api;
  }
  /**
   * @summary ãã¼ã¿ã»ããã®idãåå¾
   * @return {string}
   */


  _createClass(AbstractDataset, [{
    key: "getId",
    value: function getId() {
      return this._id;
    }
    /**
     * @summary ãªã¼ãã¼ã®idãåå¾
     * @return {string}
     */

  }, {
    key: "getOwnerId",
    value: function getOwnerId() {
      return this._owner_id;
    }
    /**
     * @summary ååãåå¾
     * @return {string}
     */

  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }
    /**
     * @summary èª¬æãåå¾
     * @return {string}
     */

  }, {
    key: "getDescription",
    value: function getDescription() {
      return this._description;
    }
    /**
     * @summary ä½ææ¥æãåå¾
     * @return {Date}
     */

  }, {
    key: "getCreatedAt",
    value: function getCreatedAt() {
      return this._created_at;
    }
    /**
     * @summary æ´æ°æ¥æãåå¾
     * @return {Date}
     */

  }, {
    key: "getUpdatedAt",
    value: function getUpdatedAt() {
      return this._updated_at;
    }
    /**
     * @private
     * @param {json} ãµã¼ãããè¿å´ãããjson
     */

  }, {
    key: "_restoreFromJson",
    value: function _restoreFromJson(json) {
      this._id = json.id;
      this._owner_id = json.owner_id;
      this._name = json.name;
      this._description = json.description;
      this._created_at = new Date(json.created_at);
      this._updated_at = new Date(json.updated_at);
    }
  }]);

  return AbstractDataset;
}();
/**
 * @summary ãã¼ã¿ã»ãããè¡¨ç¾ããã¯ã©ã¹
 */

var Dataset =
/*#__PURE__*/
function (_AbstractDataset) {
  _inherits(Dataset, _AbstractDataset);

  /**
   * @param {MaprayApi} api
   */
  function Dataset(api) {
    _classCallCheck(this, Dataset);

    return _possibleConstructorReturn(this, _getPrototypeOf(Dataset).call(this, api));
  }
  /**
   * @private
   * @param {json} ãµã¼ãããè¿å´ãããjson
   */


  _createClass(Dataset, [{
    key: "_restoreFromJson",
    value: function _restoreFromJson(json) {
      _get(_getPrototypeOf(Dataset.prototype), "_restoreFromJson", this).call(this, json);
    }
    /**
     * @private
     * @param {MaprayApi} api
     * @param {json} ãµã¼ãããè¿å´ãããjson
     * @return {Dataset}
     */

  }], [{
    key: "createFromJson",
    value: function createFromJson(api, json) {
      var dataset = new Dataset(api);

      dataset._restoreFromJson(json);

      return dataset;
    }
  }]);

  return Dataset;
}(AbstractDataset);
/**
 * @summary 3Dãã¼ã¿ã»ãããè¡¨ç¾ããã¯ã©ã¹
 */

var Dataset3D =
/*#__PURE__*/
function (_AbstractDataset2) {
  _inherits(Dataset3D, _AbstractDataset2);

  /**
   * @param {MaprayApi} api
   */
  function Dataset3D(api) {
    _classCallCheck(this, Dataset3D);

    return _possibleConstructorReturn(this, _getPrototypeOf(Dataset3D).call(this, api));
  }
  /**
   * @summary åç¹ä½ç½®
   * @return {mapray.GeoPoint}
   */


  _createClass(Dataset3D, [{
    key: "getOrigin",
    value: function getOrigin() {
      return this._origin;
    }
    /**
     * @summary ã¢ãã«ãå¬éããã¦ããURL
     * @return {string}
     */

  }, {
    key: "getUrl",
    value: function getUrl() {
      return this._url;
    }
    /**
     * @summary ãã©ã¼ããã
     * @private
     * @return {string}
     */

  }, {
    key: "getFormat",
    value: function getFormat() {
      return this._format;
    }
    /**
     * @summary ã·ã¼ã³ID
     * @private
     * @return {string}
     */

  }, {
    key: "getSceneId",
    value: function getSceneId() {
      return this._scene_id;
    }
    /**
     * @summary Path
     * @private
     * @return {string}
     */

  }, {
    key: "getPath",
    value: function getPath() {
      return this._path;
    }
    /**
     * @summary SRID
     * @private
     * @return {string}
     */

  }, {
    key: "getSRID",
    value: function getSRID() {
      return this._srid;
    }
    /**
     * @private
     * @param {json} ãµã¼ãããè¿å´ãããjson
     */

  }, {
    key: "_restoreFromJson",
    value: function _restoreFromJson(json) {
      /* missing options
      "x": 137.715,
      "y": 34.71111,
      "z": 0,
      "roll": 0,
      "tilt": 0,
      "heading": 0,
      "sx": 1,
      "sy": 1,
      "sz": 1,
      "offset_x": 0,
      "offset_y": 0,
      "offset_z": 0,
      "offset_roll": 0,
      "offset_tilt": 0,
      "offset_heading": 0,
      "offset_sx": 1,
      "offset_sy": 1,
      "offset_sz": 1,
      "altitude_mode": "absolute",
      */
      _get(_getPrototypeOf(Dataset3D.prototype), "_restoreFromJson", this).call(this, json);

      this._url = json.url;
      this._scene_id = json.scene_id;
      this._path = json.path;
      this._format = json.format;
      this._srid = json.srid;
      this._origin = new GeoPoint(json.x, json.y, json.z);
    }
    /**
     * @private
     * @param {MaprayApi} api
     * @param {json} ãµã¼ãããè¿å´ãããjson
     * @return {Dataset3D}
     */

  }], [{
    key: "createFromJson",
    value: function createFromJson(api, json) {
      var dataset = new Dataset3D(api);

      dataset._restoreFromJson(json);

      return dataset;
    }
  }]);

  return Dataset3D;
}(AbstractDataset);
/**
 * @summary ç¹ç¾¤ãã¼ã¿ã»ãããè¡¨ç¾ããã¯ã©ã¹
 */

var PointCloudDataset =
/*#__PURE__*/
function (_AbstractDataset3) {
  _inherits(PointCloudDataset, _AbstractDataset3);

  /**
   * @param {MaprayApi} api
   */
  function PointCloudDataset(api) {
    _classCallCheck(this, PointCloudDataset);

    return _possibleConstructorReturn(this, _getPrototypeOf(PointCloudDataset).call(this, api));
  }
  /**
   * @summary ç¹ç¾¤ãã¡ã¤ã«ãå¬éããã¦ããURLãåå¾
   */


  _createClass(PointCloudDataset, [{
    key: "getUrl",
    value: function getUrl() {
      return this._url;
    }
    /**
     * @summary ç¹ç¾¤ã®ãã¦ã³ãã£ã³ã°ããã¯ã¹ãåå¾
     */

  }, {
    key: "getBoundingBox",
    value: function getBoundingBox() {
      return this._bounding_box;
    }
    /**
     * @summary 1ã¬ãã«ã«1ããã¯ã¹ããå­å¨ããªãããã¯ã¹ã®ä¸­ã§æãé«ãã¬ãã«ã®ããã¯ã¹ã
     * ï¼ç¹ç¾¤ã«å«ã¾ããå¨ã¦ã®ç¹ãåå«ããããã¯ã¹ã®ä¸­ã§æãé«ãã¬ãã«ã®ããã¯ã¹ï¼
     * @return string
     */

  }, {
    key: "getContentRoot",
    value: function getContentRoot() {
      return this._content_root;
    }
    /**
     * @summary ãã©ã¼ãããï¼ç¾å¨ã¯rawã®ã¿å¯¾å¿ï¼
     * @return string
     */

  }, {
    key: "getFormat",
    value: function getFormat() {
      return this._format;
    }
    /**
     * @private
     * @param {json} ãµã¼ãããè¿å´ãããjson
     */

  }, {
    key: "_restoreFromJson",
    value: function _restoreFromJson(json) {
      _get(_getPrototypeOf(PointCloudDataset.prototype), "_restoreFromJson", this).call(this, json); // this._srid = json.srid;


      this._url = json.url;
      this._bounding_box = json.bbox;
      this._content_root = Array.isArray(json.content_root) ? json.content_root.join("/") : json.content_root;
      this._format = json.format;
    }
    /**
     * @private
     * @param {MaprayApi} api
     * @param {json} ãµã¼ãããè¿å´ãããjson
     * @return {PointCloudDataset}
     */

  }], [{
    key: "createFromJson",
    value: function createFromJson(api, json) {
      var dataset = new PointCloudDataset(api);

      dataset._restoreFromJson(json);

      return dataset;
    }
  }]);

  return PointCloudDataset;
}(AbstractDataset);

/**
 * @summary Mapray Cloudã«ç»é²ããããã¼ã¿ã«ããã¦ãURLã¢ã¯ã»ã¹ãè¦ãããªã½ã¼ã¹ãè¡¨ç¾ããã
 * <dl>
 * <dt> index.htmlã®ããã«åºæºã¨ãªããã¡ã¤ã«ãæå®ãããã®ãã¡ã¤ã«ããã®ç¸å¯¾ãã¹ã§ãµããªã½ã¼ã¹ã¸ã¢ã¯ã»ã¹ããã
 * <dd>
 *    ã³ã³ã¹ãã©ã¯ã¿ã§åºæºã¨ãªããã¡ã¤ã«ãæå®ããload()ã¯ãã®ãã¡ã¤ã«ãèª­ã¿è¾¼ãã
 *    loadSubResource( sub_url )ã¯ãsub_urlãç¸å¯¾ãã¹ã®å ´åã¯åºæºã¨ãªããã¡ã¤ã«ããã®ç¸å¯¾ãã¹ã¨ãã¦è§£éãããã
 * <dt> ã«ã¼ããã¹ãæå®ãéä¸ã®ãªã½ã¼ã¹ã¸ã¢ã¯ã»ã¹ããã
 * <dd>
 *    ã³ã³ã¹ãã©ã¯ã¿ã§åºæºã¨ãªãURLãæå®ããããã®æãURLã¯å¿ã/ã§çµäºããå¿è¦ããããload()ã¯åä½ãå®ç¾©ãããªãã
 *    loadSubResource( sub_url )ã¯ãsub_urlãç¸å¯¾ãã¹ã®å ´åã¯åºæºã¨ãªãURLããã®ç¸å¯¾ãã¹ã¨ãã¦è§£éãããã
 * </dl>
 * @private
 */

var ApiUrlResource =
/*#__PURE__*/
function (_Resource) {
  _inherits(ApiUrlResource, _Resource);

  /**
   * @param {MaprayApi} api
   * @param {string} url
   */
  function ApiUrlResource(api, url) {
    var _this;

    _classCallCheck(this, ApiUrlResource);

    var index = url.lastIndexOf("/");
    if (index === -1) throw new Error("invalid url"); //super( api, url.substr( 0, index + 1 ) );

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ApiUrlResource).call(this));
    _this._api = api;
    _this._url = url;
    _this._base_url = url.substr(0, index + 1);
    return _this;
  }
  /**
   * @param {object} options
   * @override
   */


  _createClass(ApiUrlResource, [{
    key: "load",
    value: function () {
      var _load = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var options,
            response,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
                _context.next = 3;
                return this._api.fetch(HTTP.METHOD.GET, this._url);

              case 3:
                response = _context.sent;

                if (!(options.type === ResourceType.JSON)) {
                  _context.next = 10;
                  break;
                }

                _context.next = 7;
                return response.json();

              case 7:
                _context.t0 = _context.sent;
                _context.next = 11;
                break;

              case 10:
                _context.t0 = response;

              case 11:
                return _context.abrupt("return", _context.t0);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function load() {
        return _load.apply(this, arguments);
      }

      return load;
    }()
    /**
     * @override
     */

  }, {
    key: "loadSubResourceSupported",
    value: function loadSubResourceSupported() {
      return true;
    }
    /**
     * @summary ãªã½ã¼ã¹ã«ã¢ã¯ã»ã¹ãããsub_urlã¯ç¸å¯¾ã»çµ¶å¯¾ã®ä¸¡æ¹ã«å¯¾å¿ã
     * @override
     * @param {string} sub_url
     * @return {Resource}
     */

  }, {
    key: "loadSubResource",
    value: function () {
      var _loadSubResource = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(sub_url) {
        var options,
            url,
            response,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
                url = Dom.resolveUrl(this._base_url, sub_url);
                _context2.next = 4;
                return this._api.fetch(HTTP.METHOD.GET, url);

              case 4:
                response = _context2.sent;

                if (response.ok) {
                  _context2.next = 7;
                  break;
                }

                throw new Error(response.statusText);

              case 7:
                if (!(options.type === ResourceType.BINARY)) {
                  _context2.next = 13;
                  break;
                }

                _context2.next = 10;
                return response.arrayBuffer();

              case 10:
                _context2.t0 = _context2.sent;
                _context2.next = 25;
                break;

              case 13:
                if (!(options.type === ResourceType.IMAGE)) {
                  _context2.next = 23;
                  break;
                }

                _context2.t2 = Dom;
                _context2.next = 17;
                return response.blob();

              case 17:
                _context2.t3 = _context2.sent;
                _context2.next = 20;
                return _context2.t2.loadImage.call(_context2.t2, _context2.t3);

              case 20:
                _context2.t1 = _context2.sent;
                _context2.next = 24;
                break;

              case 23:
                _context2.t1 = response;

              case 24:
                _context2.t0 = _context2.t1;

              case 25:
                return _context2.abrupt("return", _context2.t0);

              case 26:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function loadSubResource(_x) {
        return _loadSubResource.apply(this, arguments);
      }

      return loadSubResource;
    }()
  }]);

  return ApiUrlResource;
}(Resource);
/**
 * Mapray Cloudã«ç»é²ãããDatasetãè¡¨ç¾ãããªã½ã¼ã¹ã
 */


var DatasetResource =
/*#__PURE__*/
function (_Resource2) {
  _inherits(DatasetResource, _Resource2);

  function DatasetResource(api, datasetId) {
    var _this2;

    _classCallCheck(this, DatasetResource);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(DatasetResource).call(this));
    _this2._api = api;
    _this2._datasetId = datasetId;
    return _this2;
  }
  /**
   * @return {Promise(object)} ãã¼ã¿(geojson)
   */


  _createClass(DatasetResource, [{
    key: "load",
    value: function () {
      var _load2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._api.getFeatures(this._datasetId);

              case 2:
                return _context3.abrupt("return", _context3.sent);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function load() {
        return _load2.apply(this, arguments);
      }

      return load;
    }()
  }]);

  return DatasetResource;
}(Resource);
/**
 * Mapray Cloudã«ç»é²ããã3DDatasetã®ã¢ãã«ãè¡¨ç¾ãããªã½ã¼ã¹ã
 */

var Dataset3DSceneResource =
/*#__PURE__*/
function (_Resource3) {
  _inherits(Dataset3DSceneResource, _Resource3);

  /**
   * @param {MaprayApi} api
   * @param {string|string[]} datasetIds ãã¼ã¿ã»ããã®idãè¤æ°æå®ããå ´åã¯éåãæå®ããã
   */
  function Dataset3DSceneResource(api, datasetIds) {
    var _this3;

    _classCallCheck(this, Dataset3DSceneResource);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Dataset3DSceneResource).call(this));
    _this3._api = api;
    _this3._datasetIds = Array.isArray(datasetIds) ? datasetIds : [datasetIds];
    return _this3;
  }
  /**
   * @return {Promise(object)} ã·ã¼ã³ãã¡ã¤ã«(json)
   */


  _createClass(Dataset3DSceneResource, [{
    key: "load",
    value: function () {
      var _load3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._api.get3DDatasetScene(this._datasetIds);

              case 2:
                return _context4.abrupt("return", _context4.sent);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function load() {
        return _load3.apply(this, arguments);
      }

      return load;
    }()
    /**
     * @protected
     */

  }, {
    key: "resolveResourceSupported",
    value: function resolveResourceSupported() {
      return true;
    }
    /**
     * @summary ã·ã¼ã³ãã¡ã¤ã«ã«å«ã¾ããã¢ãã«åã³ã¢ãã«ã«é¢é£ã¥ãããããªã½ã¼ã¹ã¸ã¢ã¯ã»ã¹éã«å©ç¨ãããResourceã
     * @param {string} sub_url ã¢ãã«URL
     * @return {Resource} 
     */

  }, {
    key: "resolveResource",
    value: function resolveResource(sub_url) {
      return new ApiUrlResource(this._api, sub_url);
    }
  }]);

  return Dataset3DSceneResource;
}(Resource);
/**
 * Mapray Cloudã«ç»é²ãããPoint Cloud Datasetãè¡¨ç¾ãããªã½ã¼ã¹ã
 */

var PointCloudDatasetResource =
/*#__PURE__*/
function (_Resource4) {
  _inherits(PointCloudDatasetResource, _Resource4);

  /**
   * @param {MaprayApi} api
   * @param {string} datasetId ãã¼ã¿ã»ããã®id
   */
  function PointCloudDatasetResource(api, datasetId) {
    var _this4;

    _classCallCheck(this, PointCloudDatasetResource);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(PointCloudDatasetResource).call(this));
    _this4._api = api;
    _this4._datasetId = datasetId;
    return _this4;
  }
  /**
   * @return {Promise<object>} ç¹ç¾¤å®ç¾©(json)
   */


  _createClass(PointCloudDatasetResource, [{
    key: "load",
    value: function () {
      var _load4 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._api.getPointCloudDataset(this._datasetId);

              case 2:
                return _context5.abrupt("return", _context5.sent);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function load() {
        return _load4.apply(this, arguments);
      }

      return load;
    }()
    /**
     * @protected
     */

  }, {
    key: "resolveResourceSupported",
    value: function resolveResourceSupported() {
      return true;
    }
    /**
     * @param {string} sub_url ç¹ç¾¤ãå¬éããã¦ããURLã¸ã¢ã¯ã»ã¹ããããã®Resourceã
     * @return {Resource} ç¹ç¾¤ãã¡ã¤ã«ãªã½ã¼ã¹
     */

  }, {
    key: "resolveResource",
    value: function resolveResource(sub_url) {
      return new ApiUrlResource(this._api, sub_url);
    }
  }]);

  return PointCloudDatasetResource;
}(Resource);

var MaprayApiError =
/*#__PURE__*/
function (_FetchError) {
  _inherits(MaprayApiError, _FetchError);

  function MaprayApiError(code, message, url, response, cause) {
    var _this;

    _classCallCheck(this, MaprayApiError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MaprayApiError).call(this, message + " [" + code + "]", url));

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), MaprayApiError);
    }

    _this.name = "MaprayApiError";
    _this.code = code;
    _this.resonse = response;
    _this.cause = cause;

    if (cause) {
      _this.stack += "\nCaused-By: " + cause.stack;
    }

    return _this;
  }

  return MaprayApiError;
}(FetchError);
/**
 * @summary Mapray Cloudã¸ã¢ã¯ã»ã¹ããããã®ã¯ã©ã¹ã§ãã
 * @classdesc
 * <p>
 * ãã®ã¯ã©ã¹ãå©ç¨ããã«ã¯äºåã«Mapray Cloudã¢ã«ã¦ã³ããä½æããå¿è¦ãããã¾ãã
 * <a href="https://cloud.mapray.com/">https://cloud.mapray.com</a>ãããµã¤ã³ã¢ãããããã¨ãã§ãã¾ãã
 * </p>
 * <p>
 * äºåã«ä¸è¨ã®æå ±ãèª¿ã¹ã¦ããã¾ãã
 * </p>
 * <dl>
 * <dt>User ID
 * <dd>Mapray Cloudã®<a href="https://cloud.mapray.com/settings" target="_blank">ã¦ã¼ã¶ã¼æå ±ãã¼ã¸</a>ããç¢ºèªãã¾ãã
 * å³ä¸ã¡ãã¥ã¼ã®Accountã¡ãã¥ã¼ãããã®ãã¼ã¸ãéããã¨ãã§ãã¾ãã
 * <dt>Token
 * <dd>Mapray Cloudã®<a href="https://cloud.mapray.com/dashboard" target="_blank">Tokenãã¼ã¸</a>ã§ãã¼ã¯ã³ãä½æãã¾ãã
 * ä¸é¨ã®Tokensã¿ããããã®ãã¼ã¸ãéããã¨ãã§ãã¾ãã
 * <dt>ãã¼ã¿ã»ããç­ã®ID
 * <dd>Mapray Cloudã¸ãã¼ã¿ãã¢ããã­ã¼ããããã®ãã¼ã¿ãä½¿ç¨ããã«ã¯ã<a href="https://cloud.mapray.com/datasetslist">ãã¼ã¿ã»ãããã¼ã¸</a>
 * ããGeoJsonãglTFãã¼ã¿ãã¢ããã­ã¼ããã¦ãããè¡¨ä¸­ã®IDãç¢ºèªãã¾ãã
 * </dl>
 *
 * @memberof mapray
 * @example
 * const maprayApi = new mapray.MaprayApi({
 *         basePath: "https://api.mapray.com",
 *         version: "v1",
 *         userId: "...",
 *         token: "..."
 * });
 * const datasets = await maprayApi.getDatasets();
 * ...
 */


var MaprayApi =
/*#__PURE__*/
function (_HTTP) {
  _inherits(MaprayApi, _HTTP);

  /**
   * @param {object} option
   * @param {string} [option.basePath=https://cloud.mapray.com] Mapray Cloudã®URLãæå®ãã¾ããéå¸¸ã¯çç¥ãã¾ãã
   * @param {string} option.version Mapray Cloud ã® APIãã¼ã¸ã§ã³ "v1" ã®ããã«æå®ãã¾ãã
   * @param {string} option.userId Mapray Cloud ã¢ã«ã¦ã³ãã® User ID ãæå®ãã¾ãã
   * @param {string} option.token Mapray Cloud ã§çæãã Token ãæå®ãã¾ãã
   */
  function MaprayApi() {
    var _this2;

    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MaprayApi);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(MaprayApi).call(this));
    var basePath = option.basePath.endsWith("/") ? option.basePath.slice(0, -1) : option.basePath;
    _this2._option = {
      basePath: basePath || DEFAULT_BASE_PATH,
      version: option.version,
      token: option.token,
      userId: option.userId
    };
    return _this2;
  } // Dataset, 3DDataset, PointCloudDataset

  /**
   * @summary ãã¼ã¿ã»ããã®ãªã¹ããåå¾ãã¾ãã
   * ãã¼ã¸ãã¨ã«ãã¼ã¿ã»ãããªã¹ããåå¾ãã¾ãã
   * @param {number} [page=1] åå¾ããè¦ç´ ã®ãã¼ã¸çªå·
   * @param {number} [limit=5] 1ãã¼ã¸ã«å«ã¾ããè¦ç´ æ°ãæå¤§100ã¾ã§æå®ãããã¨ãã§ãã¾ãã
   * @return {Dataset[]}
   */


  _createClass(MaprayApi, [{
    key: "loadDatasets",
    value: function () {
      var _loadDatasets = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var _this3 = this;

        var page,
            limit,
            datasets_json,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                page = _args.length > 0 && _args[0] !== undefined ? _args[0] : 1;
                limit = _args.length > 1 && _args[1] !== undefined ? _args[1] : 5;
                _context.next = 4;
                return this.getDatasets(page, limit);

              case 4:
                datasets_json = _context.sent;
                return _context.abrupt("return", datasets_json.map(function (dataset_json) {
                  return Dataset.createFromJson(_this3, dataset_json);
                }));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function loadDatasets() {
        return _loadDatasets.apply(this, arguments);
      }

      return loadDatasets;
    }()
    /**
     * @summary æå®ããIDã®ãã¼ã¿ã»ãããåå¾ãã¾ãã
     * @param {string} datasetId ãã¼ã¿ã»ããã®ID
     * @return {Dataset}
     */

  }, {
    key: "loadDataset",
    value: function () {
      var _loadDataset = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(datasetId) {
        var dataset_json;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getDataset(datasetId);

              case 2:
                dataset_json = _context2.sent;
                return _context2.abrupt("return", Dataset.createFromJson(this, dataset_json));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function loadDataset(_x) {
        return _loadDataset.apply(this, arguments);
      }

      return loadDataset;
    }()
    /**
     * @summary 3Dãã¼ã¿ã»ããã®ãªã¹ããåå¾ãã¾ãã
     * ãã¼ã¸ãã¨ã«ãã¼ã¿ã»ãããªã¹ããåå¾ãã¾ãã
     * @param {number} [page=1] åå¾ããè¦ç´ ã®ãã¼ã¸çªå·
     * @param {number} [limit=5] 1ãã¼ã¸ã«å«ã¾ããè¦ç´ æ°ãæå¤§100ã¾ã§æå®ãããã¨ãã§ãã¾ãã
     * @return {Dataset3D[]}
     */

  }, {
    key: "load3DDatasets",
    value: function () {
      var _load3DDatasets = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var _this4 = this;

        var page,
            limit,
            datasets_json,
            _args3 = arguments;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                page = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 1;
                limit = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 5;
                _context3.next = 4;
                return this.get3DDatasets(page, limit);

              case 4:
                datasets_json = _context3.sent;
                return _context3.abrupt("return", datasets_json.map(function (dataset_json) {
                  return Dataset3D.createFromJson(_this4, dataset_json);
                }));

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function load3DDatasets() {
        return _load3DDatasets.apply(this, arguments);
      }

      return load3DDatasets;
    }()
    /**
     * @summary æå®ããIDã®3Dãã¼ã¿ã»ãããåå¾ãã¾ãã
     * @param {string} datasetId
     * @return {Dataset3D}
     */

  }, {
    key: "load3DDataset",
    value: function () {
      var _load3DDataset = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(datasetId) {
        var dataset_json;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.get3DDataset(datasetId);

              case 2:
                dataset_json = _context4.sent;
                return _context4.abrupt("return", Dataset3D.createFromJson(this, dataset_json));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function load3DDataset(_x2) {
        return _load3DDataset.apply(this, arguments);
      }

      return load3DDataset;
    }()
    /**
     * @summary ç¹ç¾¤ãã¼ã¿ã»ããã®ãªã¹ããåå¾ãã¾ãã
     * ãã¼ã¸ãã¨ã«ãã¼ã¿ã»ãããªã¹ããåå¾ãã¾ãã
     * @param {number} [page=1] åå¾ããè¦ç´ ã®ãã¼ã¸çªå·
     * @param {number} [limit=5] 1ãã¼ã¸ã«å«ã¾ããè¦ç´ æ°ãæå¤§100ã¾ã§æå®ãããã¨ãã§ãã¾ãã
     * @return {PointCloudDataset[]}
     */

  }, {
    key: "loadPointCloudDatasets",
    value: function () {
      var _loadPointCloudDatasets = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        var _this5 = this;

        var page,
            limit,
            datasets_json,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                page = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : 1;
                limit = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : 5;
                _context5.next = 4;
                return this.getPointCloudDatasets(page, limit);

              case 4:
                datasets_json = _context5.sent;
                return _context5.abrupt("return", datasets_json.map(function (dataset_json) {
                  return PointCloudDataset.createFromJson(_this5, dataset_json);
                }));

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function loadPointCloudDatasets() {
        return _loadPointCloudDatasets.apply(this, arguments);
      }

      return loadPointCloudDatasets;
    }()
    /**
     * @summary æå®ããIDã®ç¹ç¾¤ãã¼ã¿ã»ãããåå¾ãã¾ãã
     * @param {string} datasetId ãã¼ã¿ã»ããID
     * @return {PointCloudDataset}
     */

  }, {
    key: "loadPointCloudDataset",
    value: function () {
      var _loadPointCloudDataset = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(datasetId) {
        var dataset_json;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getPointCloudDataset(datasetId);

              case 2:
                dataset_json = _context6.sent;
                return _context6.abrupt("return", PointCloudDataset.createFromJson(this, dataset_json));

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function loadPointCloudDataset(_x3) {
        return _loadPointCloudDataset.apply(this, arguments);
      }

      return loadPointCloudDataset;
    }() // Resources

    /**
     * @summary æå®ããIDã®ãã¼ã¿ã»ããããªã½ã¼ã¹ã¨ãã¦åå¾ãã¾ãã
     * @param {string} datasetId ãã¼ã¿ã»ããID
     * @return {Resource}
     */

  }, {
    key: "getDatasetAsResource",
    value: function getDatasetAsResource(datasetId) {
      return new DatasetResource(this, datasetId);
    }
    /**
     * @summary æå®ããIDã®3Dãã¼ã¿ã»ããã®ã·ã¼ã³ãã¡ã¤ã«ããªã½ã¼ã¹ã¨ãã¦åå¾ãã¾ãã
     * @param {string[]} datasetId ãã¼ã¿ã»ããIDã®ãªã¹ã
     * @return {Resource}
     */

  }, {
    key: "get3DDatasetAsResource",
    value: function get3DDatasetAsResource(datasetIds) {
      return new Dataset3DSceneResource(this, datasetIds);
    }
    /**
     * @summary æå®ããIDã®ç¹ç¾¤ãã¼ã¿ã»ããã®å®ç¾©ãã¡ã¤ã«ããªã½ã¼ã¹ã¨ãã¦åå¾ãã¾ãã
     * @param {string} datasetId ãã¼ã¿ã»ããID
     * @return {Resource}
     */

  }, {
    key: "getPointCloudDatasetAsResource",
    value: function getPointCloudDatasetAsResource(datasetId) {
      return new PointCloudDatasetResource(this, datasetId);
    } // RestAPI

    /**
     * @summary ãã¼ã¿ã»ãããªã¹ããåå¾ãã¾ã
     * @param {number} [page=1] åå¾ããè¦ç´ ã®ãã¼ã¸çªå·
     * @param {number} [limit=5] 1ãã¼ã¸ã«å«ã¾ããè¦ç´ æ°ãæå¤§100ã¾ã§æå®ãããã¨ãã§ãã¾ãã
     * @return {object} json
     */

  }, {
    key: "getDatasets",
    value: function () {
      var _getDatasets = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7() {
        var page,
            limit,
            opt,
            _args7 = arguments;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                page = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : 1;
                limit = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : 5;
                opt = this._option;
                _context7.next = 5;
                return this.get("datasets", [opt.userId], {
                  page: page,
                  limit: limit
                });

              case 5:
                return _context7.abrupt("return", _context7.sent);

              case 6:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getDatasets() {
        return _getDatasets.apply(this, arguments);
      }

      return getDatasets;
    }()
    /**
     * @summary get dataset
     * @param {string} datasetId
     * @return {object} json
     */

  }, {
    key: "getDataset",
    value: function () {
      var _getDataset = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(datasetId) {
        var opt;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opt = this._option;
                _context8.next = 3;
                return this.get("datasets", [opt.userId, datasetId], null);

              case 3:
                return _context8.abrupt("return", _context8.sent);

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getDataset(_x4) {
        return _getDataset.apply(this, arguments);
      }

      return getDataset;
    }()
    /**
     * @summary ãã¼ã¿ã»ãããä½æãã¾ãã
     * @param {string} name åå
     * @param {string} description èª¬æ
     * @return {object}
     */

  }, {
    key: "createDataset",
    value: function () {
      var _createDataset = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9(name, description) {
        var opt, body;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                opt = this._option;
                body = {
                  name: name,
                  description: description
                };
                _context9.next = 4;
                return this.post("datasets", [opt.userId], null, body);

              case 4:
                return _context9.abrupt("return", _context9.sent);

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function createDataset(_x5, _x6) {
        return _createDataset.apply(this, arguments);
      }

      return createDataset;
    }()
    /**
     * @summary ãã¼ã¿ã»ãããåé¤ãã¾ãã
     * @return {object} json
     */

  }, {
    key: "deleteDataset",
    value: function () {
      var _deleteDataset = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10(datasetId
      /*, option={ wait: true }*/
      ) {
        var opt;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                opt = this._option;
                _context10.next = 3;
                return this["delete"]("datasets", [opt.userId, datasetId]);

              case 3:
                return _context10.abrupt("return", _context10.sent);

              case 4:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function deleteDataset(_x7) {
        return _deleteDataset.apply(this, arguments);
      }

      return deleteDataset;
    }()
    /**
     * @summary GeoJSONã®åå®¹ãåå¾ãã¾ãã
     * @param {string} datasetId ãã¼ã¿ã»ããID
     * @return {object} json
     */

  }, {
    key: "getFeatures",
    value: function () {
      var _getFeatures = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee11(datasetId) {
        var opt;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                opt = this._option;
                _context11.next = 3;
                return this.get("datasets", [opt.userId, datasetId, "features"]);

              case 3:
                return _context11.abrupt("return", _context11.sent);

              case 4:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getFeatures(_x8) {
        return _getFeatures.apply(this, arguments);
      }

      return getFeatures;
    }()
    /**
     * @summary GeoJSONè¦ç´ ãã¢ããã­ã¼ãï¼æ¿å¥ï¼ãã¾ãã
     * @param {string} datasetId ãã¼ã¿ã»ããID
     * @return {object} json
     */

  }, {
    key: "insertFeature",
    value: function () {
      var _insertFeature = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee12(datasetId, feature) {
        var opt;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                opt = this._option;
                _context12.next = 3;
                return this.post("datasets", [opt.userId, datasetId, "features"], null, feature);

              case 3:
                return _context12.abrupt("return", _context12.sent);

              case 4:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function insertFeature(_x9, _x10) {
        return _insertFeature.apply(this, arguments);
      }

      return insertFeature;
    }()
    /**
     * @summary GeoJSONè¦ç´ ãæ´æ°ï¼ä¸æ¸ãï¼ãã¾ãã
     * @param {string} datasetId ãã¼ã¿ã»ããID
     * @param {string} featureId GeoJSONè¦ç´ ID
     * @param {object} feature GeoJSONè¦ç´ 
     * @return {object} json
     */

  }, {
    key: "updateFeature",
    value: function () {
      var _updateFeature = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee13(datasetId, featureId, feature) {
        var opt;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                opt = this._option;
                _context13.next = 3;
                return this.put("datasets", [opt.userId, "features", featureId], null, feature);

              case 3:
                return _context13.abrupt("return", _context13.sent);

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function updateFeature(_x11, _x12, _x13) {
        return _updateFeature.apply(this, arguments);
      }

      return updateFeature;
    }()
    /**
     * @summary 3Dãã¼ã¿ã»ããã®ãªã¹ããåå¾ãã¾ãã
     * @param {number} [page=1] åå¾ããè¦ç´ ã®ãã¼ã¸çªå·
     * @param {number} [limit=5] 1ãã¼ã¸ã«å«ã¾ããè¦ç´ æ°ãæå¤§100ã¾ã§æå®ãããã¨ãã§ãã¾ãã
     * @return {object} json
     */

  }, {
    key: "get3DDatasets",
    value: function () {
      var _get3DDatasets = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee14() {
        var page,
            limit,
            opt,
            _args14 = arguments;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                page = _args14.length > 0 && _args14[0] !== undefined ? _args14[0] : 1;
                limit = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : 5;
                opt = this._option;
                _context14.next = 5;
                return this.get("3ddatasets", [opt.userId], {
                  page: page,
                  limit: limit
                });

              case 5:
                return _context14.abrupt("return", _context14.sent);

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function get3DDatasets() {
        return _get3DDatasets.apply(this, arguments);
      }

      return get3DDatasets;
    }()
    /**
     * @summary 3D datastãä½æãã¾ãã
     * @param {string} name åå
     * @param {string} description èª¬æ
     * @param {object} option
     * @param {string} option.path glTFãã¡ã¤ã«ã®ãã¹ãæå®ãã¾ãï¼ã¢ããã­ã¼ãããéã¯ãã£ã¬ã¯ããªãæå®ããããããã£ã¬ã¯ããªã«ã¼ãããã®glTFãã¡ã¤ã«ã¸ã®ãã¹ãæå®ãã¾ãï¼
     * @param {string} option.format "glTF"ãæå®ãã¾ã
     * @param {string} option.srid ç¾å¨ã¯4326ï¼WGS 84ï¼ãæå®ãã¾ã
     * @param {number} option.x çµåº¦
     * @param {number} option.y ç·¯åº¦
     * @param {number} option.z é«ã
     * @return {object} json
     */

  }, {
    key: "create3DDataset",
    value: function () {
      var _create3DDataset = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee15(name, description, option) {
        var opt, body;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                opt = this._option;
                body = {
                  name: name,
                  description: description,
                  path: option.path,
                  format: option.format,
                  srid: option.srid,
                  x: option.x,
                  y: option.y,
                  z: option.z
                };
                _context15.next = 4;
                return this.post("3ddatasets", [opt.userId], null, body);

              case 4:
                return _context15.abrupt("return", _context15.sent);

              case 5:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function create3DDataset(_x14, _x15, _x16) {
        return _create3DDataset.apply(this, arguments);
      }

      return create3DDataset;
    }()
    /**
     * @summary 3Dãã¼ã¿ã»ãããæ´æ°ãã¾ãã
     * @param {string} datasetId ãã¼ã¿ã»ããId
     * @param {string} name åå
     * @param {string} description èª¬æ
     * @param {object} option
     * @param {string} option.path glTFãã¡ã¤ã«ã®ãã¹ãæå®ãã¾ãï¼ã¢ããã­ã¼ãããéã¯ãã£ã¬ã¯ããªãæå®ããããããã£ã¬ã¯ããªã«ã¼ãããã®glTFãã¡ã¤ã«ã¸ã®ãã¹ãæå®ãã¾ãï¼
     * @param {string} option.format "glTF"ãæå®ãã¾ã
     * @param {string} option.srid ç¾å¨ã¯4326ï¼WGS 84ï¼ãæå®ãã¾ã
     * @param {number} option.x çµåº¦
     * @param {number} option.y ç·¯åº¦
     * @param {number} option.z é«ã
     * @return {object} json
     */

  }, {
    key: "update3DDataset",
    value: function () {
      var _update3DDataset = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee16(datasetId, name, description, option) {
        var opt, body;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                opt = this._option;
                body = {
                  name: name,
                  description: description,
                  path: option.path,
                  format: option.format,
                  srid: option.srid,
                  x: option.x,
                  y: option.y,
                  z: option.z
                };
                _context16.next = 4;
                return this.patch("3ddatasets", [opt.userId, datasetId], null, body);

              case 4:
                return _context16.abrupt("return", _context16.sent);

              case 5:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function update3DDataset(_x17, _x18, _x19, _x20) {
        return _update3DDataset.apply(this, arguments);
      }

      return update3DDataset;
    }()
    /**
     * @summary 3Dãã¼ã¿ã»ããã¢ããã­ã¼ãç¨URLãåå¾ãã¾ãã
     * @param {string} datasetId ãã¼ã¿ã»ããId
     * @return {object} json
     */

  }, {
    key: "create3DDatasetUploadUrl",
    value: function () {
      var _create3DDatasetUploadUrl = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee17(datasetId) {
        var opt;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                opt = this._option;
                _context17.next = 3;
                return this.post("3ddatasets", ["uploads", opt.userId, datasetId], null, {});

              case 3:
                return _context17.abrupt("return", _context17.sent);

              case 4:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function create3DDatasetUploadUrl(_x21) {
        return _create3DDatasetUploadUrl.apply(this, arguments);
      }

      return create3DDatasetUploadUrl;
    }()
    /**
     * @summary 3Dãã¼ã¿ã»ããæå ±ãåå¾ãã¾ãã
     * ãã¼ã¿ã»ãããä¿æãããã¼ã¿ã«ã¢ã¯ã»ã¹ããã«ã¯ãget3DDatasetScene()ãå©ç¨ãã¾ãã
     * @param {string} datasetId ãã¼ã¿ã»ããId
     * @return {object} json
     */

  }, {
    key: "get3DDataset",
    value: function () {
      var _get3DDataset = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee18(datasetId) {
        var opt;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                opt = this._option;
                _context18.next = 3;
                return this.get("3ddatasets", [opt.userId, datasetId], null);

              case 3:
                return _context18.abrupt("return", _context18.sent);

              case 4:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function get3DDataset(_x22) {
        return _get3DDataset.apply(this, arguments);
      }

      return get3DDataset;
    }()
    /**
     * @summary 3Dãã¼ã¿ã»ãããåé¤ãã¾ãã
     * @param {string} datasetId ãã¼ã¿ã»ããId
     * @return {object} json
     */

  }, {
    key: "delete3DDataset",
    value: function () {
      var _delete3DDataset = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee19(datasetId) {
        var opt;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                opt = this._option;
                _context19.next = 3;
                return this["delete"]("3ddatasets", [opt.userId, datasetId]);

              case 3:
                return _context19.abrupt("return", _context19.sent);

              case 4:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function delete3DDataset(_x23) {
        return _delete3DDataset.apply(this, arguments);
      }

      return delete3DDataset;
    }()
    /**
     * @summary 3Dãã¼ã¿ã»ããã«å«ã¾ãã sceneæå ± ãåå¾ãã¾ãã
     * @param {string|string[]} datasetIds
     * @return {object} ã·ã¼ã³ãã¡ã¤ã«ã®å®ä½
     */

  }, {
    key: "get3DDatasetScene",
    value: function () {
      var _get3DDatasetScene = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee20(datasetIds) {
        var opt, response;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                opt = this._option;
                _context20.next = 3;
                return this.get("3ddatasets", ["scene", opt.userId], {
                  "3ddatasets_ids": Array.isArray(datasetIds) ? datasetIds.join(",") : datasetIds
                });

              case 3:
                response = _context20.sent;
                response.entity_list.forEach(function (entity) {
                  var indexStr = entity.index;
                  var index = parseInt(indexStr);

                  if (index.toString() !== indexStr) {
                    throw new Error("Internal Error: ID couldn't be convert to 'number'");
                  }

                  entity.index = index;
                });
                return _context20.abrupt("return", response);

              case 6:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function get3DDatasetScene(_x24) {
        return _get3DDatasetScene.apply(this, arguments);
      }

      return get3DDatasetScene;
    }()
    /**
     * @summary ç¹ç¾¤ãã¼ã¿ã»ãããªã¹ããåå¾ãã¾ãã
     * @param {number} [page=1] åå¾ããè¦ç´ ã®ãã¼ã¸çªå·
     * @param {number} [limit=5] 1ãã¼ã¸ã«å«ã¾ããè¦ç´ æ°ãæå¤§100ã¾ã§æå®ãããã¨ãã§ãã¾ãã
     * @return {object} json
     */

  }, {
    key: "getPointCloudDatasets",
    value: function () {
      var _getPointCloudDatasets = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee21() {
        var page,
            limit,
            opt,
            _args21 = arguments;
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                page = _args21.length > 0 && _args21[0] !== undefined ? _args21[0] : 1;
                limit = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : 5;
                opt = this._option;
                _context21.next = 5;
                return this.get("pcdatasets", [opt.userId], {
                  page: page,
                  limit: limit
                });

              case 5:
                return _context21.abrupt("return", _context21.sent);

              case 6:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function getPointCloudDatasets() {
        return _getPointCloudDatasets.apply(this, arguments);
      }

      return getPointCloudDatasets;
    }()
    /**
     * @summary ç¹ç¾¤ãã¼ã¿ã»ãããåå¾ãã¾ãã
     * @param {string} datasetId ãã¼ã¿ã»ããId
     * @return {object} json
     */

  }, {
    key: "getPointCloudDataset",
    value: function () {
      var _getPointCloudDataset = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee22(datasetId) {
        var opt;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                opt = this._option;
                _context22.next = 3;
                return this.get("pcdatasets", [opt.userId, datasetId]);

              case 3:
                return _context22.abrupt("return", _context22.sent);

              case 4:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getPointCloudDataset(_x25) {
        return _getPointCloudDataset.apply(this, arguments);
      }

      return getPointCloudDataset;
    }()
    /**
     * @private
     * @return {object} json
     */

  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee23(api, args, query) {
        var option,
            _args23 = arguments;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                option = _args23.length > 3 && _args23[3] !== undefined ? _args23[3] : {};
                _context23.next = 3;
                return this.fetchAPI(HTTP.METHOD.GET, api, args, query, null, option);

              case 3:
                return _context23.abrupt("return", _context23.sent);

              case 4:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function get(_x26, _x27, _x28) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
    /**
     * @private
     * @return {object} json
     */

  }, {
    key: "post",
    value: function () {
      var _post = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee24(api, args, query, body) {
        var option,
            _args24 = arguments;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                option = _args24.length > 4 && _args24[4] !== undefined ? _args24[4] : {};

                if (typeof body !== "string") {
                  body = JSON.stringify(body);
                }

                _context24.next = 4;
                return this.fetchAPI(HTTP.METHOD.POST, api, args, query, body, option);

              case 4:
                return _context24.abrupt("return", _context24.sent);

              case 5:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function post(_x29, _x30, _x31, _x32) {
        return _post.apply(this, arguments);
      }

      return post;
    }()
    /**
     * @private
     * @return {object} json
     */

  }, {
    key: "patch",
    value: function () {
      var _patch = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee25(api, args, query, body) {
        var option,
            _args25 = arguments;
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                option = _args25.length > 4 && _args25[4] !== undefined ? _args25[4] : {};

                if (typeof body !== "string") {
                  body = JSON.stringify(body);
                }

                _context25.next = 4;
                return this.fetchAPI(HTTP.METHOD.PATCH, api, args, query, body, option);

              case 4:
                return _context25.abrupt("return", _context25.sent);

              case 5:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function patch(_x33, _x34, _x35, _x36) {
        return _patch.apply(this, arguments);
      }

      return patch;
    }()
    /**
     * @private
     * @return {object} json
     */

  }, {
    key: "put",
    value: function () {
      var _put = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee26(api, args, query, body) {
        var option,
            _args26 = arguments;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                option = _args26.length > 4 && _args26[4] !== undefined ? _args26[4] : {};

                if (typeof body !== "string") {
                  body = JSON.stringify(body);
                }

                _context26.next = 4;
                return this.fetchAPI(HTTP.METHOD.PUT, api, args, query, body, option);

              case 4:
                return _context26.abrupt("return", _context26.sent);

              case 5:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function put(_x37, _x38, _x39, _x40) {
        return _put.apply(this, arguments);
      }

      return put;
    }()
    /**
     * @private
     * @return {object} json
     */

  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee27(api, args, query) {
        var option,
            _args27 = arguments;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                option = _args27.length > 3 && _args27[3] !== undefined ? _args27[3] : {};
                _context27.next = 3;
                return this.fetchAPI(HTTP.METHOD.DELETE, api, args, query, null, option);

              case 3:
                return _context27.abrupt("return", _context27.sent);

              case 4:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function _delete(_x41, _x42, _x43) {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }()
    /**
     * @private
     * @return {object} json
     */

  }, {
    key: "fetchAPI",
    value: function () {
      var _fetchAPI = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee28(method, api, args, query, body) {
        var option,
            opt,
            url,
            response,
            _args28 = arguments;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                option = _args28.length > 5 && _args28[5] !== undefined ? _args28[5] : {};
                opt = this._option;
                url = opt.basePath + "/" + api + "/" + opt.version + (args.length > 0 ? "/" + args.join("/") : ""); // console.log( "MaprayAPI: " + method + " " + api + " (" + args.join("/") + ")" );

                _context28.next = 5;
                return this.fetch(method, url, query, body, option);

              case 5:
                response = _context28.sent;
                _context28.next = 8;
                return response.json();

              case 8:
                return _context28.abrupt("return", _context28.sent);

              case 9:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function fetchAPI(_x44, _x45, _x46, _x47, _x48) {
        return _fetchAPI.apply(this, arguments);
      }

      return fetchAPI;
    }()
    /**
     * @private
     */

  }, {
    key: "fetch",
    value: function () {
      var _fetch = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee29(method, url, query, body) {
        var option,
            opt,
            headers,
            response,
            errorResponseJson,
            _args29 = arguments;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                option = _args29.length > 4 && _args29[4] !== undefined ? _args29[4] : {};
                opt = this._option;
                headers = option.headers || (option.headers = {});
                headers["x-api-key"] = opt.token;
                _context29.prev = 4;
                _context29.next = 7;
                return HTTP.fetch(method, url, query, body, option);

              case 7:
                response = _context29.sent;
                _context29.next = 26;
                break;

              case 10:
                _context29.prev = 10;
                _context29.t0 = _context29["catch"](4);

                if (!(_context29.t0.name === "FetchError" && _context29.t0.response)) {
                  _context29.next = 25;
                  break;
                }

                _context29.prev = 13;
                _context29.next = 16;
                return _context29.t0.response.json();

              case 16:
                errorResponseJson = _context29.sent;
                _context29.next = 22;
                break;

              case 19:
                _context29.prev = 19;
                _context29.t1 = _context29["catch"](13);
                throw new MaprayApiError(-1, "Failed to fetch", url, null, _context29.t0);

              case 22:
                throw new MaprayApiError(errorObject.code, errorObject.error, url, _context29.t0.response, _context29.t0);

              case 25:
                throw new MaprayApiError(-1, "Failed to fetch", url, null, _context29.t0);

              case 26:
                return _context29.abrupt("return", response);

              case 27:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this, [[4, 10], [13, 19]]);
      }));

      function fetch(_x49, _x50, _x51, _x52) {
        return _fetch.apply(this, arguments);
      }

      return fetch;
    }()
  }]);

  return MaprayApi;
}(HTTP);

MaprayApi.DEFAULT_BASE_PATH = "https://cloud.mapray.com";

/**
 * @summary ç¹ç¾¤ãã¼ã¿ãã­ãã¤ã
 * <p>ãã®ã¤ã³ã¹ã¿ã³ã¹ã«ã¯ç¶æ ({@link mapray.PointCloudProvider.Status}å) ãããã{@link mapray.PointCloudProvider.Status.INITIALIZED}ä»¥å¤ã®ç¶æã§ã¯æ°è¦ã«èª­ã¿è¾¼ã¿({@link mapray.PointCloudProvider#load})ãè¡ããã¨ãã§ããªãã</p>
 *
 * <p>ä»¥ä¸ã®æ½è±¡ã¡ã½ããã¯æ¢å®ã®åä½ããªãã®ã§ãå©ç¨èã¯ãããã®ã¡ã½ããããªã¼ãã¼ã©ã¤ãããå·è±¡ã¯ã©ã¹ãä½¿ç¨ããªããã°ãªããªãã</p>
 * <ul>
 *   <li>{@link mapray.PointCloudProvider#doInit}</li>
 *   <li>{@link mapray.PointCloudProvider#doLoad}</li>
 *   <li>{@link mapray.PointCloudProvider#doDestroy}</li>
 * </ul>
 *
 * @memberof mapray
 * @abstract
 * @protected
 */
var PointCloudProvider =
/*#__PURE__*/
function () {
  function PointCloudProvider() {

    _classCallCheck(this, PointCloudProvider);

    this._status = PointCloudProvider.Status.NOT_INITIALIZED;
  }
  /**
   * @summary åæåã
   * ç¶æ¿ã¯ã©ã¹ã§ã¯doInit()ãç¶æ¿ãã
   */


  _createClass(PointCloudProvider, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this._status !== PointCloudProvider.Status.NOT_INITIALIZED)) {
                  _context.next = 2;
                  break;
                }

                throw new Error("invalid status");

              case 2:
                _context.prev = 2;
                _context.next = 5;
                return this.doInit();

              case 5:
                this._status = PointCloudProvider.Status.INITIALIZED;
                _context.next = 12;
                break;

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](2);
                this._status = PointCloudProvider.Status.DESTROYED;
                throw _context.t0;

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 8]]);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
    /**
     * @summary ãªã¯ã¨ã¹ãå¯è½ãªç¶æããè¿ãã
     * åæåãå®äºãã¦ãããã ãã§ã¯ãªããç¾å¨å¦çä¸­ã®ãªã¯ã¨ã¹ãæ°ãèæ®ããä¸ã§ãªã¯ã¨ã¹ãå¯è½ãªç¶æãå¤æ­ããã
     * @return {boolean}
     * @protected
     */

  }, {
    key: "isReady",
    value: function isReady() {
      return this._status == PointCloudProvider.Status.INITIALIZED && this.getNumberOfRequests() < 10;
    }
    /**
     * @summary ç¹ç¾¤ãèª­ã¿è¾¼ã
     * ç¶æ¿ã¯ã©ã¹ã§ã¯doLoad()ãç¶æ¿ãã
     * @param {number} level ã¬ãã«
     * @param {number} x x
     * @param {number} y y
     * @param {number} z z
     * @returns {mapray.PointCloudProvider.Status.Request} request
     */

  }, {
    key: "load",
    value: function load(level, x, y, z) {
      if (this._status !== PointCloudProvider.Status.INITIALIZED) {
        return {
          id: -1,
          done: Promise.reject(new Error("invalid status"))
        };
      }

      var id = PointCloudProvider._id_max++;
      return {
        id: id,
        done: this.doLoad(id, level, x, y, z)
      };
    }
  }, {
    key: "flushQueue",
    value: function flushQueue() {}
  }, {
    key: "toString",
    value: function toString() {
      return "PointCloudProvider";
    }
    /**
     * @summary å®è¡ä¸­ã®ãªã¯ã¨ã¹ããã­ã£ã³ã»ã«ãã
     * @param {number} id ãªã¯ã¨ã¹ãID
     */

  }, {
    key: "cancel",
    value: function cancel(id) {
      if (this._status !== PointCloudProvider.Status.INITIALIZED) throw new Error("invalid status");
      console.log("cancel not implemented");
    }
    /**
     * @summary å®è¡ä¸­ã®ãªã¯ã¨ã¹ãæ°ãè¿ã
     * @abstract
     */

  }, {
    key: "getNumberOfRequests",
    value: function getNumberOfRequests() {
      throw new Error("not implemented");
    }
    /**
     * @summary ç ´æ£
     * ç¶æ¿ã¯ã©ã¹ã§ã¯doDestroy()ãç¶æ¿ãã
     */

  }, {
    key: "destroy",
    value: function () {
      var _destroy = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(this._status !== PointCloudProvider.Status.INITIALIZED)) {
                  _context2.next = 2;
                  break;
                }

                throw new Error("invalid status");

              case 2:
                _context2.prev = 2;
                _context2.next = 5;
                return this.doDestroy();

              case 5:
                _context2.prev = 5;
                this._status = PointCloudProvider.Status.DESTROYED;
                return _context2.finish(5);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2,, 5, 8]]);
      }));

      function destroy() {
        return _destroy.apply(this, arguments);
      }

      return destroy;
    }()
    /**
     * @summary åæåãè¡ã
     * @protected
     * @abstract
     */

  }, {
    key: "doInit",
    value: function () {
      var _doInit = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                throw new Error("not implemented");

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function doInit() {
        return _doInit.apply(this, arguments);
      }

      return doInit;
    }()
    /**
     * @summary èª­ã¿è¾¼ã¿ãè¡ã
     * @protected
     * @abstract
     * @param {number} id ãªã¯ã¨ã¹ãid
     * @param {number} level ã¬ãã«
     * @param {number} x x
     * @param {number} y y
     * @param {number} z z
     */

  }, {
    key: "doLoad",
    value: function () {
      var _doLoad = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(id, level, x, y, z) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                throw new Error("not implemented");

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function doLoad(_x, _x2, _x3, _x4, _x5) {
        return _doLoad.apply(this, arguments);
      }

      return doLoad;
    }()
    /**
     * @summary ç ´æ£ãè¡ã
     * @protected
     * @abstract
     */

  }, {
    key: "doDestroy",
    value: function () {
      var _doDestroy = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                throw new Error("not implemented");

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function doDestroy() {
        return _doDestroy.apply(this, arguments);
      }

      return doDestroy;
    }()
  }], [{
    key: "Status",
    get: function get() {
      return Status$4;
    }
  }]);

  return PointCloudProvider;
}();

PointCloudProvider._id_max = 0;
/**
 * @typedef {Object} Request
 * @property {number} id ãªã¯ã¨ã¹ãID
 * @property {Promise} done ãªã¯ã¨ã¹ãã®å®äºãç¤ºããã­ãã¹
 * @memberof mapray.PointCloudProvider
 */

/**
 * @summary ç¶æã®åæå
 * @enum {object}
 * @memberof mapray.PointCloudProvider
 * @constant
 * @see mapray.PointCloudProvider#status
 */

var Status$4 = {
  /**
   * åæåå (åæç¶æ)
   */
  NOT_INITIALIZED: {
    id: "NOT_INITIALIZED"
  },

  /**
   * åæåæ¸ã¿ï¼èª­ã¿è¾¼ã¿å¯è½ï¼
   */
  INITIALIZED: {
    id: "INITIALIZED"
  },

  /**
   * ç ´æ£ç¶æ
   */
  DESTROYED: {
    id: "DESTROYED"
  }
};

var RawPointCloudProvider =
/*#__PURE__*/
function (_PointCloudProvider) {
  _inherits(RawPointCloudProvider, _PointCloudProvider);

  /**
   * resource ç¹ç¾¤å®ç¾©(json)ãªã½ã¼ã¹ã
   * @param {mapray.Resource} resource
   * @param {object} option
   */
  function RawPointCloudProvider(resource) {
    var _this;

    var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, RawPointCloudProvider);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RawPointCloudProvider).call(this, option));
    _this._suffix = ".xyz";

    if (resource instanceof Resource) {
      _this._info_resource = resource;
    } else if (resource.url) {
      _this._info_resource = new URLResource(resource.url, resource.option);
    } else {
      throw new Error("unsupported resource");
    }

    _this._taskMap = new Map();
    _this._requests = 0;
    return _this;
  }
  /**
   * @private
   */


  _createClass(RawPointCloudProvider, [{
    key: "_createPath",
    value: function _createPath(level, x, y, z) {
      return level + "/" + x + "/" + y + "/" + z + this._suffix;
    }
    /**
     * @override
     */

  }, {
    key: "doInit",
    value: function () {
      var _doInit = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var info;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._info_resource.load({
                  type: ResourceType.JSON
                });

              case 2:
                info = _context.sent;

                if (info.url) {
                  this._resource = this._info_resource.resolveResource(info.url);
                } else {
                  this._resource = this._info_resource;
                }

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function doInit() {
        return _doInit.apply(this, arguments);
      }

      return doInit;
    }()
    /**
     * @override
     */

  }, {
    key: "doDestroy",
    value: function () {
      var _doDestroy = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function doDestroy() {
        return _doDestroy.apply(this, arguments);
      }

      return doDestroy;
    }()
  }, {
    key: "getNumberOfRequests",
    value: function getNumberOfRequests() {
      return this._requests;
    }
    /**
     * @override
     */

  }, {
    key: "doLoad",
    value: function () {
      var _doLoad = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(id, level, x, y, z) {
        var abortController, path, buffer, header, p, buf;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._requests++;
                _context3.prev = 1;
                abortController = new AbortController();

                this._taskMap.set(id, {
                  id: id,
                  abortController: abortController
                });

                path = this._createPath(level, x, y, z);
                _context3.next = 7;
                return this._resource.loadSubResource(path, {
                  type: ResourceType.BINARY,
                  signal: abortController.signal
                });

              case 7:
                buffer = _context3.sent;
                header = {};
                p = 0;
                header.childFlags = new Uint8Array(buffer, p, 1)[0];
                p += 1;
                header.debug1 = new Int8Array(buffer, p, 1)[0];
                p += 1;
                p += 2; // skip

                header.indices = new Int32Array(buffer, p, 8);
                p += 32;
                header.average = new Float32Array(buffer, p, 3);
                p += 12;
                header.eigenVector = [];
                header.eigenVectorLength = [];
                header.eigenVector[0] = new Float32Array(buffer, p, 3);
                p += 12;
                header.eigenVectorLength[0] = new Float32Array(buffer, p, 1)[0];
                p += 4;
                header.eigenVector[1] = new Float32Array(buffer, p, 3);
                p += 12;
                header.eigenVectorLength[1] = new Float32Array(buffer, p, 1)[0];
                p += 4;
                header.eigenVector[2] = new Float32Array(buffer, p, 3);
                p += 12;
                header.eigenVectorLength[2] = new Float32Array(buffer, p, 1)[0];
                p += 4;
                console.assert(p == 96);
                buf = new Float32Array(buffer, p);

                this._taskMap["delete"](id);

                return _context3.abrupt("return", {
                  header: header,
                  body: buf
                });

              case 37:
                _context3.prev = 37;
                this._requests--;
                return _context3.finish(37);

              case 40:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[1,, 37, 40]]);
      }));

      function doLoad(_x, _x2, _x3, _x4, _x5) {
        return _doLoad.apply(this, arguments);
      }

      return doLoad;
    }()
    /**
     * @override
     */

  }, {
    key: "cancel",
    value: function cancel(id) {
      var item = this._taskMap.get(id);

      if (item) {
        item.abortController.abort();
      }
    }
  }]);

  return RawPointCloudProvider;
}(PointCloudProvider);

/**
 * Mapray é¢é£ã®æ©è½å¨ä½ãå«ã¾ããååç©ºé
 * @namespace mapray
 */

var mapray = {
  animation: animation,
  Viewer: Viewer,
  Camera: Camera,
  GeoMath: GeoMath,
  GeoPoint: GeoPoint,
  GeoRegion: GeoRegion,
  Orientation: Orientation,
  Ray: Ray,
  AltitudeMode: AltitudeMode,
  CredentialMode: CredentialMode,
  Layer: Layer,
  LayerCollection: LayerCollection,
  DemProvider: DemProvider,
  StandardDemProvider: StandardDemProvider,
  CloudDemProvider: CloudDemProvider,
  ImageProvider: ImageProvider,
  RenderCallback: RenderCallback,
  StandardImageProvider: StandardImageProvider,
  Scene: Scene,
  Entity: Entity,
  MarkerLineEntity: MarkerLineEntity,
  PathEntity: PathEntity,
  TextEntity: TextEntity,
  ModelEntity: ModelEntity,
  PolygonEntity: PolygonEntity,
  PinEntity: PinEntity,
  ImageIconEntity: ImageIconEntity,
  SceneLoader: SceneLoader,
  GeoJSONLoader: GeoJSONLoader,
  Resource: Resource,
  URLResource: URLResource,
  MaprayApi: MaprayApi,
  DebugStats: DebugStats,
  PointCloud: PointCloud,
  RawPointCloudProvider: RawPointCloudProvider,
  LogoController: LogoController,
  // ãã¦ã¹ã»Attributionéçº
  AttributionController: AttributionController // ãã¦ã¹ã»Attributionéçº

}; // äºæé¢æ°ãç»é²

{
  /* requestAnimationFrame äºæé¢æ°
   * @param {function} callback
   * @return {number} requestID
   * @see https://developer.mozilla.org/ja/docs/Web/API/Window/requestAnimationFrame
   */
  window.maprayRequestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame;
  /* cancelAnimationFrame äºæé¢æ°
   * @param {number} requestID
   * @see https://developer.mozilla.org/ja/docs/Web/API/window/cancelAnimationFrame
   */

  window.maprayCancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame;
  /* Performance.now äºæé¢æ°
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Performance/now
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now
   */

  var perf = window.performance;
  var now = perf && (perf.now || perf.mozNow || perf.msNow || perf.oNow || perf.webkitNow);
  var date = new Date();
  window.maprayNow = now ? function () {
    return now.call(perf);
  } : function () {
    return date.getTime();
  };
  /* Math.log2 äºæé¢æ°
   * @function Math.maprayLog2
   * @see https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Math/log2
   */

  Math.maprayLog2 = Math.log2 || function (x) {
    return 1.4426950408889634074 * Math.log(x);
  };
}

return mapray;

})));
//# sourceMappingURL=mapray.js.map
